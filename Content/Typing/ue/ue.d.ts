/// <reference path="puerts.d.ts" />
declare module "ue" {
    class Field extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Field;
        static Load(InName: string): Field;
    }
    
    class Struct extends Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Struct;
        static Load(InName: string): Struct;
    }
    
    class Class extends Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Class;
        static Load(InName: string): Class;
    }
    
    class LayerActorStats {
        constructor(Type: Class, Total: number);
        Type: Class;
        Total: number;
    }
    
    class Layer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerName: string;
        bIsVisible: boolean;
        ActorStats: TArray<LayerActorStats>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Layer;
        static Load(InName: string): Layer;
    }
    
    class TickFunction {
        constructor(TickGroup: number, EndTickGroup: number, bTickEvenWhenPaused: boolean, bCanEverTick: boolean, bStartWithTickEnabled: boolean, bAllowTickOnDedicatedServer: boolean, TickInterval: number);
        TickGroup: number;
        EndTickGroup: number;
        bTickEvenWhenPaused: boolean;
        bCanEverTick: boolean;
        bStartWithTickEnabled: boolean;
        bAllowTickOnDedicatedServer: boolean;
        TickInterval: number;
    }
    
    class ActorTickFunction extends TickFunction {
        constructor();
    }
    
    enum EActorUpdateOverlapsMethod { UseConfigDefault, AlwaysUpdate, OnlyUpdateMovable, NeverUpdate, EActorUpdateOverlapsMethod_MAX}
    enum EVectorQuantization { RoundWholeNumber, RoundOneDecimal, RoundTwoDecimals, EVectorQuantization_MAX}
    enum ERotatorQuantization { ByteComponents, ShortComponents, ERotatorQuantization_MAX}
    class RepMovement {
        constructor(LinearVelocity: Vector, AngularVelocity: Vector, Location: Vector, Rotation: Rotator, bSimulatedPhysicSleep: boolean, bRepPhysics: boolean, LocationQuantizationLevel: EVectorQuantization, VelocityQuantizationLevel: EVectorQuantization, RotationQuantizationLevel: ERotatorQuantization);
        LinearVelocity: Vector;
        AngularVelocity: Vector;
        Location: Vector;
        Rotation: Rotator;
        bSimulatedPhysicSleep: boolean;
        bRepPhysics: boolean;
        LocationQuantizationLevel: EVectorQuantization;
        VelocityQuantizationLevel: EVectorQuantization;
        RotationQuantizationLevel: ERotatorQuantization;
    }
    
    class Vector_NetQuantize100 extends Vector {
        constructor();
    }
    
    class ActorComponentTickFunction extends TickFunction {
        constructor();
    }
    
    class AssetUserData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetUserData;
        static Load(InName: string): AssetUserData;
    }
    
    enum EComponentCreationMethod { Native, SimpleConstructionScript, UserConstructionScript, Instance, EComponentCreationMethod_MAX}
    class SimpleMemberReference {
        constructor(MemberParent: Object, MemberName: string, MemberGuid: Guid);
        MemberParent: Object;
        MemberName: string;
        MemberGuid: Guid;
    }
    
    class ActorComponent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryComponentTick: ActorComponentTickFunction;
        ComponentTags: TArray<string>;
        AssetUserData: TArray<AssetUserData>;
        bReplicates: boolean;
        bNetAddressable: boolean;
        bCreatedByConstructionScript: boolean;
        bInstanceComponent: boolean;
        bAutoActivate: boolean;
        bIsActive: boolean;
        bEditableWhenInherited: boolean;
        bCanEverAffectNavigation: boolean;
        bIsEditorOnly: boolean;
        bIsVisualizationComponent: boolean;
        CreationMethod: EComponentCreationMethod;
        OnComponentActivated: $MulticastDelegate<(Component: ActorComponent, bReset: boolean) => void>;
        OnComponentDeactivated: $MulticastDelegate<(Component: ActorComponent) => void>;
        UCSModifiedProperties: TArray<SimpleMemberReference>;
        ToggleActive(): void;
        SetTickGroup(NewTickGroup: number): void;
        SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
        SetIsReplicated(ShouldReplicate: boolean): void;
        SetComponentTickInterval(TickInterval: number): void;
        SetComponentTickEnabled(bEnabled: boolean): void;
        SetAutoActivate(bNewAutoActivate: boolean): void;
        SetActive(bNewActive: boolean, bReset: boolean): void;
        RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
        RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
        ReceiveTick(DeltaSeconds: number): void;
        ReceiveEndPlay(EndPlayReason: number): void;
        ReceiveBeginPlay(): void;
        OnRep_IsActive(): void;
        K2_DestroyComponent(Object: Object): void;
        IsComponentTickEnabled(): boolean;
        IsBeingDestroyed(): boolean;
        IsActive(): boolean;
        GetOwner(): Actor;
        GetComponentTickInterval(): number;
        Deactivate(): void;
        ComponentHasTag(Tag: string): boolean;
        AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
        AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
        Activate(bReset: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorComponent;
        static Load(InName: string): ActorComponent;
    }
    
    class Model extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Model;
        static Load(InName: string): Model;
    }
    
    enum ELightmapType { Default, ForceSurface, ForceVolumetric, ELightmapType_MAX}
    class LightingChannels {
        constructor(bChannel0: boolean, bChannel1: boolean, bChannel2: boolean);
        bChannel0: boolean;
        bChannel1: boolean;
        bChannel2: boolean;
    }
    
    enum ERendererStencilMask { ERSM_Default, ERSM_255, ERSM_1, ERSM_2, ERSM_4, ERSM_8, ERSM_16, ERSM_32, ERSM_64, ERSM_128, ERSM_MAX}
    class CustomPrimitiveData {
        constructor(Data: TArray<number>);
        Data: TArray<number>;
    }
    
    enum ERuntimeVirtualTextureMaterialType { BaseColor, BaseColor_Normal_DEPRECATED, BaseColor_Normal_Specular, BaseColor_Normal_Specular_YCoCg, WorldHeight, Count, ERuntimeVirtualTextureMaterialType_MAX}
    class StreamableRenderAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForceMipLevelsToBeResidentTimestamp: number;
        NumCinematicMipLevels: number;
        StreamingIndex: number;
        CachedCombinedLODBias: number;
        CachedNumResidentLODs: number;
        bCachedReadyForStreaming: boolean;
        NeverStream: boolean;
        bGlobalForceMipLevelsToBeResident: boolean;
        bIsStreamable: boolean;
        bHasStreamingUpdatePending: boolean;
        bForceMiplevelsToBeResident: boolean;
        bIgnoreStreamingMipBias: boolean;
        bUseCinematicMipLevels: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamableRenderAsset;
        static Load(InName: string): StreamableRenderAsset;
    }
    
    class TextureSourceBlock {
        constructor(BlockX: number, BlockY: number, SizeX: number, SizeY: number, NumSlices: number, NumMips: number);
        BlockX: number;
        BlockY: number;
        SizeX: number;
        SizeY: number;
        NumSlices: number;
        NumMips: number;
    }
    
    class TextureSource {
        constructor(Id: Guid, BaseBlockX: number, BaseBlockY: number, SizeX: number, SizeY: number, NumSlices: number, NumMips: number, NumLayers: number, bPNGCompressed: boolean, bGuidIsHash: boolean, Format: number, LayerFormat: TArray<number>, Blocks: TArray<TextureSourceBlock>);
        Id: Guid;
        BaseBlockX: number;
        BaseBlockY: number;
        SizeX: number;
        SizeY: number;
        NumSlices: number;
        NumMips: number;
        NumLayers: number;
        bPNGCompressed: boolean;
        bGuidIsHash: boolean;
        Format: number;
        LayerFormat: TArray<number>;
        Blocks: TArray<TextureSourceBlock>;
    }
    
    class AssetImportInfo {
        constructor();
    }
    
    class AssetImportData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFilePath: string;
        SourceFileTimestamp: string;
        SourceData: AssetImportInfo;
        K2_GetFirstFilename(): string;
        K2_ExtractFilenames(): TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetImportData;
        static Load(InName: string): AssetImportData;
    }
    
    class TextureFormatSettings {
        constructor(CompressionSettings: number, CompressionNoAlpha: boolean, CompressionNone: boolean, CompressionYCoCg: boolean, SRGB: boolean);
        CompressionSettings: number;
        CompressionNoAlpha: boolean;
        CompressionNone: boolean;
        CompressionYCoCg: boolean;
        SRGB: boolean;
    }
    
    enum ETextureMipLoadOptions { Default, AllMips, OnlyFirstMip, ETextureMipLoadOptions_MAX}
    class Texture extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Source: TextureSource;
        LightingGuid: Guid;
        SourceFilePath: string;
        AssetImportData: AssetImportData;
        AdjustBrightness: number;
        AdjustBrightnessCurve: number;
        AdjustVibrance: number;
        AdjustSaturation: number;
        AdjustRGBCurve: number;
        AdjustHue: number;
        AdjustMinAlpha: number;
        AdjustMaxAlpha: number;
        CompressionNoAlpha: boolean;
        CompressionNone: boolean;
        DeferCompression: boolean;
        LossyCompressionAmount: number;
        MaxTextureSize: number;
        CompressionQuality: number;
        bDitherMipMapAlpha: boolean;
        AlphaCoverageThresholds: Vector4;
        bPreserveBorder: boolean;
        bFlipGreenChannel: boolean;
        bForcePVRTC4: boolean;
        PowerOfTwoMode: number;
        PaddingColor: Color;
        bChromaKeyTexture: boolean;
        ChromaKeyThreshold: number;
        ChromaKeyColor: Color;
        MipGenSettings: number;
        CompositeTexture: Texture;
        CompositeTextureMode: number;
        CompositePower: number;
        LayerFormatSettings: TArray<TextureFormatSettings>;
        LODBias: number;
        CompressionSettings: number;
        Filter: number;
        MipLoadOptions: ETextureMipLoadOptions;
        LODGroup: number;
        SRGB: boolean;
        bUseLegacyGamma: boolean;
        bNoTiling: boolean;
        VirtualTextureStreaming: boolean;
        CompressionYCoCg: boolean;
        bAsyncResourceReleaseHasBeenStarted: boolean;
        AssetUserData: TArray<AssetUserData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture;
        static Load(InName: string): Texture;
    }
    
    class Texture2D extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelIndex: number;
        FirstResourceMemMip: number;
        bTemporarilyDisableStreaming: boolean;
        bHasBeenPaintedInEditor: boolean;
        AddressX: number;
        AddressY: number;
        ImportedSize: IntPoint;
        Blueprint_GetSizeY(): number;
        Blueprint_GetSizeX(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2D;
        static Load(InName: string): Texture2D;
    }
    
    class VirtualTextureBuildSettings {
        constructor(TileSize: number, TileBorderSize: number, bEnableCompressCrunch: boolean, bEnableCompressZlib: boolean);
        TileSize: number;
        TileBorderSize: number;
        bEnableCompressCrunch: boolean;
        bEnableCompressZlib: boolean;
    }
    
    class RuntimeVirtualTextureStreamingProxy extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: VirtualTextureBuildSettings;
        bSinglePhysicalSpace: boolean;
        BuildHash: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureStreamingProxy;
        static Load(InName: string): RuntimeVirtualTextureStreamingProxy;
    }
    
    class RuntimeVirtualTexture extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialType: ERuntimeVirtualTextureMaterialType;
        bCompressTextures: boolean;
        bEnable: boolean;
        bClearTextures: boolean;
        bSinglePhysicalSpace: boolean;
        bPrivateSpace: boolean;
        bEnableScalability: boolean;
        Size: number;
        TileCount: number;
        TileSize: number;
        TileBorderSize: number;
        RemoveLowMips: number;
        StreamLowMips: number;
        StreamingTexture: RuntimeVirtualTextureStreamingProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTexture;
        static Load(InName: string): RuntimeVirtualTexture;
    }
    
    enum ERuntimeVirtualTextureMainPassType { Never, Exclusive, Always, ERuntimeVirtualTextureMainPassType_MAX}
    enum ESleepFamily { Normal, Sensitive, Custom, ESleepFamily_MAX}
    class CollisionResponseContainer {
        constructor(WorldStatic: number, WorldDynamic: number, Pawn: number, Visibility: number, Camera: number, PhysicsBody: number, Vehicle: number, Destructible: number, EngineTraceChannel1: number, EngineTraceChannel2: number, EngineTraceChannel3: number, EngineTraceChannel4: number, EngineTraceChannel5: number, EngineTraceChannel6: number, GameTraceChannel1: number, GameTraceChannel2: number, GameTraceChannel3: number, GameTraceChannel4: number, GameTraceChannel5: number, GameTraceChannel6: number, GameTraceChannel7: number, GameTraceChannel8: number, GameTraceChannel9: number, GameTraceChannel10: number, GameTraceChannel11: number, GameTraceChannel12: number, GameTraceChannel13: number, GameTraceChannel14: number, GameTraceChannel15: number, GameTraceChannel16: number, GameTraceChannel17: number, GameTraceChannel18: number);
        WorldStatic: number;
        WorldDynamic: number;
        Pawn: number;
        Visibility: number;
        Camera: number;
        PhysicsBody: number;
        Vehicle: number;
        Destructible: number;
        EngineTraceChannel1: number;
        EngineTraceChannel2: number;
        EngineTraceChannel3: number;
        EngineTraceChannel4: number;
        EngineTraceChannel5: number;
        EngineTraceChannel6: number;
        GameTraceChannel1: number;
        GameTraceChannel2: number;
        GameTraceChannel3: number;
        GameTraceChannel4: number;
        GameTraceChannel5: number;
        GameTraceChannel6: number;
        GameTraceChannel7: number;
        GameTraceChannel8: number;
        GameTraceChannel9: number;
        GameTraceChannel10: number;
        GameTraceChannel11: number;
        GameTraceChannel12: number;
        GameTraceChannel13: number;
        GameTraceChannel14: number;
        GameTraceChannel15: number;
        GameTraceChannel16: number;
        GameTraceChannel17: number;
        GameTraceChannel18: number;
    }
    
    class ResponseChannel {
        constructor(Channel: string, Response: number);
        Channel: string;
        Response: number;
    }
    
    class CollisionResponse {
        constructor(ResponseToChannels: CollisionResponseContainer, ResponseArray: TArray<ResponseChannel>);
        ResponseToChannels: CollisionResponseContainer;
        ResponseArray: TArray<ResponseChannel>;
    }
    
    class WalkableSlopeOverride {
        constructor(WalkableSlopeBehavior: number, WalkableSlopeAngle: number);
        WalkableSlopeBehavior: number;
        WalkableSlopeAngle: number;
    }
    
    class PhysicalMaterialPropertyBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialPropertyBase;
        static Load(InName: string): PhysicalMaterialPropertyBase;
    }
    
    class DataAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NativeClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataAsset;
        static Load(InName: string): DataAsset;
    }
    
    class TireType extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrictionScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TireType;
        static Load(InName: string): TireType;
    }
    
    class TireFrictionScalePair {
        constructor(TireType: TireType, FrictionScale: number);
        TireType: TireType;
        FrictionScale: number;
    }
    
    class PhysicalMaterial extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Friction: number;
        FrictionCombineMode: number;
        bOverrideFrictionCombineMode: boolean;
        Restitution: number;
        RestitutionCombineMode: number;
        bOverrideRestitutionCombineMode: boolean;
        Density: number;
        RaiseMassToPower: number;
        DestructibleDamageThresholdScale: number;
        PhysicalMaterialProperty: PhysicalMaterialPropertyBase;
        SurfaceType: number;
        TireFrictionScale: number;
        TireFrictionScales: TArray<TireFrictionScalePair>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalMaterial;
        static Load(InName: string): PhysicalMaterial;
    }
    
    class BodyInstance {
        constructor(ObjectType: number, CollisionEnabled: number, SleepFamily: ESleepFamily, DOFMode: number, bUseCCD: boolean, bNotifyRigidBodyCollision: boolean, bSimulatePhysics: boolean, bOverrideMass: boolean, bEnableGravity: boolean, bAutoWeld: boolean, bStartAwake: boolean, bGenerateWakeEvents: boolean, bUpdateMassWhenScaleChanges: boolean, bLockTranslation: boolean, bLockRotation: boolean, bLockXTranslation: boolean, bLockYTranslation: boolean, bLockZTranslation: boolean, bLockXRotation: boolean, bLockYRotation: boolean, bLockZRotation: boolean, bOverrideMaxAngularVelocity: boolean, bOverrideMaxDepenetrationVelocity: boolean, bOverrideWalkableSlopeOnInstance: boolean, bInterpolateWhenSubStepping: boolean, ResponseToChannels: CollisionResponseContainer, CollisionProfileName: string, PositionSolverIterationCount: number, VelocitySolverIterationCount: number, CollisionResponses: CollisionResponse, MaxDepenetrationVelocity: number, MassInKgOverride: number, LinearDamping: number, AngularDamping: number, CustomDOFPlaneNormal: Vector, COMNudge: Vector, MassScale: number, InertiaTensorScale: Vector, WalkableSlopeOverride: WalkableSlopeOverride, PhysMaterialOverride: PhysicalMaterial, MaxAngularVelocity: number, CustomSleepThresholdMultiplier: number, StabilizationThresholdMultiplier: number, PhysicsBlendWeight: number);
        ObjectType: number;
        CollisionEnabled: number;
        SleepFamily: ESleepFamily;
        DOFMode: number;
        bUseCCD: boolean;
        bNotifyRigidBodyCollision: boolean;
        bSimulatePhysics: boolean;
        bOverrideMass: boolean;
        bEnableGravity: boolean;
        bAutoWeld: boolean;
        bStartAwake: boolean;
        bGenerateWakeEvents: boolean;
        bUpdateMassWhenScaleChanges: boolean;
        bLockTranslation: boolean;
        bLockRotation: boolean;
        bLockXTranslation: boolean;
        bLockYTranslation: boolean;
        bLockZTranslation: boolean;
        bLockXRotation: boolean;
        bLockYRotation: boolean;
        bLockZRotation: boolean;
        bOverrideMaxAngularVelocity: boolean;
        bOverrideMaxDepenetrationVelocity: boolean;
        bOverrideWalkableSlopeOnInstance: boolean;
        bInterpolateWhenSubStepping: boolean;
        ResponseToChannels: CollisionResponseContainer;
        CollisionProfileName: string;
        PositionSolverIterationCount: number;
        VelocitySolverIterationCount: number;
        CollisionResponses: CollisionResponse;
        MaxDepenetrationVelocity: number;
        MassInKgOverride: number;
        LinearDamping: number;
        AngularDamping: number;
        CustomDOFPlaneNormal: Vector;
        COMNudge: Vector;
        MassScale: number;
        InertiaTensorScale: Vector;
        WalkableSlopeOverride: WalkableSlopeOverride;
        PhysMaterialOverride: PhysicalMaterial;
        MaxAngularVelocity: number;
        CustomSleepThresholdMultiplier: number;
        StabilizationThresholdMultiplier: number;
        PhysicsBlendWeight: number;
    }
    
    class Vector_NetQuantize extends Vector {
        constructor();
    }
    
    class Vector_NetQuantizeNormal extends Vector {
        constructor();
    }
    
    class HitResult {
        constructor(bBlockingHit: boolean, bStartPenetrating: boolean, FaceIndex: number, Time: number, Distance: number, Location: Vector_NetQuantize, ImpactPoint: Vector_NetQuantize, Normal: Vector_NetQuantizeNormal, ImpactNormal: Vector_NetQuantizeNormal, TraceStart: Vector_NetQuantize, TraceEnd: Vector_NetQuantize, PenetrationDepth: number, Item: number, PhysMaterial: TWeakObjectPtr<PhysicalMaterial>, Actor: TWeakObjectPtr<Actor>, Component: TWeakObjectPtr<PrimitiveComponent>, BoneName: string, MyBoneName: string);
        bBlockingHit: boolean;
        bStartPenetrating: boolean;
        FaceIndex: number;
        Time: number;
        Distance: number;
        Location: Vector_NetQuantize;
        ImpactPoint: Vector_NetQuantize;
        Normal: Vector_NetQuantizeNormal;
        ImpactNormal: Vector_NetQuantizeNormal;
        TraceStart: Vector_NetQuantize;
        TraceEnd: Vector_NetQuantize;
        PenetrationDepth: number;
        Item: number;
        PhysMaterial: TWeakObjectPtr<PhysicalMaterial>;
        Actor: TWeakObjectPtr<Actor>;
        Component: TWeakObjectPtr<PrimitiveComponent>;
        BoneName: string;
        MyBoneName: string;
    }
    
    class Key {
        constructor(KeyName: string);
        KeyName: string;
    }
    
    class SubsurfaceProfileStruct {
        constructor(SurfaceAlbedo: LinearColor, MeanFreePathColor: LinearColor, MeanFreePathDistance: number, WorldUnitScale: number, bEnableBurley: boolean, ScatterRadius: number, SubsurfaceColor: LinearColor, FalloffColor: LinearColor, BoundaryColorBleed: LinearColor, ExtinctionScale: number, NormalScale: number, ScatteringDistribution: number, IOR: number, Roughness0: number, Roughness1: number, LobeMix: number, TransmissionTintColor: LinearColor);
        SurfaceAlbedo: LinearColor;
        MeanFreePathColor: LinearColor;
        MeanFreePathDistance: number;
        WorldUnitScale: number;
        bEnableBurley: boolean;
        ScatterRadius: number;
        SubsurfaceColor: LinearColor;
        FalloffColor: LinearColor;
        BoundaryColorBleed: LinearColor;
        ExtinctionScale: number;
        NormalScale: number;
        ScatteringDistribution: number;
        IOR: number;
        Roughness0: number;
        Roughness1: number;
        LobeMix: number;
        TransmissionTintColor: LinearColor;
    }
    
    class SubsurfaceProfile extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: SubsurfaceProfileStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfile;
        static Load(InName: string): SubsurfaceProfile;
    }
    
    class LightmassMaterialInterfaceSettings {
        constructor(EmissiveBoost: number, DiffuseBoost: number, ExportResolutionScale: number, bCastShadowAsMasked: boolean, bOverrideCastShadowAsMasked: boolean, bOverrideEmissiveBoost: boolean, bOverrideDiffuseBoost: boolean, bOverrideExportResolutionScale: boolean);
        EmissiveBoost: number;
        DiffuseBoost: number;
        ExportResolutionScale: number;
        bCastShadowAsMasked: boolean;
        bOverrideCastShadowAsMasked: boolean;
        bOverrideEmissiveBoost: boolean;
        bOverrideDiffuseBoost: boolean;
        bOverrideExportResolutionScale: boolean;
    }
    
    class SoftObjectPath {
        constructor(AssetPathName: string, SubPathString: string);
        AssetPathName: string;
        SubPathString: string;
    }
    
    class MaterialTextureInfo {
        constructor(SamplingScale: number, UVChannelIndex: number, TextureName: string, TextureReference: SoftObjectPath, TextureIndex: number);
        SamplingScale: number;
        UVChannelIndex: number;
        TextureName: string;
        TextureReference: SoftObjectPath;
        TextureIndex: number;
    }
    
    class ThumbnailInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ThumbnailInfo;
        static Load(InName: string): ThumbnailInfo;
    }
    
    class EdGraphTerminalType {
        constructor(TerminalCategory: string, TerminalSubCategory: string, TerminalSubCategoryObject: TWeakObjectPtr<Object>, bTerminalIsConst: boolean, bTerminalIsWeakPointer: boolean);
        TerminalCategory: string;
        TerminalSubCategory: string;
        TerminalSubCategoryObject: TWeakObjectPtr<Object>;
        bTerminalIsConst: boolean;
        bTerminalIsWeakPointer: boolean;
    }
    
    enum EPinContainerType { None, Array, Set, Map, EPinContainerType_MAX}
    class EdGraphPinType {
        constructor(PinCategory: string, PinSubCategory: string, PinSubCategoryObject: TWeakObjectPtr<Object>, PinSubCategoryMemberReference: SimpleMemberReference, PinValueType: EdGraphTerminalType, ContainerType: EPinContainerType, bIsArray: boolean, bIsReference: boolean, bIsConst: boolean, bIsWeakPointer: boolean);
        PinCategory: string;
        PinSubCategory: string;
        PinSubCategoryObject: TWeakObjectPtr<Object>;
        PinSubCategoryMemberReference: SimpleMemberReference;
        PinValueType: EdGraphTerminalType;
        ContainerType: EPinContainerType;
        bIsArray: boolean;
        bIsReference: boolean;
        bIsConst: boolean;
        bIsWeakPointer: boolean;
    }
    
    class EdGraphPin_Deprecated extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinName: string;
        PinFriendlyName: string;
        PinToolTip: string;
        Direction: number;
        PinType: EdGraphPinType;
        DefaultValue: string;
        AutogeneratedDefaultValue: string;
        DefaultObject: Object;
        DefaultTextValue: string;
        LinkedTo: TArray<EdGraphPin_Deprecated>;
        SubPins: TArray<EdGraphPin_Deprecated>;
        ParentPin: EdGraphPin_Deprecated;
        ReferencePassThroughConnection: EdGraphPin_Deprecated;
        bHidden: boolean;
        bNotConnectable: boolean;
        bDefaultValueIsReadOnly: boolean;
        bDefaultValueIsIgnored: boolean;
        bIsDiffing: boolean;
        bAdvancedView: boolean;
        bDisplayAsMutableRef: boolean;
        PersistentGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphPin_Deprecated;
        static Load(InName: string): EdGraphPin_Deprecated;
    }
    
    enum ENodeEnabledState { Enabled, Disabled, DevelopmentOnly, ENodeEnabledState_MAX}
    class EdGraphNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeprecatedPins: TArray<EdGraphPin_Deprecated>;
        NodePosX: number;
        NodePosY: number;
        NodeWidth: number;
        NodeHeight: number;
        AdvancedPinDisplay: number;
        EnabledState: ENodeEnabledState;
        bDisplayAsDisabled: boolean;
        bUserSetEnabledState: boolean;
        bIsNodeEnabled: boolean;
        bCanResizeNode: boolean;
        bHasCompilerMessage: boolean;
        bCommentBubblePinned: boolean;
        bCommentBubbleVisible: boolean;
        bCommentBubbleMakeVisible: boolean;
        bCanRenameNode: boolean;
        NodeUpgradeMessage: string;
        NodeComment: string;
        ErrorType: number;
        ErrorMsg: string;
        NodeGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode;
        static Load(InName: string): EdGraphNode;
    }
    
    enum EMaterialFunctionUsage { Default, MaterialLayer, MaterialLayerBlend, EMaterialFunctionUsage_MAX}
    class MaterialFunctionInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StateId: Guid;
        MaterialFunctionUsage: EMaterialFunctionUsage;
        CombinedInputTypes: number;
        CombinedOutputTypes: number;
        ThumbnailInfo: ThumbnailInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInterface;
        static Load(InName: string): MaterialFunctionInterface;
    }
    
    class MaterialExpressionComment extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        SizeY: number;
        Text: string;
        CommentColor: LinearColor;
        FontSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionComment;
        static Load(InName: string): MaterialExpressionComment;
    }
    
    class MaterialFunction extends MaterialFunctionInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentFunction: MaterialFunction;
        Description: string;
        FunctionExpressions: TArray<MaterialExpression>;
        bExposeToLibrary: boolean;
        bPrefixParameterNames: boolean;
        LibraryCategories: TArray<string>;
        LibraryCategoriesText: TArray<string>;
        FunctionEditorComments: TArray<MaterialExpressionComment>;
        PreviewMaterial: Material;
        bReentrantFlag: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunction;
        static Load(InName: string): MaterialFunction;
    }
    
    class ExpressionOutput {
        constructor(OutputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number);
        OutputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
    }
    
    class MaterialExpression extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialExpressionEditorX: number;
        MaterialExpressionEditorY: number;
        GraphNode: EdGraphNode;
        MaterialExpressionGuid: Guid;
        Material: Material;
        Function: MaterialFunction;
        Desc: string;
        bRealtimePreview: boolean;
        bNeedToUpdatePreview: boolean;
        bIsParameterExpression: boolean;
        bCommentBubbleVisible: boolean;
        bShowOutputNameOnPin: boolean;
        bShowMaskColorsOnPin: boolean;
        bHidePreviewWindow: boolean;
        bCollapsed: boolean;
        bShaderInputData: boolean;
        bShowInputs: boolean;
        bShowOutputs: boolean;
        MenuCategories: TArray<string>;
        Outputs: TArray<ExpressionOutput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpression;
        static Load(InName: string): MaterialExpression;
    }
    
    class MaterialInput {
        constructor(Expression: MaterialExpression, OutputIndex: number, InputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number, ExpressionName: string);
        Expression: MaterialExpression;
        OutputIndex: number;
        InputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        ExpressionName: string;
    }
    
    class ColorMaterialInput extends MaterialInput {
        constructor(UseConstant: boolean, Constant: Color);
        UseConstant: boolean;
        Constant: Color;
    }
    
    class ScalarMaterialInput extends MaterialInput {
        constructor(UseConstant: boolean, Constant: number);
        UseConstant: boolean;
        Constant: number;
    }
    
    class VectorMaterialInput extends MaterialInput {
        constructor(UseConstant: boolean, Constant: Vector);
        UseConstant: boolean;
        Constant: Vector;
    }
    
    class MaterialShadingModelField {
        constructor(ShadingModelField: number);
        ShadingModelField: number;
    }
    
    class Vector2MaterialInput extends MaterialInput {
        constructor(UseConstant: boolean, ConstantX: number, ConstantY: number);
        UseConstant: boolean;
        ConstantX: number;
        ConstantY: number;
    }
    
    class ExpressionInput {
        constructor(Expression: MaterialExpression, OutputIndex: number, InputName: string, Mask: number, MaskR: number, MaskG: number, MaskB: number, MaskA: number, ExpressionName: string);
        Expression: MaterialExpression;
        OutputIndex: number;
        InputName: string;
        Mask: number;
        MaskR: number;
        MaskG: number;
        MaskB: number;
        MaskA: number;
        ExpressionName: string;
    }
    
    class MaterialAttributesInput extends ExpressionInput {
        constructor(PropertyConnectedBitmask: number);
        PropertyConnectedBitmask: number;
    }
    
    class ShadingModelMaterialInput extends MaterialInput {
        constructor();
    }
    
    class ParameterGroupData {
        constructor(GroupName: string, GroupSortPriority: number);
        GroupName: string;
        GroupSortPriority: number;
    }
    
    class MaterialFunctionInfo {
        constructor(StateId: Guid, Function: MaterialFunctionInterface);
        StateId: Guid;
        Function: MaterialFunctionInterface;
    }
    
    class CollectionParameterBase {
        constructor(ParameterName: string, Id: Guid);
        ParameterName: string;
        Id: Guid;
    }
    
    class CollectionScalarParameter extends CollectionParameterBase {
        constructor(DefaultValue: number);
        DefaultValue: number;
    }
    
    class CollectionVectorParameter extends CollectionParameterBase {
        constructor(DefaultValue: LinearColor);
        DefaultValue: LinearColor;
    }
    
    class MaterialParameterCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StateId: Guid;
        ScalarParameters: TArray<CollectionScalarParameter>;
        VectorParameters: TArray<CollectionVectorParameter>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollection;
        static Load(InName: string): MaterialParameterCollection;
    }
    
    class MaterialParameterCollectionInfo {
        constructor(StateId: Guid, ParameterCollection: MaterialParameterCollection);
        StateId: Guid;
        ParameterCollection: MaterialParameterCollection;
    }
    
    class Material extends MaterialInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysMaterial: PhysicalMaterial;
        DiffuseColor: ColorMaterialInput;
        SpecularColor: ColorMaterialInput;
        BaseColor: ColorMaterialInput;
        Metallic: ScalarMaterialInput;
        Specular: ScalarMaterialInput;
        Roughness: ScalarMaterialInput;
        Normal: VectorMaterialInput;
        EmissiveColor: ColorMaterialInput;
        Opacity: ScalarMaterialInput;
        OpacityMask: ScalarMaterialInput;
        MaterialDomain: number;
        BlendMode: number;
        DecalBlendMode: number;
        MaterialDecalResponse: number;
        ShadingModel: number;
        bCastDynamicShadowAsMasked: boolean;
        ShadingModels: MaterialShadingModelField;
        UsedShadingModels: string;
        OpacityMaskClipValue: number;
        WorldPositionOffset: VectorMaterialInput;
        WorldDisplacement: VectorMaterialInput;
        TessellationMultiplier: ScalarMaterialInput;
        SubsurfaceColor: ColorMaterialInput;
        ClearCoat: ScalarMaterialInput;
        ClearCoatRoughness: ScalarMaterialInput;
        AmbientOcclusion: ScalarMaterialInput;
        Refraction: ScalarMaterialInput;
        CustomizedUVs: FixSizeArray<Vector2MaterialInput>;
        MaterialAttributes: MaterialAttributesInput;
        PixelDepthOffset: ScalarMaterialInput;
        ShadingModelFromMaterialExpression: ShadingModelMaterialInput;
        bEnableSeparateTranslucency: boolean;
        bEnableResponsiveAA: boolean;
        bScreenSpaceReflections: boolean;
        bContactShadows: boolean;
        TwoSided: boolean;
        DitheredLODTransition: boolean;
        DitherOpacityMask: boolean;
        bAllowNegativeEmissiveColor: boolean;
        TranslucencyLightingMode: number;
        bEnableMobileSeparateTranslucency: boolean;
        NumCustomizedUVs: number;
        TranslucencyDirectionalLightingIntensity: number;
        TranslucentShadowDensityScale: number;
        TranslucentSelfShadowDensityScale: number;
        TranslucentSelfShadowSecondDensityScale: number;
        TranslucentSelfShadowSecondOpacity: number;
        TranslucentBackscatteringExponent: number;
        TranslucentMultipleScatteringExtinction: LinearColor;
        TranslucentShadowStartOffset: number;
        bDisableDepthTest: boolean;
        bWriteOnlyAlpha: boolean;
        bGenerateSphericalParticleNormals: boolean;
        bTangentSpaceNormal: boolean;
        bUseEmissiveForDynamicAreaLighting: boolean;
        bBlockGI: boolean;
        bUsedAsSpecialEngineMaterial: boolean;
        bUsedWithSkeletalMesh: boolean;
        bUsedWithEditorCompositing: boolean;
        bUsedWithParticleSprites: boolean;
        bUsedWithBeamTrails: boolean;
        bUsedWithMeshParticles: boolean;
        bUsedWithNiagaraSprites: boolean;
        bUsedWithNiagaraRibbons: boolean;
        bUsedWithNiagaraMeshParticles: boolean;
        bUsedWithGeometryCache: boolean;
        bUsedWithStaticLighting: boolean;
        bUsedWithMorphTargets: boolean;
        bUsedWithSplineMeshes: boolean;
        bUsedWithInstancedStaticMeshes: boolean;
        bUsedWithGeometryCollections: boolean;
        bUsesDistortion: boolean;
        bUsedWithClothing: boolean;
        bUsedWithWater: boolean;
        bUsedWithHairStrands: boolean;
        bUsedWithUI: boolean;
        bAutomaticallySetUsageInEditor: boolean;
        bFullyRough: boolean;
        bUseFullPrecision: boolean;
        bUseLightmapDirectionality: boolean;
        bUseHQForwardReflections: boolean;
        bUsePlanarForwardReflections: boolean;
        bNormalCurvatureToRoughness: boolean;
        D3D11TessellationMode: number;
        bEnableCrackFreeDisplacement: boolean;
        bEnableAdaptiveTessellation: boolean;
        AllowTranslucentCustomDepthWrites: boolean;
        Wireframe: boolean;
        bOutputVelocityOnBasePass: boolean;
        EditorX: number;
        EditorY: number;
        EditorPitch: number;
        EditorYaw: number;
        Expressions: TArray<MaterialExpression>;
        EditorComments: TArray<MaterialExpressionComment>;
        ParameterGroupData: TArray<ParameterGroupData>;
        MaterialFunctionInfos: TArray<MaterialFunctionInfo>;
        MaterialParameterCollectionInfos: TArray<MaterialParameterCollectionInfo>;
        bCanMaskedBeAssumedOpaque: boolean;
        bIsMasked: boolean;
        bIsPreviewMaterial: boolean;
        bIsFunctionPreviewMaterial: boolean;
        bUseMaterialAttributes: boolean;
        bCastRayTracedShadows: boolean;
        bUseTranslucencyVertexFog: boolean;
        bIsSky: boolean;
        bComputeFogPerPixel: boolean;
        bOutputTranslucentVelocity: boolean;
        bAllowDevelopmentShaderCompile: boolean;
        bIsMaterialEditorStatsMaterial: boolean;
        BlendableLocation: number;
        BlendableOutputAlpha: boolean;
        bEnableStencilTest: boolean;
        StencilCompare: number;
        StencilRefValue: number;
        RefractionMode: number;
        BlendablePriority: number;
        UsageFlagWarnings: number;
        RefractionDepthBias: number;
        StateId: Guid;
        MaxDisplacement: number;
        CachedQualityLevelsUsed: TArray<boolean>;
        ExpressionTextureReferences: TArray<Object>;
        ReferencedTextureGuids: TArray<Guid>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Material;
        static Load(InName: string): Material;
    }
    
    class MaterialInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SubsurfaceProfile: SubsurfaceProfile;
        LightmassSettings: LightmassMaterialInterfaceSettings;
        bTextureStreamingDataSorted: boolean;
        TextureStreamingDataVersion: number;
        TextureStreamingData: TArray<MaterialTextureInfo>;
        AssetUserData: TArray<AssetUserData>;
        TextureStreamingDataMissingEntries: TArray<MaterialTextureInfo>;
        PreviewMesh: SoftObjectPath;
        ThumbnailInfo: ThumbnailInfo;
        LayerParameterExpansion: TMap<string, boolean>;
        ParameterOverviewExpansion: TMap<string, boolean>;
        AssetImportData: AssetImportData;
        LightingGuid: Guid;
        SetForceMipLevelsToBeResident(OverrideForceMiplevelsToBeResident: boolean, bForceMiplevelsToBeResidentValue: boolean, ForceDuration: number, CinematicTextureGroups: number, bFastResponse: boolean): void;
        GetPhysicalMaterial(): PhysicalMaterial;
        GetBaseMaterial(): Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInterface;
        static Load(InName: string): MaterialInterface;
    }
    
    class Box {
        constructor(Min: Vector, Max: Vector, IsValid: number);
        Min: Vector;
        Max: Vector;
        IsValid: number;
    }
    
    class CurveBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: AssetImportData;
        ImportPath: string;
        GetValueRange(MinValue: $Ref<number>, MaxValue: $Ref<number>): void;
        GetTimeRange(MinTime: $Ref<number>, MaxTime: $Ref<number>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveBase;
        static Load(InName: string): CurveBase;
    }
    
    class KeyHandleMap {
        constructor();
    }
    
    class IndexedCurve {
        constructor(KeyHandlesToIndices: KeyHandleMap);
        KeyHandlesToIndices: KeyHandleMap;
    }
    
    class RealCurve extends IndexedCurve {
        constructor(DefaultValue: number, PreInfinityExtrap: number, PostInfinityExtrap: number);
        DefaultValue: number;
        PreInfinityExtrap: number;
        PostInfinityExtrap: number;
    }
    
    class RichCurveKey {
        constructor(InterpMode: number, TangentMode: number, TangentWeightMode: number, Time: number, Value: number, ArriveTangent: number, ArriveTangentWeight: number, LeaveTangent: number, LeaveTangentWeight: number);
        InterpMode: number;
        TangentMode: number;
        TangentWeightMode: number;
        Time: number;
        Value: number;
        ArriveTangent: number;
        ArriveTangentWeight: number;
        LeaveTangent: number;
        LeaveTangentWeight: number;
    }
    
    class RichCurve extends RealCurve {
        constructor(Keys: TArray<RichCurveKey>);
        Keys: TArray<RichCurveKey>;
    }
    
    class CurveLinearColor extends CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurves: FixSizeArray<RichCurve>;
        AdjustHue: number;
        AdjustSaturation: number;
        AdjustBrightness: number;
        AdjustBrightnessCurve: number;
        AdjustVibrance: number;
        AdjustMinAlpha: number;
        AdjustMaxAlpha: number;
        GetLinearColorValue(InTime: number): LinearColor;
        GetClampedLinearColorValue(InTime: number): LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColor;
        static Load(InName: string): CurveLinearColor;
    }
    
    class CurveLinearColorAtlas extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsDirty: boolean;
        TextureSize: number;
        GradientCurves: TArray<CurveLinearColor>;
        GetCurvePosition(InCurve: CurveLinearColor, Position: $Ref<number>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorAtlas;
        static Load(InName: string): CurveLinearColorAtlas;
    }
    
    class ScalarParameterAtlasInstanceData {
        constructor(bIsUsedAsAtlasPosition: boolean, Curve: TSoftObjectPtr<CurveLinearColor>, Atlas: TSoftObjectPtr<CurveLinearColorAtlas>);
        bIsUsedAsAtlasPosition: boolean;
        Curve: TSoftObjectPtr<CurveLinearColor>;
        Atlas: TSoftObjectPtr<CurveLinearColorAtlas>;
    }
    
    class MaterialParameterInfo {
        constructor(Name: string, Association: number, Index: number, ParameterLocation: SoftObjectPath);
        Name: string;
        Association: number;
        Index: number;
        ParameterLocation: SoftObjectPath;
    }
    
    class ScalarParameterValue {
        constructor(ParameterName: string, AtlasData: ScalarParameterAtlasInstanceData, ParameterInfo: MaterialParameterInfo, ParameterValue: number, ExpressionGUID: Guid);
        ParameterName: string;
        AtlasData: ScalarParameterAtlasInstanceData;
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: number;
        ExpressionGUID: Guid;
    }
    
    class VectorParameterValue {
        constructor(ParameterName: string, ParameterInfo: MaterialParameterInfo, ParameterValue: LinearColor, ExpressionGUID: Guid);
        ParameterName: string;
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: LinearColor;
        ExpressionGUID: Guid;
    }
    
    class TextureParameterValue {
        constructor(ParameterName: string, ParameterInfo: MaterialParameterInfo, ParameterValue: Texture, ExpressionGUID: Guid);
        ParameterName: string;
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: Texture;
        ExpressionGUID: Guid;
    }
    
    class RuntimeVirtualTextureParameterValue {
        constructor(ParameterInfo: MaterialParameterInfo, ParameterValue: RuntimeVirtualTexture, ExpressionGUID: Guid);
        ParameterInfo: MaterialParameterInfo;
        ParameterValue: RuntimeVirtualTexture;
        ExpressionGUID: Guid;
    }
    
    enum EFontCacheType { Offline, Runtime, EFontCacheType_MAX}
    class FontCharacter {
        constructor(StartU: number, StartV: number, USize: number, VSize: number, TextureIndex: number, VerticalOffset: number);
        StartU: number;
        StartV: number;
        USize: number;
        VSize: number;
        TextureIndex: number;
        VerticalOffset: number;
    }
    
    class FontImportOptionsData {
        constructor(FontName: string, Height: number, bEnableAntialiasing: boolean, bEnableBold: boolean, bEnableItalic: boolean, bEnableUnderline: boolean, bAlphaOnly: boolean, CharacterSet: number, Chars: string, UnicodeRange: string, CharsFilePath: string, CharsFileWildcard: string, bCreatePrintableOnly: boolean, bIncludeASCIIRange: boolean, ForegroundColor: LinearColor, bEnableDropShadow: boolean, TexturePageWidth: number, TexturePageMaxHeight: number, XPadding: number, YPadding: number, ExtendBoxTop: number, ExtendBoxBottom: number, ExtendBoxRight: number, ExtendBoxLeft: number, bEnableLegacyMode: boolean, Kerning: number, bUseDistanceFieldAlpha: boolean, DistanceFieldScaleFactor: number, DistanceFieldScanRadiusScale: number);
        FontName: string;
        Height: number;
        bEnableAntialiasing: boolean;
        bEnableBold: boolean;
        bEnableItalic: boolean;
        bEnableUnderline: boolean;
        bAlphaOnly: boolean;
        CharacterSet: number;
        Chars: string;
        UnicodeRange: string;
        CharsFilePath: string;
        CharsFileWildcard: string;
        bCreatePrintableOnly: boolean;
        bIncludeASCIIRange: boolean;
        ForegroundColor: LinearColor;
        bEnableDropShadow: boolean;
        TexturePageWidth: number;
        TexturePageMaxHeight: number;
        XPadding: number;
        YPadding: number;
        ExtendBoxTop: number;
        ExtendBoxBottom: number;
        ExtendBoxRight: number;
        ExtendBoxLeft: number;
        bEnableLegacyMode: boolean;
        Kerning: number;
        bUseDistanceFieldAlpha: boolean;
        DistanceFieldScaleFactor: number;
        DistanceFieldScanRadiusScale: number;
    }
    
    enum EFontHinting { Default, Auto, AutoLight, Monochrome, None, EFontHinting_MAX}
    enum EFontLoadingPolicy { LazyLoad, Stream, Inline, EFontLoadingPolicy_MAX}
    class FontBulkData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontBulkData;
        static Load(InName: string): FontBulkData;
    }
    
    class FontData {
        constructor(FontFilename: string, Hinting: EFontHinting, LoadingPolicy: EFontLoadingPolicy, SubFaceIndex: number, FontFaceAsset: Object, BulkDataPtr: FontBulkData, FontData: TArray<number>);
        FontFilename: string;
        Hinting: EFontHinting;
        LoadingPolicy: EFontLoadingPolicy;
        SubFaceIndex: number;
        FontFaceAsset: Object;
        BulkDataPtr: FontBulkData;
        FontData: TArray<number>;
    }
    
    class TypefaceEntry {
        constructor(Name: string, Font: FontData);
        Name: string;
        Font: FontData;
    }
    
    class Typeface {
        constructor(Fonts: TArray<TypefaceEntry>);
        Fonts: TArray<TypefaceEntry>;
    }
    
    class CompositeFallbackFont {
        constructor(Typeface: Typeface, ScalingFactor: number);
        Typeface: Typeface;
        ScalingFactor: number;
    }
    
    class Int32RangeBound {
        constructor(Type: number, Value: number);
        Type: number;
        Value: number;
    }
    
    class Int32Range {
        constructor(LowerBound: Int32RangeBound, UpperBound: Int32RangeBound);
        LowerBound: Int32RangeBound;
        UpperBound: Int32RangeBound;
    }
    
    class CompositeSubFont extends CompositeFallbackFont {
        constructor(CharacterRanges: TArray<Int32Range>, Cultures: string, EditorName: string);
        CharacterRanges: TArray<Int32Range>;
        Cultures: string;
        EditorName: string;
    }
    
    class CompositeFont {
        constructor(DefaultTypeface: Typeface, FallbackTypeface: CompositeFallbackFont, SubTypefaces: TArray<CompositeSubFont>);
        DefaultTypeface: Typeface;
        FallbackTypeface: CompositeFallbackFont;
        SubTypefaces: TArray<CompositeSubFont>;
    }
    
    class Font extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FontCacheType: EFontCacheType;
        Characters: TArray<FontCharacter>;
        Textures: TArray<Texture2D>;
        IsRemapped: number;
        EmScale: number;
        Ascent: number;
        Descent: number;
        Leading: number;
        Kerning: number;
        ImportOptions: FontImportOptionsData;
        NumCharacters: number;
        MaxCharHeight: TArray<number>;
        ScalingFactor: number;
        LegacyFontSize: number;
        LegacyFontName: string;
        CompositeFont: CompositeFont;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Font;
        static Load(InName: string): Font;
    }
    
    class FontParameterValue {
        constructor(ParameterName: string, ParameterInfo: MaterialParameterInfo, FontValue: Font, FontPage: number, ExpressionGUID: Guid);
        ParameterName: string;
        ParameterInfo: MaterialParameterInfo;
        FontValue: Font;
        FontPage: number;
        ExpressionGUID: Guid;
    }
    
    class MaterialInstanceBasePropertyOverrides {
        constructor(bOverride_OpacityMaskClipValue: boolean, bOverride_BlendMode: boolean, bOverride_ShadingModel: boolean, bOverride_DitheredLODTransition: boolean, bOverride_CastDynamicShadowAsMasked: boolean, bOverride_TwoSided: boolean, TwoSided: boolean, DitheredLODTransition: boolean, bCastDynamicShadowAsMasked: boolean, BlendMode: number, ShadingModel: number, OpacityMaskClipValue: number);
        bOverride_OpacityMaskClipValue: boolean;
        bOverride_BlendMode: boolean;
        bOverride_ShadingModel: boolean;
        bOverride_DitheredLODTransition: boolean;
        bOverride_CastDynamicShadowAsMasked: boolean;
        bOverride_TwoSided: boolean;
        TwoSided: boolean;
        DitheredLODTransition: boolean;
        bCastDynamicShadowAsMasked: boolean;
        BlendMode: number;
        ShadingModel: number;
        OpacityMaskClipValue: number;
    }
    
    class StaticParameterBase {
        constructor(ParameterInfo: MaterialParameterInfo, bOverride: boolean, ExpressionGUID: Guid);
        ParameterInfo: MaterialParameterInfo;
        bOverride: boolean;
        ExpressionGUID: Guid;
    }
    
    class StaticSwitchParameter extends StaticParameterBase {
        constructor(Value: boolean);
        Value: boolean;
    }
    
    class StaticComponentMaskParameter extends StaticParameterBase {
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;
    }
    
    class StaticTerrainLayerWeightParameter extends StaticParameterBase {
        constructor(WeightmapIndex: number, bWeightBasedBlend: boolean);
        WeightmapIndex: number;
        bWeightBasedBlend: boolean;
    }
    
    class MaterialLayersFunctions {
        constructor(Layers: TArray<MaterialFunctionInterface>, Blends: TArray<MaterialFunctionInterface>, LayerNames: TArray<string>, RestrictToLayerRelatives: TArray<boolean>, RestrictToBlendRelatives: TArray<boolean>, LayerStates: TArray<boolean>, KeyString: string);
        Layers: TArray<MaterialFunctionInterface>;
        Blends: TArray<MaterialFunctionInterface>;
        LayerNames: TArray<string>;
        RestrictToLayerRelatives: TArray<boolean>;
        RestrictToBlendRelatives: TArray<boolean>;
        LayerStates: TArray<boolean>;
        KeyString: string;
    }
    
    class StaticMaterialLayersParameter extends StaticParameterBase {
        constructor(Value: MaterialLayersFunctions);
        Value: MaterialLayersFunctions;
    }
    
    class StaticParameterSet {
        constructor(StaticSwitchParameters: TArray<StaticSwitchParameter>, StaticComponentMaskParameters: TArray<StaticComponentMaskParameter>, TerrainLayerWeightParameters: TArray<StaticTerrainLayerWeightParameter>, MaterialLayersParameters: TArray<StaticMaterialLayersParameter>);
        StaticSwitchParameters: TArray<StaticSwitchParameter>;
        StaticComponentMaskParameters: TArray<StaticComponentMaskParameter>;
        TerrainLayerWeightParameters: TArray<StaticTerrainLayerWeightParameter>;
        MaterialLayersParameters: TArray<StaticMaterialLayersParameter>;
    }
    
    class MaterialInstance extends MaterialInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysMaterial: PhysicalMaterial;
        Parent: MaterialInterface;
        bHasStaticPermutationResource: boolean;
        bOverrideSubsurfaceProfile: boolean;
        ScalarParameterValues: TArray<ScalarParameterValue>;
        VectorParameterValues: TArray<VectorParameterValue>;
        TextureParameterValues: TArray<TextureParameterValue>;
        RuntimeVirtualTextureParameterValues: TArray<RuntimeVirtualTextureParameterValue>;
        FontParameterValues: TArray<FontParameterValue>;
        bOverrideBaseProperties: boolean;
        BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
        PermutationTextureReferences: TArray<Object>;
        ReferencedTextureGuids: TArray<Guid>;
        StaticParameters: StaticParameterSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstance;
        static Load(InName: string): MaterialInstance;
    }
    
    class MaterialInstanceDynamic extends MaterialInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetVectorParameterValue(ParameterName: string, Value: LinearColor): void;
        SetTextureParameterValue(ParameterName: string, Value: Texture): void;
        SetScalarParameterValue(ParameterName: string, Value: number): void;
        K2_InterpolateMaterialInstanceParams(SourceA: MaterialInstance, SourceB: MaterialInstance, Alpha: number): void;
        K2_GetVectorParameterValue(ParameterName: string): LinearColor;
        K2_GetTextureParameterValue(ParameterName: string): Texture;
        K2_GetScalarParameterValue(ParameterName: string): number;
        K2_CopyMaterialInstanceParameters(Source: MaterialInterface, bQuickParametersOnly: boolean): void;
        CopyParameterOverrides(MaterialInstance: MaterialInstance): void;
        CopyInterpParameters(Source: MaterialInstance): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceDynamic;
        static Load(InName: string): MaterialInstanceDynamic;
    }
    
    enum EAutoPossessAI { Disabled, PlacedInWorld, Spawned, PlacedInWorldOrSpawned, EAutoPossessAI_MAX}
    class SpriteCategoryInfo {
        constructor(Category: string, DisplayName: string, Description: string);
        Category: string;
        DisplayName: string;
        Description: string;
    }
    
    class BillboardComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sprite: Texture2D;
        bIsScreenSizeScaled: boolean;
        ScreenSize: number;
        U: number;
        UL: number;
        V: number;
        VL: number;
        SpriteCategoryName: string;
        SpriteInfo: SpriteCategoryInfo;
        bUseInEditorScaling: boolean;
        SetUV(NewU: number, NewUL: number, NewV: number, NewVL: number): void;
        SetSpriteAndUV(NewSprite: Texture2D, NewU: number, NewUL: number, NewV: number, NewVL: number): void;
        SetSprite(NewSprite: Texture2D): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BillboardComponent;
        static Load(InName: string): BillboardComponent;
    }
    
    class Info extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Info;
        static Load(InName: string): Info;
    }
    
    class UniqueNetIdWrapper {
        constructor();
    }
    
    class UniqueNetIdRepl extends UniqueNetIdWrapper {
        constructor(ReplicationBytes: TArray<number>);
        ReplicationBytes: TArray<number>;
    }
    
    class PlayerState extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Score: number;
        PlayerName: string;
        PlayerId: number;
        Ping: number;
        bShouldUpdateReplicatedPing: boolean;
        bIsSpectator: boolean;
        bOnlySpectator: boolean;
        bIsABot: boolean;
        bIsInactive: boolean;
        bFromPreviousLevel: boolean;
        StartTime: number;
        EngineMessageClass: Class;
        SavedNetworkAddress: string;
        UniqueId: UniqueNetIdRepl;
        PawnPrivate: Pawn;
        PlayerNamePrivate: string;
        ReceiveOverrideWith(OldPlayerState: PlayerState): void;
        ReceiveCopyProperties(NewPlayerState: PlayerState): void;
        OnRep_UniqueId(): void;
        OnRep_Score(): void;
        OnRep_PlayerName(): void;
        OnRep_PlayerId(): void;
        OnRep_bIsInactive(): void;
        GetPlayerName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerState;
        static Load(InName: string): PlayerState;
    }
    
    class DamageType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCausedByWorld: boolean;
        bScaleMomentumByMass: boolean;
        bRadialDamageVelChange: boolean;
        DamageImpulse: number;
        DestructibleImpulse: number;
        DestructibleDamageSpreadScale: number;
        DamageFalloff: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DamageType;
        static Load(InName: string): DamageType;
    }
    
    class MeshComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OverrideMaterials: TArray<MaterialInterface>;
        bEnableMaterialParameterCaching: boolean;
        SetVectorParameterValueOnMaterials(ParameterName: string, ParameterValue: Vector): void;
        SetScalarParameterValueOnMaterials(ParameterName: string, ParameterValue: number): void;
        PrestreamTextures(Seconds: number, bPrioritizeCharacterTextures: boolean, CinematicTextureGroups: number): void;
        IsMaterialSlotNameValid(MaterialSlotName: string): boolean;
        GetMaterialSlotNames(): TArray<string>;
        GetMaterials(): TArray<MaterialInterface>;
        GetMaterialIndex(MaterialSlotName: string): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshComponent;
        static Load(InName: string): MeshComponent;
    }
    
    class BoneNode {
        constructor(Name: string, ParentIndex: number, TranslationRetargetingMode: number);
        Name: string;
        ParentIndex: number;
        TranslationRetargetingMode: number;
    }
    
    class VirtualBone {
        constructor(SourceBoneName: string, TargetBoneName: string, VirtualBoneName: string);
        SourceBoneName: string;
        TargetBoneName: string;
        VirtualBoneName: string;
    }
    
    class SkeletalMeshSocket extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SocketName: string;
        BoneName: string;
        RelativeLocation: Vector;
        RelativeRotation: Rotator;
        RelativeScale: Vector;
        bForceAlwaysAnimated: boolean;
        InitializeSocketFromLocation(SkelComp: SkeletalMeshComponent, WorldLocation: Vector, WorldNormal: Vector): void;
        GetSocketLocation(SkelComp: SkeletalMeshComponent): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSocket;
        static Load(InName: string): SkeletalMeshSocket;
    }
    
    class SmartNameContainer {
        constructor();
    }
    
    class BoneReference {
        constructor(BoneName: string);
        BoneName: string;
    }
    
    class BlendProfileBoneEntry {
        constructor(BoneReference: BoneReference, BlendScale: number);
        BoneReference: BoneReference;
        BlendScale: number;
    }
    
    class BlendProfile extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningSkeleton: Skeleton;
        ProfileEntries: TArray<BlendProfileBoneEntry>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendProfile;
        static Load(InName: string): BlendProfile;
    }
    
    class AnimSlotGroup {
        constructor(GroupName: string, SlotNames: TArray<string>);
        GroupName: string;
        SlotNames: TArray<string>;
    }
    
    class RigTransformConstraint {
        constructor(TranformType: number, ParentSpace: string, Weight: number);
        TranformType: number;
        ParentSpace: string;
        Weight: number;
    }
    
    class TransformBaseConstraint {
        constructor(TransformConstraints: TArray<RigTransformConstraint>);
        TransformConstraints: TArray<RigTransformConstraint>;
    }
    
    class TransformBase {
        constructor(Node: string, Constraints: FixSizeArray<TransformBaseConstraint>);
        Node: string;
        Constraints: FixSizeArray<TransformBaseConstraint>;
    }
    
    class Node {
        constructor(Name: string, ParentName: string, Transform: Transform, DisplayName: string, bAdvanced: boolean);
        Name: string;
        ParentName: string;
        Transform: Transform;
        DisplayName: string;
        bAdvanced: boolean;
    }
    
    class Rig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformBases: TArray<TransformBase>;
        Nodes: TArray<Node>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Rig;
        static Load(InName: string): Rig;
    }
    
    class NameMapping {
        constructor(NodeName: string, BoneName: string);
        NodeName: string;
        BoneName: string;
    }
    
    class RigConfiguration {
        constructor(Rig: Rig, BoneMappingTable: TArray<NameMapping>);
        Rig: Rig;
        BoneMappingTable: TArray<NameMapping>;
    }
    
    class PreviewAttachedObjectPair {
        constructor(AttachedObject: TSoftObjectPtr<Object>, Object: Object, AttachedTo: string);
        AttachedObject: TSoftObjectPtr<Object>;
        Object: Object;
        AttachedTo: string;
    }
    
    class PreviewAssetAttachContainer {
        constructor(AttachedObjects: TArray<PreviewAttachedObjectPair>);
        AttachedObjects: TArray<PreviewAttachedObjectPair>;
    }
    
    class Skeleton extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoneTree: TArray<BoneNode>;
        RefLocalPoses: TArray<Transform>;
        VirtualBoneGuid: Guid;
        VirtualBones: TArray<VirtualBone>;
        Sockets: TArray<SkeletalMeshSocket>;
        SmartNames: SmartNameContainer;
        BlendProfiles: TArray<BlendProfile>;
        SlotGroups: TArray<AnimSlotGroup>;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        AdditionalPreviewSkeletalMeshes: TSoftObjectPtr<DataAsset>;
        RigConfig: RigConfiguration;
        AnimationNotifies: TArray<string>;
        PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
        AssetUserData: TArray<AssetUserData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Skeleton;
        static Load(InName: string): Skeleton;
    }
    
    class BoxSphereBounds {
        constructor(Origin: Vector, BoxExtent: Vector, SphereRadius: number);
        Origin: Vector;
        BoxExtent: Vector;
        SphereRadius: number;
    }
    
    class MeshUVChannelInfo {
        constructor(bInitialized: boolean, bOverrideDensities: boolean, LocalUVDensities: FixSizeArray<number>);
        bInitialized: boolean;
        bOverrideDensities: boolean;
        LocalUVDensities: FixSizeArray<number>;
    }
    
    class SkeletalMaterial {
        constructor(MaterialInterface: MaterialInterface, MaterialSlotName: string, bEnableShadowCasting: boolean, bRecomputeTangent: boolean, ImportedMaterialSlotName: string, UVChannelData: MeshUVChannelInfo);
        MaterialInterface: MaterialInterface;
        MaterialSlotName: string;
        bEnableShadowCasting: boolean;
        bRecomputeTangent: boolean;
        ImportedMaterialSlotName: string;
        UVChannelData: MeshUVChannelInfo;
    }
    
    class BoneMirrorInfo {
        constructor(SourceIndex: number, BoneFlipAxis: number);
        SourceIndex: number;
        BoneFlipAxis: number;
    }
    
    class PerPlatformFloat {
        constructor(Default: number, PerPlatform: TMap<string, number>);
        Default: number;
        PerPlatform: TMap<string, number>;
    }
    
    class SkeletalMeshBuildSettings {
        constructor(bRecomputeNormals: boolean, bRecomputeTangents: boolean, bUseMikkTSpace: boolean, bComputeWeightedNormals: boolean, bRemoveDegenerates: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bBuildAdjacencyBuffer: boolean, ThresholdPosition: number, ThresholdTangentNormal: number, ThresholdUV: number);
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bUseMikkTSpace: boolean;
        bComputeWeightedNormals: boolean;
        bRemoveDegenerates: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bBuildAdjacencyBuffer: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
    }
    
    class AnimMetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimMetaData;
        static Load(InName: string): AnimMetaData;
    }
    
    class AssetMapping {
        constructor(SourceAsset: AnimationAsset, TargetAsset: AnimationAsset);
        SourceAsset: AnimationAsset;
        TargetAsset: AnimationAsset;
    }
    
    class AssetMappingTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MappedAssets: TArray<AssetMapping>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetMappingTable;
        static Load(InName: string): AssetMappingTable;
    }
    
    class SmartName {
        constructor(DisplayName: string);
        DisplayName: string;
    }
    
    class PoseData {
        constructor(SourceLocalSpacePose: TArray<Transform>, SourceCurveData: TArray<number>, LocalSpacePose: TArray<Transform>, TrackToBufferIndex: TMap<number, number>, CurveData: TArray<number>);
        SourceLocalSpacePose: TArray<Transform>;
        SourceCurveData: TArray<number>;
        LocalSpacePose: TArray<Transform>;
        TrackToBufferIndex: TMap<number, number>;
        CurveData: TArray<number>;
    }
    
    class AnimCurveBase {
        constructor(LastObservedName: string, Name: SmartName, CurveTypeFlags: number);
        LastObservedName: string;
        Name: SmartName;
        CurveTypeFlags: number;
    }
    
    class PoseDataContainer {
        constructor(PoseNames: TArray<SmartName>, Tracks: TArray<string>, TrackMap: TMap<string, number>, Poses: TArray<PoseData>, Curves: TArray<AnimCurveBase>);
        PoseNames: TArray<SmartName>;
        Tracks: TArray<string>;
        TrackMap: TMap<string, number>;
        Poses: TArray<PoseData>;
        Curves: TArray<AnimCurveBase>;
    }
    
    class PoseAsset extends AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PoseContainer: PoseDataContainer;
        bAdditivePose: boolean;
        BasePoseIndex: number;
        RetargetSource: string;
        SourceAnimation: AnimSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseAsset;
        static Load(InName: string): PoseAsset;
    }
    
    class AnimationAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeleton: Skeleton;
        MetaData: TArray<AnimMetaData>;
        ParentAsset: AnimationAsset;
        ChildrenAssets: TArray<AnimationAsset>;
        AssetMappingTable: AssetMappingTable;
        AssetUserData: TArray<AssetUserData>;
        ThumbnailInfo: ThumbnailInfo;
        PreviewPoseAsset: PoseAsset;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationAsset;
        static Load(InName: string): AnimationAsset;
    }
    
    class AnimCompositeBase extends AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompositeBase;
        static Load(InName: string): AnimCompositeBase;
    }
    
    class CurveFloat extends CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurve: RichCurve;
        bIsEventCurve: boolean;
        GetFloatValue(InTime: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveFloat;
        static Load(InName: string): CurveFloat;
    }
    
    enum EAlphaBlendOption { Linear, Cubic, HermiteCubic, Sinusoidal, QuadraticInOut, CubicInOut, QuarticInOut, QuinticInOut, CircularIn, CircularOut, CircularInOut, ExpIn, ExpOut, ExpInOut, Custom, EAlphaBlendOption_MAX}
    class AlphaBlend {
        constructor(CustomCurve: CurveFloat, BlendTime: number, BlendOption: EAlphaBlendOption);
        CustomCurve: CurveFloat;
        BlendTime: number;
        BlendOption: EAlphaBlendOption;
    }
    
    class AnimSyncMarker {
        constructor(MarkerName: string, Time: number, TrackIndex: number);
        MarkerName: string;
        Time: number;
        TrackIndex: number;
    }
    
    class MarkerSyncData {
        constructor(AuthoredSyncMarkers: TArray<AnimSyncMarker>);
        AuthoredSyncMarkers: TArray<AnimSyncMarker>;
    }
    
    class CompositeSection extends AnimLinkableElement {
        constructor(SectionName: string, StartTime: number, NextSectionName: string, MetaData: TArray<AnimMetaData>);
        SectionName: string;
        StartTime: number;
        NextSectionName: string;
        MetaData: TArray<AnimMetaData>;
    }
    
    class AnimSegment {
        constructor(AnimReference: AnimSequenceBase, StartPos: number, AnimStartTime: number, AnimEndTime: number, AnimPlayRate: number, LoopingCount: number);
        AnimReference: AnimSequenceBase;
        StartPos: number;
        AnimStartTime: number;
        AnimEndTime: number;
        AnimPlayRate: number;
        LoopingCount: number;
    }
    
    class AnimTrack {
        constructor(AnimSegments: TArray<AnimSegment>);
        AnimSegments: TArray<AnimSegment>;
    }
    
    class SlotAnimationTrack {
        constructor(SlotName: string, AnimTrack: AnimTrack);
        SlotName: string;
        AnimTrack: AnimTrack;
    }
    
    class BranchingPoint extends AnimLinkableElement {
        constructor(EventName: string, DisplayTime: number, TriggerTimeOffset: number);
        EventName: string;
        DisplayTime: number;
        TriggerTimeOffset: number;
    }
    
    class BranchingPointMarker {
        constructor(NotifyIndex: number, TriggerTime: number, NotifyEventType: number);
        NotifyIndex: number;
        TriggerTime: number;
        NotifyEventType: number;
    }
    
    class TimeStretchCurveMarker {
        constructor(Time: FixSizeArray<number>, Alpha: number);
        Time: FixSizeArray<number>;
        Alpha: number;
    }
    
    class TimeStretchCurve {
        constructor(SamplingRate: number, CurveValueMinPrecision: number, Markers: TArray<TimeStretchCurveMarker>, Sum_dT_i_by_C_i: FixSizeArray<number>);
        SamplingRate: number;
        CurveValueMinPrecision: number;
        Markers: TArray<TimeStretchCurveMarker>;
        Sum_dT_i_by_C_i: FixSizeArray<number>;
    }
    
    class AnimMontage extends AnimCompositeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendIn: AlphaBlend;
        BlendInTime: number;
        BlendOut: AlphaBlend;
        BlendOutTime: number;
        BlendOutTriggerTime: number;
        SyncGroup: string;
        SyncSlotIndex: number;
        MarkerData: MarkerSyncData;
        CompositeSections: TArray<CompositeSection>;
        SlotAnimTracks: TArray<SlotAnimationTrack>;
        BranchingPoints: TArray<BranchingPoint>;
        bEnableRootMotionTranslation: boolean;
        bEnableRootMotionRotation: boolean;
        bEnableAutoBlendOut: boolean;
        RootMotionRootLock: number;
        PreviewBasePose: AnimSequence;
        BranchingPointMarkers: TArray<BranchingPointMarker>;
        BranchingPointStateNotifyIndices: TArray<number>;
        TimeStretchCurve: TimeStretchCurve;
        TimeStretchCurveName: string;
        GetDefaultBlendOutTime(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimMontage;
        static Load(InName: string): AnimMontage;
    }
    
    class AnimLinkableElement {
        constructor(LinkedMontage: AnimMontage, SlotIndex: number, SegmentIndex: number, LinkMethod: number, CachedLinkMethod: number, SegmentBeginTime: number, SegmentLength: number, LinkValue: number, LinkedSequence: AnimSequenceBase);
        LinkedMontage: AnimMontage;
        SlotIndex: number;
        SegmentIndex: number;
        LinkMethod: number;
        CachedLinkMethod: number;
        SegmentBeginTime: number;
        SegmentLength: number;
        LinkValue: number;
        LinkedSequence: AnimSequenceBase;
    }
    
    class AnimNotify extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyColor: Color;
        Received_Notify(MeshComp: SkeletalMeshComponent, Animation: AnimSequenceBase): boolean;
        GetNotifyName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify;
        static Load(InName: string): AnimNotify;
    }
    
    class AnimNotifyState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyColor: Color;
        Received_NotifyTick(MeshComp: SkeletalMeshComponent, Animation: AnimSequenceBase, FrameDeltaTime: number): boolean;
        Received_NotifyEnd(MeshComp: SkeletalMeshComponent, Animation: AnimSequenceBase): boolean;
        Received_NotifyBegin(MeshComp: SkeletalMeshComponent, Animation: AnimSequenceBase, TotalDuration: number): boolean;
        GetNotifyName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState;
        static Load(InName: string): AnimNotifyState;
    }
    
    class AnimNotifyEvent extends AnimLinkableElement {
        constructor(DisplayTime: number, TriggerTimeOffset: number, EndTriggerTimeOffset: number, TriggerWeightThreshold: number, NotifyName: string, Notify: AnimNotify, NotifyStateClass: AnimNotifyState, Duration: number, EndLink: AnimLinkableElement, bConvertedFromBranchingPoint: boolean, MontageTickType: number, NotifyTriggerChance: number, NotifyFilterType: number, NotifyFilterLOD: number, bTriggerOnDedicatedServer: boolean, bTriggerOnFollower: boolean, NotifyColor: Color, TrackIndex: number);
        DisplayTime: number;
        TriggerTimeOffset: number;
        EndTriggerTimeOffset: number;
        TriggerWeightThreshold: number;
        NotifyName: string;
        Notify: AnimNotify;
        NotifyStateClass: AnimNotifyState;
        Duration: number;
        EndLink: AnimLinkableElement;
        bConvertedFromBranchingPoint: boolean;
        MontageTickType: number;
        NotifyTriggerChance: number;
        NotifyFilterType: number;
        NotifyFilterLOD: number;
        bTriggerOnDedicatedServer: boolean;
        bTriggerOnFollower: boolean;
        NotifyColor: Color;
        TrackIndex: number;
    }
    
    class FloatCurve extends AnimCurveBase {
        constructor(FloatCurve: RichCurve);
        FloatCurve: RichCurve;
    }
    
    class VectorCurve extends AnimCurveBase {
        constructor(FloatCurves: FixSizeArray<RichCurve>);
        FloatCurves: FixSizeArray<RichCurve>;
    }
    
    class TransformCurve extends AnimCurveBase {
        constructor(TranslationCurve: VectorCurve, RotationCurve: VectorCurve, ScaleCurve: VectorCurve);
        TranslationCurve: VectorCurve;
        RotationCurve: VectorCurve;
        ScaleCurve: VectorCurve;
    }
    
    class RawCurveTracks {
        constructor(FloatCurves: TArray<FloatCurve>, VectorCurves: TArray<VectorCurve>, TransformCurves: TArray<TransformCurve>);
        FloatCurves: TArray<FloatCurve>;
        VectorCurves: TArray<VectorCurve>;
        TransformCurves: TArray<TransformCurve>;
    }
    
    class AnimNotifyTrack {
        constructor(TrackName: string, TrackColor: LinearColor);
        TrackName: string;
        TrackColor: LinearColor;
    }
    
    class AnimSequenceBase extends AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Notifies: TArray<AnimNotifyEvent>;
        SequenceLength: number;
        RateScale: number;
        RawCurveData: RawCurveTracks;
        AnimNotifyTracks: TArray<AnimNotifyTrack>;
        GetPlayLength(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceBase;
        static Load(InName: string): AnimSequenceBase;
    }
    
    class TrackToSkeletonMap {
        constructor(BoneTreeIndex: number);
        BoneTreeIndex: number;
    }
    
    class AnimCompress extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Description: string;
        bNeedsSkeleton: boolean;
        bEnableSegmenting: boolean;
        IdealNumFramesPerSegment: number;
        MaxNumFramesPerSegment: number;
        TranslationCompressionFormat: number;
        RotationCompressionFormat: number;
        ScaleCompressionFormat: number;
        MaxCurveError: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress;
        static Load(InName: string): AnimCompress;
    }
    
    class AnimCurveCompressionCodec extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec;
        static Load(InName: string): AnimCurveCompressionCodec;
    }
    
    class AnimCurveCompressionSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Codec: AnimCurveCompressionCodec;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionSettings;
        static Load(InName: string): AnimCurveCompressionSettings;
    }
    
    enum EAnimInterpolationType { Linear, Step, EAnimInterpolationType_MAX}
    class AnimSequence extends AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportFileFramerate: number;
        ImportResampleFramerate: number;
        NumFrames: number;
        TrackToSkeletonMapTable: TArray<TrackToSkeletonMap>;
        RawDataGuid: Guid;
        AnimationTrackNames: TArray<string>;
        CompressionScheme: AnimCompress;
        bAllowFrameStripping: boolean;
        CompressionErrorThresholdScale: number;
        CurveCompressionSettings: AnimCurveCompressionSettings;
        AdditiveAnimType: number;
        RefPoseType: number;
        RefPoseSeq: AnimSequence;
        RefFrameIndex: number;
        RetargetSource: string;
        Interpolation: EAnimInterpolationType;
        bEnableRootMotion: boolean;
        RootMotionRootLock: number;
        bForceRootLock: boolean;
        bUseNormalizedRootMotionScale: boolean;
        bRootMotionSettingsCopiedFromMontage: boolean;
        CompressCommandletVersion: number;
        bDoNotOverrideCompression: boolean;
        AssetImportData: AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        bNeedsRebake: boolean;
        AuthoredSyncMarkers: TArray<AnimSyncMarker>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequence;
        static Load(InName: string): AnimSequence;
    }
    
    class SkeletalMeshOptimizationSettings {
        constructor(TerminationCriterion: number, NumOfTrianglesPercentage: number, NumOfVertPercentage: number, MaxNumOfTriangles: number, MaxNumOfVerts: number, MaxDeviationPercentage: number, ReductionMethod: number, SilhouetteImportance: number, TextureImportance: number, ShadingImportance: number, SkinningImportance: number, bRemapMorphTargets: boolean, bRecalcNormals: boolean, WeldingThreshold: number, NormalsThreshold: number, MaxBonesPerVertex: number, bEnforceBoneBoundaries: boolean, VolumeImportance: number, bLockEdges: boolean, BaseLOD: number, BonesToRemove: TArray<BoneReference>, BakePose: AnimSequence);
        TerminationCriterion: number;
        NumOfTrianglesPercentage: number;
        NumOfVertPercentage: number;
        MaxNumOfTriangles: number;
        MaxNumOfVerts: number;
        MaxDeviationPercentage: number;
        ReductionMethod: number;
        SilhouetteImportance: number;
        TextureImportance: number;
        ShadingImportance: number;
        SkinningImportance: number;
        bRemapMorphTargets: boolean;
        bRecalcNormals: boolean;
        WeldingThreshold: number;
        NormalsThreshold: number;
        MaxBonesPerVertex: number;
        bEnforceBoneBoundaries: boolean;
        VolumeImportance: number;
        bLockEdges: boolean;
        BaseLOD: number;
        BonesToRemove: TArray<BoneReference>;
        BakePose: AnimSequence;
    }
    
    class SkeletalMeshLODInfo {
        constructor(ScreenSize: PerPlatformFloat, LODHysteresis: number, LODMaterialMap: TArray<number>, bEnableShadowCasting: TArray<boolean>, RemovedBones: TArray<string>, BuildSettings: SkeletalMeshBuildSettings, ReductionSettings: SkeletalMeshOptimizationSettings, BonesToRemove: TArray<BoneReference>, BonesToPrioritize: TArray<BoneReference>, WeightOfPrioritization: number, BakePose: AnimSequence, BakePoseOverride: AnimSequence, SourceImportFilename: string, bHasBeenSimplified: boolean, bHasPerLODVertexColors: boolean, bAllowCPUAccess: boolean, bSupportUniformlyDistributedSampling: boolean, bImportWithBaseMesh: boolean);
        ScreenSize: PerPlatformFloat;
        LODHysteresis: number;
        LODMaterialMap: TArray<number>;
        bEnableShadowCasting: TArray<boolean>;
        RemovedBones: TArray<string>;
        BuildSettings: SkeletalMeshBuildSettings;
        ReductionSettings: SkeletalMeshOptimizationSettings;
        BonesToRemove: TArray<BoneReference>;
        BonesToPrioritize: TArray<BoneReference>;
        WeightOfPrioritization: number;
        BakePose: AnimSequence;
        BakePoseOverride: AnimSequence;
        SourceImportFilename: string;
        bHasBeenSimplified: boolean;
        bHasPerLODVertexColors: boolean;
        bAllowCPUAccess: boolean;
        bSupportUniformlyDistributedSampling: boolean;
        bImportWithBaseMesh: boolean;
    }
    
    class PerPlatformInt {
        constructor(Default: number, PerPlatform: TMap<string, number>);
        Default: number;
        PerPlatform: TMap<string, number>;
    }
    
    class PerPlatformBool {
        constructor(Default: boolean, PerPlatform: TMap<string, boolean>);
        Default: boolean;
        PerPlatform: TMap<string, boolean>;
    }
    
    enum EBoneFilterActionOption { Remove, Keep, Invalid, EBoneFilterActionOption_MAX}
    class BoneFilter {
        constructor(bExcludeSelf: boolean, BoneName: string);
        bExcludeSelf: boolean;
        BoneName: string;
    }
    
    class SkeletalMeshLODGroupSettings {
        constructor(ScreenSize: PerPlatformFloat, LODHysteresis: number, BoneFilterActionOption: EBoneFilterActionOption, BoneList: TArray<BoneFilter>, BonesToPrioritize: TArray<string>, WeightOfPrioritization: number, BakePose: AnimSequence, ReductionSettings: SkeletalMeshOptimizationSettings);
        ScreenSize: PerPlatformFloat;
        LODHysteresis: number;
        BoneFilterActionOption: EBoneFilterActionOption;
        BoneList: TArray<BoneFilter>;
        BonesToPrioritize: TArray<string>;
        WeightOfPrioritization: number;
        BakePose: AnimSequence;
        ReductionSettings: SkeletalMeshOptimizationSettings;
    }
    
    class SkeletalMeshLODSettings extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinLod: PerPlatformInt;
        DisableBelowMinLodStripping: PerPlatformBool;
        bSupportLODStreaming: PerPlatformBool;
        MaxNumStreamedLODs: PerPlatformInt;
        MaxNumOptionalLODs: PerPlatformInt;
        LODGroups: TArray<SkeletalMeshLODGroupSettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshLODSettings;
        static Load(InName: string): SkeletalMeshLODSettings;
    }
    
    class KShapeElem {
        constructor(RestOffset: number, Name: string, bContributeToMass: boolean);
        RestOffset: number;
        Name: string;
        bContributeToMass: boolean;
    }
    
    class Plane extends Vector {
        constructor(W: number);
        W: number;
    }
    
    class Matrix {
        constructor(XPlane: Plane, YPlane: Plane, ZPlane: Plane, WPlane: Plane);
        XPlane: Plane;
        YPlane: Plane;
        ZPlane: Plane;
        WPlane: Plane;
    }
    
    class KSphereElem extends KShapeElem {
        constructor(TM: Matrix, Center: Vector, Radius: number);
        TM: Matrix;
        Center: Vector;
        Radius: number;
    }
    
    class KBoxElem extends KShapeElem {
        constructor(TM: Matrix, Orientation: Quat, Center: Vector, Rotation: Rotator, X: number, Y: number, Z: number);
        TM: Matrix;
        Orientation: Quat;
        Center: Vector;
        Rotation: Rotator;
        X: number;
        Y: number;
        Z: number;
    }
    
    class KSphylElem extends KShapeElem {
        constructor(TM: Matrix, Orientation: Quat, Center: Vector, Rotation: Rotator, Radius: number, Length: number);
        TM: Matrix;
        Orientation: Quat;
        Center: Vector;
        Rotation: Rotator;
        Radius: number;
        Length: number;
    }
    
    class KConvexElem extends KShapeElem {
        constructor(VertexData: TArray<Vector>, ElemBox: Box, Transform: Transform);
        VertexData: TArray<Vector>;
        ElemBox: Box;
        Transform: Transform;
    }
    
    class KTaperedCapsuleElem extends KShapeElem {
        constructor(Center: Vector, Rotation: Rotator, Radius0: number, Radius1: number, Length: number);
        Center: Vector;
        Rotation: Rotator;
        Radius0: number;
        Radius1: number;
        Length: number;
    }
    
    class KAggregateGeom {
        constructor(SphereElems: TArray<KSphereElem>, BoxElems: TArray<KBoxElem>, SphylElems: TArray<KSphylElem>, ConvexElems: TArray<KConvexElem>, TaperedCapsuleElems: TArray<KTaperedCapsuleElem>);
        SphereElems: TArray<KSphereElem>;
        BoxElems: TArray<KBoxElem>;
        SphylElems: TArray<KSphylElem>;
        ConvexElems: TArray<KConvexElem>;
        TaperedCapsuleElems: TArray<KTaperedCapsuleElem>;
    }
    
    class BodySetup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AggGeom: KAggregateGeom;
        BoneName: string;
        PhysicsType: number;
        bAlwaysFullAnimWeight: boolean;
        bConsiderForBounds: boolean;
        bMeshCollideAll: boolean;
        bDoubleSidedGeometry: boolean;
        bGenerateNonMirroredCollision: boolean;
        bSharedCookedData: boolean;
        bGenerateMirroredCollision: boolean;
        CollisionReponse: number;
        CollisionTraceFlag: number;
        PhysMaterial: PhysicalMaterial;
        WalkableSlopeOverride: WalkableSlopeOverride;
        BuildScale: number;
        DefaultInstance: BodyInstance;
        BuildScale3D: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BodySetup;
        static Load(InName: string): BodySetup;
    }
    
    class PhysicalAnimationData {
        constructor(BodyName: string, bIsLocalSimulation: boolean, OrientationStrength: number, AngularVelocityStrength: number, PositionStrength: number, VelocityStrength: number, MaxLinearForce: number, MaxAngularForce: number);
        BodyName: string;
        bIsLocalSimulation: boolean;
        OrientationStrength: number;
        AngularVelocityStrength: number;
        PositionStrength: number;
        VelocityStrength: number;
        MaxLinearForce: number;
        MaxAngularForce: number;
    }
    
    class PhysicalAnimationProfile {
        constructor(ProfileName: string, PhysicalAnimationData: PhysicalAnimationData);
        ProfileName: string;
        PhysicalAnimationData: PhysicalAnimationData;
    }
    
    class SkeletalBodySetup extends BodySetup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentPhysicalAnimationProfile: PhysicalAnimationProfile;
        bSkipScaleFromAnimation: boolean;
        PhysicalAnimationData: TArray<PhysicalAnimationProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalBodySetup;
        static Load(InName: string): SkeletalBodySetup;
    }
    
    class ConstraintBaseParams {
        constructor(Stiffness: number, Damping: number, Restitution: number, ContactDistance: number, bSoftConstraint: boolean);
        Stiffness: number;
        Damping: number;
        Restitution: number;
        ContactDistance: number;
        bSoftConstraint: boolean;
    }
    
    class LinearConstraint extends ConstraintBaseParams {
        constructor(Limit: number, XMotion: number, YMotion: number, ZMotion: number);
        Limit: number;
        XMotion: number;
        YMotion: number;
        ZMotion: number;
    }
    
    class ConeConstraint extends ConstraintBaseParams {
        constructor(Swing1LimitDegrees: number, Swing2LimitDegrees: number, Swing1Motion: number, Swing2Motion: number);
        Swing1LimitDegrees: number;
        Swing2LimitDegrees: number;
        Swing1Motion: number;
        Swing2Motion: number;
    }
    
    class TwistConstraint extends ConstraintBaseParams {
        constructor(TwistLimitDegrees: number, TwistMotion: number);
        TwistLimitDegrees: number;
        TwistMotion: number;
    }
    
    class ConstraintDrive {
        constructor(Stiffness: number, Damping: number, MaxForce: number, bEnablePositionDrive: boolean, bEnableVelocityDrive: boolean);
        Stiffness: number;
        Damping: number;
        MaxForce: number;
        bEnablePositionDrive: boolean;
        bEnableVelocityDrive: boolean;
    }
    
    class LinearDriveConstraint {
        constructor(PositionTarget: Vector, VelocityTarget: Vector, XDrive: ConstraintDrive, YDrive: ConstraintDrive, ZDrive: ConstraintDrive, bEnablePositionDrive: boolean);
        PositionTarget: Vector;
        VelocityTarget: Vector;
        XDrive: ConstraintDrive;
        YDrive: ConstraintDrive;
        ZDrive: ConstraintDrive;
        bEnablePositionDrive: boolean;
    }
    
    class AngularDriveConstraint {
        constructor(TwistDrive: ConstraintDrive, SwingDrive: ConstraintDrive, SlerpDrive: ConstraintDrive, OrientationTarget: Rotator, AngularVelocityTarget: Vector, AngularDriveMode: number);
        TwistDrive: ConstraintDrive;
        SwingDrive: ConstraintDrive;
        SlerpDrive: ConstraintDrive;
        OrientationTarget: Rotator;
        AngularVelocityTarget: Vector;
        AngularDriveMode: number;
    }
    
    class ConstraintProfileProperties {
        constructor(ProjectionLinearTolerance: number, ProjectionAngularTolerance: number, LinearBreakThreshold: number, AngularBreakThreshold: number, LinearLimit: LinearConstraint, ConeLimit: ConeConstraint, TwistLimit: TwistConstraint, LinearDrive: LinearDriveConstraint, AngularDrive: AngularDriveConstraint, bDisableCollision: boolean, bParentDominates: boolean, bEnableProjection: boolean, bAngularBreakable: boolean, bLinearBreakable: boolean);
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearBreakThreshold: number;
        AngularBreakThreshold: number;
        LinearLimit: LinearConstraint;
        ConeLimit: ConeConstraint;
        TwistLimit: TwistConstraint;
        LinearDrive: LinearDriveConstraint;
        AngularDrive: AngularDriveConstraint;
        bDisableCollision: boolean;
        bParentDominates: boolean;
        bEnableProjection: boolean;
        bAngularBreakable: boolean;
        bLinearBreakable: boolean;
    }
    
    class ConstraintInstance {
        constructor(JointName: string, ConstraintBone1: string, ConstraintBone2: string, Pos1: Vector, PriAxis1: Vector, SecAxis1: Vector, Pos2: Vector, PriAxis2: Vector, SecAxis2: Vector, AngularRotationOffset: Rotator, bScaleLinearLimits: boolean, ProfileInstance: ConstraintProfileProperties, bDisableCollision: boolean, bEnableProjection: boolean, ProjectionLinearTolerance: number, ProjectionAngularTolerance: number, LinearXMotion: number, LinearYMotion: number, LinearZMotion: number, LinearLimitSize: number, bLinearLimitSoft: boolean, LinearLimitStiffness: number, LinearLimitDamping: number, bLinearBreakable: boolean, LinearBreakThreshold: number, AngularSwing1Motion: number, AngularTwistMotion: number, AngularSwing2Motion: number, bSwingLimitSoft: boolean, bTwistLimitSoft: boolean, Swing1LimitAngle: number, TwistLimitAngle: number, Swing2LimitAngle: number, SwingLimitStiffness: number, SwingLimitDamping: number, TwistLimitStiffness: number, TwistLimitDamping: number, bAngularBreakable: boolean, AngularBreakThreshold: number, bLinearXPositionDrive: boolean, bLinearXVelocityDrive: boolean, bLinearYPositionDrive: boolean, bLinearYVelocityDrive: boolean, bLinearZPositionDrive: boolean, bLinearZVelocityDrive: boolean, bLinearPositionDrive: boolean, bLinearVelocityDrive: boolean, LinearPositionTarget: Vector, LinearVelocityTarget: Vector, LinearDriveSpring: number, LinearDriveDamping: number, LinearDriveForceLimit: number, bSwingPositionDrive: boolean, bSwingVelocityDrive: boolean, bTwistPositionDrive: boolean, bTwistVelocityDrive: boolean, bAngularSlerpDrive: boolean, bAngularOrientationDrive: boolean, bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bAngularVelocityDrive: boolean, AngularPositionTarget: Quat, AngularDriveMode: number, AngularOrientationTarget: Rotator, AngularVelocityTarget: Vector, AngularDriveSpring: number, AngularDriveDamping: number, AngularDriveForceLimit: number);
        JointName: string;
        ConstraintBone1: string;
        ConstraintBone2: string;
        Pos1: Vector;
        PriAxis1: Vector;
        SecAxis1: Vector;
        Pos2: Vector;
        PriAxis2: Vector;
        SecAxis2: Vector;
        AngularRotationOffset: Rotator;
        bScaleLinearLimits: boolean;
        ProfileInstance: ConstraintProfileProperties;
        bDisableCollision: boolean;
        bEnableProjection: boolean;
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearXMotion: number;
        LinearYMotion: number;
        LinearZMotion: number;
        LinearLimitSize: number;
        bLinearLimitSoft: boolean;
        LinearLimitStiffness: number;
        LinearLimitDamping: number;
        bLinearBreakable: boolean;
        LinearBreakThreshold: number;
        AngularSwing1Motion: number;
        AngularTwistMotion: number;
        AngularSwing2Motion: number;
        bSwingLimitSoft: boolean;
        bTwistLimitSoft: boolean;
        Swing1LimitAngle: number;
        TwistLimitAngle: number;
        Swing2LimitAngle: number;
        SwingLimitStiffness: number;
        SwingLimitDamping: number;
        TwistLimitStiffness: number;
        TwistLimitDamping: number;
        bAngularBreakable: boolean;
        AngularBreakThreshold: number;
        bLinearXPositionDrive: boolean;
        bLinearXVelocityDrive: boolean;
        bLinearYPositionDrive: boolean;
        bLinearYVelocityDrive: boolean;
        bLinearZPositionDrive: boolean;
        bLinearZVelocityDrive: boolean;
        bLinearPositionDrive: boolean;
        bLinearVelocityDrive: boolean;
        LinearPositionTarget: Vector;
        LinearVelocityTarget: Vector;
        LinearDriveSpring: number;
        LinearDriveDamping: number;
        LinearDriveForceLimit: number;
        bSwingPositionDrive: boolean;
        bSwingVelocityDrive: boolean;
        bTwistPositionDrive: boolean;
        bTwistVelocityDrive: boolean;
        bAngularSlerpDrive: boolean;
        bAngularOrientationDrive: boolean;
        bEnableSwingDrive: boolean;
        bEnableTwistDrive: boolean;
        bAngularVelocityDrive: boolean;
        AngularPositionTarget: Quat;
        AngularDriveMode: number;
        AngularOrientationTarget: Rotator;
        AngularVelocityTarget: Vector;
        AngularDriveSpring: number;
        AngularDriveDamping: number;
        AngularDriveForceLimit: number;
    }
    
    class PhysicsConstraintProfileHandle {
        constructor(ProfileProperties: ConstraintProfileProperties, ProfileName: string);
        ProfileProperties: ConstraintProfileProperties;
        ProfileName: string;
    }
    
    class PhysicsConstraintTemplate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultInstance: ConstraintInstance;
        ProfileHandles: TArray<PhysicsConstraintProfileHandle>;
        DefaultProfile: ConstraintProfileProperties;
        JointName: string;
        ConstraintBone1: string;
        ConstraintBone2: string;
        Pos1: Vector;
        PriAxis1: Vector;
        SecAxis1: Vector;
        Pos2: Vector;
        PriAxis2: Vector;
        SecAxis2: Vector;
        bEnableProjection: boolean;
        ProjectionLinearTolerance: number;
        ProjectionAngularTolerance: number;
        LinearXMotion: number;
        LinearYMotion: number;
        LinearZMotion: number;
        LinearLimitSize: number;
        bLinearLimitSoft: boolean;
        LinearLimitStiffness: number;
        LinearLimitDamping: number;
        bLinearBreakable: boolean;
        LinearBreakThreshold: number;
        AngularSwing1Motion: number;
        AngularSwing2Motion: number;
        AngularTwistMotion: number;
        bSwingLimitSoft: boolean;
        bTwistLimitSoft: boolean;
        Swing1LimitAngle: number;
        Swing2LimitAngle: number;
        TwistLimitAngle: number;
        SwingLimitStiffness: number;
        SwingLimitDamping: number;
        TwistLimitStiffness: number;
        TwistLimitDamping: number;
        bAngularBreakable: boolean;
        AngularBreakThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintTemplate;
        static Load(InName: string): PhysicsConstraintTemplate;
    }
    
    class PhysicsAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSkelMesh: SkeletalMesh;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        PhysicalAnimationProfiles: TArray<string>;
        ConstraintProfiles: TArray<string>;
        CurrentPhysicalAnimationProfileName: string;
        CurrentConstraintProfileName: string;
        BoundsBodies: TArray<number>;
        SkeletalBodySetups: TArray<SkeletalBodySetup>;
        ConstraintSetup: TArray<PhysicsConstraintTemplate>;
        bNotForDedicatedServer: boolean;
        ThumbnailInfo: ThumbnailInfo;
        BodySetup: TArray<BodySetup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAsset;
        static Load(InName: string): PhysicsAsset;
    }
    
    class NodeItem {
        constructor(ParentName: string, Transform: Transform);
        ParentName: string;
        Transform: Transform;
    }
    
    class NodeMappingContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceItems: TMap<string, NodeItem>;
        TargetItems: TMap<string, NodeItem>;
        SourceToTarget: TMap<string, string>;
        SourceAsset: TSoftObjectPtr<Object>;
        TargetAsset: TSoftObjectPtr<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NodeMappingContainer;
        static Load(InName: string): NodeMappingContainer;
    }
    
    class MorphTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseSkelMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MorphTarget;
        static Load(InName: string): MorphTarget;
    }
    
    class ClothPhysicsProperties_Legacy {
        constructor(VerticalResistance: number, HorizontalResistance: number, BendResistance: number, ShearResistance: number, Friction: number, Damping: number, TetherStiffness: number, TetherLimit: number, Drag: number, StiffnessFrequency: number, GravityScale: number, MassScale: number, InertiaBlend: number, SelfCollisionThickness: number, SelfCollisionSquashScale: number, SelfCollisionStiffness: number, SolverFrequency: number, FiberCompression: number, FiberExpansion: number, FiberResistance: number);
        VerticalResistance: number;
        HorizontalResistance: number;
        BendResistance: number;
        ShearResistance: number;
        Friction: number;
        Damping: number;
        TetherStiffness: number;
        TetherLimit: number;
        Drag: number;
        StiffnessFrequency: number;
        GravityScale: number;
        MassScale: number;
        InertiaBlend: number;
        SelfCollisionThickness: number;
        SelfCollisionSquashScale: number;
        SelfCollisionStiffness: number;
        SolverFrequency: number;
        FiberCompression: number;
        FiberExpansion: number;
        FiberResistance: number;
    }
    
    class ClothingAssetData_Legacy {
        constructor(AssetName: string, ApexFileName: string, bClothPropertiesChanged: boolean, PhysicsProperties: ClothPhysicsProperties_Legacy);
        AssetName: string;
        ApexFileName: string;
        bClothPropertiesChanged: boolean;
        PhysicsProperties: ClothPhysicsProperties_Legacy;
    }
    
    class ClothingAssetBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportedFilePath: string;
        AssetGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetBase;
        static Load(InName: string): ClothingAssetBase;
    }
    
    class SkeletalMeshSamplingRegionMaterialFilter {
        constructor(MaterialName: string);
        MaterialName: string;
    }
    
    class SkeletalMeshSamplingRegionBoneFilter {
        constructor(BoneName: string, bIncludeOrExclude: boolean, bApplyToChildren: boolean);
        BoneName: string;
        bIncludeOrExclude: boolean;
        bApplyToChildren: boolean;
    }
    
    class SkeletalMeshSamplingRegion {
        constructor(Name: string, LODIndex: number, bSupportUniformlyDistributedSampling: boolean, MaterialFilters: TArray<SkeletalMeshSamplingRegionMaterialFilter>, BoneFilters: TArray<SkeletalMeshSamplingRegionBoneFilter>);
        Name: string;
        LODIndex: number;
        bSupportUniformlyDistributedSampling: boolean;
        MaterialFilters: TArray<SkeletalMeshSamplingRegionMaterialFilter>;
        BoneFilters: TArray<SkeletalMeshSamplingRegionBoneFilter>;
    }
    
    class SkeletalMeshSamplingLODBuiltData {
        constructor();
    }
    
    class SkeletalMeshSamplingRegionBuiltData {
        constructor();
    }
    
    class SkeletalMeshSamplingBuiltData {
        constructor(WholeMeshBuiltData: TArray<SkeletalMeshSamplingLODBuiltData>, RegionBuiltData: TArray<SkeletalMeshSamplingRegionBuiltData>);
        WholeMeshBuiltData: TArray<SkeletalMeshSamplingLODBuiltData>;
        RegionBuiltData: TArray<SkeletalMeshSamplingRegionBuiltData>;
    }
    
    class SkeletalMeshSamplingInfo {
        constructor(Regions: TArray<SkeletalMeshSamplingRegion>, BuiltData: SkeletalMeshSamplingBuiltData);
        Regions: TArray<SkeletalMeshSamplingRegion>;
        BuiltData: SkeletalMeshSamplingBuiltData;
    }
    
    class SkinWeightProfileInfo {
        constructor(Name: string, DefaultProfile: PerPlatformBool, DefaultProfileFromLODIndex: PerPlatformInt, PerLODSourceFiles: TMap<number, string>);
        Name: string;
        DefaultProfile: PerPlatformBool;
        DefaultProfileFromLODIndex: PerPlatformInt;
        PerLODSourceFiles: TMap<number, string>;
    }
    
    class BlueprintCore extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletonGeneratedClass: Class;
        GeneratedClass: Class;
        bLegacyNeedToPurgeSkelRefs: boolean;
        BlueprintGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintCore;
        static Load(InName: string): BlueprintCore;
    }
    
    enum EBlueprintNativizationFlag { Disabled, Dependency, ExplicitlyEnabled, EBlueprintNativizationFlag_MAX}
    enum EBlueprintCompileMode { Default, Development, FinalRelease, EBlueprintCompileMode_MAX}
    class BlueprintComponentChangedPropertyInfo {
        constructor(PropertyName: string, ArrayIndex: number, PropertyScope: Struct);
        PropertyName: string;
        ArrayIndex: number;
        PropertyScope: Struct;
    }
    
    class BlueprintCookedComponentInstancingData {
        constructor(ChangedPropertyList: TArray<BlueprintComponentChangedPropertyInfo>, bHasValidCookedData: boolean);
        ChangedPropertyList: TArray<BlueprintComponentChangedPropertyInfo>;
        bHasValidCookedData: boolean;
    }
    
    class BPVariableMetaDataEntry {
        constructor(DataKey: string, DataValue: string);
        DataKey: string;
        DataValue: string;
    }
    
    class SCS_Node extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentClass: Class;
        ComponentTemplate: ActorComponent;
        CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
        CategoryName: string;
        AttachToName: string;
        ParentComponentOrVariableName: string;
        ParentComponentOwnerClassName: string;
        bIsParentComponentNative: boolean;
        ChildNodes: TArray<SCS_Node>;
        MetaDataArray: TArray<BPVariableMetaDataEntry>;
        VariableGuid: Guid;
        bIsNative: boolean;
        NativeComponentName: string;
        bVariableNameAutoGenerated: boolean;
        InternalVariableName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SCS_Node;
        static Load(InName: string): SCS_Node;
    }
    
    class SimpleConstructionScript extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootNodes: TArray<SCS_Node>;
        AllNodes: TArray<SCS_Node>;
        DefaultSceneRootNode: SCS_Node;
        RootNode: SCS_Node;
        ActorComponentNodes: TArray<SCS_Node>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SimpleConstructionScript;
        static Load(InName: string): SimpleConstructionScript;
    }
    
    class EdGraph extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Schema: Class;
        Nodes: TArray<EdGraphNode>;
        bEditable: boolean;
        bAllowDeletion: boolean;
        bAllowRenaming: boolean;
        SubGraphs: TArray<EdGraph>;
        GraphGuid: Guid;
        InterfaceGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraph;
        static Load(InName: string): EdGraph;
    }
    
    class BlueprintMacroCosmeticInfo {
        constructor();
    }
    
    class TTTrackBase {
        constructor(TrackName: string, bIsExternalCurve: boolean);
        TrackName: string;
        bIsExternalCurve: boolean;
    }
    
    class TTEventTrack extends TTTrackBase {
        constructor(FunctionName: string, CurveKeys: CurveFloat);
        FunctionName: string;
        CurveKeys: CurveFloat;
    }
    
    class TTPropertyTrack extends TTTrackBase {
        constructor(PropertyName: string);
        PropertyName: string;
    }
    
    class TTFloatTrack extends TTPropertyTrack {
        constructor(CurveFloat: CurveFloat);
        CurveFloat: CurveFloat;
    }
    
    class CurveVector extends CurveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurves: FixSizeArray<RichCurve>;
        GetVectorValue(InTime: number): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveVector;
        static Load(InName: string): CurveVector;
    }
    
    class TTVectorTrack extends TTPropertyTrack {
        constructor(CurveVector: CurveVector);
        CurveVector: CurveVector;
    }
    
    class TTLinearColorTrack extends TTPropertyTrack {
        constructor(CurveLinearColor: CurveLinearColor);
        CurveLinearColor: CurveLinearColor;
    }
    
    class TimelineTemplate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimelineLength: number;
        LengthMode: number;
        bAutoPlay: boolean;
        bLoop: boolean;
        bReplicated: boolean;
        bIgnoreTimeDilation: boolean;
        EventTracks: TArray<TTEventTrack>;
        FloatTracks: TArray<TTFloatTrack>;
        VectorTracks: TArray<TTVectorTrack>;
        LinearColorTracks: TArray<TTLinearColorTrack>;
        MetaDataArray: TArray<BPVariableMetaDataEntry>;
        TimelineGuid: Guid;
        VariableName: string;
        DirectionPropertyName: string;
        UpdateFunctionName: string;
        FinishedFunctionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimelineTemplate;
        static Load(InName: string): TimelineTemplate;
    }
    
    class BPComponentClassOverride {
        constructor(ComponentName: string, ComponentClass: Class);
        ComponentName: string;
        ComponentClass: Class;
    }
    
    class ComponentKey {
        constructor(OwnerClass: Class, SCSVariableName: string, AssociatedGuid: Guid);
        OwnerClass: Class;
        SCSVariableName: string;
        AssociatedGuid: Guid;
    }
    
    class ComponentOverrideRecord {
        constructor(ComponentClass: Class, ComponentTemplate: ActorComponent, ComponentKey: ComponentKey, CookedComponentInstancingData: BlueprintCookedComponentInstancingData);
        ComponentClass: Class;
        ComponentTemplate: ActorComponent;
        ComponentKey: ComponentKey;
        CookedComponentInstancingData: BlueprintCookedComponentInstancingData;
    }
    
    class InheritableComponentHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Records: TArray<ComponentOverrideRecord>;
        UnnecessaryComponents: TArray<ActorComponent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InheritableComponentHandler;
        static Load(InName: string): InheritableComponentHandler;
    }
    
    class BPVariableDescription {
        constructor(VarName: string, VarGuid: Guid, VarType: EdGraphPinType, FriendlyName: string, Category: string, PropertyFlags: bigint, RepNotifyFunc: string, ReplicationCondition: number, MetaDataArray: TArray<BPVariableMetaDataEntry>, DefaultValue: string);
        VarName: string;
        VarGuid: Guid;
        VarType: EdGraphPinType;
        FriendlyName: string;
        Category: string;
        PropertyFlags: bigint;
        RepNotifyFunc: string;
        ReplicationCondition: number;
        MetaDataArray: TArray<BPVariableMetaDataEntry>;
        DefaultValue: string;
    }
    
    class BPInterfaceDescription {
        constructor(Interface: Class, Graphs: TArray<EdGraph>);
        Interface: Class;
        Graphs: TArray<EdGraph>;
    }
    
    class EditedDocumentInfo {
        constructor(EditedObjectPath: SoftObjectPath, SavedViewOffset: Vector2D, SavedZoomAmount: number, EditedObject: Object);
        EditedObjectPath: SoftObjectPath;
        SavedViewOffset: Vector2D;
        SavedZoomAmount: number;
        EditedObject: Object;
    }
    
    class BPEditorBookmarkNode {
        constructor(NodeGuid: Guid, ParentGuid: Guid, DisplayName: string);
        NodeGuid: Guid;
        ParentGuid: Guid;
        DisplayName: string;
    }
    
    class Breakpoint extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnabled: boolean;
        Node: EdGraphNode;
        bStepOnce: boolean;
        bStepOnce_WasPreviouslyDisabled: boolean;
        bStepOnce_RemoveAfterHit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Breakpoint;
        static Load(InName: string): Breakpoint;
    }
    
    class EdGraphPinReference {
        constructor(OwningNode: TWeakObjectPtr<EdGraphNode>, PinId: Guid);
        OwningNode: TWeakObjectPtr<EdGraphNode>;
        PinId: Guid;
    }
    
    class BlueprintExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintExtension;
        static Load(InName: string): BlueprintExtension;
    }
    
    class Blueprint extends BlueprintCore {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentClass: Class;
        BlueprintType: number;
        bRecompileOnLoad: boolean;
        bHasBeenRegenerated: boolean;
        bIsRegeneratingOnLoad: boolean;
        bBeingCompiled: boolean;
        bIsNewlyCreated: boolean;
        bForceFullEditor: boolean;
        bQueuedForCompilation: boolean;
        bRunConstructionScriptOnDrag: boolean;
        bRunConstructionScriptInSequencer: boolean;
        bGenerateConstClass: boolean;
        bGenerateAbstractClass: boolean;
        bDisplayCompilePIEWarning: boolean;
        bDeprecate: boolean;
        bDuplicatingReadOnly: boolean;
        bNativize: boolean;
        NativizationFlag: EBlueprintNativizationFlag;
        CompileMode: EBlueprintCompileMode;
        Status: number;
        BlueprintDisplayName: string;
        BlueprintDescription: string;
        BlueprintCategory: string;
        HideCategories: TArray<string>;
        SearchGuid: Guid;
        BlueprintSystemVersion: number;
        SimpleConstructionScript: SimpleConstructionScript;
        UbergraphPages: TArray<EdGraph>;
        FunctionGraphs: TArray<EdGraph>;
        DelegateSignatureGraphs: TArray<EdGraph>;
        MacroGraphs: TArray<EdGraph>;
        IntermediateGeneratedGraphs: TArray<EdGraph>;
        EventGraphs: TArray<EdGraph>;
        PRIVATE_CachedMacroInfo: TMap<EdGraph, BlueprintMacroCosmeticInfo>;
        ComponentTemplates: TArray<ActorComponent>;
        Timelines: TArray<TimelineTemplate>;
        ComponentClassOverrides: TArray<BPComponentClassOverride>;
        InheritableComponentHandler: InheritableComponentHandler;
        NewVariables: TArray<BPVariableDescription>;
        CategorySorting: TArray<string>;
        ImplementedInterfaces: TArray<BPInterfaceDescription>;
        LastEditedDocuments: TArray<EditedDocumentInfo>;
        Bookmarks: TMap<Guid, EditedDocumentInfo>;
        BookmarkNodes: TArray<BPEditorBookmarkNode>;
        Breakpoints: TArray<Breakpoint>;
        WatchedPins: TArray<EdGraphPinReference>;
        DeprecatedPinWatches: TArray<EdGraphPin_Deprecated>;
        ComponentTemplateNameIndex: TMap<string, number>;
        OldToNewComponentTemplateNames: TMap<string, string>;
        Extensions: TArray<BlueprintExtension>;
        ThumbnailInfo: ThumbnailInfo;
        CrcLastCompiledCDO: number;
        CrcLastCompiledSignature: number;
        OriginalClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Blueprint;
        static Load(InName: string): Blueprint;
    }
    
    class SkeletalMesh extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeleton: Skeleton;
        ImportedBounds: BoxSphereBounds;
        ExtendedBounds: BoxSphereBounds;
        PositiveBoundsExtension: Vector;
        NegativeBoundsExtension: Vector;
        Materials: TArray<SkeletalMaterial>;
        SkelMirrorTable: TArray<BoneMirrorInfo>;
        LODInfo: TArray<SkeletalMeshLODInfo>;
        MinLod: PerPlatformInt;
        DisableBelowMinLodStripping: PerPlatformBool;
        bSupportLODStreaming: PerPlatformBool;
        MaxNumStreamedLODs: PerPlatformInt;
        MaxNumOptionalLODs: PerPlatformInt;
        LODSettings: SkeletalMeshLODSettings;
        SkelMirrorAxis: number;
        SkelMirrorFlipAxis: number;
        bUseFullPrecisionUVs: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bHasBeenSimplified: boolean;
        bHasVertexColors: boolean;
        bEnablePerPolyCollision: boolean;
        VertexColorGuid: Guid;
        BodySetup: BodySetup;
        PhysicsAsset: PhysicsAsset;
        ShadowPhysicsAsset: PhysicsAsset;
        NodeMappingData: TArray<NodeMappingContainer>;
        AssetImportData: AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        ThumbnailInfo: ThumbnailInfo;
        bHasCustomDefaultEditorCamera: boolean;
        DefaultEditorCameraLocation: Vector;
        DefaultEditorCameraRotation: Rotator;
        DefaultEditorCameraLookAt: Vector;
        DefaultEditorCameraOrthoZoom: number;
        PreviewAttachedAssetContainer: PreviewAssetAttachContainer;
        MorphTargets: TArray<MorphTarget>;
        FloorOffset: number;
        RetargetBasePose: TArray<Transform>;
        ClothingAssets: TArray<ClothingAssetData_Legacy>;
        PostProcessAnimBlueprint: Class;
        MeshClothingAssets: TArray<ClothingAssetBase>;
        SamplingInfo: SkeletalMeshSamplingInfo;
        AssetUserData: TArray<AssetUserData>;
        Sockets: TArray<SkeletalMeshSocket>;
        SkinWeightProfiles: TArray<SkinWeightProfileInfo>;
        SetLODSettings(InLODSettings: SkeletalMeshLODSettings): void;
        NumSockets(): number;
        K2_GetAllMorphTargetNames(): TArray<string>;
        IsSectionUsingCloth(InSectionIndex: number, bCheckCorrespondingSections: boolean): boolean;
        GetSocketByIndex(Index: number): SkeletalMeshSocket;
        GetNodeMappingContainer(SourceAsset: Blueprint): NodeMappingContainer;
        GetImportedBounds(): BoxSphereBounds;
        GetBounds(): BoxSphereBounds;
        FindSocketInfo(InSocketName: string, OutTransform: $Ref<Transform>, OutBoneIndex: $Ref<number>, OutIndex: $Ref<number>): SkeletalMeshSocket;
        FindSocketAndIndex(InSocketName: string, OutIndex: $Ref<number>): SkeletalMeshSocket;
        FindSocket(InSocketName: string): SkeletalMeshSocket;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMesh;
        static Load(InName: string): SkeletalMesh;
    }
    
    class SkelMeshComponentLODInfo {
        constructor(HiddenMaterials: TArray<boolean>);
        HiddenMaterials: TArray<boolean>;
    }
    
    enum EVisibilityBasedAnimTickOption { AlwaysTickPoseAndRefreshBones, AlwaysTickPose, OnlyTickMontagesWhenNotRendered, OnlyTickPoseWhenRendered, EVisibilityBasedAnimTickOption_MAX}
    class SkelMeshSkinWeightInfo {
        constructor(Bones: FixSizeArray<number>, Weights: FixSizeArray<number>);
        Bones: FixSizeArray<number>;
        Weights: FixSizeArray<number>;
    }
    
    class SkinnedMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletalMesh: SkeletalMesh;
        MasterPoseComponent: TWeakObjectPtr<SkinnedMeshComponent>;
        WireframeColor: Color;
        PhysicsAssetOverride: PhysicsAsset;
        ForcedLodModel: number;
        MinLodModel: number;
        StreamingDistanceMultiplier: number;
        LODInfo: TArray<SkelMeshComponentLODInfo>;
        VisibilityBasedAnimTickOption: EVisibilityBasedAnimTickOption;
        bOverrideMinLod: boolean;
        bUseBoundsFromMasterPoseComponent: boolean;
        bForceWireframe: boolean;
        bDisplayBones: boolean;
        bDisableMorphTarget: boolean;
        bHideSkin: boolean;
        bPerBoneMotionBlur: boolean;
        bComponentUseFixedSkelBounds: boolean;
        bConsiderAllBodiesForBounds: boolean;
        bSyncAttachParentLOD: boolean;
        bCanHighlightSelectedSections: boolean;
        bRecentlyRendered: boolean;
        bCastCapsuleDirectShadow: boolean;
        bCastCapsuleIndirectShadow: boolean;
        bCPUSkinning: boolean;
        bEnableUpdateRateOptimizations: boolean;
        bDisplayDebugUpdateRateOptimizations: boolean;
        bRenderStatic: boolean;
        bIgnoreMasterPoseComponentLOD: boolean;
        bCachedLocalBoundsUpToDate: boolean;
        bForceMeshObjectUpdate: boolean;
        CapsuleIndirectShadowMinVisibility: number;
        CachedWorldSpaceBounds: BoxSphereBounds;
        CachedWorldToLocalTransform: Matrix;
        UnloadSkinWeightProfile(InProfileName: string): void;
        UnHideBoneByName(BoneName: string): void;
        TransformToBoneSpace(BoneName: string, InPosition: Vector, InRotation: Rotator, OutPosition: $Ref<Vector>, OutRotation: $Ref<Rotator>): void;
        TransformFromBoneSpace(BoneName: string, InPosition: Vector, InRotation: Rotator, OutPosition: $Ref<Vector>, OutRotation: $Ref<Rotator>): void;
        ShowMaterialSection(MaterialID: number, SectionIndex: number, bShow: boolean, LODIndex: number): void;
        ShowAllMaterialSections(LODIndex: number): void;
        SetVertexColorOverride_LinearColor(LODIndex: number, VertexColors: TArray<LinearColor>): void;
        SetSkinWeightProfile(InProfileName: string): boolean;
        SetSkinWeightOverride(LODIndex: number, SkinWeights: TArray<SkelMeshSkinWeightInfo>): void;
        SetSkeletalMesh(NewMesh: SkeletalMesh, bReinitPose: boolean): void;
        SetRenderStatic(bNewValue: boolean): void;
        SetPhysicsAsset(NewPhysicsAsset: PhysicsAsset, bForceReInit: boolean): void;
        SetMinLOD(InNewMinLOD: number): void;
        SetMasterPoseComponent(NewMasterBoneComponent: SkinnedMeshComponent, bForceUpdate: boolean): void;
        SetForcedLOD(InNewForcedLOD: number): void;
        SetCastCapsuleIndirectShadow(bNewValue: boolean): void;
        SetCastCapsuleDirectShadow(bNewValue: boolean): void;
        SetCapsuleIndirectShadowMinVisibility(NewValue: number): void;
        IsUsingSkinWeightProfile(): boolean;
        IsMaterialSectionShown(MaterialID: number, LODIndex: number): boolean;
        IsBoneHiddenByName(BoneName: string): boolean;
        HideBoneByName(BoneName: string, PhysBodyOption: number): void;
        GetTwistAndSwingAngleOfDeltaRotationFromRefPose(BoneName: string, OutTwistAngle: $Ref<number>, OutSwingAngle: $Ref<number>): boolean;
        GetSocketBoneName(InSocketName: string): string;
        GetRefPosePosition(BoneIndex: number): Vector;
        GetParentBone(BoneName: string): string;
        GetNumLODs(): number;
        GetNumBones(): number;
        GetForcedLOD(): number;
        GetDeltaTransformFromRefPose(BoneName: string, BaseName: string): Transform;
        GetCurrentSkinWeightProfileName(): string;
        GetBoneName(BoneIndex: number): string;
        GetBoneIndex(BoneName: string): number;
        FindClosestBone_K2(TestLocation: Vector, BoneLocation: $Ref<Vector>, IgnoreScale: number, bRequirePhysicsAsset: boolean): string;
        ClearVertexColorOverride(LODIndex: number): void;
        ClearSkinWeightProfile(): void;
        ClearSkinWeightOverride(LODIndex: number): void;
        BoneIsChildOf(BoneName: string, ParentBoneName: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkinnedMeshComponent;
        static Load(InName: string): SkinnedMeshComponent;
    }
    
    class AnimGroupInfo {
        constructor(Name: string, Color: LinearColor);
        Name: string;
        Color: LinearColor;
    }
    
    class AnimParentNodeAssetOverride {
        constructor(NewAsset: AnimationAsset, ParentNodeGuid: Guid);
        NewAsset: AnimationAsset;
        ParentNodeGuid: Guid;
    }
    
    class PoseWatch extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: EdGraphNode;
        PoseWatchColour: Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseWatch;
        static Load(InName: string): PoseWatch;
    }
    
    enum EPreviewAnimationBlueprintApplicationMethod { LinkedLayers, LinkedAnimGraph, EPreviewAnimationBlueprintApplicationMethod_MAX}
    class AnimBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        Groups: TArray<AnimGroupInfo>;
        bUseMultiThreadedAnimationUpdate: boolean;
        bWarnAboutBlueprintUsage: boolean;
        ParentAssetOverrides: TArray<AnimParentNodeAssetOverride>;
        PoseWatches: TArray<PoseWatch>;
        PreviewSkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
        PreviewAnimationBlueprint: TSoftObjectPtr<AnimBlueprint>;
        PreviewAnimationBlueprintApplicationMethod: EPreviewAnimationBlueprintApplicationMethod;
        PreviewAnimationBlueprintTag: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprint;
        static Load(InName: string): AnimBlueprint;
    }
    
    class DynamicBlueprintBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicBlueprintBinding;
        static Load(InName: string): DynamicBlueprintBinding;
    }
    
    class Property extends Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Property;
        static Load(InName: string): Property;
    }
    
    class StructProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructProperty;
        static Load(InName: string): StructProperty;
    }
    
    class Function extends Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Function;
        static Load(InName: string): Function;
    }
    
    class EventGraphFastCallPair {
        constructor(FunctionToPatch: Function, EventGraphCallOffset: number);
        FunctionToPatch: Function;
        EventGraphCallOffset: number;
    }
    
    class BlueprintGeneratedClass extends Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumReplicatedProperties: number;
        bHasNativizedParent: boolean;
        bHasCookedComponentInstancingData: boolean;
        bIsSparseClassDataSerializable: boolean;
        DynamicBindingObjects: TArray<DynamicBlueprintBinding>;
        ComponentTemplates: TArray<ActorComponent>;
        Timelines: TArray<TimelineTemplate>;
        ComponentClassOverrides: TArray<BPComponentClassOverride>;
        SimpleConstructionScript: SimpleConstructionScript;
        InheritableComponentHandler: InheritableComponentHandler;
        UberGraphFramePointerProperty: StructProperty;
        UberGraphFunction: Function;
        FastCallPairs: TArray<EventGraphFastCallPair>;
        OverridenArchetypeForCDO: Object;
        PropertyGuids: TMap<string, Guid>;
        CalledFunctions: TArray<Function>;
        CookedComponentInstancingData: TMap<string, BlueprintCookedComponentInstancingData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintGeneratedClass;
        static Load(InName: string): BlueprintGeneratedClass;
    }
    
    class BakedStateExitTransition {
        constructor(CanTakeDelegateIndex: number, CustomResultNodeIndex: number, TransitionIndex: number, bDesiredTransitionReturnValue: boolean, bAutomaticRemainingTimeRule: boolean, PoseEvaluatorLinks: TArray<number>);
        CanTakeDelegateIndex: number;
        CustomResultNodeIndex: number;
        TransitionIndex: number;
        bDesiredTransitionReturnValue: boolean;
        bAutomaticRemainingTimeRule: boolean;
        PoseEvaluatorLinks: TArray<number>;
    }
    
    class BakedAnimationState {
        constructor(StateName: string, Transitions: TArray<BakedStateExitTransition>, StateRootNodeIndex: number, StartNotify: number, EndNotify: number, FullyBlendedNotify: number, bIsAConduit: boolean, EntryRuleNodeIndex: number, PlayerNodeIndices: TArray<number>, LayerNodeIndices: TArray<number>, bAlwaysResetOnEntry: boolean);
        StateName: string;
        Transitions: TArray<BakedStateExitTransition>;
        StateRootNodeIndex: number;
        StartNotify: number;
        EndNotify: number;
        FullyBlendedNotify: number;
        bIsAConduit: boolean;
        EntryRuleNodeIndex: number;
        PlayerNodeIndices: TArray<number>;
        LayerNodeIndices: TArray<number>;
        bAlwaysResetOnEntry: boolean;
    }
    
    class AnimationStateBase {
        constructor(StateName: string);
        StateName: string;
    }
    
    class AnimationTransitionBetweenStates extends AnimationStateBase {
        constructor(PreviousState: number, NextState: number, CrossfadeDuration: number, StartNotify: number, EndNotify: number, InterruptNotify: number, BlendMode: EAlphaBlendOption, CustomCurve: CurveFloat, BlendProfile: BlendProfile, LogicType: number);
        PreviousState: number;
        NextState: number;
        CrossfadeDuration: number;
        StartNotify: number;
        EndNotify: number;
        InterruptNotify: number;
        BlendMode: EAlphaBlendOption;
        CustomCurve: CurveFloat;
        BlendProfile: BlendProfile;
        LogicType: number;
    }
    
    class BakedAnimationStateMachine {
        constructor(MachineName: string, InitialState: number, States: TArray<BakedAnimationState>, Transitions: TArray<AnimationTransitionBetweenStates>);
        MachineName: string;
        InitialState: number;
        States: TArray<BakedAnimationState>;
        Transitions: TArray<AnimationTransitionBetweenStates>;
    }
    
    class CachedPoseIndices {
        constructor(OrderedSavedPoseNodeIndices: TArray<number>);
        OrderedSavedPoseNodeIndices: TArray<number>;
    }
    
    enum EPostCopyOperation { None, LogicalNegateBool, EPostCopyOperation_MAX}
    enum ECopyType { MemCopy, BoolProperty, StructProperty, ObjectProperty, ECopyType_MAX}
    class ExposedValueCopyRecord {
        constructor(SourceProperty: Property, SourcePropertyName: string, SourceSubPropertyName: string, SourceArrayIndex: number, bInstanceIsTarget: boolean, PostCopyOperation: EPostCopyOperation, CopyType: ECopyType, DestProperty: Property, DestArrayIndex: number, Size: number, CachedSourceProperty: Property, CachedSourceStructSubProperty: Property);
        SourceProperty: Property;
        SourcePropertyName: string;
        SourceSubPropertyName: string;
        SourceArrayIndex: number;
        bInstanceIsTarget: boolean;
        PostCopyOperation: EPostCopyOperation;
        CopyType: ECopyType;
        DestProperty: Property;
        DestArrayIndex: number;
        Size: number;
        CachedSourceProperty: Property;
        CachedSourceStructSubProperty: Property;
    }
    
    class ExposedValueHandler {
        constructor(BoundFunction: string, CopyRecords: TArray<ExposedValueCopyRecord>, Function: Function, ValueHandlerNodeProperty: StructProperty);
        BoundFunction: string;
        CopyRecords: TArray<ExposedValueCopyRecord>;
        Function: Function;
        ValueHandlerNodeProperty: StructProperty;
    }
    
    class GraphAssetPlayerInformation {
        constructor(PlayerNodeIndices: TArray<number>);
        PlayerNodeIndices: TArray<number>;
    }
    
    class AnimGraphBlendOptions {
        constructor(BlendInTime: number, BlendOutTime: number);
        BlendInTime: number;
        BlendOutTime: number;
    }
    
    class AnimBlueprintGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BakedStateMachines: TArray<BakedAnimationStateMachine>;
        TargetSkeleton: Skeleton;
        AnimNotifies: TArray<AnimNotifyEvent>;
        OrderedSavedPoseIndicesMap: TMap<string, CachedPoseIndices>;
        SyncGroupNames: TArray<string>;
        EvaluateGraphExposedInputs: TArray<ExposedValueHandler>;
        GraphAssetPlayerInformation: TMap<string, GraphAssetPlayerInformation>;
        GraphBlendOptions: TMap<string, AnimGraphBlendOptions>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintGeneratedClass;
        static Load(InName: string): AnimBlueprintGeneratedClass;
    }
    
    class SoftClassPath extends SoftObjectPath {
        constructor();
    }
    
    class AnimNotifyEventReference {
        constructor(NotifySource: Object);
        NotifySource: Object;
    }
    
    class AnimNotifyArray {
        constructor(Notifies: TArray<AnimNotifyEventReference>);
        Notifies: TArray<AnimNotifyEventReference>;
    }
    
    class AnimNotifyQueue {
        constructor(AnimNotifies: TArray<AnimNotifyEventReference>, UnfilteredMontageAnimNotifies: TMap<string, AnimNotifyArray>);
        AnimNotifies: TArray<AnimNotifyEventReference>;
        UnfilteredMontageAnimNotifies: TMap<string, AnimNotifyArray>;
    }
    
    class PoseSnapshot {
        constructor(LocalTransforms: TArray<Transform>, BoneNames: TArray<string>, SkeletalMeshName: string, SnapshotName: string, bIsValid: boolean);
        LocalTransforms: TArray<Transform>;
        BoneNames: TArray<string>;
        SkeletalMeshName: string;
        SnapshotName: string;
        bIsValid: boolean;
    }
    
    enum ETeleportType { None, TeleportPhysics, ResetPhysics, ETeleportType_MAX}
    enum EMontagePlayReturnType { MontageLength, Duration, EMontagePlayReturnType_MAX}
    class MarkerSyncAnimPosition {
        constructor(PreviousMarkerName: string, NextMarkerName: string, PositionBetweenMarkers: number);
        PreviousMarkerName: string;
        NextMarkerName: string;
        PositionBetweenMarkers: number;
    }
    
    enum EAnimCurveType { AttributeCurve, MaterialCurve, MorphTargetCurve, MaxAnimCurveType, EAnimCurveType_MAX}
    class AnimInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentSkeleton: Skeleton;
        RootMotionMode: number;
        DeltaTime: number;
        bRunUpdatesInWorkerThreads: boolean;
        bCanUseParallelUpdateAnimation: boolean;
        bWarnAboutBlueprintUsage: boolean;
        bUseMultiThreadedAnimationUpdate: boolean;
        bUsingCopyPoseFromMesh: boolean;
        bQueueMontageEvents: boolean;
        OnMontageBlendingOut: $MulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
        OnMontageStarted: $MulticastDelegate<(Montage: AnimMontage) => void>;
        OnMontageEnded: $MulticastDelegate<(Montage: AnimMontage, bInterrupted: boolean) => void>;
        OnAllMontageInstancesEnded: $MulticastDelegate<() => void>;
        PostCompileValidationClassName: SoftClassPath;
        NotifyQueue: AnimNotifyQueue;
        ActiveAnimNotifyState: TArray<AnimNotifyEvent>;
        UnlockAIResources(bUnlockMovement: boolean, UnlockAILogic: boolean): void;
        UnlinkAnimClassLayers(InClass: Class): void;
        TryGetPawnOwner(): Pawn;
        StopSlotAnimation(InBlendOutTime: number, SlotNodeName: string): void;
        SnapshotPose(Snapshot: $Ref<PoseSnapshot>): void;
        SetRootMotionMode(Value: number): void;
        SetMorphTarget(MorphTargetName: string, Value: number): void;
        SavePoseSnapshot(SnapshotName: string): void;
        ResetDynamics(InTeleportType: ETeleportType): void;
        PlaySlotAnimationAsDynamicMontage(Asset: AnimSequenceBase, SlotNodeName: string, BlendInTime: number, BlendOutTime: number, InPlayRate: number, LoopCount: number, BlendOutTriggerTime: number, InTimeToStartMontageAt: number): AnimMontage;
        PlaySlotAnimation(Asset: AnimSequenceBase, SlotNodeName: string, BlendInTime: number, BlendOutTime: number, InPlayRate: number, LoopCount: number): number;
        Montage_Stop(InBlendOutTime: number, Montage: AnimMontage): void;
        Montage_SetPosition(Montage: AnimMontage, NewPosition: number): void;
        Montage_SetPlayRate(Montage: AnimMontage, NewPlayRate: number): void;
        Montage_SetNextSection(SectionNameToChange: string, NextSection: string, Montage: AnimMontage): void;
        Montage_Resume(Montage: AnimMontage): void;
        Montage_Play(MontageToPlay: AnimMontage, InPlayRate: number, ReturnValueType: EMontagePlayReturnType, InTimeToStartMontageAt: number, bStopAllMontages: boolean): number;
        Montage_Pause(Montage: AnimMontage): void;
        Montage_JumpToSectionsEnd(SectionName: string, Montage: AnimMontage): void;
        Montage_JumpToSection(SectionName: string, Montage: AnimMontage): void;
        Montage_IsPlaying(Montage: AnimMontage): boolean;
        Montage_IsActive(Montage: AnimMontage): boolean;
        Montage_GetPosition(Montage: AnimMontage): number;
        Montage_GetPlayRate(Montage: AnimMontage): number;
        Montage_GetIsStopped(Montage: AnimMontage): boolean;
        Montage_GetCurrentSection(Montage: AnimMontage): string;
        Montage_GetBlendTime(Montage: AnimMontage): number;
        LockAIResources(bLockMovement: boolean, LockAILogic: boolean): void;
        LinkAnimGraphByTag(InTag: string, InClass: Class): void;
        LinkAnimClassLayers(InClass: Class): void;
        IsSyncGroupBetweenMarkers(InSyncGroupName: string, PreviousMarker: string, NextMarker: string, bRespectMarkerOrder: boolean): boolean;
        IsPlayingSlotAnimation(Asset: AnimSequenceBase, SlotNodeName: string): boolean;
        IsAnyMontagePlaying(): boolean;
        HasMarkerBeenHitThisFrame(SyncGroup: string, MarkerName: string): boolean;
        GetTimeToClosestMarker(SyncGroup: string, MarkerName: string, OutMarkerTime: $Ref<number>): boolean;
        GetSyncGroupPosition(InSyncGroupName: string): MarkerSyncAnimPosition;
        GetRelevantAnimTimeRemainingFraction(MachineIndex: number, StateIndex: number): number;
        GetRelevantAnimTimeRemaining(MachineIndex: number, StateIndex: number): number;
        GetRelevantAnimTimeFraction(MachineIndex: number, StateIndex: number): number;
        GetRelevantAnimTime(MachineIndex: number, StateIndex: number): number;
        GetRelevantAnimLength(MachineIndex: number, StateIndex: number): number;
        GetOwningComponent(): SkeletalMeshComponent;
        GetOwningActor(): Actor;
        GetLinkedAnimLayerInstanceByGroup(InGroup: string): AnimInstance;
        GetLinkedAnimLayerInstanceByClass(InClass: Class): AnimInstance;
        GetLinkedAnimGraphInstancesByTag(InTag: string, OutLinkedInstances: $Ref<TArray<AnimInstance>>): void;
        GetLinkedAnimGraphInstanceByTag(InTag: string): AnimInstance;
        GetInstanceTransitionTimeElapsedFraction(MachineIndex: number, TransitionIndex: number): number;
        GetInstanceTransitionTimeElapsed(MachineIndex: number, TransitionIndex: number): number;
        GetInstanceTransitionCrossfadeDuration(MachineIndex: number, TransitionIndex: number): number;
        GetInstanceStateWeight(MachineIndex: number, StateIndex: number): number;
        GetInstanceMachineWeight(MachineIndex: number): number;
        GetInstanceCurrentStateElapsedTime(MachineIndex: number): number;
        GetInstanceAssetPlayerTimeFromEndFraction(AssetPlayerIndex: number): number;
        GetInstanceAssetPlayerTimeFromEnd(AssetPlayerIndex: number): number;
        GetInstanceAssetPlayerTimeFraction(AssetPlayerIndex: number): number;
        GetInstanceAssetPlayerTime(AssetPlayerIndex: number): number;
        GetInstanceAssetPlayerLength(AssetPlayerIndex: number): number;
        GetCurveValue(CurveName: string): number;
        GetCurrentStateName(MachineIndex: number): string;
        GetCurrentActiveMontage(): AnimMontage;
        GetAllCurveNames(OutNames: $Ref<TArray<string>>): void;
        GetActiveCurveNames(CurveType: EAnimCurveType, OutNames: $Ref<TArray<string>>): void;
        ClearMorphTargets(): void;
        CalculateDirection(Velocity: Vector, BaseRotation: Rotator): number;
        BlueprintUpdateAnimation(DeltaTimeX: number): void;
        BlueprintPostEvaluateAnimation(): void;
        BlueprintInitializeAnimation(): void;
        BlueprintBeginPlay(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimInstance;
        static Load(InName: string): AnimInstance;
    }
    
    class SingleAnimationPlayData {
        constructor(AnimToPlay: AnimationAsset, bSavedLooping: boolean, bSavedPlaying: boolean, SavedPosition: number, SavedPlayRate: number);
        AnimToPlay: AnimationAsset;
        bSavedLooping: boolean;
        bSavedPlaying: boolean;
        SavedPosition: number;
        SavedPlayRate: number;
    }
    
    enum EClothMassMode { UniformMass, TotalMass, Density, MaxClothMassMode, EClothMassMode_MAX}
    class ClothingSimulationInteractor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsAssetUpdated(): void;
        ClothConfigUpdated(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationInteractor;
        static Load(InName: string): ClothingSimulationInteractor;
    }
    
    class SkeletalMeshComponent extends SkinnedMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationBlueprint: AnimBlueprint;
        AnimBlueprintGeneratedClass: AnimBlueprintGeneratedClass;
        AnimClass: Class;
        AnimScriptInstance: AnimInstance;
        SubInstances: TArray<AnimInstance>;
        PostProcessAnimInstance: AnimInstance;
        AnimationData: SingleAnimationPlayData;
        RootBoneTranslation: Vector;
        LineCheckBoundsScale: Vector;
        LinkedInstances: TArray<AnimInstance>;
        CachedBoneSpaceTransforms: TArray<Transform>;
        CachedComponentSpaceTransforms: TArray<Transform>;
        GlobalAnimRateScale: number;
        KinematicBonesUpdateType: number;
        PhysicsTransformUpdateMode: number;
        AnimationMode: number;
        bDisablePostProcessBlueprint: boolean;
        bUpdateOverlapsOnAnimationFinalize: boolean;
        bHasValidBodies: boolean;
        bBlendPhysics: boolean;
        bEnablePhysicsOnDedicatedServer: boolean;
        bUpdateJointsFromAnimation: boolean;
        bDisableClothSimulation: boolean;
        bAllowAnimCurveEvaluation: boolean;
        bDisableAnimCurves: boolean;
        bCollideWithEnvironment: boolean;
        bCollideWithAttachedChildren: boolean;
        bLocalSpaceSimulation: boolean;
        bResetAfterTeleport: boolean;
        bDeferKinematicBoneUpdate: boolean;
        bNoSkeletonUpdate: boolean;
        bPauseAnims: boolean;
        bUseRefPoseOnInitAnim: boolean;
        bEnablePerPolyCollision: boolean;
        bForceRefpose: boolean;
        bOnlyAllowAutonomousTickPose: boolean;
        bIsAutonomousTickPose: boolean;
        bOldForceRefPose: boolean;
        bShowPrePhysBones: boolean;
        bRequiredBonesUpToDate: boolean;
        bAnimTreeInitialised: boolean;
        bIncludeComponentLocationIntoBounds: boolean;
        bEnableLineCheckWithBounds: boolean;
        bUseBendingElements: boolean;
        bUseTetrahedralConstraints: boolean;
        bUseThinShellVolumeConstraints: boolean;
        bUseSelfCollisions: boolean;
        bUseContinuousCollisionDetection: boolean;
        bPropagateCurvesToSlaves: boolean;
        bSkipKinematicUpdateWhenInterpolating: boolean;
        bSkipBoundsUpdateWhenInterpolating: boolean;
        bUpdateAnimationInEditor: boolean;
        bNeedsQueuedAnimEventsDispatched: boolean;
        CachedAnimCurveUidVersion: number;
        MassMode: EClothMassMode;
        UniformMass: number;
        TotalMass: number;
        Density: number;
        MinPerParticleMass: number;
        ClothBlendWeight: number;
        EdgeStiffness: number;
        BendingStiffness: number;
        AreaStiffness: number;
        VolumeStiffness: number;
        StrainLimitingStiffness: number;
        ShapeTargetStiffness: number;
        DisallowedAnimCurves: TArray<string>;
        BodySetup: BodySetup;
        OnConstraintBroken: $MulticastDelegate<(ConstraintIndex: number) => void>;
        ClothingSimulationFactory: Class;
        TeleportDistanceThreshold: number;
        TeleportRotationThreshold: number;
        LastPoseTickFrame: number;
        ClothingInteractor: ClothingSimulationInteractor;
        OnAnimInitialized: $MulticastDelegate<() => void>;
        SequenceToPlay: AnimSequence;
        AnimToPlay: AnimationAsset;
        bDefaultLooping: boolean;
        bDefaultPlaying: boolean;
        DefaultPosition: number;
        DefaultPlayRate: number;
        UnlinkAnimClassLayers(InClass: Class): void;
        UnbindClothFromMasterPoseComponent(bRestoreSimulationSpace: boolean): void;
        ToggleDisablePostProcessBlueprint(): void;
        TermBodiesBelow(ParentBoneName: string): void;
        SuspendClothingSimulation(): void;
        Stop(): void;
        SnapshotPose(Snapshot: $Ref<PoseSnapshot>): void;
        SetUpdateAnimationInEditor(NewUpdateState: boolean): void;
        SetTeleportRotationThreshold(Threshold: number): void;
        SetTeleportDistanceThreshold(Threshold: number): void;
        SetPosition(InPos: number, bFireNotifies: boolean): void;
        SetPlayRate(Rate: number): void;
        SetPhysicsBlendWeight(PhysicsBlendWeight: number): void;
        SetNotifyRigidBodyCollisionBelow(bNewNotifyRigidBodyCollision: boolean, BoneName: string, bIncludeSelf: boolean): void;
        SetMorphTarget(MorphTargetName: string, Value: number, bRemoveZeroWeight: boolean): void;
        SetEnablePhysicsBlending(bNewBlendPhysics: boolean): void;
        SetEnableGravityOnAllBodiesBelow(bEnableGravity: boolean, BoneName: string, bIncludeSelf: boolean): void;
        SetEnableBodyGravity(bEnableGravity: boolean, BoneName: string): void;
        SetDisablePostProcessBlueprint(bInDisablePostProcess: boolean): void;
        SetDisableAnimCurves(bInDisableAnimCurves: boolean): void;
        SetConstraintProfileForAll(ProfileName: string, bDefaultIfNotFound: boolean): void;
        SetConstraintProfile(JointName: string, ProfileName: string, bDefaultIfNotFound: boolean): void;
        SetClothMaxDistanceScale(Scale: number): void;
        SetBodyNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean, BoneName: string): void;
        SetAnimClass(NewClass: Class): void;
        SetAnimationMode(InAnimationMode: number): void;
        SetAnimation(NewAnimToPlay: AnimationAsset): void;
        SetAngularLimits(InBoneName: string, Swing1LimitAngle: number, TwistLimitAngle: number, Swing2LimitAngle: number): void;
        SetAllowedAnimCurvesEvaluation(List: TArray<string>, bAllow: boolean): void;
        SetAllowAnimCurveEvaluation(bInAllow: boolean): void;
        SetAllMotorsAngularVelocityDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bSkipCustomPhysicsType: boolean): void;
        SetAllMotorsAngularPositionDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean, bSkipCustomPhysicsType: boolean): void;
        SetAllMotorsAngularDriveParams(InSpring: number, InDamping: number, InForceLimit: number, bSkipCustomPhysicsType: boolean): void;
        SetAllBodiesSimulatePhysics(bNewSimulate: boolean): void;
        SetAllBodiesPhysicsBlendWeight(PhysicsBlendWeight: number, bSkipCustomPhysicsType: boolean): void;
        SetAllBodiesBelowSimulatePhysics(InBoneName: string, bNewSimulate: boolean, bIncludeSelf: boolean): void;
        SetAllBodiesBelowPhysicsBlendWeight(InBoneName: string, PhysicsBlendWeight: number, bSkipCustomPhysicsType: boolean, bIncludeSelf: boolean): void;
        ResumeClothingSimulation(): void;
        ResetClothTeleportMode(): void;
        ResetAnimInstanceDynamics(InTeleportType: ETeleportType): void;
        ResetAllowedAnimCurveEvaluation(): void;
        ResetAllBodiesSimulatePhysics(): void;
        PlayAnimation(NewAnimToPlay: AnimationAsset, bLooping: boolean): void;
        Play(bLooping: boolean): void;
        OverrideAnimationData(InAnimToPlay: AnimationAsset, bIsLooping: boolean, bIsPlaying: boolean, Position: number, PlayRate: number): void;
        LinkAnimGraphByTag(InTag: string, InClass: Class): void;
        LinkAnimClassLayers(InClass: Class): void;
        K2_GetClosestPointOnPhysicsAsset(WorldPosition: Vector, ClosestWorldPosition: $Ref<Vector>, Normal: $Ref<Vector>, BoneName: $Ref<string>, Distance: $Ref<number>): boolean;
        IsPlaying(): boolean;
        IsClothingSimulationSuspended(): boolean;
        IsBodyGravityEnabled(BoneName: string): boolean;
        HasValidAnimationInstance(): boolean;
        GetTeleportRotationThreshold(): number;
        GetTeleportDistanceThreshold(): number;
        GetSkeletalCenterOfMass(): Vector;
        GetPostProcessInstance(): AnimInstance;
        GetPosition(): number;
        GetPlayRate(): number;
        GetMorphTarget(MorphTargetName: string): number;
        GetLinkedAnimLayerInstanceByGroup(InGroup: string): AnimInstance;
        GetLinkedAnimLayerInstanceByClass(InClass: Class): AnimInstance;
        GetLinkedAnimGraphInstancesByTag(InTag: string, OutLinkedInstances: $Ref<TArray<AnimInstance>>): void;
        GetLinkedAnimGraphInstanceByTag(InTag: string): AnimInstance;
        GetDisablePostProcessBlueprint(): boolean;
        GetDisableAnimCurves(): boolean;
        GetCurrentJointAngles(InBoneName: string, Swing1Angle: $Ref<number>, TwistAngle: $Ref<number>, Swing2Angle: $Ref<number>): void;
        GetClothMaxDistanceScale(): number;
        GetClothingSimulationInteractor(): ClothingSimulationInteractor;
        GetBoneMass(BoneName: string, bScaleMass: boolean): number;
        GetAnimInstance(): AnimInstance;
        GetAnimClass(): Class;
        GetAnimationMode(): number;
        GetAllowedAnimCurveEvaluate(): boolean;
        ForceClothNextUpdateTeleportAndReset(): void;
        ForceClothNextUpdateTeleport(): void;
        FindConstraintBoneName(ConstraintIndex: number): string;
        ClearMorphTargets(): void;
        BreakConstraint(Impulse: Vector, HitLocation: Vector, InBoneName: string): void;
        BindClothToMasterPoseComponent(): void;
        AllowAnimCurveEvaluation(NameOfCurve: string, bAllow: boolean): void;
        AddImpulseToAllBodiesBelow(Impulse: Vector, BoneName: string, bVelChange: boolean, bIncludeSelf: boolean): void;
        AddForceToAllBodiesBelow(Force: Vector, BoneName: string, bAccelChange: boolean, bIncludeSelf: boolean): void;
        AccumulateAllBodiesBelowPhysicsBlendWeight(InBoneName: string, AddPhysicsBlendWeight: number, bSkipCustomPhysicsType: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshComponent;
        static Load(InName: string): SkeletalMeshComponent;
    }
    
    enum EPlaneConstraintAxisSetting { Custom, X, Y, Z, UseGlobalPhysicsSetting, EPlaneConstraintAxisSetting_MAX}
    class MovementComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdatedComponent: SceneComponent;
        UpdatedPrimitive: PrimitiveComponent;
        Velocity: Vector;
        PlaneConstraintNormal: Vector;
        PlaneConstraintOrigin: Vector;
        bUpdateOnlyIfRendered: boolean;
        bAutoUpdateTickRegistration: boolean;
        bTickBeforeOwner: boolean;
        bAutoRegisterUpdatedComponent: boolean;
        bConstrainToPlane: boolean;
        bSnapToPlaneAtStart: boolean;
        bAutoRegisterPhysicsVolumeUpdates: boolean;
        bComponentShouldUpdatePhysicsVolume: boolean;
        PlaneConstraintAxisSetting: EPlaneConstraintAxisSetting;
        StopMovementImmediately(): void;
        SnapUpdatedComponentToPlane(): void;
        SetUpdatedComponent(NewUpdatedComponent: SceneComponent): void;
        SetPlaneConstraintOrigin(PlaneOrigin: Vector): void;
        SetPlaneConstraintNormal(PlaneNormal: Vector): void;
        SetPlaneConstraintFromVectors(Forward: Vector, Up: Vector): void;
        SetPlaneConstraintEnabled(bEnabled: boolean): void;
        SetPlaneConstraintAxisSetting(NewAxisSetting: EPlaneConstraintAxisSetting): void;
        PhysicsVolumeChanged(NewVolume: PhysicsVolume): void;
        K2_MoveUpdatedComponent(Delta: Vector, NewRotation: Rotator, OutHit: $Ref<HitResult>, bSweep: boolean, bTeleport: boolean): boolean;
        K2_GetModifiedMaxSpeed(): number;
        K2_GetMaxSpeedModifier(): number;
        IsExceedingMaxSpeed(MaxSpeed: number): boolean;
        GetPlaneConstraintOrigin(): Vector;
        GetPlaneConstraintNormal(): Vector;
        GetPlaneConstraintAxisSetting(): EPlaneConstraintAxisSetting;
        GetPhysicsVolume(): PhysicsVolume;
        GetMaxSpeed(): number;
        GetGravityZ(): number;
        ConstrainNormalToPlane(Normal: Vector): Vector;
        ConstrainLocationToPlane(Location: Vector): Vector;
        ConstrainDirectionToPlane(Direction: Vector): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovementComponent;
        static Load(InName: string): MovementComponent;
    }
    
    class MovementProperties {
        constructor(bCanCrouch: boolean, bCanJump: boolean, bCanWalk: boolean, bCanSwim: boolean, bCanFly: boolean);
        bCanCrouch: boolean;
        bCanJump: boolean;
        bCanWalk: boolean;
        bCanSwim: boolean;
        bCanFly: boolean;
    }
    
    class NavAgentProperties extends MovementProperties {
        constructor(AgentRadius: number, AgentHeight: number, AgentStepHeight: number, NavWalkingSearchHeightScale: number, PreferredNavData: SoftClassPath);
        AgentRadius: number;
        AgentHeight: number;
        AgentStepHeight: number;
        NavWalkingSearchHeightScale: number;
        PreferredNavData: SoftClassPath;
    }
    
    class NavMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavAgentProps: NavAgentProperties;
        FixedPathBrakingDistance: number;
        bUpdateNavAgentWithOwnersCollision: boolean;
        bUseAccelerationForPaths: boolean;
        bUseFixedBrakingDistanceForPaths: boolean;
        MovementState: MovementProperties;
        PathFollowingComp: Object;
        StopMovementKeepPathing(): void;
        StopActiveMovement(): void;
        IsSwimming(): boolean;
        IsMovingOnGround(): boolean;
        IsFlying(): boolean;
        IsFalling(): boolean;
        IsCrouching(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavMovementComponent;
        static Load(InName: string): NavMovementComponent;
    }
    
    class PawnMovementComponent extends NavMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PawnOwner: Pawn;
        K2_GetInputVector(): Vector;
        IsMoveInputIgnored(): boolean;
        GetPendingInputVector(): Vector;
        GetPawnOwner(): Pawn;
        GetLastInputVector(): Vector;
        ConsumeInputVector(): Vector;
        AddInputVector(WorldVector: Vector, bForce: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnMovementComponent;
        static Load(InName: string): PawnMovementComponent;
    }
    
    enum ENetworkSmoothingMode { Disabled, Linear, Exponential, Replay, ENetworkSmoothingMode_MAX}
    class FindFloorResult {
        constructor(bBlockingHit: boolean, bWalkableFloor: boolean, bLineTrace: boolean, FloorDist: number, LineDist: number, HitResult: HitResult);
        bBlockingHit: boolean;
        bWalkableFloor: boolean;
        bLineTrace: boolean;
        FloorDist: number;
        LineDist: number;
        HitResult: HitResult;
    }
    
    class NavAvoidanceMask {
        constructor(bGroup0: boolean, bGroup1: boolean, bGroup2: boolean, bGroup3: boolean, bGroup4: boolean, bGroup5: boolean, bGroup6: boolean, bGroup7: boolean, bGroup8: boolean, bGroup9: boolean, bGroup10: boolean, bGroup11: boolean, bGroup12: boolean, bGroup13: boolean, bGroup14: boolean, bGroup15: boolean, bGroup16: boolean, bGroup17: boolean, bGroup18: boolean, bGroup19: boolean, bGroup20: boolean, bGroup21: boolean, bGroup22: boolean, bGroup23: boolean, bGroup24: boolean, bGroup25: boolean, bGroup26: boolean, bGroup27: boolean, bGroup28: boolean, bGroup29: boolean, bGroup30: boolean, bGroup31: boolean);
        bGroup0: boolean;
        bGroup1: boolean;
        bGroup2: boolean;
        bGroup3: boolean;
        bGroup4: boolean;
        bGroup5: boolean;
        bGroup6: boolean;
        bGroup7: boolean;
        bGroup8: boolean;
        bGroup9: boolean;
        bGroup10: boolean;
        bGroup11: boolean;
        bGroup12: boolean;
        bGroup13: boolean;
        bGroup14: boolean;
        bGroup15: boolean;
        bGroup16: boolean;
        bGroup17: boolean;
        bGroup18: boolean;
        bGroup19: boolean;
        bGroup20: boolean;
        bGroup21: boolean;
        bGroup22: boolean;
        bGroup23: boolean;
        bGroup24: boolean;
        bGroup25: boolean;
        bGroup26: boolean;
        bGroup27: boolean;
        bGroup28: boolean;
        bGroup29: boolean;
        bGroup30: boolean;
        bGroup31: boolean;
    }
    
    class CharacterMovementComponentPostPhysicsTickFunction extends TickFunction {
        constructor();
    }
    
    class RootMotionSourceSettings {
        constructor(Flags: number);
        Flags: number;
    }
    
    class Vector_NetQuantize10 extends Vector {
        constructor();
    }
    
    class RootMotionSourceGroup {
        constructor(bHasAdditiveSources: boolean, bHasOverrideSources: boolean, bIsAdditiveVelocityApplied: boolean, LastAccumulatedSettings: RootMotionSourceSettings, LastPreAdditiveVelocity: Vector_NetQuantize10);
        bHasAdditiveSources: boolean;
        bHasOverrideSources: boolean;
        bIsAdditiveVelocityApplied: boolean;
        LastAccumulatedSettings: RootMotionSourceSettings;
        LastPreAdditiveVelocity: Vector_NetQuantize10;
    }
    
    class RootMotionMovementParams {
        constructor(bHasRootMotion: boolean, BlendWeight: number, RootMotionTransform: Transform);
        bHasRootMotion: boolean;
        BlendWeight: number;
        RootMotionTransform: Transform;
    }
    
    class CharacterMovementComponent extends PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CharacterOwner: Character;
        GravityScale: number;
        MaxStepHeight: number;
        JumpZVelocity: number;
        JumpOffJumpZFactor: number;
        WalkableFloorAngle: number;
        WalkableFloorZ: number;
        MovementMode: number;
        CustomMovementMode: number;
        NetworkSmoothingMode: ENetworkSmoothingMode;
        GroundFriction: number;
        MaxWalkSpeed: number;
        MaxWalkSpeedCrouched: number;
        MaxSwimSpeed: number;
        MaxFlySpeed: number;
        MaxCustomMovementSpeed: number;
        MaxAcceleration: number;
        MinAnalogWalkSpeed: number;
        BrakingFrictionFactor: number;
        BrakingFriction: number;
        BrakingSubStepTime: number;
        BrakingDecelerationWalking: number;
        BrakingDecelerationFalling: number;
        BrakingDecelerationSwimming: number;
        BrakingDecelerationFlying: number;
        AirControl: number;
        AirControlBoostMultiplier: number;
        AirControlBoostVelocityThreshold: number;
        FallingLateralFriction: number;
        CrouchedHalfHeight: number;
        Buoyancy: number;
        PerchRadiusThreshold: number;
        PerchAdditionalHeight: number;
        RotationRate: Rotator;
        bUseSeparateBrakingFriction: boolean;
        bApplyGravityWhileJumping: boolean;
        bUseControllerDesiredRotation: boolean;
        bOrientRotationToMovement: boolean;
        bSweepWhileNavWalking: boolean;
        bMovementInProgress: boolean;
        bEnableScopedMovementUpdates: boolean;
        bEnableServerDualMoveScopedMovementUpdates: boolean;
        bForceMaxAccel: boolean;
        bRunPhysicsWithNoController: boolean;
        bForceNextFloorCheck: boolean;
        bShrinkProxyCapsule: boolean;
        bCanWalkOffLedges: boolean;
        bCanWalkOffLedgesWhenCrouching: boolean;
        bNetworkSkipProxyPredictionOnNetUpdate: boolean;
        bNetworkAlwaysReplicateTransformUpdateTimestamp: boolean;
        bDeferUpdateMoveComponent: boolean;
        bEnablePhysicsInteraction: boolean;
        bTouchForceScaledToMass: boolean;
        bPushForceScaledToMass: boolean;
        bPushForceUsingZOffset: boolean;
        bScalePushForceToVelocity: boolean;
        DeferredUpdatedMoveComponent: SceneComponent;
        MaxOutOfWaterStepHeight: number;
        OutofWaterZ: number;
        Mass: number;
        StandingDownwardForceScale: number;
        InitialPushForceFactor: number;
        PushForceFactor: number;
        PushForcePointZOffsetFactor: number;
        TouchForceFactor: number;
        MinTouchForce: number;
        MaxTouchForce: number;
        RepulsionForce: number;
        bForceBraking: boolean;
        CrouchedSpeedMultiplier: number;
        UpperImpactNormalScale: number;
        Acceleration: Vector;
        LastUpdateRotation: Quat;
        LastUpdateLocation: Vector;
        LastUpdateVelocity: Vector;
        ServerLastTransformUpdateTimeStamp: number;
        ServerLastClientGoodMoveAckTime: number;
        ServerLastClientAdjustmentTime: number;
        PendingImpulseToApply: Vector;
        PendingForceToApply: Vector;
        AnalogInputModifier: number;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        MaxJumpApexAttemptsPerSimulation: number;
        MaxDepenetrationWithGeometry: number;
        MaxDepenetrationWithGeometryAsProxy: number;
        MaxDepenetrationWithPawn: number;
        MaxDepenetrationWithPawnAsProxy: number;
        NetworkSimulatedSmoothLocationTime: number;
        NetworkSimulatedSmoothRotationTime: number;
        ListenServerNetworkSimulatedSmoothLocationTime: number;
        ListenServerNetworkSimulatedSmoothRotationTime: number;
        NetProxyShrinkRadius: number;
        NetProxyShrinkHalfHeight: number;
        NetworkMaxSmoothUpdateDistance: number;
        NetworkNoSmoothUpdateDistance: number;
        NetworkMinTimeBetweenClientAckGoodMoves: number;
        NetworkMinTimeBetweenClientAdjustments: number;
        NetworkMinTimeBetweenClientAdjustmentsLargeCorrection: number;
        NetworkLargeClientCorrectionDistance: number;
        LedgeCheckThreshold: number;
        JumpOutOfWaterPitch: number;
        CurrentFloor: FindFloorResult;
        DefaultLandMovementMode: number;
        DefaultWaterMovementMode: number;
        GroundMovementMode: number;
        bMaintainHorizontalGroundVelocity: boolean;
        bImpartBaseVelocityX: boolean;
        bImpartBaseVelocityY: boolean;
        bImpartBaseVelocityZ: boolean;
        bImpartBaseAngularVelocity: boolean;
        bJustTeleported: boolean;
        bNetworkUpdateReceived: boolean;
        bNetworkMovementModeChanged: boolean;
        bIgnoreClientMovementErrorChecksAndCorrection: boolean;
        bServerAcceptClientAuthoritativePosition: boolean;
        bNotifyApex: boolean;
        bCheatFlying: boolean;
        bWantsToCrouch: boolean;
        bCrouchMaintainsBaseLocation: boolean;
        bIgnoreBaseRotation: boolean;
        bFastAttachedMove: boolean;
        bAlwaysCheckFloor: boolean;
        bUseFlatBaseForFloorChecks: boolean;
        bPerformingJumpOff: boolean;
        bWantsToLeaveNavWalking: boolean;
        bUseRVOAvoidance: boolean;
        bRequestedMoveUseAcceleration: boolean;
        bWasSimulatingRootMotion: boolean;
        bAllowPhysicsRotationDuringAnimRootMotion: boolean;
        bHasRequestedVelocity: boolean;
        bRequestedMoveWithMaxSpeed: boolean;
        bWasAvoidanceUpdated: boolean;
        bProjectNavMeshWalking: boolean;
        bProjectNavMeshOnBothWorldChannels: boolean;
        AvoidanceConsiderationRadius: number;
        RequestedVelocity: Vector;
        AvoidanceUID: number;
        AvoidanceGroup: NavAvoidanceMask;
        GroupsToAvoid: NavAvoidanceMask;
        GroupsToIgnore: NavAvoidanceMask;
        AvoidanceWeight: number;
        PendingLaunchVelocity: Vector;
        NavMeshProjectionInterval: number;
        NavMeshProjectionTimer: number;
        NavMeshProjectionInterpSpeed: number;
        NavMeshProjectionHeightScaleUp: number;
        NavMeshProjectionHeightScaleDown: number;
        NavWalkingFloorDistTolerance: number;
        PostPhysicsTickFunction: CharacterMovementComponentPostPhysicsTickFunction;
        MinTimeBetweenTimeStampResets: number;
        CurrentRootMotion: RootMotionSourceGroup;
        RootMotionParams: RootMotionMovementParams;
        AnimRootMotionVelocity: Vector;
        SetWalkableFloorZ(InWalkableFloorZ: number): void;
        SetWalkableFloorAngle(InWalkableFloorAngle: number): void;
        SetMovementMode(NewMovementMode: number, NewCustomMode: number): void;
        SetGroupsToIgnoreMask(GroupMask: NavAvoidanceMask): void;
        SetGroupsToIgnore(GroupFlags: number): void;
        SetGroupsToAvoidMask(GroupMask: NavAvoidanceMask): void;
        SetGroupsToAvoid(GroupFlags: number): void;
        SetAvoidanceGroupMask(GroupMask: NavAvoidanceMask): void;
        SetAvoidanceGroup(GroupFlags: number): void;
        SetAvoidanceEnabled(bEnable: boolean): void;
        K2_GetWalkableFloorZ(): number;
        K2_GetWalkableFloorAngle(): number;
        K2_GetModifiedMaxAcceleration(): number;
        K2_FindFloor(CapsuleLocation: Vector, FloorResult: $Ref<FindFloorResult>): void;
        K2_ComputeFloorDist(CapsuleLocation: Vector, LineDistance: number, SweepDistance: number, SweepRadius: number, FloorResult: $Ref<FindFloorResult>): void;
        IsWalking(): boolean;
        IsWalkable(Hit: HitResult): boolean;
        GetValidPerchRadius(): number;
        GetPerchRadiusThreshold(): number;
        GetMovementBase(): PrimitiveComponent;
        GetMinAnalogSpeed(): number;
        GetMaxJumpHeightWithJumpTime(): number;
        GetMaxJumpHeight(): number;
        GetMaxBrakingDeceleration(): number;
        GetMaxAcceleration(): number;
        GetLastUpdateVelocity(): Vector;
        GetLastUpdateRotation(): Rotator;
        GetLastUpdateLocation(): Vector;
        GetImpartedMovementBaseVelocity(): Vector;
        GetCurrentAcceleration(): Vector;
        GetCharacterOwner(): Character;
        GetAnalogInputModifier(): number;
        DisableMovement(): void;
        ClearAccumulatedForces(): void;
        CapsuleTouched(OverlappedComp: PrimitiveComponent, Other: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult): void;
        CalcVelocity(DeltaTime: number, Friction: number, bFluid: boolean, BrakingDeceleration: number): void;
        AddImpulse(Impulse: Vector, bVelocityChange: boolean): void;
        AddForce(Force: Vector): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CharacterMovementComponent;
        static Load(InName: string): CharacterMovementComponent;
    }
    
    class ShapeComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShapeBodySetup: BodySetup;
        AreaClass: Class;
        ShapeColor: Color;
        bDrawOnlyIfSelected: boolean;
        bShouldCollideWhenPlacing: boolean;
        bDynamicObstacle: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShapeComponent;
        static Load(InName: string): ShapeComponent;
    }
    
    class CapsuleComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleHalfHeight: number;
        CapsuleRadius: number;
        CapsuleHeight: number;
        SetCapsuleSize(InRadius: number, InHalfHeight: number, bUpdateOverlaps: boolean): void;
        SetCapsuleRadius(Radius: number, bUpdateOverlaps: boolean): void;
        SetCapsuleHalfHeight(HalfHeight: number, bUpdateOverlaps: boolean): void;
        GetUnscaledCapsuleSize_WithoutHemisphere(OutRadius: $Ref<number>, OutHalfHeightWithoutHemisphere: $Ref<number>): void;
        GetUnscaledCapsuleSize(OutRadius: $Ref<number>, OutHalfHeight: $Ref<number>): void;
        GetUnscaledCapsuleRadius(): number;
        GetUnscaledCapsuleHalfHeight_WithoutHemisphere(): number;
        GetUnscaledCapsuleHalfHeight(): number;
        GetShapeScale(): number;
        GetScaledCapsuleSize_WithoutHemisphere(OutRadius: $Ref<number>, OutHalfHeightWithoutHemisphere: $Ref<number>): void;
        GetScaledCapsuleSize(OutRadius: $Ref<number>, OutHalfHeight: $Ref<number>): void;
        GetScaledCapsuleRadius(): number;
        GetScaledCapsuleHalfHeight_WithoutHemisphere(): number;
        GetScaledCapsuleHalfHeight(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CapsuleComponent;
        static Load(InName: string): CapsuleComponent;
    }
    
    class ArrowComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ArrowColor: Color;
        ArrowSize: number;
        ScreenSize: number;
        bIsScreenSizeScaled: boolean;
        bTreatAsASprite: boolean;
        SpriteCategoryName: string;
        SpriteInfo: SpriteCategoryInfo;
        bLightAttachment: boolean;
        bUseInEditorScaling: boolean;
        SetArrowColor(NewColor: LinearColor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArrowComponent;
        static Load(InName: string): ArrowComponent;
    }
    
    class BasedMovementInfo {
        constructor(MovementBase: PrimitiveComponent, BoneName: string, Location: Vector_NetQuantize100, Rotation: Rotator, bServerHasBaseComponent: boolean, bRelativeRotation: boolean, bServerHasVelocity: boolean);
        MovementBase: PrimitiveComponent;
        BoneName: string;
        Location: Vector_NetQuantize100;
        Rotation: Rotator;
        bServerHasBaseComponent: boolean;
        bRelativeRotation: boolean;
        bServerHasVelocity: boolean;
    }
    
    class RepRootMotionMontage {
        constructor(bIsActive: boolean, AnimMontage: AnimMontage, Position: number, Location: Vector_NetQuantize100, Rotation: Rotator, MovementBase: PrimitiveComponent, MovementBaseBoneName: string, bRelativePosition: boolean, bRelativeRotation: boolean, AuthoritativeRootMotion: RootMotionSourceGroup, Acceleration: Vector_NetQuantize10, LinearVelocity: Vector_NetQuantize10);
        bIsActive: boolean;
        AnimMontage: AnimMontage;
        Position: number;
        Location: Vector_NetQuantize100;
        Rotation: Rotator;
        MovementBase: PrimitiveComponent;
        MovementBaseBoneName: string;
        bRelativePosition: boolean;
        bRelativeRotation: boolean;
        AuthoritativeRootMotion: RootMotionSourceGroup;
        Acceleration: Vector_NetQuantize10;
        LinearVelocity: Vector_NetQuantize10;
    }
    
    class SimulatedRootMotionReplicatedMove {
        constructor(Time: number, RootMotion: RepRootMotionMontage);
        Time: number;
        RootMotion: RepRootMotionMontage;
    }
    
    class Character extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: SkeletalMeshComponent;
        CharacterMovement: CharacterMovementComponent;
        CapsuleComponent: CapsuleComponent;
        ArrowComponent: ArrowComponent;
        BasedMovement: BasedMovementInfo;
        ReplicatedBasedMovement: BasedMovementInfo;
        AnimRootMotionTranslationScale: number;
        BaseTranslationOffset: Vector;
        BaseRotationOffset: Quat;
        ReplicatedServerLastTransformUpdateTimeStamp: number;
        ReplayLastTransformUpdateTimeStamp: number;
        ReplicatedMovementMode: number;
        bInBaseReplication: boolean;
        CrouchedEyeHeight: number;
        bIsCrouched: boolean;
        bProxyIsJumpForceApplied: boolean;
        bPressedJump: boolean;
        bClientUpdating: boolean;
        bClientWasFalling: boolean;
        bClientResimulateRootMotion: boolean;
        bClientResimulateRootMotionSources: boolean;
        bSimGravityDisabled: boolean;
        bClientCheckEncroachmentOnNetUpdate: boolean;
        bServerMoveIgnoreRootMotion: boolean;
        bWasJumping: boolean;
        JumpKeyHoldTime: number;
        JumpForceTimeRemaining: number;
        ProxyJumpForceStartedTime: number;
        JumpMaxHoldTime: number;
        JumpMaxCount: number;
        JumpCurrentCount: number;
        OnReachedJumpApex: $MulticastDelegate<() => void>;
        MovementModeChangedDelegate: $MulticastDelegate<(Character: Character, PrevMovementMode: number, PreviousCustomMode: number) => void>;
        OnCharacterMovementUpdated: $MulticastDelegate<(DeltaSeconds: number, OldLocation: Vector, OldVelocity: Vector) => void>;
        SavedRootMotion: RootMotionSourceGroup;
        ClientRootMotionParams: RootMotionMovementParams;
        RootMotionRepMoves: TArray<SimulatedRootMotionReplicatedMove>;
        RepRootMotion: RepRootMotionMontage;
        UnCrouch(bClientSimulation: boolean): void;
        StopJumping(): void;
        StopAnimMontage(AnimMontage: AnimMontage): void;
        ServerMoveOld(OldTimeStamp: number, OldAccel: Vector_NetQuantize10, OldMoveFlags: number): void;
        ServerMoveNoBase(TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, CompressedMoveFlags: number, ClientRoll: number, View: number, ClientMovementMode: number): void;
        ServerMoveDualNoBase(TimeStamp0: number, InAccel0: Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementMode: number): void;
        ServerMoveDualHybridRootMotion(TimeStamp0: number, InAccel0: Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementBase: PrimitiveComponent, ClientBaseBoneName: string, ClientMovementMode: number): void;
        ServerMoveDual(TimeStamp0: number, InAccel0: Vector_NetQuantize10, PendingFlags: number, View0: number, TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, NewFlags: number, ClientRoll: number, View: number, ClientMovementBase: PrimitiveComponent, ClientBaseBoneName: string, ClientMovementMode: number): void;
        ServerMove(TimeStamp: number, InAccel: Vector_NetQuantize10, ClientLoc: Vector_NetQuantize100, CompressedMoveFlags: number, ClientRoll: number, View: number, ClientMovementBase: PrimitiveComponent, ClientBaseBoneName: string, ClientMovementMode: number): void;
        RootMotionDebugClientPrintOnScreen(InString: string): void;
        PlayAnimMontage(AnimMontage: AnimMontage, InPlayRate: number, StartSectionName: string): number;
        OnWalkingOffLedge(PreviousFloorImpactNormal: Vector, PreviousFloorContactNormal: Vector, PreviousLocation: Vector, TimeDelta: number): void;
        OnRep_RootMotion(): void;
        OnRep_ReplicatedBasedMovement(): void;
        OnRep_ReplayLastTransformUpdateTimeStamp(): void;
        OnRep_IsCrouched(): void;
        OnLaunched(LaunchVelocity: Vector, bXYOverride: boolean, bZOverride: boolean): void;
        OnLanded(Hit: HitResult): void;
        OnJumped(): void;
        LaunchCharacter(LaunchVelocity: Vector, bXYOverride: boolean, bZOverride: boolean): void;
        K2_UpdateCustomMovement(DeltaTime: number): void;
        K2_OnStartCrouch(HalfHeightAdjust: number, ScaledHalfHeightAdjust: number): void;
        K2_OnMovementModeChanged(PrevMovementMode: number, NewMovementMode: number, PrevCustomMode: number, NewCustomMode: number): void;
        K2_OnEndCrouch(HalfHeightAdjust: number, ScaledHalfHeightAdjust: number): void;
        Jump(): void;
        IsPlayingRootMotion(): boolean;
        IsPlayingNetworkedRootMotionMontage(): boolean;
        IsJumpProvidingForce(): boolean;
        HasAnyRootMotion(): boolean;
        GetCurrentMontage(): AnimMontage;
        GetBaseTranslationOffset(): Vector;
        GetBaseRotationOffsetRotator(): Rotator;
        GetAnimRootMotionTranslationScale(): number;
        Crouch(bClientSimulation: boolean): void;
        ClientVeryShortAdjustPosition(TimeStamp: number, NewLoc: Vector, NewBase: PrimitiveComponent, NewBaseBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;
        ClientCheatWalk(): void;
        ClientCheatGhost(): void;
        ClientCheatFly(): void;
        ClientAdjustRootMotionSourcePosition(TimeStamp: number, ServerRootMotion: RootMotionSourceGroup, bHasAnimRootMotion: boolean, ServerMontageTrackPosition: number, ServerLoc: Vector, ServerRotation: Vector_NetQuantizeNormal, ServerVelZ: number, ServerBase: PrimitiveComponent, ServerBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;
        ClientAdjustRootMotionPosition(TimeStamp: number, ServerMontageTrackPosition: number, ServerLoc: Vector, ServerRotation: Vector_NetQuantizeNormal, ServerVelZ: number, ServerBase: PrimitiveComponent, ServerBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;
        ClientAdjustPosition(TimeStamp: number, NewLoc: Vector, NewVel: Vector, NewBase: PrimitiveComponent, NewBaseBoneName: string, bHasBase: boolean, bBaseRelativePosition: boolean, ServerMovementMode: number): void;
        ClientAckGoodMove(TimeStamp: number): void;
        CanJumpInternal(): boolean;
        CanJump(): boolean;
        CanCrouch(): boolean;
        CacheInitialMeshOffset(MeshRelativeLocation: Vector, MeshRelativeRotation: Rotator): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Character;
        static Load(InName: string): Character;
    }
    
    class Player extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerController: PlayerController;
        CurrentNetSpeed: number;
        ConfiguredInternetSpeed: number;
        ConfiguredLanSpeed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Player;
        static Load(InName: string): Player;
    }
    
    class InterpTrackInst extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInst;
        static Load(InName: string): InterpTrackInst;
    }
    
    class InterpTrackInstDirector extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OldViewTarget: Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstDirector;
        static Load(InName: string): InterpTrackInstDirector;
    }
    
    class ReporterBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReporterBase;
        static Load(InName: string): ReporterBase;
    }
    
    class ReporterGraph extends ReporterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReporterGraph;
        static Load(InName: string): ReporterGraph;
    }
    
    class CanvasUVTri {
        constructor(V0_Pos: Vector2D, V0_UV: Vector2D, V0_Color: LinearColor, V1_Pos: Vector2D, V1_UV: Vector2D, V1_Color: LinearColor, V2_Pos: Vector2D, V2_UV: Vector2D, V2_Color: LinearColor);
        V0_Pos: Vector2D;
        V0_UV: Vector2D;
        V0_Color: LinearColor;
        V1_Pos: Vector2D;
        V1_UV: Vector2D;
        V1_Color: LinearColor;
        V2_Pos: Vector2D;
        V2_UV: Vector2D;
        V2_Color: LinearColor;
    }
    
    class Canvas extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OrgX: number;
        OrgY: number;
        ClipX: number;
        ClipY: number;
        DrawColor: Color;
        bCenterX: boolean;
        bCenterY: boolean;
        bNoSmooth: boolean;
        SizeX: number;
        SizeY: number;
        ColorModulate: Plane;
        DefaultTexture: Texture2D;
        GradientTexture0: Texture2D;
        ReporterGraph: ReporterGraph;
        K2_TextSize(RenderFont: Font, RenderText: string, Scale: Vector2D): Vector2D;
        K2_StrLen(RenderFont: Font, RenderText: string): Vector2D;
        K2_Project(WorldLocation: Vector): Vector;
        K2_DrawTriangle(RenderTexture: Texture, Triangles: TArray<CanvasUVTri>): void;
        K2_DrawTexture(RenderTexture: Texture, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize: Vector2D, RenderColor: LinearColor, BlendMode: number, Rotation: number, PivotPoint: Vector2D): void;
        K2_DrawText(RenderFont: Font, RenderText: string, ScreenPosition: Vector2D, Scale: Vector2D, RenderColor: LinearColor, Kerning: number, ShadowColor: LinearColor, ShadowOffset: Vector2D, bCentreX: boolean, bCentreY: boolean, bOutlined: boolean, OutlineColor: LinearColor): void;
        K2_DrawPolygon(RenderTexture: Texture, ScreenPosition: Vector2D, Radius: Vector2D, NumberOfSides: number, RenderColor: LinearColor): void;
        K2_DrawMaterialTriangle(RenderMaterial: MaterialInterface, Triangles: TArray<CanvasUVTri>): void;
        K2_DrawMaterial(RenderMaterial: MaterialInterface, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize: Vector2D, Rotation: number, PivotPoint: Vector2D): void;
        K2_DrawLine(ScreenPositionA: Vector2D, ScreenPositionB: Vector2D, Thickness: number, RenderColor: LinearColor): void;
        K2_DrawBox(ScreenPosition: Vector2D, ScreenSize: Vector2D, Thickness: number, RenderColor: LinearColor): void;
        K2_DrawBorder(BorderTexture: Texture, BackgroundTexture: Texture, LeftBorderTexture: Texture, RightBorderTexture: Texture, TopBorderTexture: Texture, BottomBorderTexture: Texture, ScreenPosition: Vector2D, ScreenSize: Vector2D, CoordinatePosition: Vector2D, CoordinateSize: Vector2D, RenderColor: LinearColor, BorderScale: Vector2D, BackgroundScale: Vector2D, Rotation: number, PivotPoint: Vector2D, CornerSize: Vector2D): void;
        K2_Deproject(ScreenPosition: Vector2D, WorldOrigin: $Ref<Vector>, WorldDirection: $Ref<Vector>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Canvas;
        static Load(InName: string): Canvas;
    }
    
    class DebugTextInfo {
        constructor(SrcActor: Actor, SrcActorOffset: Vector, SrcActorDesiredOffset: Vector, DebugText: string, TimeRemaining: number, Duration: number, TextColor: Color, bAbsoluteLocation: boolean, bKeepAttachedToActor: boolean, bDrawShadow: boolean, OrigActorLocation: Vector, Font: Font, FontScale: number);
        SrcActor: Actor;
        SrcActorOffset: Vector;
        SrcActorDesiredOffset: Vector;
        DebugText: string;
        TimeRemaining: number;
        Duration: number;
        TextColor: Color;
        bAbsoluteLocation: boolean;
        bKeepAttachedToActor: boolean;
        bDrawShadow: boolean;
        OrigActorLocation: Vector;
        Font: Font;
        FontScale: number;
    }
    
    class HUD extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerOwner: PlayerController;
        bLostFocusPaused: boolean;
        bShowHUD: boolean;
        bShowDebugInfo: boolean;
        CurrentTargetIndex: number;
        bShowHitBoxDebugInfo: boolean;
        bShowOverlays: boolean;
        bEnableDebugTextShadow: boolean;
        PostRenderedActors: TArray<Actor>;
        DebugDisplay: TArray<string>;
        ToggledDebugCategories: TArray<string>;
        Canvas: Canvas;
        DebugCanvas: Canvas;
        DebugTextList: TArray<DebugTextInfo>;
        ShowDebugTargetDesiredClass: Class;
        ShowDebugTargetActor: Actor;
        ShowHUD(): void;
        ShowDebugToggleSubCategory(Category: string): void;
        ShowDebugForReticleTargetToggle(DesiredClass: Class): void;
        ShowDebug(DebugType: string): void;
        RemoveDebugText(SrcActor: Actor, bLeaveDurationText: boolean): void;
        RemoveAllDebugStrings(): void;
        ReceiveHitBoxRelease(BoxName: string): void;
        ReceiveHitBoxEndCursorOver(BoxName: string): void;
        ReceiveHitBoxClick(BoxName: string): void;
        ReceiveHitBoxBeginCursorOver(BoxName: string): void;
        ReceiveDrawHUD(SizeX: number, SizeY: number): void;
        Project(Location: Vector): Vector;
        PreviousDebugTarget(): void;
        NextDebugTarget(): void;
        GetTextSize(Text: string, OutWidth: $Ref<number>, OutHeight: $Ref<number>, Font: Font, Scale: number): void;
        GetOwningPlayerController(): PlayerController;
        GetOwningPawn(): Pawn;
        GetActorsInSelectionRectangle(ClassFilter: Class, FirstPoint: Vector2D, SecondPoint: Vector2D, OutActors: $Ref<TArray<Actor>>, bIncludeNonCollidingComponents: boolean, bActorMustBeFullyEnclosed: boolean): void;
        DrawTextureSimple(Texture: Texture, ScreenX: number, ScreenY: number, Scale: number, bScalePosition: boolean): void;
        DrawTexture(Texture: Texture, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, TextureU: number, TextureV: number, TextureUWidth: number, TextureVHeight: number, TintColor: LinearColor, BlendMode: number, Scale: number, bScalePosition: boolean, Rotation: number, RotPivot: Vector2D): void;
        DrawText(Text: string, TextColor: LinearColor, ScreenX: number, ScreenY: number, Font: Font, Scale: number, bScalePosition: boolean): void;
        DrawRect(RectColor: LinearColor, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number): void;
        DrawMaterialTriangle(Material: MaterialInterface, V0_Pos: Vector2D, V1_Pos: Vector2D, V2_Pos: Vector2D, V0_UV: Vector2D, V1_UV: Vector2D, V2_UV: Vector2D, V0_Color: LinearColor, V1_Color: LinearColor, V2_Color: LinearColor): void;
        DrawMaterialSimple(Material: MaterialInterface, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, Scale: number, bScalePosition: boolean): void;
        DrawMaterial(Material: MaterialInterface, ScreenX: number, ScreenY: number, ScreenW: number, ScreenH: number, MaterialU: number, MaterialV: number, MaterialUWidth: number, MaterialVHeight: number, Scale: number, bScalePosition: boolean, Rotation: number, RotPivot: Vector2D): void;
        DrawLine(StartScreenX: number, StartScreenY: number, EndScreenX: number, EndScreenY: number, LineColor: LinearColor, LineThickness: number): void;
        Deproject(ScreenX: number, ScreenY: number, WorldPosition: $Ref<Vector>, WorldDirection: $Ref<Vector>): void;
        AddHitBox(Position: Vector2D, Size: Vector2D, InName: string, bConsumesInput: boolean, Priority: number): void;
        AddDebugText(DebugText: string, SrcActor: Actor, Duration: number, Offset: Vector, DesiredOffset: Vector, TextColor: Color, bSkipOverwriteCheck: boolean, bAbsoluteLocation: boolean, bKeepAttachedToActor: boolean, InFont: Font, FontScale: number, bDrawShadow: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HUD;
        static Load(InName: string): HUD;
    }
    
    class TextureCube extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureCube;
        static Load(InName: string): TextureCube;
    }
    
    enum ERayTracingGlobalIlluminationType { Disabled, BruteForce, FinalGather, ERayTracingGlobalIlluminationType_MAX}
    enum EReflectionsType { ScreenSpace, RayTracing, EReflectionsType_MAX}
    enum EReflectedAndRefractedRayTracedShadows { Disabled, Hard_shadows, Area_shadows, EReflectedAndRefractedRayTracedShadows_MAX}
    enum ETranslucencyType { Raster, RayTracing, ETranslucencyType_MAX}
    class WeightedBlendable {
        constructor(Weight: number, Object: Object);
        Weight: number;
        Object: Object;
    }
    
    class WeightedBlendables {
        constructor(Array: TArray<WeightedBlendable>);
        Array: TArray<WeightedBlendable>;
    }
    
    class PostProcessSettings {
        constructor(bOverride_WhiteTemp: boolean, bOverride_WhiteTint: boolean, bOverride_ColorSaturation: boolean, bOverride_ColorContrast: boolean, bOverride_ColorGamma: boolean, bOverride_ColorGain: boolean, bOverride_ColorOffset: boolean, bOverride_ColorSaturationShadows: boolean, bOverride_ColorContrastShadows: boolean, bOverride_ColorGammaShadows: boolean, bOverride_ColorGainShadows: boolean, bOverride_ColorOffsetShadows: boolean, bOverride_ColorSaturationMidtones: boolean, bOverride_ColorContrastMidtones: boolean, bOverride_ColorGammaMidtones: boolean, bOverride_ColorGainMidtones: boolean, bOverride_ColorOffsetMidtones: boolean, bOverride_ColorSaturationHighlights: boolean, bOverride_ColorContrastHighlights: boolean, bOverride_ColorGammaHighlights: boolean, bOverride_ColorGainHighlights: boolean, bOverride_ColorOffsetHighlights: boolean, bOverride_ColorCorrectionShadowsMax: boolean, bOverride_ColorCorrectionHighlightsMin: boolean, bOverride_BlueCorrection: boolean, bOverride_ExpandGamut: boolean, bOverride_FilmWhitePoint: boolean, bOverride_FilmSaturation: boolean, bOverride_FilmChannelMixerRed: boolean, bOverride_FilmChannelMixerGreen: boolean, bOverride_FilmChannelMixerBlue: boolean, bOverride_FilmContrast: boolean, bOverride_FilmDynamicRange: boolean, bOverride_FilmHealAmount: boolean, bOverride_FilmToeAmount: boolean, bOverride_FilmShadowTint: boolean, bOverride_FilmShadowTintBlend: boolean, bOverride_FilmShadowTintAmount: boolean, bOverride_FilmSlope: boolean, bOverride_FilmToe: boolean, bOverride_FilmShoulder: boolean, bOverride_FilmBlackClip: boolean, bOverride_FilmWhiteClip: boolean, bOverride_SceneColorTint: boolean, bOverride_SceneFringeIntensity: boolean, bOverride_ChromaticAberrationStartOffset: boolean, bOverride_AmbientCubemapTint: boolean, bOverride_AmbientCubemapIntensity: boolean, bOverride_BloomMethod: boolean, bOverride_BloomIntensity: boolean, bOverride_BloomThreshold: boolean, bOverride_Bloom1Tint: boolean, bOverride_Bloom1Size: boolean, bOverride_Bloom2Size: boolean, bOverride_Bloom2Tint: boolean, bOverride_Bloom3Tint: boolean, bOverride_Bloom3Size: boolean, bOverride_Bloom4Tint: boolean, bOverride_Bloom4Size: boolean, bOverride_Bloom5Tint: boolean, bOverride_Bloom5Size: boolean, bOverride_Bloom6Tint: boolean, bOverride_Bloom6Size: boolean, bOverride_BloomSizeScale: boolean, bOverride_BloomConvolutionTexture: boolean, bOverride_BloomConvolutionSize: boolean, bOverride_BloomConvolutionCenterUV: boolean, bOverride_BloomConvolutionPreFilter: boolean, bOverride_BloomConvolutionPreFilterMin: boolean, bOverride_BloomConvolutionPreFilterMax: boolean, bOverride_BloomConvolutionPreFilterMult: boolean, bOverride_BloomConvolutionBufferScale: boolean, bOverride_BloomDirtMaskIntensity: boolean, bOverride_BloomDirtMaskTint: boolean, bOverride_BloomDirtMask: boolean, bOverride_CameraShutterSpeed: boolean, bOverride_CameraISO: boolean, bOverride_AutoExposureMethod: boolean, bOverride_AutoExposureLowPercent: boolean, bOverride_AutoExposureHighPercent: boolean, bOverride_AutoExposureMinBrightness: boolean, bOverride_AutoExposureMaxBrightness: boolean, bOverride_AutoExposureCalibrationConstant: boolean, bOverride_AutoExposureSpeedUp: boolean, bOverride_AutoExposureSpeedDown: boolean, bOverride_AutoExposureBias: boolean, bOverride_AutoExposureBiasCurve: boolean, bOverride_HistogramLogMin: boolean, bOverride_HistogramLogMax: boolean, bOverride_LensFlareIntensity: boolean, bOverride_LensFlareTint: boolean, bOverride_LensFlareTints: boolean, bOverride_LensFlareBokehSize: boolean, bOverride_LensFlareBokehShape: boolean, bOverride_LensFlareThreshold: boolean, bOverride_VignetteIntensity: boolean, bOverride_GrainIntensity: boolean, bOverride_GrainJitter: boolean, bOverride_AmbientOcclusionIntensity: boolean, bOverride_AmbientOcclusionStaticFraction: boolean, bOverride_AmbientOcclusionRadius: boolean, bOverride_AmbientOcclusionFadeDistance: boolean, bOverride_AmbientOcclusionFadeRadius: boolean, bOverride_AmbientOcclusionDistance: boolean, bOverride_AmbientOcclusionRadiusInWS: boolean, bOverride_AmbientOcclusionPower: boolean, bOverride_AmbientOcclusionBias: boolean, bOverride_AmbientOcclusionQuality: boolean, bOverride_AmbientOcclusionMipBlend: boolean, bOverride_AmbientOcclusionMipScale: boolean, bOverride_AmbientOcclusionMipThreshold: boolean, bOverride_RayTracingAO: boolean, bOverride_RayTracingAOSamplesPerPixel: boolean, bOverride_LPVIntensity: boolean, bOverride_LPVDirectionalOcclusionIntensity: boolean, bOverride_LPVDirectionalOcclusionRadius: boolean, bOverride_LPVDiffuseOcclusionExponent: boolean, bOverride_LPVSpecularOcclusionExponent: boolean, bOverride_LPVDiffuseOcclusionIntensity: boolean, bOverride_LPVSpecularOcclusionIntensity: boolean, bOverride_LPVSize: boolean, bOverride_LPVSecondaryOcclusionIntensity: boolean, bOverride_LPVSecondaryBounceIntensity: boolean, bOverride_LPVGeometryVolumeBias: boolean, bOverride_LPVVplInjectionBias: boolean, bOverride_LPVEmissiveInjectionIntensity: boolean, bOverride_LPVFadeRange: boolean, bOverride_LPVDirectionalOcclusionFadeRange: boolean, bOverride_IndirectLightingColor: boolean, bOverride_IndirectLightingIntensity: boolean, bOverride_ColorGradingIntensity: boolean, bOverride_ColorGradingLUT: boolean, bOverride_DepthOfFieldFocalDistance: boolean, bOverride_DepthOfFieldFstop: boolean, bOverride_DepthOfFieldMinFstop: boolean, bOverride_DepthOfFieldBladeCount: boolean, bOverride_DepthOfFieldSensorWidth: boolean, bOverride_DepthOfFieldDepthBlurRadius: boolean, bOverride_DepthOfFieldDepthBlurAmount: boolean, bOverride_DepthOfFieldFocalRegion: boolean, bOverride_DepthOfFieldNearTransitionRegion: boolean, bOverride_DepthOfFieldFarTransitionRegion: boolean, bOverride_DepthOfFieldScale: boolean, bOverride_DepthOfFieldNearBlurSize: boolean, bOverride_DepthOfFieldFarBlurSize: boolean, bOverride_MobileHQGaussian: boolean, bOverride_DepthOfFieldOcclusion: boolean, bOverride_DepthOfFieldSkyFocusDistance: boolean, bOverride_DepthOfFieldVignetteSize: boolean, bOverride_MotionBlurAmount: boolean, bOverride_MotionBlurMax: boolean, bOverride_MotionBlurTargetFPS: boolean, bOverride_MotionBlurPerObjectSize: boolean, bOverride_ScreenPercentage: boolean, bOverride_ScreenSpaceReflectionIntensity: boolean, bOverride_ScreenSpaceReflectionQuality: boolean, bOverride_ScreenSpaceReflectionMaxRoughness: boolean, bOverride_ScreenSpaceReflectionRoughnessScale: boolean, bOverride_ReflectionsType: boolean, bOverride_RayTracingReflectionsMaxRoughness: boolean, bOverride_RayTracingReflectionsMaxBounces: boolean, bOverride_RayTracingReflectionsSamplesPerPixel: boolean, bOverride_RayTracingReflectionsShadows: boolean, bOverride_RayTracingReflectionsTranslucency: boolean, bOverride_TranslucencyType: boolean, bOverride_RayTracingTranslucencyMaxRoughness: boolean, bOverride_RayTracingTranslucencyRefractionRays: boolean, bOverride_RayTracingTranslucencySamplesPerPixel: boolean, bOverride_RayTracingTranslucencyShadows: boolean, bOverride_RayTracingTranslucencyRefraction: boolean, bOverride_RayTracingGI: boolean, bOverride_RayTracingGIMaxBounces: boolean, bOverride_RayTracingGISamplesPerPixel: boolean, bOverride_PathTracingMaxBounces: boolean, bOverride_PathTracingSamplesPerPixel: boolean, bMobileHQGaussian: boolean, BloomMethod: number, AutoExposureMethod: number, DepthOfFieldMethod: number, WhiteTemp: number, WhiteTint: number, ColorSaturation: Vector4, ColorContrast: Vector4, ColorGamma: Vector4, ColorGain: Vector4, ColorOffset: Vector4, ColorSaturationShadows: Vector4, ColorContrastShadows: Vector4, ColorGammaShadows: Vector4, ColorGainShadows: Vector4, ColorOffsetShadows: Vector4, ColorSaturationMidtones: Vector4, ColorContrastMidtones: Vector4, ColorGammaMidtones: Vector4, ColorGainMidtones: Vector4, ColorOffsetMidtones: Vector4, ColorSaturationHighlights: Vector4, ColorContrastHighlights: Vector4, ColorGammaHighlights: Vector4, ColorGainHighlights: Vector4, ColorOffsetHighlights: Vector4, ColorCorrectionHighlightsMin: number, ColorCorrectionShadowsMax: number, BlueCorrection: number, ExpandGamut: number, FilmSlope: number, FilmToe: number, FilmShoulder: number, FilmBlackClip: number, FilmWhiteClip: number, FilmWhitePoint: LinearColor, FilmShadowTint: LinearColor, FilmShadowTintBlend: number, FilmShadowTintAmount: number, FilmSaturation: number, FilmChannelMixerRed: LinearColor, FilmChannelMixerGreen: LinearColor, FilmChannelMixerBlue: LinearColor, FilmContrast: number, FilmToeAmount: number, FilmHealAmount: number, FilmDynamicRange: number, SceneColorTint: LinearColor, SceneFringeIntensity: number, ChromaticAberrationStartOffset: number, BloomIntensity: number, BloomThreshold: number, BloomSizeScale: number, Bloom1Size: number, Bloom2Size: number, Bloom3Size: number, Bloom4Size: number, Bloom5Size: number, Bloom6Size: number, Bloom1Tint: LinearColor, Bloom2Tint: LinearColor, Bloom3Tint: LinearColor, Bloom4Tint: LinearColor, Bloom5Tint: LinearColor, Bloom6Tint: LinearColor, BloomConvolutionSize: number, BloomConvolutionTexture: Texture2D, BloomConvolutionCenterUV: Vector2D, BloomConvolutionPreFilter: Vector, BloomConvolutionPreFilterMin: number, BloomConvolutionPreFilterMax: number, BloomConvolutionPreFilterMult: number, BloomConvolutionBufferScale: number, BloomDirtMask: Texture, BloomDirtMaskIntensity: number, BloomDirtMaskTint: LinearColor, AmbientCubemapTint: LinearColor, AmbientCubemapIntensity: number, AmbientCubemap: TextureCube, CameraShutterSpeed: number, CameraISO: number, DepthOfFieldFstop: number, DepthOfFieldMinFstop: number, DepthOfFieldBladeCount: number, AutoExposureBias: number, AutoExposureBiasCurve: CurveFloat, AutoExposureLowPercent: number, AutoExposureHighPercent: number, AutoExposureMinBrightness: number, AutoExposureMaxBrightness: number, AutoExposureSpeedUp: number, AutoExposureSpeedDown: number, HistogramLogMin: number, HistogramLogMax: number, AutoExposureCalibrationConstant: number, LensFlareIntensity: number, LensFlareTint: LinearColor, LensFlareBokehSize: number, LensFlareThreshold: number, LensFlareBokehShape: Texture, LensFlareTints: FixSizeArray<LinearColor>, VignetteIntensity: number, GrainJitter: number, GrainIntensity: number, AmbientOcclusionIntensity: number, AmbientOcclusionStaticFraction: number, AmbientOcclusionRadius: number, AmbientOcclusionRadiusInWS: boolean, AmbientOcclusionFadeDistance: number, AmbientOcclusionFadeRadius: number, AmbientOcclusionDistance: number, AmbientOcclusionPower: number, AmbientOcclusionBias: number, AmbientOcclusionQuality: number, AmbientOcclusionMipBlend: number, AmbientOcclusionMipScale: number, AmbientOcclusionMipThreshold: number, RayTracingAO: boolean, RayTracingAOSamplesPerPixel: number, IndirectLightingColor: LinearColor, IndirectLightingIntensity: number, RayTracingGI: boolean, RayTracingGIType: ERayTracingGlobalIlluminationType, RayTracingGIMaxBounces: number, RayTracingGISamplesPerPixel: number, ColorGradingIntensity: number, ColorGradingLUT: Texture, DepthOfFieldSensorWidth: number, DepthOfFieldFocalDistance: number, DepthOfFieldDepthBlurAmount: number, DepthOfFieldDepthBlurRadius: number, DepthOfFieldFocalRegion: number, DepthOfFieldNearTransitionRegion: number, DepthOfFieldFarTransitionRegion: number, DepthOfFieldScale: number, DepthOfFieldNearBlurSize: number, DepthOfFieldFarBlurSize: number, DepthOfFieldOcclusion: number, DepthOfFieldSkyFocusDistance: number, DepthOfFieldVignetteSize: number, MotionBlurAmount: number, MotionBlurMax: number, MotionBlurTargetFPS: number, MotionBlurPerObjectSize: number, LPVIntensity: number, LPVVplInjectionBias: number, LPVSize: number, LPVSecondaryOcclusionIntensity: number, LPVSecondaryBounceIntensity: number, LPVGeometryVolumeBias: number, LPVEmissiveInjectionIntensity: number, LPVDirectionalOcclusionIntensity: number, LPVDirectionalOcclusionRadius: number, LPVDiffuseOcclusionExponent: number, LPVSpecularOcclusionExponent: number, LPVDiffuseOcclusionIntensity: number, LPVSpecularOcclusionIntensity: number, ReflectionsType: EReflectionsType, ScreenSpaceReflectionIntensity: number, ScreenSpaceReflectionQuality: number, ScreenSpaceReflectionMaxRoughness: number, RayTracingReflectionsMaxRoughness: number, RayTracingReflectionsMaxBounces: number, RayTracingReflectionsSamplesPerPixel: number, RayTracingReflectionsShadows: EReflectedAndRefractedRayTracedShadows, RayTracingReflectionsTranslucency: boolean, TranslucencyType: ETranslucencyType, RayTracingTranslucencyMaxRoughness: number, RayTracingTranslucencyRefractionRays: number, RayTracingTranslucencySamplesPerPixel: number, RayTracingTranslucencyShadows: EReflectedAndRefractedRayTracedShadows, RayTracingTranslucencyRefraction: boolean, PathTracingMaxBounces: number, PathTracingSamplesPerPixel: number, LPVFadeRange: number, LPVDirectionalOcclusionFadeRange: number, ScreenPercentage: number, WeightedBlendables: WeightedBlendables, Blendables: TArray<Object>);
        bOverride_WhiteTemp: boolean;
        bOverride_WhiteTint: boolean;
        bOverride_ColorSaturation: boolean;
        bOverride_ColorContrast: boolean;
        bOverride_ColorGamma: boolean;
        bOverride_ColorGain: boolean;
        bOverride_ColorOffset: boolean;
        bOverride_ColorSaturationShadows: boolean;
        bOverride_ColorContrastShadows: boolean;
        bOverride_ColorGammaShadows: boolean;
        bOverride_ColorGainShadows: boolean;
        bOverride_ColorOffsetShadows: boolean;
        bOverride_ColorSaturationMidtones: boolean;
        bOverride_ColorContrastMidtones: boolean;
        bOverride_ColorGammaMidtones: boolean;
        bOverride_ColorGainMidtones: boolean;
        bOverride_ColorOffsetMidtones: boolean;
        bOverride_ColorSaturationHighlights: boolean;
        bOverride_ColorContrastHighlights: boolean;
        bOverride_ColorGammaHighlights: boolean;
        bOverride_ColorGainHighlights: boolean;
        bOverride_ColorOffsetHighlights: boolean;
        bOverride_ColorCorrectionShadowsMax: boolean;
        bOverride_ColorCorrectionHighlightsMin: boolean;
        bOverride_BlueCorrection: boolean;
        bOverride_ExpandGamut: boolean;
        bOverride_FilmWhitePoint: boolean;
        bOverride_FilmSaturation: boolean;
        bOverride_FilmChannelMixerRed: boolean;
        bOverride_FilmChannelMixerGreen: boolean;
        bOverride_FilmChannelMixerBlue: boolean;
        bOverride_FilmContrast: boolean;
        bOverride_FilmDynamicRange: boolean;
        bOverride_FilmHealAmount: boolean;
        bOverride_FilmToeAmount: boolean;
        bOverride_FilmShadowTint: boolean;
        bOverride_FilmShadowTintBlend: boolean;
        bOverride_FilmShadowTintAmount: boolean;
        bOverride_FilmSlope: boolean;
        bOverride_FilmToe: boolean;
        bOverride_FilmShoulder: boolean;
        bOverride_FilmBlackClip: boolean;
        bOverride_FilmWhiteClip: boolean;
        bOverride_SceneColorTint: boolean;
        bOverride_SceneFringeIntensity: boolean;
        bOverride_ChromaticAberrationStartOffset: boolean;
        bOverride_AmbientCubemapTint: boolean;
        bOverride_AmbientCubemapIntensity: boolean;
        bOverride_BloomMethod: boolean;
        bOverride_BloomIntensity: boolean;
        bOverride_BloomThreshold: boolean;
        bOverride_Bloom1Tint: boolean;
        bOverride_Bloom1Size: boolean;
        bOverride_Bloom2Size: boolean;
        bOverride_Bloom2Tint: boolean;
        bOverride_Bloom3Tint: boolean;
        bOverride_Bloom3Size: boolean;
        bOverride_Bloom4Tint: boolean;
        bOverride_Bloom4Size: boolean;
        bOverride_Bloom5Tint: boolean;
        bOverride_Bloom5Size: boolean;
        bOverride_Bloom6Tint: boolean;
        bOverride_Bloom6Size: boolean;
        bOverride_BloomSizeScale: boolean;
        bOverride_BloomConvolutionTexture: boolean;
        bOverride_BloomConvolutionSize: boolean;
        bOverride_BloomConvolutionCenterUV: boolean;
        bOverride_BloomConvolutionPreFilter: boolean;
        bOverride_BloomConvolutionPreFilterMin: boolean;
        bOverride_BloomConvolutionPreFilterMax: boolean;
        bOverride_BloomConvolutionPreFilterMult: boolean;
        bOverride_BloomConvolutionBufferScale: boolean;
        bOverride_BloomDirtMaskIntensity: boolean;
        bOverride_BloomDirtMaskTint: boolean;
        bOverride_BloomDirtMask: boolean;
        bOverride_CameraShutterSpeed: boolean;
        bOverride_CameraISO: boolean;
        bOverride_AutoExposureMethod: boolean;
        bOverride_AutoExposureLowPercent: boolean;
        bOverride_AutoExposureHighPercent: boolean;
        bOverride_AutoExposureMinBrightness: boolean;
        bOverride_AutoExposureMaxBrightness: boolean;
        bOverride_AutoExposureCalibrationConstant: boolean;
        bOverride_AutoExposureSpeedUp: boolean;
        bOverride_AutoExposureSpeedDown: boolean;
        bOverride_AutoExposureBias: boolean;
        bOverride_AutoExposureBiasCurve: boolean;
        bOverride_HistogramLogMin: boolean;
        bOverride_HistogramLogMax: boolean;
        bOverride_LensFlareIntensity: boolean;
        bOverride_LensFlareTint: boolean;
        bOverride_LensFlareTints: boolean;
        bOverride_LensFlareBokehSize: boolean;
        bOverride_LensFlareBokehShape: boolean;
        bOverride_LensFlareThreshold: boolean;
        bOverride_VignetteIntensity: boolean;
        bOverride_GrainIntensity: boolean;
        bOverride_GrainJitter: boolean;
        bOverride_AmbientOcclusionIntensity: boolean;
        bOverride_AmbientOcclusionStaticFraction: boolean;
        bOverride_AmbientOcclusionRadius: boolean;
        bOverride_AmbientOcclusionFadeDistance: boolean;
        bOverride_AmbientOcclusionFadeRadius: boolean;
        bOverride_AmbientOcclusionDistance: boolean;
        bOverride_AmbientOcclusionRadiusInWS: boolean;
        bOverride_AmbientOcclusionPower: boolean;
        bOverride_AmbientOcclusionBias: boolean;
        bOverride_AmbientOcclusionQuality: boolean;
        bOverride_AmbientOcclusionMipBlend: boolean;
        bOverride_AmbientOcclusionMipScale: boolean;
        bOverride_AmbientOcclusionMipThreshold: boolean;
        bOverride_RayTracingAO: boolean;
        bOverride_RayTracingAOSamplesPerPixel: boolean;
        bOverride_LPVIntensity: boolean;
        bOverride_LPVDirectionalOcclusionIntensity: boolean;
        bOverride_LPVDirectionalOcclusionRadius: boolean;
        bOverride_LPVDiffuseOcclusionExponent: boolean;
        bOverride_LPVSpecularOcclusionExponent: boolean;
        bOverride_LPVDiffuseOcclusionIntensity: boolean;
        bOverride_LPVSpecularOcclusionIntensity: boolean;
        bOverride_LPVSize: boolean;
        bOverride_LPVSecondaryOcclusionIntensity: boolean;
        bOverride_LPVSecondaryBounceIntensity: boolean;
        bOverride_LPVGeometryVolumeBias: boolean;
        bOverride_LPVVplInjectionBias: boolean;
        bOverride_LPVEmissiveInjectionIntensity: boolean;
        bOverride_LPVFadeRange: boolean;
        bOverride_LPVDirectionalOcclusionFadeRange: boolean;
        bOverride_IndirectLightingColor: boolean;
        bOverride_IndirectLightingIntensity: boolean;
        bOverride_ColorGradingIntensity: boolean;
        bOverride_ColorGradingLUT: boolean;
        bOverride_DepthOfFieldFocalDistance: boolean;
        bOverride_DepthOfFieldFstop: boolean;
        bOverride_DepthOfFieldMinFstop: boolean;
        bOverride_DepthOfFieldBladeCount: boolean;
        bOverride_DepthOfFieldSensorWidth: boolean;
        bOverride_DepthOfFieldDepthBlurRadius: boolean;
        bOverride_DepthOfFieldDepthBlurAmount: boolean;
        bOverride_DepthOfFieldFocalRegion: boolean;
        bOverride_DepthOfFieldNearTransitionRegion: boolean;
        bOverride_DepthOfFieldFarTransitionRegion: boolean;
        bOverride_DepthOfFieldScale: boolean;
        bOverride_DepthOfFieldNearBlurSize: boolean;
        bOverride_DepthOfFieldFarBlurSize: boolean;
        bOverride_MobileHQGaussian: boolean;
        bOverride_DepthOfFieldOcclusion: boolean;
        bOverride_DepthOfFieldSkyFocusDistance: boolean;
        bOverride_DepthOfFieldVignetteSize: boolean;
        bOverride_MotionBlurAmount: boolean;
        bOverride_MotionBlurMax: boolean;
        bOverride_MotionBlurTargetFPS: boolean;
        bOverride_MotionBlurPerObjectSize: boolean;
        bOverride_ScreenPercentage: boolean;
        bOverride_ScreenSpaceReflectionIntensity: boolean;
        bOverride_ScreenSpaceReflectionQuality: boolean;
        bOverride_ScreenSpaceReflectionMaxRoughness: boolean;
        bOverride_ScreenSpaceReflectionRoughnessScale: boolean;
        bOverride_ReflectionsType: boolean;
        bOverride_RayTracingReflectionsMaxRoughness: boolean;
        bOverride_RayTracingReflectionsMaxBounces: boolean;
        bOverride_RayTracingReflectionsSamplesPerPixel: boolean;
        bOverride_RayTracingReflectionsShadows: boolean;
        bOverride_RayTracingReflectionsTranslucency: boolean;
        bOverride_TranslucencyType: boolean;
        bOverride_RayTracingTranslucencyMaxRoughness: boolean;
        bOverride_RayTracingTranslucencyRefractionRays: boolean;
        bOverride_RayTracingTranslucencySamplesPerPixel: boolean;
        bOverride_RayTracingTranslucencyShadows: boolean;
        bOverride_RayTracingTranslucencyRefraction: boolean;
        bOverride_RayTracingGI: boolean;
        bOverride_RayTracingGIMaxBounces: boolean;
        bOverride_RayTracingGISamplesPerPixel: boolean;
        bOverride_PathTracingMaxBounces: boolean;
        bOverride_PathTracingSamplesPerPixel: boolean;
        bMobileHQGaussian: boolean;
        BloomMethod: number;
        AutoExposureMethod: number;
        DepthOfFieldMethod: number;
        WhiteTemp: number;
        WhiteTint: number;
        ColorSaturation: Vector4;
        ColorContrast: Vector4;
        ColorGamma: Vector4;
        ColorGain: Vector4;
        ColorOffset: Vector4;
        ColorSaturationShadows: Vector4;
        ColorContrastShadows: Vector4;
        ColorGammaShadows: Vector4;
        ColorGainShadows: Vector4;
        ColorOffsetShadows: Vector4;
        ColorSaturationMidtones: Vector4;
        ColorContrastMidtones: Vector4;
        ColorGammaMidtones: Vector4;
        ColorGainMidtones: Vector4;
        ColorOffsetMidtones: Vector4;
        ColorSaturationHighlights: Vector4;
        ColorContrastHighlights: Vector4;
        ColorGammaHighlights: Vector4;
        ColorGainHighlights: Vector4;
        ColorOffsetHighlights: Vector4;
        ColorCorrectionHighlightsMin: number;
        ColorCorrectionShadowsMax: number;
        BlueCorrection: number;
        ExpandGamut: number;
        FilmSlope: number;
        FilmToe: number;
        FilmShoulder: number;
        FilmBlackClip: number;
        FilmWhiteClip: number;
        FilmWhitePoint: LinearColor;
        FilmShadowTint: LinearColor;
        FilmShadowTintBlend: number;
        FilmShadowTintAmount: number;
        FilmSaturation: number;
        FilmChannelMixerRed: LinearColor;
        FilmChannelMixerGreen: LinearColor;
        FilmChannelMixerBlue: LinearColor;
        FilmContrast: number;
        FilmToeAmount: number;
        FilmHealAmount: number;
        FilmDynamicRange: number;
        SceneColorTint: LinearColor;
        SceneFringeIntensity: number;
        ChromaticAberrationStartOffset: number;
        BloomIntensity: number;
        BloomThreshold: number;
        BloomSizeScale: number;
        Bloom1Size: number;
        Bloom2Size: number;
        Bloom3Size: number;
        Bloom4Size: number;
        Bloom5Size: number;
        Bloom6Size: number;
        Bloom1Tint: LinearColor;
        Bloom2Tint: LinearColor;
        Bloom3Tint: LinearColor;
        Bloom4Tint: LinearColor;
        Bloom5Tint: LinearColor;
        Bloom6Tint: LinearColor;
        BloomConvolutionSize: number;
        BloomConvolutionTexture: Texture2D;
        BloomConvolutionCenterUV: Vector2D;
        BloomConvolutionPreFilter: Vector;
        BloomConvolutionPreFilterMin: number;
        BloomConvolutionPreFilterMax: number;
        BloomConvolutionPreFilterMult: number;
        BloomConvolutionBufferScale: number;
        BloomDirtMask: Texture;
        BloomDirtMaskIntensity: number;
        BloomDirtMaskTint: LinearColor;
        AmbientCubemapTint: LinearColor;
        AmbientCubemapIntensity: number;
        AmbientCubemap: TextureCube;
        CameraShutterSpeed: number;
        CameraISO: number;
        DepthOfFieldFstop: number;
        DepthOfFieldMinFstop: number;
        DepthOfFieldBladeCount: number;
        AutoExposureBias: number;
        AutoExposureBiasCurve: CurveFloat;
        AutoExposureLowPercent: number;
        AutoExposureHighPercent: number;
        AutoExposureMinBrightness: number;
        AutoExposureMaxBrightness: number;
        AutoExposureSpeedUp: number;
        AutoExposureSpeedDown: number;
        HistogramLogMin: number;
        HistogramLogMax: number;
        AutoExposureCalibrationConstant: number;
        LensFlareIntensity: number;
        LensFlareTint: LinearColor;
        LensFlareBokehSize: number;
        LensFlareThreshold: number;
        LensFlareBokehShape: Texture;
        LensFlareTints: FixSizeArray<LinearColor>;
        VignetteIntensity: number;
        GrainJitter: number;
        GrainIntensity: number;
        AmbientOcclusionIntensity: number;
        AmbientOcclusionStaticFraction: number;
        AmbientOcclusionRadius: number;
        AmbientOcclusionRadiusInWS: boolean;
        AmbientOcclusionFadeDistance: number;
        AmbientOcclusionFadeRadius: number;
        AmbientOcclusionDistance: number;
        AmbientOcclusionPower: number;
        AmbientOcclusionBias: number;
        AmbientOcclusionQuality: number;
        AmbientOcclusionMipBlend: number;
        AmbientOcclusionMipScale: number;
        AmbientOcclusionMipThreshold: number;
        RayTracingAO: boolean;
        RayTracingAOSamplesPerPixel: number;
        IndirectLightingColor: LinearColor;
        IndirectLightingIntensity: number;
        RayTracingGI: boolean;
        RayTracingGIType: ERayTracingGlobalIlluminationType;
        RayTracingGIMaxBounces: number;
        RayTracingGISamplesPerPixel: number;
        ColorGradingIntensity: number;
        ColorGradingLUT: Texture;
        DepthOfFieldSensorWidth: number;
        DepthOfFieldFocalDistance: number;
        DepthOfFieldDepthBlurAmount: number;
        DepthOfFieldDepthBlurRadius: number;
        DepthOfFieldFocalRegion: number;
        DepthOfFieldNearTransitionRegion: number;
        DepthOfFieldFarTransitionRegion: number;
        DepthOfFieldScale: number;
        DepthOfFieldNearBlurSize: number;
        DepthOfFieldFarBlurSize: number;
        DepthOfFieldOcclusion: number;
        DepthOfFieldSkyFocusDistance: number;
        DepthOfFieldVignetteSize: number;
        MotionBlurAmount: number;
        MotionBlurMax: number;
        MotionBlurTargetFPS: number;
        MotionBlurPerObjectSize: number;
        LPVIntensity: number;
        LPVVplInjectionBias: number;
        LPVSize: number;
        LPVSecondaryOcclusionIntensity: number;
        LPVSecondaryBounceIntensity: number;
        LPVGeometryVolumeBias: number;
        LPVEmissiveInjectionIntensity: number;
        LPVDirectionalOcclusionIntensity: number;
        LPVDirectionalOcclusionRadius: number;
        LPVDiffuseOcclusionExponent: number;
        LPVSpecularOcclusionExponent: number;
        LPVDiffuseOcclusionIntensity: number;
        LPVSpecularOcclusionIntensity: number;
        ReflectionsType: EReflectionsType;
        ScreenSpaceReflectionIntensity: number;
        ScreenSpaceReflectionQuality: number;
        ScreenSpaceReflectionMaxRoughness: number;
        RayTracingReflectionsMaxRoughness: number;
        RayTracingReflectionsMaxBounces: number;
        RayTracingReflectionsSamplesPerPixel: number;
        RayTracingReflectionsShadows: EReflectedAndRefractedRayTracedShadows;
        RayTracingReflectionsTranslucency: boolean;
        TranslucencyType: ETranslucencyType;
        RayTracingTranslucencyMaxRoughness: number;
        RayTracingTranslucencyRefractionRays: number;
        RayTracingTranslucencySamplesPerPixel: number;
        RayTracingTranslucencyShadows: EReflectedAndRefractedRayTracedShadows;
        RayTracingTranslucencyRefraction: boolean;
        PathTracingMaxBounces: number;
        PathTracingSamplesPerPixel: number;
        LPVFadeRange: number;
        LPVDirectionalOcclusionFadeRange: number;
        ScreenPercentage: number;
        WeightedBlendables: WeightedBlendables;
        Blendables: TArray<Object>;
    }
    
    class MinimalViewInfo {
        constructor(Location: Vector, Rotation: Rotator, FOV: number, DesiredFOV: number, OrthoWidth: number, OrthoNearClipPlane: number, OrthoFarClipPlane: number, AspectRatio: number, bConstrainAspectRatio: boolean, bUseFieldOfViewForLOD: boolean, ProjectionMode: number, PostProcessBlendWeight: number, PostProcessSettings: PostProcessSettings, OffCenterProjectionOffset: Vector2D);
        Location: Vector;
        Rotation: Rotator;
        FOV: number;
        DesiredFOV: number;
        OrthoWidth: number;
        OrthoNearClipPlane: number;
        OrthoFarClipPlane: number;
        AspectRatio: number;
        bConstrainAspectRatio: boolean;
        bUseFieldOfViewForLOD: boolean;
        ProjectionMode: number;
        PostProcessBlendWeight: number;
        PostProcessSettings: PostProcessSettings;
        OffCenterProjectionOffset: Vector2D;
    }
    
    class CameraCacheEntry {
        constructor(TimeStamp: number, POV: MinimalViewInfo);
        TimeStamp: number;
        POV: MinimalViewInfo;
    }
    
    class TViewTarget {
        constructor(Target: Actor, POV: MinimalViewInfo, PlayerState: PlayerState);
        Target: Actor;
        POV: MinimalViewInfo;
        PlayerState: PlayerState;
    }
    
    class CameraModifier extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDebug: boolean;
        bExclusive: boolean;
        Priority: number;
        CameraOwner: PlayerCameraManager;
        AlphaInTime: number;
        AlphaOutTime: number;
        Alpha: number;
        IsDisabled(): boolean;
        GetViewTarget(): Actor;
        EnableModifier(): void;
        DisableModifier(bImmediate: boolean): void;
        BlueprintModifyPostProcess(DeltaTime: number, PostProcessBlendWeight: $Ref<number>, PostProcessSettings: $Ref<PostProcessSettings>): void;
        BlueprintModifyCamera(DeltaTime: number, ViewLocation: Vector, ViewRotation: Rotator, FOV: number, NewViewLocation: $Ref<Vector>, NewViewRotation: $Ref<Rotator>, NewFOV: $Ref<number>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraModifier;
        static Load(InName: string): CameraModifier;
    }
    
    enum EAttachmentRule { KeepRelative, KeepWorld, SnapToTarget, EAttachmentRule_MAX}
    class FXSystemAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPoolSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FXSystemAsset;
        static Load(InName: string): FXSystemAsset;
    }
    
    class FXSystemComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetVectorParameter(ParameterName: string, Param: Vector): void;
        SetUseAutoManageAttachment(bAutoManage: boolean): void;
        SetFloatParameter(ParameterName: string, Param: number): void;
        SetEmitterEnable(EmitterName: string, bNewEnableState: boolean): void;
        SetColorParameter(ParameterName: string, Param: LinearColor): void;
        SetAutoAttachmentParameters(Parent: SceneComponent, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule): void;
        SetActorParameter(ParameterName: string, Param: Actor): void;
        ReleaseToPool(): void;
        GetFXSystemAsset(): FXSystemAsset;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FXSystemComponent;
        static Load(InName: string): FXSystemComponent;
    }
    
    enum EParticleSignificanceLevel { Low, Medium, High, Critical, Num, EParticleSignificanceLevel_MAX}
    class ParticleModule extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSpawnModule: boolean;
        bUpdateModule: boolean;
        bFinalUpdateModule: boolean;
        bUpdateForGPUEmitter: boolean;
        bCurvesAsColor: boolean;
        b3DDrawMode: boolean;
        bSupported3DDrawMode: boolean;
        bEnabled: boolean;
        bEditable: boolean;
        LODDuplicate: boolean;
        bSupportsRandomSeed: boolean;
        bRequiresLoopingNotification: boolean;
        LODValidity: number;
        ModuleEditorColor: Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModule;
        static Load(InName: string): ParticleModule;
    }
    
    class DistributionLookupTable {
        constructor(TimeScale: number, TimeBias: number, Values: TArray<number>, Op: number, EntryCount: number, EntryStride: number, SubEntryStride: number, LockFlag: number);
        TimeScale: number;
        TimeBias: number;
        Values: TArray<number>;
        Op: number;
        EntryCount: number;
        EntryStride: number;
        SubEntryStride: number;
        LockFlag: number;
    }
    
    class RawDistribution {
        constructor(Table: DistributionLookupTable);
        Table: DistributionLookupTable;
    }
    
    class Distribution extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Distribution;
        static Load(InName: string): Distribution;
    }
    
    class DistributionFloat extends Distribution {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanBeBaked: boolean;
        bBakedDataSuccesfully: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloat;
        static Load(InName: string): DistributionFloat;
    }
    
    class RawDistributionFloat extends RawDistribution {
        constructor(MinValue: number, MaxValue: number, Distribution: DistributionFloat);
        MinValue: number;
        MaxValue: number;
        Distribution: DistributionFloat;
    }
    
    class ParticleBurst {
        constructor(Count: number, CountLow: number, Time: number);
        Count: number;
        CountLow: number;
        Time: number;
    }
    
    enum EParticleUVFlipMode { None, FlipUV, FlipUOnly, FlipVOnly, RandomFlipUV, RandomFlipUOnly, RandomFlipVOnly, RandomFlipUVIndependent, EParticleUVFlipMode_MAX}
    class ParticleModuleRequired extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: MaterialInterface;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        EmitterOrigin: Vector;
        EmitterRotation: Rotator;
        ScreenAlignment: number;
        bUseLocalSpace: boolean;
        bKillOnDeactivate: boolean;
        bKillOnCompleted: boolean;
        SortMode: number;
        bUseLegacyEmitterTime: boolean;
        bRemoveHMDRoll: boolean;
        bEmitterDurationUseRange: boolean;
        EmitterDuration: number;
        SpawnRate: RawDistributionFloat;
        BurstList: TArray<ParticleBurst>;
        EmitterDelay: number;
        EmitterDelayLow: number;
        bDelayFirstLoopOnly: boolean;
        InterpolationMethod: number;
        bScaleUV: boolean;
        bEmitterDelayUseRange: boolean;
        ParticleBurstMethod: number;
        bOverrideSystemMacroUV: boolean;
        bUseMaxDrawCount: boolean;
        OpacitySourceMode: number;
        EmitterNormalsMode: number;
        bOrbitModuleAffectsVelocityAlignment: boolean;
        SubImages_Horizontal: number;
        SubImages_Vertical: number;
        RandomImageTime: number;
        RandomImageChanges: number;
        MacroUVPosition: Vector;
        MacroUVRadius: number;
        UVFlippingMode: EParticleUVFlipMode;
        BoundingMode: number;
        bDurationRecalcEachLoop: boolean;
        NormalsSphereCenter: Vector;
        AlphaThreshold: number;
        EmitterLoops: number;
        CutoutTexture: Texture2D;
        MaxDrawCount: number;
        EmitterDurationLow: number;
        NormalsCylinderDirection: Vector;
        NamedMaterialOverrides: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRequired;
        static Load(InName: string): ParticleModuleRequired;
    }
    
    class ParticleModuleTypeDataBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataBase;
        static Load(InName: string): ParticleModuleTypeDataBase;
    }
    
    class ParticleModuleSpawnBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bProcessSpawnRate: boolean;
        bProcessBurstList: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawnBase;
        static Load(InName: string): ParticleModuleSpawnBase;
    }
    
    class ParticleModuleSpawn extends ParticleModuleSpawnBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Rate: RawDistributionFloat;
        RateScale: RawDistributionFloat;
        ParticleBurstMethod: number;
        BurstList: TArray<ParticleBurst>;
        BurstScale: RawDistributionFloat;
        bApplyGlobalSpawnRateScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawn;
        static Load(InName: string): ParticleModuleSpawn;
    }
    
    class ParticleModuleEventBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventBase;
        static Load(InName: string): ParticleModuleEventBase;
    }
    
    class ParticleModuleEventSendToGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventSendToGame;
        static Load(InName: string): ParticleModuleEventSendToGame;
    }
    
    class ParticleEvent_GenerateInfo {
        constructor(Type: number, Frequency: number, ParticleFrequency: number, FirstTimeOnly: boolean, LastTimeOnly: boolean, UseReflectedImpactVector: boolean, bUseOrbitOffset: boolean, CustomName: string, ParticleModuleEventsToSendToGame: TArray<ParticleModuleEventSendToGame>);
        Type: number;
        Frequency: number;
        ParticleFrequency: number;
        FirstTimeOnly: boolean;
        LastTimeOnly: boolean;
        UseReflectedImpactVector: boolean;
        bUseOrbitOffset: boolean;
        CustomName: string;
        ParticleModuleEventsToSendToGame: TArray<ParticleModuleEventSendToGame>;
    }
    
    class ParticleModuleEventGenerator extends ParticleModuleEventBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Events: TArray<ParticleEvent_GenerateInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventGenerator;
        static Load(InName: string): ParticleModuleEventGenerator;
    }
    
    class ParticleModuleOrbitBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseEmitterTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrbitBase;
        static Load(InName: string): ParticleModuleOrbitBase;
    }
    
    class DistributionVector extends Distribution {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanBeBaked: boolean;
        bIsDirty: boolean;
        bBakedDataSuccesfully: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVector;
        static Load(InName: string): DistributionVector;
    }
    
    class RawDistributionVector extends RawDistribution {
        constructor(MinValue: number, MaxValue: number, MinValueVec: Vector, MaxValueVec: Vector, Distribution: DistributionVector);
        MinValue: number;
        MaxValue: number;
        MinValueVec: Vector;
        MaxValueVec: Vector;
        Distribution: DistributionVector;
    }
    
    class OrbitOptions {
        constructor(bProcessDuringSpawn: boolean, bProcessDuringUpdate: boolean, bUseEmitterTime: boolean);
        bProcessDuringSpawn: boolean;
        bProcessDuringUpdate: boolean;
        bUseEmitterTime: boolean;
    }
    
    class ParticleModuleOrbit extends ParticleModuleOrbitBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChainMode: number;
        OffsetAmount: RawDistributionVector;
        OffsetOptions: OrbitOptions;
        RotationAmount: RawDistributionVector;
        RotationOptions: OrbitOptions;
        RotationRateAmount: RawDistributionVector;
        RotationRateOptions: OrbitOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrbit;
        static Load(InName: string): ParticleModuleOrbit;
    }
    
    class ParticleModuleEventReceiverBase extends ParticleModuleEventBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventGeneratorType: number;
        EventName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverBase;
        static Load(InName: string): ParticleModuleEventReceiverBase;
    }
    
    class ParticleLODLevel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Level: number;
        bEnabled: boolean;
        RequiredModule: ParticleModuleRequired;
        Modules: TArray<ParticleModule>;
        TypeDataModule: ParticleModuleTypeDataBase;
        SpawnModule: ParticleModuleSpawn;
        EventGenerator: ParticleModuleEventGenerator;
        SpawningModules: TArray<ParticleModuleSpawnBase>;
        SpawnModules: TArray<ParticleModule>;
        UpdateModules: TArray<ParticleModule>;
        OrbitModules: TArray<ParticleModuleOrbit>;
        EventReceiverModules: TArray<ParticleModuleEventReceiverBase>;
        ConvertedModules: boolean;
        PeakActiveParticles: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleLODLevel;
        static Load(InName: string): ParticleLODLevel;
    }
    
    class ParticleEmitter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        SubUVDataOffset: number;
        EmitterRenderMode: number;
        SignificanceLevel: EParticleSignificanceLevel;
        bUseLegacySpawningBehavior: boolean;
        ConvertedModules: boolean;
        bIsSoloing: boolean;
        bCookedOut: boolean;
        bDisabledLODsKeepEmitterAlive: boolean;
        bDisableWhenInsignficant: boolean;
        bCollapsed: boolean;
        DetailMode: number;
        EmitterEditorColor: Color;
        LODLevels: TArray<ParticleLODLevel>;
        PeakActiveParticles: number;
        InitialAllocationCount: number;
        QualityLevelSpawnRateScale: number;
        DetailModeBitmask: number;
        DetailModeDisplay: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleEmitter;
        static Load(InName: string): ParticleEmitter;
    }
    
    class CurveEdEntry {
        constructor(CurveObject: Object, CurveColor: Color, CurveName: string, bHideCurve: number, bColorCurve: number, bFloatingPointColorCurve: number, bClamp: number, ClampLow: number, ClampHigh: number);
        CurveObject: Object;
        CurveColor: Color;
        CurveName: string;
        bHideCurve: number;
        bColorCurve: number;
        bFloatingPointColorCurve: number;
        bClamp: number;
        ClampLow: number;
        ClampHigh: number;
    }
    
    class CurveEdTab {
        constructor(TabName: string, Curves: TArray<CurveEdEntry>, ViewStartInput: number, ViewEndInput: number, ViewStartOutput: number, ViewEndOutput: number);
        TabName: string;
        Curves: TArray<CurveEdEntry>;
        ViewStartInput: number;
        ViewEndInput: number;
        ViewStartOutput: number;
        ViewEndOutput: number;
    }
    
    class InterpCurveEdSetup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tabs: TArray<CurveEdTab>;
        ActiveTab: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpCurveEdSetup;
        static Load(InName: string): InterpCurveEdSetup;
    }
    
    class ParticleSystemLOD {
        constructor();
    }
    
    enum EParticleSystemInsignificanceReaction { Auto, Complete, DisableTick, DisableTickAndKill, Num, EParticleSystemInsignificanceReaction_MAX}
    class LODSoloTrack {
        constructor(SoloEnableSetting: TArray<number>);
        SoloEnableSetting: TArray<number>;
    }
    
    class NamedEmitterMaterial {
        constructor(Name: string, Material: MaterialInterface);
        Name: string;
        Material: MaterialInterface;
    }
    
    class ParticleSystem extends FXSystemAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateTime_FPS: number;
        UpdateTime_Delta: number;
        WarmupTime: number;
        WarmupTickRate: number;
        Emitters: TArray<ParticleEmitter>;
        PreviewComponent: ParticleSystemComponent;
        ThumbnailAngle: Rotator;
        ThumbnailDistance: number;
        ThumbnailWarmup: number;
        CurveEdSetup: InterpCurveEdSetup;
        LODDistanceCheckTime: number;
        MacroUVRadius: number;
        LODDistances: TArray<number>;
        EditorLODSetting: number;
        LODSettings: TArray<ParticleSystemLOD>;
        FixedRelativeBoundingBox: Box;
        SecondsBeforeInactive: number;
        FloorMesh: string;
        FloorPosition: Vector;
        FloorRotation: Rotator;
        FloorScale: number;
        FloorScale3D: Vector;
        BackgroundColor: Color;
        Delay: number;
        DelayLow: number;
        bOrientZAxisTowardCamera: boolean;
        bUseFixedRelativeBoundingBox: boolean;
        bShouldResetPeakCounts: boolean;
        bHasPhysics: boolean;
        bUseRealtimeThumbnail: boolean;
        ThumbnailImageOutOfDate: boolean;
        ThumbnailImage: Texture2D;
        bUseDelayRange: boolean;
        bAllowManagedTicking: boolean;
        bAutoDeactivate: boolean;
        bRegenerateLODDuplicate: boolean;
        SystemUpdateMode: number;
        LODMethod: number;
        InsignificantReaction: EParticleSystemInsignificanceReaction;
        OcclusionBoundsMethod: number;
        MaxSignificanceLevel: EParticleSignificanceLevel;
        MinTimeBetweenTicks: number;
        InsignificanceDelay: number;
        MacroUVPosition: Vector;
        CustomOcclusionBounds: Box;
        SoloTracking: TArray<LODSoloTrack>;
        NamedMaterialSlots: TArray<NamedEmitterMaterial>;
        ContainsEmitterType(TypeData: Class): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystem;
        static Load(InName: string): ParticleSystem;
    }
    
    class ParticleSysParam {
        constructor(Name: string, ParamType: number, Scalar: number, Scalar_Low: number, Vector: Vector, Vector_Low: Vector, Color: Color, Actor: Actor, Material: MaterialInterface);
        Name: string;
        ParamType: number;
        Scalar: number;
        Scalar_Low: number;
        Vector: Vector;
        Vector_Low: Vector;
        Color: Color;
        Actor: Actor;
        Material: MaterialInterface;
    }
    
    class ParticleSystemReplay extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClipIDNumber: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemReplay;
        static Load(InName: string): ParticleSystemReplay;
    }
    
    class ParticleSystemComponent extends FXSystemComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Template: ParticleSystem;
        EmitterMaterials: TArray<MaterialInterface>;
        SkelMeshComponents: TArray<SkeletalMeshComponent>;
        bResetOnDetach: boolean;
        bUpdateOnDedicatedServer: boolean;
        bAllowRecycling: boolean;
        bAutoManageAttachment: boolean;
        bWarmingUp: boolean;
        bOverrideLODMethod: boolean;
        bSkipUpdateDynamicDataDuringTick: boolean;
        LODMethod: number;
        RequiredSignificance: EParticleSignificanceLevel;
        InstanceParameters: TArray<ParticleSysParam>;
        OnParticleSpawn: $MulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
        OnParticleBurst: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
        OnParticleDeath: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
        OnParticleCollide: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
        OldPosition: Vector;
        PartSysVelocity: Vector;
        WarmupTime: number;
        WarmupTickRate: number;
        SecondsBeforeInactive: number;
        MaxTimeBeforeForceUpdateTransform: number;
        EditorLODLevel: number;
        EditorDetailMode: number;
        ReplayClips: TArray<ParticleSystemReplay>;
        CustomTimeDilation: number;
        AutoAttachParent: TWeakObjectPtr<SceneComponent>;
        AutoAttachSocketName: string;
        AutoAttachLocationType: number;
        AutoAttachLocationRule: EAttachmentRule;
        AutoAttachRotationRule: EAttachmentRule;
        AutoAttachScaleRule: EAttachmentRule;
        OnSystemFinished: $MulticastDelegate<(PSystem: ParticleSystemComponent) => void>;
        SetTrailSourceData(InFirstSocketName: string, InSecondSocketName: string, InWidthMode: number, InWidth: number): void;
        SetTemplate(NewTemplate: ParticleSystem): void;
        SetMaterialParameter(ParameterName: string, Param: MaterialInterface): void;
        SetBeamTargetTangent(EmitterIndex: number, NewTangentPoint: Vector, TargetIndex: number): void;
        SetBeamTargetStrength(EmitterIndex: number, NewTargetStrength: number, TargetIndex: number): void;
        SetBeamTargetPoint(EmitterIndex: number, NewTargetPoint: Vector, TargetIndex: number): void;
        SetBeamSourceTangent(EmitterIndex: number, NewTangentPoint: Vector, SourceIndex: number): void;
        SetBeamSourceStrength(EmitterIndex: number, NewSourceStrength: number, SourceIndex: number): void;
        SetBeamSourcePoint(EmitterIndex: number, NewSourcePoint: Vector, SourceIndex: number): void;
        SetBeamEndPoint(EmitterIndex: number, NewEndPoint: Vector): void;
        SetAutoAttachParams(Parent: SceneComponent, SocketName: string, LocationType: number): void;
        GetNumActiveParticles(): number;
        GetNamedMaterial(InName: string): MaterialInterface;
        GetBeamTargetTangent(EmitterIndex: number, TargetIndex: number, OutTangentPoint: $Ref<Vector>): boolean;
        GetBeamTargetStrength(EmitterIndex: number, TargetIndex: number, OutTargetStrength: $Ref<number>): boolean;
        GetBeamTargetPoint(EmitterIndex: number, TargetIndex: number, OutTargetPoint: $Ref<Vector>): boolean;
        GetBeamSourceTangent(EmitterIndex: number, SourceIndex: number, OutTangentPoint: $Ref<Vector>): boolean;
        GetBeamSourceStrength(EmitterIndex: number, SourceIndex: number, OutSourceStrength: $Ref<number>): boolean;
        GetBeamSourcePoint(EmitterIndex: number, SourceIndex: number, OutSourcePoint: $Ref<Vector>): boolean;
        GetBeamEndPoint(EmitterIndex: number, OutEndPoint: $Ref<Vector>): boolean;
        GenerateParticleEvent(InEventName: string, InEmitterTime: number, InLocation: Vector, InDirection: Vector, InVelocity: Vector): void;
        EndTrails(): void;
        CreateNamedDynamicMaterialInstance(InName: string, SourceMaterial: MaterialInterface): MaterialInstanceDynamic;
        BeginTrails(InFirstSocketName: string, InSecondSocketName: string, InWidthMode: number, InWidth: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemComponent;
        static Load(InName: string): ParticleSystemComponent;
    }
    
    class Emitter extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParticleSystemComponent: ParticleSystemComponent;
        bDestroyOnSystemFinish: boolean;
        bPostUpdateTickGroup: boolean;
        bCurrentlyActive: boolean;
        OnParticleSpawn: $MulticastDelegate<(EventName: string, EmitterTime: number, Location: Vector, Velocity: Vector) => void>;
        OnParticleBurst: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleCount: number) => void>;
        OnParticleDeath: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector) => void>;
        OnParticleCollide: $MulticastDelegate<(EventName: string, EmitterTime: number, ParticleTime: number, Location: Vector, Velocity: Vector, Direction: Vector, Normal: Vector, BoneName: string, PhysMat: PhysicalMaterial) => void>;
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;
        ToggleActive(): void;
        SetVectorParameter(ParameterName: string, Param: Vector): void;
        SetTemplate(NewTemplate: ParticleSystem): void;
        SetMaterialParameter(ParameterName: string, Param: MaterialInterface): void;
        SetFloatParameter(ParameterName: string, Param: number): void;
        SetColorParameter(ParameterName: string, Param: LinearColor): void;
        SetActorParameter(ParameterName: string, Param: Actor): void;
        OnRep_bCurrentlyActive(): void;
        OnParticleSystemFinished(FinishedComponent: ParticleSystemComponent): void;
        IsActive(): boolean;
        Deactivate(): void;
        Activate(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Emitter;
        static Load(InName: string): Emitter;
    }
    
    class EmitterCameraLensEffectBase extends Emitter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PS_CameraEffect: ParticleSystem;
        PS_CameraEffectNonExtremeContent: ParticleSystem;
        BaseCamera: PlayerCameraManager;
        RelativeTransform: Transform;
        BaseFOV: number;
        bAllowMultipleInstances: boolean;
        bResetWhenRetriggered: boolean;
        EmittersToTreatAsSame: TArray<Class>;
        DistFromCamera: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EmitterCameraLensEffectBase;
        static Load(InName: string): EmitterCameraLensEffectBase;
    }
    
    enum EOscillatorWaveform { SineWave, PerlinNoise, EOscillatorWaveform_MAX}
    class FOscillator {
        constructor(Amplitude: number, Frequency: number, InitialOffset: number, Waveform: EOscillatorWaveform);
        Amplitude: number;
        Frequency: number;
        InitialOffset: number;
        Waveform: EOscillatorWaveform;
    }
    
    class ROscillator {
        constructor(Pitch: FOscillator, Yaw: FOscillator, Roll: FOscillator);
        Pitch: FOscillator;
        Yaw: FOscillator;
        Roll: FOscillator;
    }
    
    class VOscillator {
        constructor(X: FOscillator, Y: FOscillator, Z: FOscillator);
        X: FOscillator;
        Y: FOscillator;
        Z: FOscillator;
    }
    
    class SubTrackGroup {
        constructor(GroupName: string, TrackIndices: TArray<number>, bIsCollapsed: boolean, bIsSelected: boolean);
        GroupName: string;
        TrackIndices: TArray<number>;
        bIsCollapsed: boolean;
        bIsSelected: boolean;
    }
    
    class SupportedSubTrackInfo {
        constructor(SupportedClass: Class, SubTrackName: string, GroupIndex: number);
        SupportedClass: Class;
        SubTrackName: string;
        GroupIndex: number;
    }
    
    class InterpTrack extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SubTracks: TArray<InterpTrack>;
        SubTrackGroups: TArray<SubTrackGroup>;
        SupportedSubTracks: TArray<SupportedSubTrackInfo>;
        TrackInstClass: Class;
        ActiveCondition: number;
        TrackTitle: string;
        bOnePerGroup: boolean;
        bDirGroupOnly: boolean;
        bDisableTrack: boolean;
        bIsSelected: boolean;
        TrackIcon: Texture2D;
        bIsAnimControlTrack: boolean;
        bSubTrackOnly: boolean;
        bVisible: boolean;
        bIsRecording: boolean;
        bIsCollapsed: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrack;
        static Load(InName: string): InterpTrack;
    }
    
    class InterpGroup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InterpTracks: TArray<InterpTrack>;
        GroupName: string;
        GroupColor: Color;
        bCollapsed: boolean;
        bVisible: boolean;
        bIsFolder: boolean;
        bIsParented: boolean;
        bIsSelected: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroup;
        static Load(InName: string): InterpGroup;
    }
    
    class CameraAnim extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraInterpGroup: InterpGroup;
        PreviewInterpGroup: InterpGroup;
        AnimLength: number;
        BoundingBox: Box;
        bRelativeToInitialTransform: boolean;
        bRelativeToInitialFOV: boolean;
        BaseFOV: number;
        BasePostProcessSettings: PostProcessSettings;
        BasePostProcessBlendWeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraAnim;
        static Load(InName: string): CameraAnim;
    }
    
    class InterpGroupInst extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Group: InterpGroup;
        GroupActor: Actor;
        TrackInst: TArray<InterpTrackInst>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupInst;
        static Load(InName: string): InterpGroupInst;
    }
    
    class InterpCurvePointVector {
        constructor(InVal: number, OutVal: Vector, ArriveTangent: Vector, LeaveTangent: Vector, InterpMode: number);
        InVal: number;
        OutVal: Vector;
        ArriveTangent: Vector;
        LeaveTangent: Vector;
        InterpMode: number;
    }
    
    class InterpCurveVector {
        constructor(Points: TArray<InterpCurvePointVector>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<InterpCurvePointVector>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
    }
    
    class InterpLookupPoint {
        constructor(GroupName: string, Time: number);
        GroupName: string;
        Time: number;
    }
    
    class InterpLookupTrack {
        constructor(Points: TArray<InterpLookupPoint>);
        Points: TArray<InterpLookupPoint>;
    }
    
    class InterpTrackMove extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PosTrack: InterpCurveVector;
        EulerTrack: InterpCurveVector;
        LookupTrack: InterpLookupTrack;
        LookAtGroupName: string;
        LinCurveTension: number;
        AngCurveTension: number;
        bUseQuatInterpolation: boolean;
        bShowArrowAtKeys: boolean;
        bDisableMovement: boolean;
        bShowTranslationOnCurveEd: boolean;
        bShowRotationOnCurveEd: boolean;
        bHide3DTrack: boolean;
        RotMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackMove;
        static Load(InName: string): InterpTrackMove;
    }
    
    class InterpTrackInstMove extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetLocation: Vector;
        ResetRotation: Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstMove;
        static Load(InName: string): InterpTrackInstMove;
    }
    
    class CameraAnimInst extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CamAnim: CameraAnim;
        InterpGroupInst: InterpGroupInst;
        PlayRate: number;
        MoveTrack: InterpTrackMove;
        MoveInst: InterpTrackInstMove;
        PlaySpace: number;
        Stop(bImmediate: boolean): void;
        SetScale(NewDuration: number): void;
        SetDuration(NewDuration: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraAnimInst;
        static Load(InName: string): CameraAnimInst;
    }
    
    class CameraShake extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSingleInstance: boolean;
        OscillationDuration: number;
        OscillationBlendInTime: number;
        OscillationBlendOutTime: number;
        RotOscillation: ROscillator;
        LocOscillation: VOscillator;
        FOVOscillation: FOscillator;
        AnimPlayRate: number;
        AnimScale: number;
        AnimBlendInTime: number;
        AnimBlendOutTime: number;
        RandomAnimSegmentDuration: number;
        Anim: CameraAnim;
        bRandomAnimSegment: boolean;
        CameraOwner: PlayerCameraManager;
        ShakeScale: number;
        OscillatorTimeRemaining: number;
        AnimInst: CameraAnimInst;
        ReceiveStopShake(bImmediately: boolean): void;
        ReceivePlayShake(Scale: number): void;
        ReceiveIsFinished(): boolean;
        BlueprintUpdateCameraShake(DeltaTime: number, Alpha: number, POV: MinimalViewInfo, ModifiedPOV: $Ref<MinimalViewInfo>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraShake;
        static Load(InName: string): CameraShake;
    }
    
    class PooledCameraShakes {
        constructor(PooledShakes: TArray<CameraShake>);
        PooledShakes: TArray<CameraShake>;
    }
    
    class CameraModifier_CameraShake extends CameraModifier {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveShakes: TArray<CameraShake>;
        ExpiredPooledShakesMap: TMap<Class, PooledCameraShakes>;
        SplitScreenShakeScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraModifier_CameraShake;
        static Load(InName: string): CameraModifier_CameraShake;
    }
    
    class MeshBuildSettings {
        constructor(bUseMikkTSpace: boolean, bRecomputeNormals: boolean, bRecomputeTangents: boolean, bComputeWeightedNormals: boolean, bRemoveDegenerates: boolean, bBuildAdjacencyBuffer: boolean, bBuildReversedIndexBuffer: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bGenerateLightmapUVs: boolean, bGenerateDistanceFieldAsIfTwoSided: boolean, MinLightmapResolution: number, SrcLightmapIndex: number, DstLightmapIndex: number, BuildScale: number, BuildScale3D: Vector, DistanceFieldResolutionScale: number, DistanceFieldBias: number, DistanceFieldReplacementMesh: StaticMesh);
        bUseMikkTSpace: boolean;
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bComputeWeightedNormals: boolean;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bGenerateLightmapUVs: boolean;
        bGenerateDistanceFieldAsIfTwoSided: boolean;
        MinLightmapResolution: number;
        SrcLightmapIndex: number;
        DstLightmapIndex: number;
        BuildScale: number;
        BuildScale3D: Vector;
        DistanceFieldResolutionScale: number;
        DistanceFieldBias: number;
        DistanceFieldReplacementMesh: StaticMesh;
    }
    
    enum EStaticMeshReductionTerimationCriterion { Triangles, Vertices, Any, EStaticMeshReductionTerimationCriterion_MAX}
    class MeshReductionSettings {
        constructor(PercentTriangles: number, PercentVertices: number, MaxDeviation: number, PixelError: number, WeldingThreshold: number, HardAngleThreshold: number, BaseLODModel: number, SilhouetteImportance: number, TextureImportance: number, ShadingImportance: number, bRecalculateNormals: boolean, bGenerateUniqueLightmapUVs: boolean, bKeepSymmetry: boolean, bVisibilityAided: boolean, bCullOccluded: boolean, TerminationCriterion: EStaticMeshReductionTerimationCriterion, VisibilityAggressiveness: number, VertexColorImportance: number);
        PercentTriangles: number;
        PercentVertices: number;
        MaxDeviation: number;
        PixelError: number;
        WeldingThreshold: number;
        HardAngleThreshold: number;
        BaseLODModel: number;
        SilhouetteImportance: number;
        TextureImportance: number;
        ShadingImportance: number;
        bRecalculateNormals: boolean;
        bGenerateUniqueLightmapUVs: boolean;
        bKeepSymmetry: boolean;
        bVisibilityAided: boolean;
        bCullOccluded: boolean;
        TerminationCriterion: EStaticMeshReductionTerimationCriterion;
        VisibilityAggressiveness: number;
        VertexColorImportance: number;
    }
    
    class StaticMeshSourceModel {
        constructor(BuildSettings: MeshBuildSettings, ReductionSettings: MeshReductionSettings, LODDistance: number, ScreenSize: PerPlatformFloat, SourceImportFilename: string, bImportWithBaseMesh: boolean);
        BuildSettings: MeshBuildSettings;
        ReductionSettings: MeshReductionSettings;
        LODDistance: number;
        ScreenSize: PerPlatformFloat;
        SourceImportFilename: string;
        bImportWithBaseMesh: boolean;
    }
    
    class MeshSectionInfo {
        constructor(MaterialIndex: number, bEnableCollision: boolean, bCastShadow: boolean);
        MaterialIndex: number;
        bEnableCollision: boolean;
        bCastShadow: boolean;
    }
    
    class MeshSectionInfoMap {
        constructor(Map: TMap<number, MeshSectionInfo>);
        Map: TMap<number, MeshSectionInfo>;
    }
    
    class MaterialRemapIndex {
        constructor(ImportVersionKey: number, MaterialRemap: TArray<number>);
        ImportVersionKey: number;
        MaterialRemap: TArray<number>;
    }
    
    class StaticMaterial {
        constructor(MaterialInterface: MaterialInterface, MaterialSlotName: string, ImportedMaterialSlotName: string, UVChannelData: MeshUVChannelInfo);
        MaterialInterface: MaterialInterface;
        MaterialSlotName: string;
        ImportedMaterialSlotName: string;
        UVChannelData: MeshUVChannelInfo;
    }
    
    class AssetEditorOrbitCameraPosition {
        constructor(bIsSet: boolean, CamOrbitPoint: Vector, CamOrbitZoom: Vector, CamOrbitRotation: Rotator);
        bIsSet: boolean;
        CamOrbitPoint: Vector;
        CamOrbitZoom: Vector;
        CamOrbitRotation: Rotator;
    }
    
    class StaticMeshSocket extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SocketName: string;
        RelativeLocation: Vector;
        RelativeRotation: Rotator;
        RelativeScale: Vector;
        Tag: string;
        PreviewStaticMesh: StaticMesh;
        bSocketCreatedAtImport: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshSocket;
        static Load(InName: string): StaticMeshSocket;
    }
    
    class NavCollisionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsDynamicObstacle: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavCollisionBase;
        static Load(InName: string): NavCollisionBase;
    }
    
    class ElementID {
        constructor(IDValue: number);
        IDValue: number;
    }
    
    class VertexID extends ElementID {
        constructor();
    }
    
    class PolygonID extends ElementID {
        constructor();
    }
    
    class VertexInstanceID extends ElementID {
        constructor();
    }
    
    class PolygonGroupID extends ElementID {
        constructor();
    }
    
    class TriangleID extends ElementID {
        constructor();
    }
    
    class EdgeID extends ElementID {
        constructor();
    }
    
    class MeshDescriptionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetVertexPosition(VertexID: VertexID, Position: Vector): void;
        SetPolygonVertexInstance(PolygonID: PolygonID, PerimeterIndex: number, VertexInstanceID: VertexInstanceID): void;
        SetPolygonPolygonGroup(PolygonID: PolygonID, PolygonGroupID: PolygonGroupID): void;
        ReversePolygonFacing(PolygonID: PolygonID): void;
        ReserveNewVertices(NumberOfNewVertices: number): void;
        ReserveNewVertexInstances(NumberOfNewVertexInstances: number): void;
        ReserveNewTriangles(NumberOfNewTriangles: number): void;
        ReserveNewPolygons(NumberOfNewPolygons: number): void;
        ReserveNewPolygonGroups(NumberOfNewPolygonGroups: number): void;
        ReserveNewEdges(NumberOfNewEdges: number): void;
        IsVertexValid(VertexID: VertexID): boolean;
        IsVertexOrphaned(VertexID: VertexID): boolean;
        IsVertexInstanceValid(VertexInstanceID: VertexInstanceID): boolean;
        IsTriangleValid(TriangleID: TriangleID): boolean;
        IsTrianglePartOfNgon(TriangleID: TriangleID): boolean;
        IsPolygonValid(PolygonID: PolygonID): boolean;
        IsPolygonGroupValid(PolygonGroupID: PolygonGroupID): boolean;
        IsEmpty(): boolean;
        IsEdgeValid(EdgeID: EdgeID): boolean;
        IsEdgeInternalToPolygon(EdgeID: EdgeID, PolygonID: PolygonID): boolean;
        IsEdgeInternal(EdgeID: EdgeID): boolean;
        GetVertexVertexInstances(VertexID: VertexID, OutVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;
        GetVertexPosition(VertexID: VertexID): Vector;
        GetVertexPairEdge(VertexID0: VertexID, VertexID1: VertexID): EdgeID;
        GetVertexInstanceVertex(VertexInstanceID: VertexInstanceID): VertexID;
        GetVertexInstancePairEdge(VertexInstanceID0: VertexInstanceID, VertexInstanceID1: VertexInstanceID): EdgeID;
        GetVertexInstanceForTriangleVertex(TriangleID: TriangleID, VertexID: VertexID): VertexInstanceID;
        GetVertexInstanceForPolygonVertex(PolygonID: PolygonID, VertexID: VertexID): VertexInstanceID;
        GetVertexInstanceConnectedTriangles(VertexInstanceID: VertexInstanceID, OutConnectedTriangleIDs: $Ref<TArray<TriangleID>>): void;
        GetVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetVertexConnectedTriangles(VertexID: VertexID, OutConnectedTriangleIDs: $Ref<TArray<TriangleID>>): void;
        GetVertexConnectedPolygons(VertexID: VertexID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetVertexConnectedEdges(VertexID: VertexID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;
        GetVertexAdjacentVertices(VertexID: VertexID, OutAdjacentVertexIDs: $Ref<TArray<VertexID>>): void;
        GetTriangleVertices(TriangleID: TriangleID, OutVertexIDs: $Ref<TArray<VertexID>>): void;
        GetTriangleVertexInstances(TriangleID: TriangleID, OutVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;
        GetTriangleVertexInstance(TriangleID: TriangleID, Index: number): VertexInstanceID;
        GetTrianglePolygonGroup(TriangleID: TriangleID): PolygonGroupID;
        GetTrianglePolygon(TriangleID: TriangleID): PolygonID;
        GetTriangleEdges(TriangleID: TriangleID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;
        GetTriangleAdjacentTriangles(TriangleID: TriangleID, OutTriangleIDs: $Ref<TArray<TriangleID>>): void;
        GetPolygonVertices(PolygonID: PolygonID, OutVertexIDs: $Ref<TArray<VertexID>>): void;
        GetPolygonVertexInstances(PolygonID: PolygonID, OutVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;
        GetPolygonTriangles(PolygonID: PolygonID, OutTriangleIDs: $Ref<TArray<TriangleID>>): void;
        GetPolygonPolygonGroup(PolygonID: PolygonID): PolygonGroupID;
        GetPolygonPerimeterEdges(PolygonID: PolygonID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;
        GetPolygonInternalEdges(PolygonID: PolygonID, OutEdgeIDs: $Ref<TArray<EdgeID>>): void;
        GetPolygonGroupPolygons(PolygonGroupID: PolygonGroupID, OutPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetPolygonAdjacentPolygons(PolygonID: PolygonID, OutPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetNumVertexVertexInstances(VertexID: VertexID): number;
        GetNumVertexInstanceConnectedTriangles(VertexInstanceID: VertexInstanceID): number;
        GetNumVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID): number;
        GetNumVertexConnectedTriangles(VertexID: VertexID): number;
        GetNumVertexConnectedPolygons(VertexID: VertexID): number;
        GetNumVertexConnectedEdges(VertexID: VertexID): number;
        GetNumPolygonVertices(PolygonID: PolygonID): number;
        GetNumPolygonTriangles(PolygonID: PolygonID): number;
        GetNumPolygonInternalEdges(PolygonID: PolygonID): number;
        GetNumPolygonGroupPolygons(PolygonGroupID: PolygonGroupID): number;
        GetNumEdgeConnectedTriangles(EdgeID: EdgeID): number;
        GetNumEdgeConnectedPolygons(EdgeID: EdgeID): number;
        GetEdgeVertices(EdgeID: EdgeID, OutVertexIDs: $Ref<TArray<VertexID>>): void;
        GetEdgeVertex(EdgeID: EdgeID, VertexNumber: number): VertexID;
        GetEdgeConnectedTriangles(EdgeID: EdgeID, OutConnectedTriangleIDs: $Ref<TArray<TriangleID>>): void;
        GetEdgeConnectedPolygons(EdgeID: EdgeID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;
        Empty(): void;
        DeleteVertexInstance(VertexInstanceID: VertexInstanceID, OrphanedVertices: $Ref<TArray<VertexID>>): void;
        DeleteVertex(VertexID: VertexID): void;
        DeleteTriangle(TriangleID: TriangleID, OrphanedEdges: $Ref<TArray<EdgeID>>, OrphanedVertexInstances: $Ref<TArray<VertexInstanceID>>, OrphanedPolygonGroupsPtr: $Ref<TArray<PolygonGroupID>>): void;
        DeletePolygonGroup(PolygonGroupID: PolygonGroupID): void;
        DeletePolygon(PolygonID: PolygonID, OrphanedEdges: $Ref<TArray<EdgeID>>, OrphanedVertexInstances: $Ref<TArray<VertexInstanceID>>, OrphanedPolygonGroups: $Ref<TArray<PolygonGroupID>>): void;
        DeleteEdge(EdgeID: EdgeID, OrphanedVertices: $Ref<TArray<VertexID>>): void;
        CreateVertexWithID(VertexID: VertexID): void;
        CreateVertexInstanceWithID(VertexInstanceID: VertexInstanceID, VertexID: VertexID): void;
        CreateVertexInstance(VertexID: VertexID): VertexInstanceID;
        CreateVertex(): VertexID;
        CreateTriangleWithID(TriangleID: TriangleID, PolygonGroupID: PolygonGroupID, VertexInstanceIDs: TArray<VertexInstanceID>, NewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        CreateTriangle(PolygonGroupID: PolygonGroupID, VertexInstanceIDs: TArray<VertexInstanceID>, NewEdgeIDs: $Ref<TArray<EdgeID>>): TriangleID;
        CreatePolygonWithID(PolygonID: PolygonID, PolygonGroupID: PolygonGroupID, VertexInstanceIDs: $Ref<TArray<VertexInstanceID>>, NewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        CreatePolygonGroupWithID(PolygonGroupID: PolygonGroupID): void;
        CreatePolygonGroup(): PolygonGroupID;
        CreatePolygon(PolygonGroupID: PolygonGroupID, VertexInstanceIDs: $Ref<TArray<VertexInstanceID>>, NewEdgeIDs: $Ref<TArray<EdgeID>>): PolygonID;
        CreateEdgeWithID(EdgeID: EdgeID, VertexID0: VertexID, VertexID1: VertexID): void;
        CreateEdge(VertexID0: VertexID, VertexID1: VertexID): EdgeID;
        ComputePolygonTriangulation(PolygonID: PolygonID): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshDescriptionBase;
        static Load(InName: string): MeshDescriptionBase;
    }
    
    class StaticMeshDescription extends MeshDescriptionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetVertexInstanceUV(VertexInstanceID: VertexInstanceID, UV: Vector2D, UVIndex: number): void;
        SetPolygonGroupMaterialSlotName(PolygonGroupID: PolygonGroupID, SlotName: string): void;
        GetVertexInstanceUV(VertexInstanceID: VertexInstanceID, UVIndex: number): Vector2D;
        CreateCube(Center: Vector, HalfExtents: Vector, PolygonGroup: PolygonGroupID, PolygonID_PlusX: $Ref<PolygonID>, PolygonID_MinusX: $Ref<PolygonID>, PolygonID_PlusY: $Ref<PolygonID>, PolygonID_MinusY: $Ref<PolygonID>, PolygonID_PlusZ: $Ref<PolygonID>, PolygonID_MinusZ: $Ref<PolygonID>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshDescription;
        static Load(InName: string): StaticMeshDescription;
    }
    
    class StaticMesh extends StreamableRenderAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceModels: TArray<StaticMeshSourceModel>;
        SectionInfoMap: MeshSectionInfoMap;
        OriginalSectionInfoMap: MeshSectionInfoMap;
        LODGroup: string;
        NumStreamedLODs: PerPlatformInt;
        ImportVersion: number;
        MaterialRemapIndexPerImportVersion: TArray<MaterialRemapIndex>;
        LightmapUVVersion: number;
        bAutoComputeLODScreenSize: boolean;
        Materials: TArray<MaterialInterface>;
        MinLOD: PerPlatformInt;
        LpvBiasMultiplier: number;
        StaticMaterials: TArray<StaticMaterial>;
        LightmapUVDensity: number;
        LightMapResolution: number;
        LightMapCoordinateIndex: number;
        DistanceFieldSelfShadowBias: number;
        BodySetup: BodySetup;
        LODForCollision: number;
        bGenerateMeshDistanceField: boolean;
        bStripComplexCollisionForConsole: boolean;
        bHasNavigationData: boolean;
        bSupportUniformlyDistributedSampling: boolean;
        bIsBuiltAtRuntime: boolean;
        bAllowCPUAccess: boolean;
        bSupportGpuUniformlyDistributedSampling: boolean;
        AssetImportData: AssetImportData;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        ThumbnailInfo: ThumbnailInfo;
        EditorCameraPosition: AssetEditorOrbitCameraPosition;
        bCustomizedCollision: boolean;
        LODForOccluderMesh: number;
        Sockets: TArray<StaticMeshSocket>;
        PositiveBoundsExtension: Vector;
        NegativeBoundsExtension: Vector;
        ExtendedBounds: BoxSphereBounds;
        ElementToIgnoreForTexFactor: number;
        AssetUserData: TArray<AssetUserData>;
        EditableMesh: Object;
        ComplexCollisionMesh: StaticMesh;
        NavCollision: NavCollisionBase;
        SetNumSourceModels(Num: number): void;
        SetMaterial(MaterialIndex: number, NewMaterial: MaterialInterface): void;
        RemoveSocket(Socket: StaticMeshSocket): void;
        GetNumSections(InLOD: number): number;
        GetNumLODs(): number;
        GetMinimumLODForPlatforms(PlatformMinimumLODs: $Ref<TMap<string, number>>): void;
        GetMinimumLODForPlatform(PlatformName: string): number;
        GetMaterialIndex(MaterialSlotName: string): number;
        GetMaterial(MaterialIndex: number): MaterialInterface;
        GetBounds(): BoxSphereBounds;
        GetBoundingBox(): Box;
        FindSocket(InSocketName: string): StaticMeshSocket;
        static CreateStaticMeshDescription(Outer: Object): StaticMeshDescription;
        BuildFromStaticMeshDescriptions(StaticMeshDescriptions: TArray<StaticMeshDescription>): void;
        AddSocket(Socket: StaticMeshSocket): void;
        AddMaterial(Material: MaterialInterface): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMesh;
        static Load(InName: string): StaticMesh;
    }
    
    class Interface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface;
        static Load(InName: string): Interface;
    }
    
    class BlendableInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendableInterface;
        static Load(InName: string): BlendableInterface;
    }
    
    class CameraComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FieldOfView: number;
        OrthoWidth: number;
        OrthoNearClipPlane: number;
        OrthoFarClipPlane: number;
        AspectRatio: number;
        bConstrainAspectRatio: boolean;
        bUseFieldOfViewForLOD: boolean;
        bCameraMeshHiddenInGame: boolean;
        bLockToHmd: boolean;
        bUsePawnControlRotation: boolean;
        ProjectionMode: number;
        CameraMesh: StaticMesh;
        PostProcessBlendWeight: number;
        PostProcessSettings: PostProcessSettings;
        bUseControllerViewRotation: boolean;
        SetUseFieldOfViewForLOD(bInUseFieldOfViewForLOD: boolean): void;
        SetProjectionMode(InProjectionMode: number): void;
        SetPostProcessBlendWeight(InPostProcessBlendWeight: number): void;
        SetOrthoWidth(InOrthoWidth: number): void;
        SetOrthoNearClipPlane(InOrthoNearClipPlane: number): void;
        SetOrthoFarClipPlane(InOrthoFarClipPlane: number): void;
        SetFieldOfView(InFieldOfView: number): void;
        SetConstraintAspectRatio(bInConstrainAspectRatio: boolean): void;
        SetAspectRatio(InAspectRatio: number): void;
        RemoveBlendable(InBlendableObject: BlendableInterface): void;
        OnCameraMeshHiddenChanged(): void;
        GetFilmbackText(): string;
        GetCameraView(DeltaTime: number, DesiredView: $Ref<MinimalViewInfo>): void;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraComponent;
        static Load(InName: string): CameraComponent;
    }
    
    class CameraActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoActivateForPlayer: number;
        CameraComponent: CameraComponent;
        SceneComponent: SceneComponent;
        bConstrainAspectRatio: boolean;
        AspectRatio: number;
        FOVAngle: number;
        PostProcessBlendWeight: number;
        PostProcessSettings: PostProcessSettings;
        GetAutoActivatePlayerIndex(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraActor;
        static Load(InName: string): CameraActor;
    }
    
    class PlayerCameraManager extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PCOwner: PlayerController;
        TransformComponent: SceneComponent;
        DefaultFOV: number;
        DefaultOrthoWidth: number;
        DefaultAspectRatio: number;
        CameraCache: CameraCacheEntry;
        LastFrameCameraCache: CameraCacheEntry;
        ViewTarget: TViewTarget;
        PendingViewTarget: TViewTarget;
        CameraCachePrivate: CameraCacheEntry;
        LastFrameCameraCachePrivate: CameraCacheEntry;
        ModifierList: TArray<CameraModifier>;
        DefaultModifiers: TArray<Class>;
        FreeCamDistance: number;
        FreeCamOffset: Vector;
        ViewTargetOffset: Vector;
        CameraLensEffects: TArray<EmitterCameraLensEffectBase>;
        CachedCameraShakeMod: CameraModifier_CameraShake;
        AnimInstPool: FixSizeArray<CameraAnimInst>;
        PostProcessBlendCache: TArray<PostProcessSettings>;
        ActiveAnims: TArray<CameraAnimInst>;
        FreeAnims: TArray<CameraAnimInst>;
        AnimCameraActor: CameraActor;
        bIsOrthographic: boolean;
        bDefaultConstrainAspectRatio: boolean;
        bClientSimulatingViewTarget: boolean;
        bUseClientSideCameraUpdates: boolean;
        bGameCameraCutThisFrame: boolean;
        ViewPitchMin: number;
        ViewPitchMax: number;
        ViewYawMin: number;
        ViewYawMax: number;
        ViewRollMin: number;
        ViewRollMax: number;
        ServerUpdateCameraTimeout: number;
        StopCameraShake(ShakeInstance: CameraShake, bImmediately: boolean): void;
        StopCameraFade(): void;
        StopCameraAnimInst(AnimInst: CameraAnimInst, bImmediate: boolean): void;
        StopAllInstancesOfCameraShake(Shake: Class, bImmediately: boolean): void;
        StopAllInstancesOfCameraAnim(Anim: CameraAnim, bImmediate: boolean): void;
        StopAllCameraShakes(bImmediately: boolean): void;
        StopAllCameraAnims(bImmediate: boolean): void;
        StartCameraFade(FromAlpha: number, ToAlpha: number, Duration: number, Color: LinearColor, bShouldFadeAudio: boolean, bHoldWhenFinished: boolean): void;
        SetManualCameraFade(InFadeAmount: number, Color: LinearColor, bInFadeAudio: boolean): void;
        SetGameCameraCutThisFrame(): void;
        RemoveCameraModifier(ModifierToRemove: CameraModifier): boolean;
        RemoveCameraLensEffect(Emitter: EmitterCameraLensEffectBase): void;
        PlayCameraShake(ShakeClass: Class, Scale: number, PlaySpace: number, UserPlaySpaceRot: Rotator): CameraShake;
        PlayCameraAnim(Anim: CameraAnim, Rate: number, Scale: number, BlendInTime: number, BlendOutTime: number, bLoop: boolean, bRandomStartTime: boolean, Duration: number, PlaySpace: number, UserPlaySpaceRot: Rotator): CameraAnimInst;
        PhotographyCameraModify(NewCameraLocation: Vector, PreviousCameraLocation: Vector, OriginalCameraLocation: Vector, ResultCameraLocation: $Ref<Vector>): void;
        OnPhotographySessionStart(): void;
        OnPhotographySessionEnd(): void;
        OnPhotographyMultiPartCaptureStart(): void;
        OnPhotographyMultiPartCaptureEnd(): void;
        GetOwningPlayerController(): PlayerController;
        GetFOVAngle(): number;
        GetCameraRotation(): Rotator;
        GetCameraLocation(): Vector;
        FindCameraModifierByClass(ModifierClass: Class): CameraModifier;
        ClearCameraLensEffects(): void;
        BlueprintUpdateCamera(CameraTarget: Actor, NewCameraLocation: $Ref<Vector>, NewCameraRotation: $Ref<Rotator>, NewCameraFOV: $Ref<number>): boolean;
        AddNewCameraModifier(ModifierClass: Class): CameraModifier;
        AddCameraLensEffect(LensEffectEmitterClass: Class): EmitterCameraLensEffectBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerCameraManager;
        static Load(InName: string): PlayerCameraManager;
    }
    
    class DrawFrustumComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrustumColor: Color;
        FrustumAngle: number;
        FrustumAspectRatio: number;
        FrustumStartDist: number;
        FrustumEndDist: number;
        Texture: Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DrawFrustumComponent;
        static Load(InName: string): DrawFrustumComponent;
    }
    
    class DebugCameraController extends PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowSelectedInfo: boolean;
        bIsFrozenRendering: boolean;
        bIsOrbitingSelectedActor: boolean;
        bOrbitPivotUseCenter: boolean;
        bEnableBufferVisualization: boolean;
        bEnableBufferVisualizationFullMode: boolean;
        bIsBufferVisualizationInputSetup: boolean;
        bLastDisplayEnabled: boolean;
        DrawFrustum: DrawFrustumComponent;
        SelectedActor: Actor;
        SelectedComponent: PrimitiveComponent;
        SelectedHitPoint: HitResult;
        OriginalControllerRef: PlayerController;
        OriginalPlayer: Player;
        SpeedScale: number;
        InitialMaxSpeed: number;
        InitialAccel: number;
        InitialDecel: number;
        ToggleDisplay(): void;
        ShowDebugSelectedInfo(): void;
        SetPawnMovementSpeedScale(NewSpeedScale: number): void;
        ReceiveOnDeactivate(RestoredPC: PlayerController): void;
        ReceiveOnActorSelected(NewSelectedActor: Actor, SelectHitLocation: Vector, SelectHitNormal: Vector, Hit: HitResult): void;
        ReceiveOnActivate(OriginalPC: PlayerController): void;
        GetSelectedActor(): Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugCameraController;
        static Load(InName: string): DebugCameraController;
    }
    
    class CheatManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugCameraControllerRef: DebugCameraController;
        DebugCameraControllerClass: Class;
        Walk(): void;
        ViewSelf(): void;
        ViewPlayer(S: string): void;
        ViewClass(DesiredClass: Class): void;
        ViewActor(ActorName: string): void;
        UpdateSafeArea(): void;
        ToggleServerStatReplicatorUpdateStatNet(): void;
        ToggleServerStatReplicatorClientOverwrite(): void;
        ToggleDebugCamera(): void;
        ToggleAILogging(): void;
        TestCollisionDistance(): void;
        Teleport(): void;
        Summon(ClassName: string): void;
        StreamLevelOut(PackageName: string): void;
        StreamLevelIn(PackageName: string): void;
        SpawnServerStatReplicator(): void;
        Slomo(NewTimeDilation: number): void;
        SetWorldOrigin(): void;
        SetMouseSensitivityToDefault(): void;
        ServerToggleAILogging(): void;
        ReceiveInitCheatManager(): void;
        ReceiveEndPlay(): void;
        PlayersOnly(): void;
        OnlyLoadLevel(PackageName: string): void;
        LogLoc(): void;
        InvertMouse(): void;
        God(): void;
        Ghost(): void;
        FreezeFrame(Delay: number): void;
        Fly(): void;
        FlushLog(): void;
        EnableDebugCamera(): void;
        DumpVoiceMutingState(): void;
        DumpPartyState(): void;
        DumpOnlineSessionState(): void;
        DumpChatState(): void;
        DisableDebugCamera(): void;
        DestroyTarget(): void;
        DestroyServerStatReplicator(): void;
        DestroyPawns(aClass: Class): void;
        DestroyAllPawnsExceptTarget(): void;
        DestroyAll(aClass: Class): void;
        DebugCapsuleSweepSize(HalfHeight: number, Radius: number): void;
        DebugCapsuleSweepPawn(): void;
        DebugCapsuleSweepComplex(bTraceComplex: boolean): void;
        DebugCapsuleSweepClear(): void;
        DebugCapsuleSweepChannel(Channel: number): void;
        DebugCapsuleSweepCapture(): void;
        DebugCapsuleSweep(): void;
        DamageTarget(DamageAmount: number): void;
        CheatScript(ScriptName: string): void;
        ChangeSize(F: number): void;
        BugItStringCreator(ViewLocation: Vector, ViewRotation: Rotator, GoString: $Ref<string>, LocString: $Ref<string>): void;
        BugItGo(X: number, Y: number, Z: number, Pitch: number, Yaw: number, Roll: number): void;
        BugIt(ScreenShotDescription: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheatManager;
        static Load(InName: string): CheatManager;
    }
    
    class KeyBind {
        constructor(Key: Key, Command: string, Control: boolean, Shift: boolean, Alt: boolean, Cmd: boolean, bIgnoreCtrl: boolean, bIgnoreShift: boolean, bIgnoreAlt: boolean, bIgnoreCmd: boolean, bDisabled: boolean);
        Key: Key;
        Command: string;
        Control: boolean;
        Shift: boolean;
        Alt: boolean;
        Cmd: boolean;
        bIgnoreCtrl: boolean;
        bIgnoreShift: boolean;
        bIgnoreAlt: boolean;
        bIgnoreCmd: boolean;
        bDisabled: boolean;
    }
    
    class PlayerInput extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugExecBindings: TArray<KeyBind>;
        InvertedAxis: TArray<string>;
        SetMouseSensitivity(Sensitivity: number): void;
        SetBind(BindName: string, Command: string): void;
        InvertAxisKey(AxisKey: Key): void;
        InvertAxis(AxisName: string): void;
        ClearSmoothing(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerInput;
        static Load(InName: string): PlayerInput;
    }
    
    class RuntimeFloatCurve {
        constructor(EditorCurveData: RichCurve, ExternalCurve: CurveFloat);
        EditorCurveData: RichCurve;
        ExternalCurve: CurveFloat;
    }
    
    class ForceFeedbackChannelDetails {
        constructor(bAffectsLeftLarge: boolean, bAffectsLeftSmall: boolean, bAffectsRightLarge: boolean, bAffectsRightSmall: boolean, Curve: RuntimeFloatCurve);
        bAffectsLeftLarge: boolean;
        bAffectsLeftSmall: boolean;
        bAffectsRightLarge: boolean;
        bAffectsRightSmall: boolean;
        Curve: RuntimeFloatCurve;
    }
    
    class ForceFeedbackEffect extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChannelDetails: TArray<ForceFeedbackChannelDetails>;
        Duration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackEffect;
        static Load(InName: string): ForceFeedbackEffect;
    }
    
    class ActiveForceFeedbackEffect {
        constructor(ForceFeedbackEffect: ForceFeedbackEffect);
        ForceFeedbackEffect: ForceFeedbackEffect;
    }
    
    class ChildConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: NetConnection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChildConnection;
        static Load(InName: string): ChildConnection;
    }
    
    class Package extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Package;
        static Load(InName: string): Package;
    }
    
    class ChannelDefinition {
        constructor(ChannelName: string, ClassName: string, ChannelClass: Class, StaticChannelIndex: number, bTickOnCreate: boolean, bServerOpen: boolean, bClientOpen: boolean, bInitialServer: boolean, bInitialClient: boolean);
        ChannelName: string;
        ClassName: string;
        ChannelClass: Class;
        StaticChannelIndex: number;
        bTickOnCreate: boolean;
        bServerOpen: boolean;
        bClientOpen: boolean;
        bInitialServer: boolean;
        bInitialClient: boolean;
    }
    
    class Channel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Connection: NetConnection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Channel;
        static Load(InName: string): Channel;
    }
    
    class ReplicationDriver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplicationDriver;
        static Load(InName: string): ReplicationDriver;
    }
    
    class NetDriver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NetConnectionClassName: string;
        ReplicationDriverClassName: string;
        MaxDownloadSize: number;
        bClampListenServerTickRate: boolean;
        NetServerMaxTickRate: number;
        MaxNetTickRate: number;
        MaxInternetClientRate: number;
        MaxClientRate: number;
        ServerTravelPause: number;
        SpawnPrioritySeconds: number;
        RelevantTimeout: number;
        KeepAliveTime: number;
        InitialConnectTimeout: number;
        ConnectionTimeout: number;
        TimeoutMultiplierForUnoptimizedBuilds: number;
        bNoTimeouts: boolean;
        bNeverApplyNetworkEmulationSettings: boolean;
        ServerConnection: NetConnection;
        ClientConnections: TArray<NetConnection>;
        RecentlyDisconnectedTrackingTime: number;
        World: World;
        WorldPackage: Package;
        NetConnectionClass: Class;
        ReplicationDriverClass: Class;
        RoleProperty: Property;
        RemoteRoleProperty: Property;
        NetDriverName: string;
        ChannelDefinitions: TArray<ChannelDefinition>;
        ChannelDefinitionMap: TMap<string, ChannelDefinition>;
        ActorChannelPool: TArray<Channel>;
        Time: number;
        ReplicationDriver: ReplicationDriver;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetDriver;
        static Load(InName: string): NetDriver;
    }
    
    class PackageMap extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageMap;
        static Load(InName: string): PackageMap;
    }
    
    class NetConnection extends Player {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Children: TArray<ChildConnection>;
        Driver: NetDriver;
        PackageMapClass: Class;
        PackageMap: PackageMap;
        OpenChannels: TArray<Channel>;
        SentTemporaries: TArray<Actor>;
        ViewTarget: Actor;
        OwningActor: Actor;
        MaxPacket: number;
        InternalAck: boolean;
        PlayerId: UniqueNetIdRepl;
        LastReceiveTime: number;
        ChannelsToTick: TArray<Channel>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetConnection;
        static Load(InName: string): NetConnection;
    }
    
    class CachedKeyToActionInfo {
        constructor(PlayerInput: PlayerInput);
        PlayerInput: PlayerInput;
    }
    
    class InputComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CachedKeyToActionInfo: TArray<CachedKeyToActionInfo>;
        WasControllerKeyJustReleased(Key: Key): boolean;
        WasControllerKeyJustPressed(Key: Key): boolean;
        IsControllerKeyDown(Key: Key): boolean;
        GetTouchState(FingerIndex: number, LocationX: $Ref<number>, LocationY: $Ref<number>, bIsCurrentlyPressed: $Ref<boolean>): void;
        GetControllerVectorKeyState(Key: Key): Vector;
        GetControllerMouseDelta(DeltaX: $Ref<number>, DeltaY: $Ref<number>): void;
        GetControllerKeyTimeDown(Key: Key): number;
        GetControllerAnalogStickState(WhichStick: number, StickX: $Ref<number>, StickY: $Ref<number>): void;
        GetControllerAnalogKeyState(Key: Key): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputComponent;
        static Load(InName: string): InputComponent;
    }
    
    class TouchInputControl {
        constructor(Image1: Texture2D, Image2: Texture2D, Center: Vector2D, VisualSize: Vector2D, ThumbSize: Vector2D, InteractionSize: Vector2D, InputScale: Vector2D, MainInputKey: Key, AltInputKey: Key);
        Image1: Texture2D;
        Image2: Texture2D;
        Center: Vector2D;
        VisualSize: Vector2D;
        ThumbSize: Vector2D;
        InteractionSize: Vector2D;
        InputScale: Vector2D;
        MainInputKey: Key;
        AltInputKey: Key;
    }
    
    class TouchInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Controls: TArray<TouchInputControl>;
        ActiveOpacity: number;
        InactiveOpacity: number;
        TimeUntilDeactive: number;
        TimeUntilReset: number;
        ActivationDelay: number;
        bPreventRecenter: boolean;
        StartupDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TouchInterface;
        static Load(InName: string): TouchInterface;
    }
    
    class SphereComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SphereRadius: number;
        SetSphereRadius(InSphereRadius: number, bUpdateOverlaps: boolean): void;
        GetUnscaledSphereRadius(): number;
        GetShapeScale(): number;
        GetScaledSphereRadius(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SphereComponent;
        static Load(InName: string): SphereComponent;
    }
    
    class StaticMeshComponentLODInfo {
        constructor();
    }
    
    class StreamingTextureBuildInfo {
        constructor(PackedRelativeBox: number, TextureLevelIndex: number, TexelFactor: number);
        PackedRelativeBox: number;
        TextureLevelIndex: number;
        TexelFactor: number;
    }
    
    class LightmassPrimitiveSettings {
        constructor(bUseTwoSidedLighting: boolean, bShadowIndirectOnly: boolean, bUseEmissiveForStaticLighting: boolean, bUseVertexNormalForHemisphereGather: boolean, EmissiveLightFalloffExponent: number, EmissiveLightExplicitInfluenceRadius: number, EmissiveBoost: number, DiffuseBoost: number, FullyOccludedSamplesFraction: number);
        bUseTwoSidedLighting: boolean;
        bShadowIndirectOnly: boolean;
        bUseEmissiveForStaticLighting: boolean;
        bUseVertexNormalForHemisphereGather: boolean;
        EmissiveLightFalloffExponent: number;
        EmissiveLightExplicitInfluenceRadius: number;
        EmissiveBoost: number;
        DiffuseBoost: number;
        FullyOccludedSamplesFraction: number;
    }
    
    class StaticMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForcedLodModel: number;
        PreviousLODLevel: number;
        MinLOD: number;
        SubDivisionStepSize: number;
        StaticMesh: StaticMesh;
        WireframeColorOverride: Color;
        bEvaluateWorldPositionOffset: boolean;
        SelectedEditorSection: number;
        SelectedEditorMaterial: number;
        SectionIndexPreview: number;
        MaterialIndexPreview: number;
        StaticMeshImportVersion: number;
        bOverrideWireframeColor: boolean;
        bOverrideMinLOD: boolean;
        bOverrideNavigationExport: boolean;
        bForceNavigationObstacle: boolean;
        bDisallowMeshPaintPerInstance: boolean;
        bIgnoreInstanceForTextureStreaming: boolean;
        bOverrideLightMapRes: boolean;
        bCastDistanceFieldIndirectShadow: boolean;
        bOverrideDistanceFieldSelfShadowBias: boolean;
        bUseSubDivisions: boolean;
        bUseDefaultCollision: boolean;
        bCustomOverrideVertexColorPerLOD: boolean;
        bDisplayVertexColors: boolean;
        bReverseCulling: boolean;
        OverriddenLightMapRes: number;
        DistanceFieldIndirectShadowMinVisibility: number;
        DistanceFieldSelfShadowBias: number;
        StreamingDistanceMultiplier: number;
        IrrelevantLights: TArray<Guid>;
        LODData: TArray<StaticMeshComponentLODInfo>;
        StreamingTextureData: TArray<StreamingTextureBuildInfo>;
        StaticMeshDerivedDataKey: string;
        MaterialStreamingRelativeBoxes: TArray<number>;
        LightmassSettings: LightmassPrimitiveSettings;
        SetStaticMesh(NewMesh: StaticMesh): boolean;
        SetReverseCulling(ReverseCulling: boolean): void;
        SetForcedLodModel(NewForcedLodModel: number): void;
        SetDistanceFieldSelfShadowBias(NewValue: number): void;
        OnRep_StaticMesh(OldStaticMesh: StaticMesh): void;
        GetLocalBounds(Min: $Ref<Vector>, Max: $Ref<Vector>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshComponent;
        static Load(InName: string): StaticMeshComponent;
    }
    
    class DefaultPawn extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseTurnRate: number;
        BaseLookUpRate: number;
        MovementComponent: PawnMovementComponent;
        CollisionComponent: SphereComponent;
        MeshComponent: StaticMeshComponent;
        bAddDefaultMovementBindings: boolean;
        TurnAtRate(Rate: number): void;
        MoveUp_World(Val: number): void;
        MoveRight(Val: number): void;
        MoveForward(Val: number): void;
        LookUpAtRate(Rate: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultPawn;
        static Load(InName: string): DefaultPawn;
    }
    
    class SpectatorPawn extends DefaultPawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorPawn;
        static Load(InName: string): SpectatorPawn;
    }
    
    enum EControllerHand { Left, Right, AnyHand, Pad, ExternalCamera, Gun, Special_1, Special_2, Special_3, Special_4, Special_5, Special_6, Special_7, Special_8, Special_9, Special_10, Special_11, ControllerHand_Count, EControllerHand_MAX}
    class Visual extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Visual;
        static Load(InName: string): Visual;
    }
    
    class PanelWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Slots: TArray<PanelSlot>;
        RemoveChildAt(Index: number): boolean;
        RemoveChild(Content: Widget): boolean;
        HasChild(Content: Widget): boolean;
        HasAnyChildren(): boolean;
        GetChildrenCount(): number;
        GetChildIndex(Content: Widget): number;
        GetChildAt(Index: number): Widget;
        GetAllChildren(): TArray<Widget>;
        ClearChildren(): void;
        AddChild(Content: Widget): PanelSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PanelWidget;
        static Load(InName: string): PanelWidget;
    }
    
    class PanelSlot extends Visual {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: PanelWidget;
        Content: Widget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PanelSlot;
        static Load(InName: string): PanelSlot;
    }
    
    enum ESlateVisibility { Visible, Collapsed, Hidden, HitTestInvisible, SelfHitTestInvisible, ESlateVisibility_MAX}
    class WidgetTransform {
        constructor(Translation: Vector2D, Scale: Vector2D, Shear: Vector2D, Angle: number);
        Translation: Vector2D;
        Scale: Vector2D;
        Shear: Vector2D;
        Angle: number;
    }
    
    enum ESlateAccessibleBehavior { NotAccessible, Auto, Summary, Custom, ToolTip, ESlateAccessibleBehavior_MAX}
    class SlateAccessibleWidgetData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanChildrenBeAccessible: boolean;
        AccessibleBehavior: ESlateAccessibleBehavior;
        AccessibleSummaryBehavior: ESlateAccessibleBehavior;
        AccessibleText: string;
        AccessibleTextDelegate: $Delegate<() => string>;
        AccessibleSummaryText: string;
        AccessibleSummaryTextDelegate: $Delegate<() => string>;
        GetText__DelegateSignature(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateAccessibleWidgetData;
        static Load(InName: string): SlateAccessibleWidgetData;
    }
    
    enum EWidgetClipping { Inherit, ClipToBounds, ClipToBoundsWithoutIntersecting, ClipToBoundsAlways, OnDemand, EWidgetClipping_MAX}
    enum EUINavigation { Left, Right, Up, Down, Next, Previous, Num, Invalid, EUINavigation_MAX}
    enum EUINavigationRule { Escape, Explicit, Wrap, Stop, Custom, CustomBoundary, Invalid, EUINavigationRule_MAX}
    class WidgetNavigationData {
        constructor(Rule: EUINavigationRule, WidgetToFocus: string, Widget: TWeakObjectPtr<Widget>, CustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>);
        Rule: EUINavigationRule;
        WidgetToFocus: string;
        Widget: TWeakObjectPtr<Widget>;
        CustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>;
    }
    
    class WidgetNavigation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Up: WidgetNavigationData;
        Down: WidgetNavigationData;
        Left: WidgetNavigationData;
        Right: WidgetNavigationData;
        Next: WidgetNavigationData;
        Previous: WidgetNavigationData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetNavigation;
        static Load(InName: string): WidgetNavigation;
    }
    
    enum EFlowDirectionPreference { Inherit, Culture, LeftToRight, RightToLeft, EFlowDirectionPreference_MAX}
    class PropertyPathSegment {
        constructor(Name: string, ArrayIndex: number, Struct: Struct, Field: Field);
        Name: string;
        ArrayIndex: number;
        Struct: Struct;
        Field: Field;
    }
    
    class CachedPropertyPath {
        constructor(Segments: TArray<PropertyPathSegment>, CachedFunction: Function);
        Segments: TArray<PropertyPathSegment>;
        CachedFunction: Function;
    }
    
    class DynamicPropertyPath extends CachedPropertyPath {
        constructor();
    }
    
    class PropertyBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceObject: TWeakObjectPtr<Object>;
        SourcePath: DynamicPropertyPath;
        DestinationProperty: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyBinding;
        static Load(InName: string): PropertyBinding;
    }
    
    class EventReply {
        constructor();
    }
    
    class Geometry {
        constructor();
    }
    
    class InputEvent {
        constructor();
    }
    
    class PointerEvent extends InputEvent {
        constructor();
    }
    
    class SlateColor {
        constructor(SpecifiedColor: LinearColor, ColorUseRule: number);
        SpecifiedColor: LinearColor;
        ColorUseRule: number;
    }
    
    class Margin {
        constructor(Left: number, Top: number, Right: number, Bottom: number);
        Left: number;
        Top: number;
        Right: number;
        Bottom: number;
    }
    
    class SlateBrush {
        constructor(ImageSize: Vector2D, Margin: Margin, Tint: LinearColor, TintColor: SlateColor, ResourceObject: Object, ResourceName: string, UVRegion: Box2D, DrawAs: number, Tiling: number, Mirroring: number, ImageType: number, bIsDynamicallyLoaded: boolean, bHasUObject: boolean);
        ImageSize: Vector2D;
        Margin: Margin;
        Tint: LinearColor;
        TintColor: SlateColor;
        ResourceObject: Object;
        ResourceName: string;
        UVRegion: Box2D;
        DrawAs: number;
        Tiling: number;
        Mirroring: number;
        ImageType: number;
        bIsDynamicallyLoaded: boolean;
        bHasUObject: boolean;
    }
    
    class ScriptViewportClient extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScriptViewportClient;
        static Load(InName: string): ScriptViewportClient;
    }
    
    class Console extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConsoleTargetPlayer: LocalPlayer;
        DefaultTexture_Black: Texture2D;
        DefaultTexture_White: Texture2D;
        HistoryBuffer: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Console;
        static Load(InName: string): Console;
    }
    
    class DebugDisplayProperty {
        constructor(Obj: Object, WithinClass: Class);
        Obj: Object;
        WithinClass: Class;
    }
    
    class OnlineSession extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineSession;
        static Load(InName: string): OnlineSession;
    }
    
    class GameInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalPlayers: TArray<LocalPlayer>;
        OnlineSession: OnlineSession;
        ReferencedObjects: TArray<Object>;
        ReceiveShutdown(): void;
        ReceiveInit(): void;
        HandleTravelError(FailureType: number): void;
        HandleNetworkError(FailureType: number, bIsServer: boolean): void;
        DebugRemovePlayer(ControllerId: number): void;
        DebugCreatePlayer(ControllerId: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameInstance;
        static Load(InName: string): GameInstance;
    }
    
    class GameViewportClient extends ScriptViewportClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewportConsole: Console;
        DebugProperties: TArray<DebugDisplayProperty>;
        World: World;
        GameInstance: GameInstance;
        SSSwapControllers(): void;
        ShowTitleSafeArea(): void;
        SetConsoleTarget(PlayerIndex: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameViewportClient;
        static Load(InName: string): GameViewportClient;
    }
    
    class LocalPlayer extends Player {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewportClient: GameViewportClient;
        AspectRatioAxisConstraint: number;
        PendingLevelPlayerControllerClass: Class;
        bSentSplitJoin: boolean;
        ControllerId: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalPlayer;
        static Load(InName: string): LocalPlayer;
    }
    
    enum ECheckBoxState { Unchecked, Checked, Undetermined, ECheckBoxState_MAX}
    class Widget extends Visual {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Slot: PanelSlot;
        bIsEnabledDelegate: $Delegate<() => boolean>;
        ToolTipText: string;
        ToolTipTextDelegate: $Delegate<() => string>;
        ToolTipWidget: Widget;
        ToolTipWidgetDelegate: $Delegate<() => Widget>;
        VisibilityDelegate: $Delegate<() => ESlateVisibility>;
        RenderTransform: WidgetTransform;
        RenderTransformPivot: Vector2D;
        bIsVariable: boolean;
        bCreatedByConstructionScript: boolean;
        bIsEnabled: boolean;
        bOverride_Cursor: boolean;
        bOverrideAccessibleDefaults: boolean;
        bCanChildrenBeAccessible: boolean;
        AccessibleBehavior: ESlateAccessibleBehavior;
        AccessibleSummaryBehavior: ESlateAccessibleBehavior;
        AccessibleText: string;
        AccessibleTextDelegate: $Delegate<() => string>;
        AccessibleSummaryText: string;
        AccessibleSummaryTextDelegate: $Delegate<() => string>;
        AccessibleWidgetData: SlateAccessibleWidgetData;
        bIsVolatile: boolean;
        bHiddenInDesigner: boolean;
        bExpandedInDesigner: boolean;
        bLockedInDesigner: boolean;
        Cursor: number;
        Clipping: EWidgetClipping;
        Visibility: ESlateVisibility;
        RenderOpacity: number;
        Navigation: WidgetNavigation;
        FlowDirectionPreference: EFlowDirectionPreference;
        NativeBindings: TArray<PropertyBinding>;
        DesignerFlags: number;
        DisplayLabel: string;
        CategoryName: string;
        SetVisibility(InVisibility: ESlateVisibility): void;
        SetUserFocus(PlayerController: PlayerController): void;
        SetToolTipText(InToolTipText: string): void;
        SetToolTip(Widget: Widget): void;
        SetRenderTranslation(Translation: Vector2D): void;
        SetRenderTransformPivot(Pivot: Vector2D): void;
        SetRenderTransformAngle(Angle: number): void;
        SetRenderTransform(InTransform: WidgetTransform): void;
        SetRenderShear(Shear: Vector2D): void;
        SetRenderScale(Scale: Vector2D): void;
        SetRenderOpacity(InOpacity: number): void;
        SetNavigationRuleExplicit(Direction: EUINavigation, InWidget: Widget): void;
        SetNavigationRuleCustomBoundary(Direction: EUINavigation, InCustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>): void;
        SetNavigationRuleCustom(Direction: EUINavigation, InCustomDelegate: $Delegate<(Navigation: EUINavigation) => Widget>): void;
        SetNavigationRuleBase(Direction: EUINavigation, Rule: EUINavigationRule): void;
        SetNavigationRule(Direction: EUINavigation, Rule: EUINavigationRule, WidgetToFocus: string): void;
        SetKeyboardFocus(): void;
        SetIsEnabled(bInIsEnabled: boolean): void;
        SetFocus(): void;
        SetCursor(InCursor: number): void;
        SetClipping(InClipping: EWidgetClipping): void;
        SetAllNavigationRules(Rule: EUINavigationRule, WidgetToFocus: string): void;
        ResetCursor(): void;
        RemoveFromParent(): void;
        OnReply__DelegateSignature(): EventReply;
        OnPointerEvent__DelegateSignature(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;
        IsVisible(): boolean;
        IsHovered(): boolean;
        InvalidateLayoutAndVolatility(): void;
        HasUserFocusedDescendants(PlayerController: PlayerController): boolean;
        HasUserFocus(PlayerController: PlayerController): boolean;
        HasMouseCaptureByUser(UserIndex: number, PointerIndex: number): boolean;
        HasMouseCapture(): boolean;
        HasKeyboardFocus(): boolean;
        HasFocusedDescendants(): boolean;
        HasAnyUserFocus(): boolean;
        GetWidget__DelegateSignature(): Widget;
        GetVisibility(): ESlateVisibility;
        GetTickSpaceGeometry(): Geometry;
        GetText__DelegateSignature(): string;
        GetSlateVisibility__DelegateSignature(): ESlateVisibility;
        GetSlateColor__DelegateSignature(): SlateColor;
        GetSlateBrush__DelegateSignature(): SlateBrush;
        GetRenderTransformAngle(): number;
        GetRenderOpacity(): number;
        GetParent(): PanelWidget;
        GetPaintSpaceGeometry(): Geometry;
        GetOwningPlayer(): PlayerController;
        GetOwningLocalPlayer(): LocalPlayer;
        GetMouseCursor__DelegateSignature(): number;
        GetLinearColor__DelegateSignature(): LinearColor;
        GetIsEnabled(): boolean;
        GetInt32__DelegateSignature(): number;
        GetGameInstance(): GameInstance;
        GetFloat__DelegateSignature(): number;
        GetDesiredSize(): Vector2D;
        GetClipping(): EWidgetClipping;
        GetCheckBoxState__DelegateSignature(): ECheckBoxState;
        GetCachedGeometry(): Geometry;
        GetBool__DelegateSignature(): boolean;
        GenerateWidgetForString__DelegateSignature(Item: string): Widget;
        GenerateWidgetForObject__DelegateSignature(Item: Object): Widget;
        ForceVolatile(bForce: boolean): void;
        ForceLayoutPrepass(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Widget;
        static Load(InName: string): Widget;
    }
    
    class MovieSceneSignedObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Signature: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSignedObject;
        static Load(InName: string): MovieSceneSignedObject;
    }
    
    class MovieSceneTrackIdentifier {
        constructor(Value: number);
        Value: number;
    }
    
    enum EEvaluationMethod { Static, Swept, EEvaluationMethod_MAX}
    class MovieSceneSegment {
        constructor();
    }
    
    class MovieSceneEvaluationTrackSegments {
        constructor(SegmentIdentifierToIndex: TArray<number>, SortedSegments: TArray<MovieSceneSegment>);
        SegmentIdentifierToIndex: TArray<number>;
        SortedSegments: TArray<MovieSceneSegment>;
    }
    
    class MovieSceneTrackEvalOptions {
        constructor(bCanEvaluateNearestSection: boolean, bEvalNearestSection: boolean, bEvaluateInPreroll: boolean, bEvaluateInPostroll: boolean, bEvaluateNearestSection: boolean);
        bCanEvaluateNearestSection: boolean;
        bEvalNearestSection: boolean;
        bEvaluateInPreroll: boolean;
        bEvaluateInPostroll: boolean;
        bEvaluateNearestSection: boolean;
    }
    
    class MovieSceneTrackDisplayOptions {
        constructor(bShowVerticalFrames: boolean);
        bShowVerticalFrames: boolean;
    }
    
    class MovieSceneTrack extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EvalOptions: MovieSceneTrackEvalOptions;
        DisplayOptions: MovieSceneTrackDisplayOptions;
        bIsEvalDisabled: boolean;
        TrackTint: Color;
        SortingOrder: number;
        bSupportsDefaultSections: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneTrack;
        static Load(InName: string): MovieSceneTrack;
    }
    
    class SectionEvaluationDataTree {
        constructor();
    }
    
    class MovieSceneEvalTemplatePtr {
        constructor();
    }
    
    class MovieSceneTrackImplementationPtr {
        constructor();
    }
    
    class MovieSceneEvaluationTrack {
        constructor(ObjectBindingID: Guid, EvaluationPriority: number, EvaluationMethod: EEvaluationMethod, Segments: MovieSceneEvaluationTrackSegments, SourceTrack: MovieSceneTrack, EvaluationTree: SectionEvaluationDataTree, ChildTemplates: TArray<MovieSceneEvalTemplatePtr>, TrackTemplate: MovieSceneTrackImplementationPtr, EvaluationGroup: string, bEvaluateInPreroll: boolean, bEvaluateInPostroll: boolean, bTearDownPriority: boolean);
        ObjectBindingID: Guid;
        EvaluationPriority: number;
        EvaluationMethod: EEvaluationMethod;
        Segments: MovieSceneEvaluationTrackSegments;
        SourceTrack: MovieSceneTrack;
        EvaluationTree: SectionEvaluationDataTree;
        ChildTemplates: TArray<MovieSceneEvalTemplatePtr>;
        TrackTemplate: MovieSceneTrackImplementationPtr;
        EvaluationGroup: string;
        bEvaluateInPreroll: boolean;
        bEvaluateInPostroll: boolean;
        bTearDownPriority: boolean;
    }
    
    class MovieSceneFrameRange {
        constructor();
    }
    
    class MovieSceneEvaluationGroupLUTIndex {
        constructor(LUTOffset: number, NumInitPtrs: number, NumEvalPtrs: number);
        LUTOffset: number;
        NumInitPtrs: number;
        NumEvalPtrs: number;
    }
    
    class MovieSceneSequenceID {
        constructor(Value: number);
        Value: number;
    }
    
    class MovieSceneEvaluationFieldTrackPtr {
        constructor(SequenceID: MovieSceneSequenceID, TrackIdentifier: MovieSceneTrackIdentifier);
        SequenceID: MovieSceneSequenceID;
        TrackIdentifier: MovieSceneTrackIdentifier;
    }
    
    class MovieSceneSegmentIdentifier {
        constructor(IdentifierIndex: number);
        IdentifierIndex: number;
    }
    
    class MovieSceneEvaluationFieldSegmentPtr extends MovieSceneEvaluationFieldTrackPtr {
        constructor(SegmentID: MovieSceneSegmentIdentifier);
        SegmentID: MovieSceneSegmentIdentifier;
    }
    
    class MovieSceneEvaluationGroup {
        constructor(LUTIndices: TArray<MovieSceneEvaluationGroupLUTIndex>, SegmentPtrLUT: TArray<MovieSceneEvaluationFieldSegmentPtr>);
        LUTIndices: TArray<MovieSceneEvaluationGroupLUTIndex>;
        SegmentPtrLUT: TArray<MovieSceneEvaluationFieldSegmentPtr>;
    }
    
    class MovieSceneEvaluationKey {
        constructor(SequenceID: MovieSceneSequenceID, TrackIdentifier: MovieSceneTrackIdentifier, SectionIndex: number);
        SequenceID: MovieSceneSequenceID;
        TrackIdentifier: MovieSceneTrackIdentifier;
        SectionIndex: number;
    }
    
    class MovieSceneOrderedEvaluationKey {
        constructor(Key: MovieSceneEvaluationKey, SetupIndex: number, TearDownIndex: number);
        Key: MovieSceneEvaluationKey;
        SetupIndex: number;
        TearDownIndex: number;
    }
    
    class MovieSceneEvaluationMetaData {
        constructor(ActiveSequences: TArray<MovieSceneSequenceID>, ActiveEntities: TArray<MovieSceneOrderedEvaluationKey>, SubTemplateSerialNumbers: TMap<MovieSceneSequenceID, number>);
        ActiveSequences: TArray<MovieSceneSequenceID>;
        ActiveEntities: TArray<MovieSceneOrderedEvaluationKey>;
        SubTemplateSerialNumbers: TMap<MovieSceneSequenceID, number>;
    }
    
    class MovieSceneEvaluationField {
        constructor(Signature: Guid, Ranges: TArray<MovieSceneFrameRange>, Groups: TArray<MovieSceneEvaluationGroup>, MetaData: TArray<MovieSceneEvaluationMetaData>);
        Signature: Guid;
        Ranges: TArray<MovieSceneFrameRange>;
        Groups: TArray<MovieSceneEvaluationGroup>;
        MetaData: TArray<MovieSceneEvaluationMetaData>;
    }
    
    class FrameNumber {
        constructor(Value: number);
        Value: number;
    }
    
    class FrameTime {
        constructor(FrameNumber: FrameNumber, SubFrame: number);
        FrameNumber: FrameNumber;
        SubFrame: number;
    }
    
    class MovieSceneSequenceTransform {
        constructor(TimeScale: number, Offset: FrameTime);
        TimeScale: number;
        Offset: FrameTime;
    }
    
    class FrameRate {
        constructor(Numerator: number, Denominator: number);
        Numerator: number;
        Denominator: number;
    }
    
    class MovieSceneSequenceInstanceDataPtr {
        constructor();
    }
    
    class MovieSceneSubSequenceData {
        constructor(Sequence: SoftObjectPath, RootToSequenceTransform: MovieSceneSequenceTransform, TickResolution: FrameRate, DeterministicSequenceID: MovieSceneSequenceID, PlayRange: MovieSceneFrameRange, PreRollRange: MovieSceneFrameRange, PostRollRange: MovieSceneFrameRange, HierarchicalBias: number, InstanceData: MovieSceneSequenceInstanceDataPtr, SectionPath: string, SubSectionSignature: Guid, OuterToInnerTransform: MovieSceneSequenceTransform);
        Sequence: SoftObjectPath;
        RootToSequenceTransform: MovieSceneSequenceTransform;
        TickResolution: FrameRate;
        DeterministicSequenceID: MovieSceneSequenceID;
        PlayRange: MovieSceneFrameRange;
        PreRollRange: MovieSceneFrameRange;
        PostRollRange: MovieSceneFrameRange;
        HierarchicalBias: number;
        InstanceData: MovieSceneSequenceInstanceDataPtr;
        SectionPath: string;
        SubSectionSignature: Guid;
        OuterToInnerTransform: MovieSceneSequenceTransform;
    }
    
    class MovieSceneSequenceHierarchyNode {
        constructor(ParentID: MovieSceneSequenceID, Children: TArray<MovieSceneSequenceID>);
        ParentID: MovieSceneSequenceID;
        Children: TArray<MovieSceneSequenceID>;
    }
    
    class MovieSceneSequenceHierarchy {
        constructor(SubSequences: TMap<MovieSceneSequenceID, MovieSceneSubSequenceData>, Hierarchy: TMap<MovieSceneSequenceID, MovieSceneSequenceHierarchyNode>);
        SubSequences: TMap<MovieSceneSequenceID, MovieSceneSubSequenceData>;
        Hierarchy: TMap<MovieSceneSequenceID, MovieSceneSequenceHierarchyNode>;
    }
    
    class MovieSceneEvaluationTemplateSerialNumber {
        constructor(Value: number);
        Value: number;
    }
    
    class MovieSceneTemplateGenerationLedger {
        constructor(LastTrackIdentifier: MovieSceneTrackIdentifier, TrackSignatureToTrackIdentifier: TMap<Guid, MovieSceneTrackIdentifier>, SubSectionRanges: TMap<Guid, MovieSceneFrameRange>);
        LastTrackIdentifier: MovieSceneTrackIdentifier;
        TrackSignatureToTrackIdentifier: TMap<Guid, MovieSceneTrackIdentifier>;
        SubSectionRanges: TMap<Guid, MovieSceneFrameRange>;
    }
    
    class MovieSceneTrackFieldData {
        constructor();
    }
    
    class MovieSceneSubSectionFieldData {
        constructor();
    }
    
    class MovieSceneEvaluationTemplate {
        constructor(Tracks: TMap<MovieSceneTrackIdentifier, MovieSceneEvaluationTrack>, EvaluationField: MovieSceneEvaluationField, Hierarchy: MovieSceneSequenceHierarchy, SequenceSignature: Guid, TemplateSerialNumber: MovieSceneEvaluationTemplateSerialNumber, TemplateLedger: MovieSceneTemplateGenerationLedger, TrackFieldData: MovieSceneTrackFieldData, SubSectionFieldData: MovieSceneSubSectionFieldData);
        Tracks: TMap<MovieSceneTrackIdentifier, MovieSceneEvaluationTrack>;
        EvaluationField: MovieSceneEvaluationField;
        Hierarchy: MovieSceneSequenceHierarchy;
        SequenceSignature: Guid;
        TemplateSerialNumber: MovieSceneEvaluationTemplateSerialNumber;
        TemplateLedger: MovieSceneTemplateGenerationLedger;
        TrackFieldData: MovieSceneTrackFieldData;
        SubSectionFieldData: MovieSceneSubSectionFieldData;
    }
    
    enum EMovieSceneCompletionMode { KeepState, RestoreState, ProjectDefault, EMovieSceneCompletionMode_MAX}
    enum EMovieSceneObjectBindingSpace { Local, Root, EMovieSceneObjectBindingSpace_MAX}
    class MovieSceneObjectBindingID {
        constructor(SequenceID: number, Space: EMovieSceneObjectBindingSpace, Guid: Guid);
        SequenceID: number;
        Space: EMovieSceneObjectBindingSpace;
        Guid: Guid;
    }
    
    class MovieSceneSequence extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrecompiledEvaluationTemplate: MovieSceneEvaluationTemplate;
        DefaultCompletionMode: EMovieSceneCompletionMode;
        bParentContextsAreSignificant: boolean;
        bPlayableDirectly: boolean;
        FindBindingsByTag(InBindingName: string): TArray<MovieSceneObjectBindingID>;
        FindBindingByTag(InBindingName: string): MovieSceneObjectBindingID;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSequence;
        static Load(InName: string): MovieSceneSequence;
    }
    
    class Timecode {
        constructor(Hours: number, Minutes: number, Seconds: number, Frames: number, bDropFrameFormat: boolean);
        Hours: number;
        Minutes: number;
        Seconds: number;
        Frames: number;
        bDropFrameFormat: boolean;
    }
    
    class MovieSceneTimecodeSource {
        constructor(Timecode: Timecode, DeltaFrame: FrameNumber);
        Timecode: Timecode;
        DeltaFrame: FrameNumber;
    }
    
    enum ESpawnOwnership { InnerSequence, MasterSequence, External, ESpawnOwnership_MAX}
    class MovieSceneSpawnable {
        constructor(SpawnTransform: Transform, Tags: TArray<string>, bContinuouslyRespawn: boolean, Guid: Guid, Name: string, ObjectTemplate: Object, ChildPossessables: TArray<Guid>, Ownership: ESpawnOwnership, GeneratedClass: Class, LevelName: string);
        SpawnTransform: Transform;
        Tags: TArray<string>;
        bContinuouslyRespawn: boolean;
        Guid: Guid;
        Name: string;
        ObjectTemplate: Object;
        ChildPossessables: TArray<Guid>;
        Ownership: ESpawnOwnership;
        GeneratedClass: Class;
        LevelName: string;
    }
    
    class MovieScenePossessable {
        constructor(Tags: TArray<string>, Guid: Guid, Name: string, PossessedObjectClass: Class, ParentGuid: Guid);
        Tags: TArray<string>;
        Guid: Guid;
        Name: string;
        PossessedObjectClass: Class;
        ParentGuid: Guid;
    }
    
    class MovieSceneBinding {
        constructor(ObjectGuid: Guid, BindingName: string, Tracks: TArray<MovieSceneTrack>, SortingOrder: number);
        ObjectGuid: Guid;
        BindingName: string;
        Tracks: TArray<MovieSceneTrack>;
        SortingOrder: number;
    }
    
    class MovieSceneObjectBindingIDs {
        constructor(IDs: TArray<MovieSceneObjectBindingID>);
        IDs: TArray<MovieSceneObjectBindingID>;
    }
    
    enum EMovieSceneEvaluationType { FrameLocked, WithSubFrames, EMovieSceneEvaluationType_MAX}
    enum EUpdateClockSource { Tick, Platform, Audio, Timecode, EUpdateClockSource_MAX}
    class MovieSceneMarkedFrame {
        constructor(FrameNumber: FrameNumber, Label: string, Color: LinearColor);
        FrameNumber: FrameNumber;
        Label: string;
        Color: LinearColor;
    }
    
    class MovieSceneTrackLabels {
        constructor(Strings: TArray<string>);
        Strings: TArray<string>;
    }
    
    class MovieSceneExpansionState {
        constructor(bExpanded: boolean);
        bExpanded: boolean;
    }
    
    class FloatRangeBound {
        constructor(Type: number, Value: number);
        Type: number;
        Value: number;
    }
    
    class FloatRange {
        constructor(LowerBound: FloatRangeBound, UpperBound: FloatRangeBound);
        LowerBound: FloatRangeBound;
        UpperBound: FloatRangeBound;
    }
    
    class MovieSceneEditorData {
        constructor(ExpansionStates: TMap<string, MovieSceneExpansionState>, PinnedNodes: TArray<string>, ViewStart: number, ViewEnd: number, WorkStart: number, WorkEnd: number, MarkedFrames: TSet<FrameNumber>, WorkingRange: FloatRange, ViewRange: FloatRange);
        ExpansionStates: TMap<string, MovieSceneExpansionState>;
        PinnedNodes: TArray<string>;
        ViewStart: number;
        ViewEnd: number;
        WorkStart: number;
        WorkEnd: number;
        MarkedFrames: TSet<FrameNumber>;
        WorkingRange: FloatRange;
        ViewRange: FloatRange;
    }
    
    class MovieSceneFolder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FolderName: string;
        ChildFolders: TArray<MovieSceneFolder>;
        ChildMasterTracks: TArray<MovieSceneTrack>;
        ChildObjectBindingStrings: TArray<string>;
        FolderColor: Color;
        SortingOrder: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFolder;
        static Load(InName: string): MovieSceneFolder;
    }
    
    class MovieSceneSectionEvalOptions {
        constructor(bCanEditCompletionMode: boolean, CompletionMode: EMovieSceneCompletionMode);
        bCanEditCompletionMode: boolean;
        CompletionMode: EMovieSceneCompletionMode;
    }
    
    class MovieSceneEasingFunction extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnEvaluate(Interp: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEasingFunction;
        static Load(InName: string): MovieSceneEasingFunction;
    }
    
    class MovieSceneEasingSettings {
        constructor(AutoEaseInDuration: number, AutoEaseOutDuration: number, EaseIn: MovieSceneEasingFunction, bManualEaseIn: boolean, ManualEaseInDuration: number, EaseOut: MovieSceneEasingFunction, bManualEaseOut: boolean, ManualEaseOutDuration: number, AutoEaseInTime: number, AutoEaseOutTime: number, ManualEaseInTime: number, ManualEaseOutTime: number);
        AutoEaseInDuration: number;
        AutoEaseOutDuration: number;
        EaseIn: MovieSceneEasingFunction;
        bManualEaseIn: boolean;
        ManualEaseInDuration: number;
        EaseOut: MovieSceneEasingFunction;
        bManualEaseOut: boolean;
        ManualEaseOutDuration: number;
        AutoEaseInTime: number;
        AutoEaseOutTime: number;
        ManualEaseInTime: number;
        ManualEaseOutTime: number;
    }
    
    enum EMovieSceneBlendType { Invalid, Absolute, Additive, Relative, EMovieSceneBlendType_MAX}
    class OptionalMovieSceneBlendType {
        constructor(BlendType: EMovieSceneBlendType, bIsValid: boolean);
        BlendType: EMovieSceneBlendType;
        bIsValid: boolean;
    }
    
    class MovieSceneSection extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EvalOptions: MovieSceneSectionEvalOptions;
        Easing: MovieSceneEasingSettings;
        SectionRange: MovieSceneFrameRange;
        TimecodeSource: MovieSceneTimecodeSource;
        PreRollFrames: FrameNumber;
        PostRollFrames: FrameNumber;
        RowIndex: number;
        OverlapPriority: number;
        bIsActive: boolean;
        bIsLocked: boolean;
        StartTime: number;
        EndTime: number;
        PreRollTime: number;
        PostRollTime: number;
        bIsInfinite: boolean;
        bSupportsInfiniteRange: boolean;
        BlendType: OptionalMovieSceneBlendType;
        SetRowIndex(NewRowIndex: number): void;
        SetPreRollFrames(InPreRollFrames: number): void;
        SetPostRollFrames(InPostRollFrames: number): void;
        SetOverlapPriority(NewPriority: number): void;
        SetIsLocked(bInIsLocked: boolean): void;
        SetIsActive(bInIsActive: boolean): void;
        SetCompletionMode(InCompletionMode: EMovieSceneCompletionMode): void;
        SetBlendType(InBlendType: EMovieSceneBlendType): void;
        IsLocked(): boolean;
        IsActive(): boolean;
        GetRowIndex(): number;
        GetPreRollFrames(): number;
        GetPostRollFrames(): number;
        GetOverlapPriority(): number;
        GetCompletionMode(): EMovieSceneCompletionMode;
        GetBlendType(): OptionalMovieSceneBlendType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSection;
        static Load(InName: string): MovieSceneSection;
    }
    
    class MovieSceneSectionGroup {
        constructor(Sections: TArray<TWeakObjectPtr<MovieSceneSection>>);
        Sections: TArray<TWeakObjectPtr<MovieSceneSection>>;
    }
    
    class MovieScene extends MovieSceneSignedObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimecodeSource: MovieSceneTimecodeSource;
        Spawnables: TArray<MovieSceneSpawnable>;
        Possessables: TArray<MovieScenePossessable>;
        ObjectBindings: TArray<MovieSceneBinding>;
        BindingGroups: TMap<string, MovieSceneObjectBindingIDs>;
        MasterTracks: TArray<MovieSceneTrack>;
        CameraCutTrack: MovieSceneTrack;
        SelectionRange: MovieSceneFrameRange;
        PlaybackRange: MovieSceneFrameRange;
        TickResolution: FrameRate;
        DisplayRate: FrameRate;
        EvaluationType: EMovieSceneEvaluationType;
        ClockSource: EUpdateClockSource;
        MarkedFrames: TArray<MovieSceneMarkedFrame>;
        bReadOnly: boolean;
        bPlaybackRangeLocked: boolean;
        ObjectsToDisplayNames: TMap<string, string>;
        ObjectsToLabels: TMap<string, MovieSceneTrackLabels>;
        EditorData: MovieSceneEditorData;
        RootFolders: TArray<MovieSceneFolder>;
        SoloNodes: TArray<string>;
        MuteNodes: TArray<string>;
        SectionGroups: TArray<MovieSceneSectionGroup>;
        InTime: number;
        OutTime: number;
        StartTime: number;
        EndTime: number;
        bForceFixedFrameIntervalPlayback: boolean;
        FixedFrameInterval: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene;
        static Load(InName: string): MovieScene;
    }
    
    class WidgetAnimationBinding {
        constructor(WidgetName: string, SlotWidgetName: string, AnimationGuid: Guid, bIsRootWidget: boolean);
        WidgetName: string;
        SlotWidgetName: string;
        AnimationGuid: Guid;
        bIsRootWidget: boolean;
    }
    
    class WidgetAnimation extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAnimationStarted: $MulticastDelegate<() => void>;
        OnAnimationFinished: $MulticastDelegate<() => void>;
        MovieScene: MovieScene;
        AnimationBindings: TArray<WidgetAnimationBinding>;
        bLegacyFinishOnStop: boolean;
        DisplayLabel: string;
        UnbindFromAnimationStarted(Widget: UserWidget, Delegate: $Delegate<() => void>): void;
        UnbindFromAnimationFinished(Widget: UserWidget, Delegate: $Delegate<() => void>): void;
        UnbindAllFromAnimationStarted(Widget: UserWidget): void;
        UnbindAllFromAnimationFinished(Widget: UserWidget): void;
        GetStartTime(): number;
        GetEndTime(): number;
        BindToAnimationStarted(Widget: UserWidget, Delegate: $Delegate<() => void>): void;
        BindToAnimationFinished(Widget: UserWidget, Delegate: $Delegate<() => void>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetAnimation;
        static Load(InName: string): WidgetAnimation;
    }
    
    class UMGSequencePlayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Animation: WidgetAnimation;
        SetUserTag(InUserTag: string): void;
        GetUserTag(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UMGSequencePlayer;
        static Load(InName: string): UMGSequencePlayer;
    }
    
    class NamedSlotBinding {
        constructor(Name: string, Content: Widget);
        Name: string;
        Content: Widget;
    }
    
    class WidgetTree extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootWidget: Widget;
        AllWidgets: TArray<Widget>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetTree;
        static Load(InName: string): WidgetTree;
    }
    
    enum EDesignPreviewSizeMode { FillScreen, Custom, CustomOnScreen, Desired, DesiredOnScreen, EDesignPreviewSizeMode_MAX}
    enum EWidgetTickFrequency { Never, Auto, EWidgetTickFrequency_MAX}
    enum EWidgetAnimationEvent { Started, Finished, EWidgetAnimationEvent_MAX}
    class AnimationEventBinding {
        constructor(Animation: WidgetAnimation, Delegate: $Delegate<() => void>, AnimationEvent: EWidgetAnimationEvent, UserTag: string);
        Animation: WidgetAnimation;
        Delegate: $Delegate<() => void>;
        AnimationEvent: EWidgetAnimationEvent;
        UserTag: string;
    }
    
    class Anchors {
        constructor(Minimum: Vector2D, Maximum: Vector2D);
        Minimum: Vector2D;
        Maximum: Vector2D;
    }
    
    enum ESoundWaveLoadingBehavior { Inherited, RetainOnLoad, PrimeOnLoad, LoadOnDemand, ForceInline, Uninitialized, ESoundWaveLoadingBehavior_MAX}
    class SoundClassProperties {
        constructor(Volume: number, Pitch: number, LowPassFilterFrequency: number, StereoBleed: number, LFEBleed: number, VoiceCenterChannelVolume: number, RadioFilterVolume: number, RadioFilterVolumeThreshold: number, bApplyEffects: boolean, bAlwaysPlay: boolean, bIsUISound: boolean, bIsMusic: boolean, bReverb: boolean, Default2DReverbSendAmount: number, bCenterChannelOnly: boolean, bApplyAmbientVolumes: boolean, OutputTarget: number, LoadingBehavior: ESoundWaveLoadingBehavior);
        Volume: number;
        Pitch: number;
        LowPassFilterFrequency: number;
        StereoBleed: number;
        LFEBleed: number;
        VoiceCenterChannelVolume: number;
        RadioFilterVolume: number;
        RadioFilterVolumeThreshold: number;
        bApplyEffects: boolean;
        bAlwaysPlay: boolean;
        bIsUISound: boolean;
        bIsMusic: boolean;
        bReverb: boolean;
        Default2DReverbSendAmount: number;
        bCenterChannelOnly: boolean;
        bApplyAmbientVolumes: boolean;
        OutputTarget: number;
        LoadingBehavior: ESoundWaveLoadingBehavior;
    }
    
    class AudioEQEffect {
        constructor(FrequencyCenter0: number, Gain0: number, Bandwidth0: number, FrequencyCenter1: number, Gain1: number, Bandwidth1: number, FrequencyCenter2: number, Gain2: number, Bandwidth2: number, FrequencyCenter3: number, Gain3: number, Bandwidth3: number);
        FrequencyCenter0: number;
        Gain0: number;
        Bandwidth0: number;
        FrequencyCenter1: number;
        Gain1: number;
        Bandwidth1: number;
        FrequencyCenter2: number;
        Gain2: number;
        Bandwidth2: number;
        FrequencyCenter3: number;
        Gain3: number;
        Bandwidth3: number;
    }
    
    class SoundClassAdjuster {
        constructor(SoundClassObject: SoundClass, VolumeAdjuster: number, PitchAdjuster: number, LowPassFilterFrequency: number, bApplyToChildren: boolean, VoiceCenterChannelVolumeAdjuster: number);
        SoundClassObject: SoundClass;
        VolumeAdjuster: number;
        PitchAdjuster: number;
        LowPassFilterFrequency: number;
        bApplyToChildren: boolean;
        VoiceCenterChannelVolumeAdjuster: number;
    }
    
    class SoundMix extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bApplyEQ: boolean;
        EQPriority: number;
        EQSettings: AudioEQEffect;
        SoundClassEffects: TArray<SoundClassAdjuster>;
        InitialDelay: number;
        FadeInTime: number;
        Duration: number;
        FadeOutTime: number;
        bChanged: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundMix;
        static Load(InName: string): SoundMix;
    }
    
    class PassiveSoundMixModifier {
        constructor(SoundMix: SoundMix, MinVolumeThreshold: number, MaxVolumeThreshold: number);
        SoundMix: SoundMix;
        MinVolumeThreshold: number;
        MaxVolumeThreshold: number;
    }
    
    class SoundModulationPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundModulationPluginSourceSettingsBase;
        static Load(InName: string): SoundModulationPluginSourceSettingsBase;
    }
    
    class SoundModulation {
        constructor(Settings: TArray<SoundModulationPluginSourceSettingsBase>);
        Settings: TArray<SoundModulationPluginSourceSettingsBase>;
    }
    
    class SoundClass extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Properties: SoundClassProperties;
        ChildClasses: TArray<SoundClass>;
        PassiveSoundMixModifiers: TArray<PassiveSoundMixModifier>;
        Modulation: SoundModulation;
        ParentClass: SoundClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClass;
        static Load(InName: string): SoundClass;
    }
    
    enum EVirtualizationMode { Disabled, PlayWhenSilent, Restart, EVirtualizationMode_MAX}
    class SoundConcurrencySettings {
        constructor(MaxCount: number, bLimitToOwner: boolean, ResolutionRule: number, VolumeScale: number, VolumeScaleAttackTime: number, bVolumeScaleCanRelease: boolean, VolumeScaleReleaseTime: number, VoiceStealReleaseTime: number);
        MaxCount: number;
        bLimitToOwner: boolean;
        ResolutionRule: number;
        VolumeScale: number;
        VolumeScaleAttackTime: number;
        bVolumeScaleCanRelease: boolean;
        VolumeScaleReleaseTime: number;
        VoiceStealReleaseTime: number;
    }
    
    class SoundConcurrency extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Concurrency: SoundConcurrencySettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundConcurrency;
        static Load(InName: string): SoundConcurrency;
    }
    
    enum EAttenuationDistanceModel { Linear, Logarithmic, Inverse, LogReverse, NaturalSound, Custom, EAttenuationDistanceModel_MAX}
    class BaseAttenuationSettings {
        constructor(DistanceAlgorithm: EAttenuationDistanceModel, AttenuationShape: number, dBAttenuationAtMax: number, AttenuationShapeExtents: Vector, ConeOffset: number, FalloffDistance: number, CustomAttenuationCurve: RuntimeFloatCurve);
        DistanceAlgorithm: EAttenuationDistanceModel;
        AttenuationShape: number;
        dBAttenuationAtMax: number;
        AttenuationShapeExtents: Vector;
        ConeOffset: number;
        FalloffDistance: number;
        CustomAttenuationCurve: RuntimeFloatCurve;
    }
    
    enum EAirAbsorptionMethod { Linear, CustomCurve, EAirAbsorptionMethod_MAX}
    enum EReverbSendMethod { Linear, CustomCurve, Manual, EReverbSendMethod_MAX}
    class SpatializationPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpatializationPluginSourceSettingsBase;
        static Load(InName: string): SpatializationPluginSourceSettingsBase;
    }
    
    class OcclusionPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OcclusionPluginSourceSettingsBase;
        static Load(InName: string): OcclusionPluginSourceSettingsBase;
    }
    
    class ReverbPluginSourceSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReverbPluginSourceSettingsBase;
        static Load(InName: string): ReverbPluginSourceSettingsBase;
    }
    
    class SoundAttenuationPluginSettings {
        constructor(SpatializationPluginSettingsArray: TArray<SpatializationPluginSourceSettingsBase>, OcclusionPluginSettingsArray: TArray<OcclusionPluginSourceSettingsBase>, ReverbPluginSettingsArray: TArray<ReverbPluginSourceSettingsBase>);
        SpatializationPluginSettingsArray: TArray<SpatializationPluginSourceSettingsBase>;
        OcclusionPluginSettingsArray: TArray<OcclusionPluginSourceSettingsBase>;
        ReverbPluginSettingsArray: TArray<ReverbPluginSourceSettingsBase>;
    }
    
    class SoundAttenuationSettings extends BaseAttenuationSettings {
        constructor(bAttenuate: boolean, bSpatialize: boolean, bAttenuateWithLPF: boolean, bEnableListenerFocus: boolean, bEnableFocusInterpolation: boolean, bEnableOcclusion: boolean, bUseComplexCollisionForOcclusion: boolean, bEnableReverbSend: boolean, bApplyNormalizationToStereoSounds: boolean, bEnableLogFrequencyScaling: boolean, SpatializationAlgorithm: number, BinauralRadius: number, AbsorptionMethod: EAirAbsorptionMethod, OcclusionTraceChannel: number, ReverbSendMethod: EReverbSendMethod, DistanceType: number, OmniRadius: number, StereoSpread: number, SpatializationPluginSettings: SpatializationPluginSourceSettingsBase, RadiusMin: number, RadiusMax: number, LPFRadiusMin: number, LPFRadiusMax: number, CustomLowpassAirAbsorptionCurve: RuntimeFloatCurve, CustomHighpassAirAbsorptionCurve: RuntimeFloatCurve, LPFFrequencyAtMin: number, LPFFrequencyAtMax: number, HPFFrequencyAtMin: number, HPFFrequencyAtMax: number, FocusAzimuth: number, NonFocusAzimuth: number, FocusDistanceScale: number, NonFocusDistanceScale: number, FocusPriorityScale: number, NonFocusPriorityScale: number, FocusVolumeAttenuation: number, NonFocusVolumeAttenuation: number, FocusAttackInterpSpeed: number, FocusReleaseInterpSpeed: number, OcclusionLowPassFilterFrequency: number, OcclusionVolumeAttenuation: number, OcclusionInterpolationTime: number, OcclusionPluginSettings: OcclusionPluginSourceSettingsBase, ReverbPluginSettings: ReverbPluginSourceSettingsBase, ReverbWetLevelMin: number, ReverbWetLevelMax: number, ReverbDistanceMin: number, ReverbDistanceMax: number, ManualReverbSendLevel: number, CustomReverbSendCurve: RuntimeFloatCurve, PluginSettings: SoundAttenuationPluginSettings);
        bAttenuate: boolean;
        bSpatialize: boolean;
        bAttenuateWithLPF: boolean;
        bEnableListenerFocus: boolean;
        bEnableFocusInterpolation: boolean;
        bEnableOcclusion: boolean;
        bUseComplexCollisionForOcclusion: boolean;
        bEnableReverbSend: boolean;
        bApplyNormalizationToStereoSounds: boolean;
        bEnableLogFrequencyScaling: boolean;
        SpatializationAlgorithm: number;
        BinauralRadius: number;
        AbsorptionMethod: EAirAbsorptionMethod;
        OcclusionTraceChannel: number;
        ReverbSendMethod: EReverbSendMethod;
        DistanceType: number;
        OmniRadius: number;
        StereoSpread: number;
        SpatializationPluginSettings: SpatializationPluginSourceSettingsBase;
        RadiusMin: number;
        RadiusMax: number;
        LPFRadiusMin: number;
        LPFRadiusMax: number;
        CustomLowpassAirAbsorptionCurve: RuntimeFloatCurve;
        CustomHighpassAirAbsorptionCurve: RuntimeFloatCurve;
        LPFFrequencyAtMin: number;
        LPFFrequencyAtMax: number;
        HPFFrequencyAtMin: number;
        HPFFrequencyAtMax: number;
        FocusAzimuth: number;
        NonFocusAzimuth: number;
        FocusDistanceScale: number;
        NonFocusDistanceScale: number;
        FocusPriorityScale: number;
        NonFocusPriorityScale: number;
        FocusVolumeAttenuation: number;
        NonFocusVolumeAttenuation: number;
        FocusAttackInterpSpeed: number;
        FocusReleaseInterpSpeed: number;
        OcclusionLowPassFilterFrequency: number;
        OcclusionVolumeAttenuation: number;
        OcclusionInterpolationTime: number;
        OcclusionPluginSettings: OcclusionPluginSourceSettingsBase;
        ReverbPluginSettings: ReverbPluginSourceSettingsBase;
        ReverbWetLevelMin: number;
        ReverbWetLevelMax: number;
        ReverbDistanceMin: number;
        ReverbDistanceMax: number;
        ManualReverbSendLevel: number;
        CustomReverbSendCurve: RuntimeFloatCurve;
        PluginSettings: SoundAttenuationPluginSettings;
    }
    
    class SoundAttenuation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Attenuation: SoundAttenuationSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundAttenuation;
        static Load(InName: string): SoundAttenuation;
    }
    
    enum ESubmixChannelFormat { Device, Stereo, Quad, FiveDotOne, SevenDotOne, Ambisonics, Count, ESubmixChannelFormat_MAX}
    class SoundEffectPreset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectPreset;
        static Load(InName: string): SoundEffectPreset;
    }
    
    class SoundEffectSubmixPreset extends SoundEffectPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectSubmixPreset;
        static Load(InName: string): SoundEffectSubmixPreset;
    }
    
    class AmbisonicsSubmixSettingsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AmbisonicsSubmixSettingsBase;
        static Load(InName: string): AmbisonicsSubmixSettingsBase;
    }
    
    enum ESoundwaveSampleRateSettings { Max, High, Medium, Low, Min, MatchDevice, ESoundwaveSampleRateSettings_MAX}
    enum ESoundWaveFFTSize { VerySmall_64, Small_256, Medium_512, Large_1024, VeryLarge_2048, ESoundWaveFFTSize_MAX}
    class SoundWaveSpectralDataEntry {
        constructor(Magnitude: number, NormalizedMagnitude: number);
        Magnitude: number;
        NormalizedMagnitude: number;
    }
    
    class SoundWaveSpectralTimeData {
        constructor(Data: TArray<SoundWaveSpectralDataEntry>, TimeSec: number);
        Data: TArray<SoundWaveSpectralDataEntry>;
        TimeSec: number;
    }
    
    class SoundWaveEnvelopeTimeData {
        constructor(Amplitude: number, TimeSec: number);
        Amplitude: number;
        TimeSec: number;
    }
    
    class SubtitleCue {
        constructor(Text: string, Time: number);
        Text: string;
        Time: number;
    }
    
    class CurveTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: AssetImportData;
        ImportPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveTable;
        static Load(InName: string): CurveTable;
    }
    
    class SoundWave extends SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompressionQuality: number;
        StreamingPriority: number;
        SampleRateQuality: ESoundwaveSampleRateSettings;
        SoundGroup: number;
        bLooping: boolean;
        bStreaming: boolean;
        bSeekableStreaming: boolean;
        LoadingBehavior: ESoundWaveLoadingBehavior;
        bMature: boolean;
        bManualWordWrap: boolean;
        bSingleLine: boolean;
        bVirtualizeWhenSilent: boolean;
        bIsAmbisonics: boolean;
        OverrideSoundToUseForAnalysis: SoundWave;
        TreatFileAsLoopingForAnalysis: boolean;
        bEnableBakedFFTAnalysis: boolean;
        bEnableAmplitudeEnvelopeAnalysis: boolean;
        FFTSize: ESoundWaveFFTSize;
        FFTAnalysisFrameSize: number;
        FFTAnalysisAttackTime: number;
        FFTAnalysisReleaseTime: number;
        EnvelopeFollowerFrameSize: number;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        FrequenciesToAnalyze: TArray<number>;
        CookedSpectralTimeData: TArray<SoundWaveSpectralTimeData>;
        CookedEnvelopeTimeData: TArray<SoundWaveEnvelopeTimeData>;
        InitialChunkSize: number;
        SpokenText: string;
        SubtitlePriority: number;
        Volume: number;
        Pitch: number;
        NumChannels: number;
        ChannelOffsets: TArray<number>;
        ChannelSizes: TArray<number>;
        SampleRate: number;
        Subtitles: TArray<SubtitleCue>;
        Comment: string;
        SourceFilePath: string;
        SourceFileTimestamp: string;
        AssetImportData: AssetImportData;
        Curves: CurveTable;
        InternalCurves: CurveTable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundWave;
        static Load(InName: string): SoundWave;
    }
    
    enum EAudioRecordingExportType { SoundWave, WavFile, EAudioRecordingExportType_MAX}
    class SoundSubmix extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildSubmixes: TArray<SoundSubmix>;
        ParentSubmix: SoundSubmix;
        ChannelFormat: ESubmixChannelFormat;
        bMuteWhenBackgrounded: boolean;
        SubmixEffectChain: TArray<SoundEffectSubmixPreset>;
        AmbisonicsPluginSettings: AmbisonicsSubmixSettingsBase;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        OutputVolume: number;
        OnSubmixRecordedFileDone: $MulticastDelegate<(ResultingSoundWave: SoundWave) => void>;
        StopRecordingOutput(WorldContextObject: Object, ExportType: EAudioRecordingExportType, Name: string, Path: string, ExistingSoundWaveToOverwrite: SoundWave): void;
        StopEnvelopeFollowing(WorldContextObject: Object): void;
        StartRecordingOutput(WorldContextObject: Object, ExpectedDuration: number): void;
        StartEnvelopeFollowing(WorldContextObject: Object): void;
        SetSubmixOutputVolume(WorldContextObject: Object, InOutputVolume: number): void;
        AddEnvelopeFollowerDelegate(WorldContextObject: Object, OnSubmixEnvelopeBP: $Delegate<(Envelope: TArray<number>) => void>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmix;
        static Load(InName: string): SoundSubmix;
    }
    
    enum ESendLevelControlMethod { Linear, CustomCurve, Manual, ESendLevelControlMethod_MAX}
    class SoundSubmixSendInfo {
        constructor(SendLevelControlMethod: ESendLevelControlMethod, SoundSubmix: SoundSubmix, SendLevel: number, MinSendLevel: number, MaxSendLevel: number, MinSendDistance: number, MaxSendDistance: number, CustomSendLevelCurve: RuntimeFloatCurve);
        SendLevelControlMethod: ESendLevelControlMethod;
        SoundSubmix: SoundSubmix;
        SendLevel: number;
        MinSendLevel: number;
        MaxSendLevel: number;
        MinSendDistance: number;
        MaxSendDistance: number;
        CustomSendLevelCurve: RuntimeFloatCurve;
    }
    
    class SoundEffectSourcePreset extends SoundEffectPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePreset;
        static Load(InName: string): SoundEffectSourcePreset;
    }
    
    class SourceEffectChainEntry {
        constructor(Preset: SoundEffectSourcePreset, bBypass: boolean);
        Preset: SoundEffectSourcePreset;
        bBypass: boolean;
    }
    
    class SoundEffectSourcePresetChain extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Chain: TArray<SourceEffectChainEntry>;
        bPlayEffectChainTails: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundEffectSourcePresetChain;
        static Load(InName: string): SoundEffectSourcePresetChain;
    }
    
    enum ESourceBusSendLevelControlMethod { Linear, CustomCurve, Manual, ESourceBusSendLevelControlMethod_MAX}
    enum ESourceBusChannels { Mono, Stereo, ESourceBusChannels_MAX}
    class SoundSourceBus extends SoundWave {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceBusChannels: ESourceBusChannels;
        SourceBusDuration: number;
        bAutoDeactivateWhenSilent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceBus;
        static Load(InName: string): SoundSourceBus;
    }
    
    class SoundSourceBusSendInfo {
        constructor(SourceBusSendLevelControlMethod: ESourceBusSendLevelControlMethod, SoundSourceBus: SoundSourceBus, SendLevel: number, MinSendLevel: number, MaxSendLevel: number, MinSendDistance: number, MaxSendDistance: number, CustomSendLevelCurve: RuntimeFloatCurve);
        SourceBusSendLevelControlMethod: ESourceBusSendLevelControlMethod;
        SoundSourceBus: SoundSourceBus;
        SendLevel: number;
        MinSendLevel: number;
        MaxSendLevel: number;
        MinSendDistance: number;
        MaxSendDistance: number;
        CustomSendLevelCurve: RuntimeFloatCurve;
    }
    
    class SoundBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundClassObject: SoundClass;
        bDebug: boolean;
        bOverrideConcurrency: boolean;
        bOutputToBusOnly: boolean;
        bHasDelayNode: boolean;
        bHasConcatenatorNode: boolean;
        bHasVirtualizeWhenSilent: boolean;
        bBypassVolumeScaleForPriority: boolean;
        VirtualizationMode: EVirtualizationMode;
        MaxConcurrentResolutionRule: number;
        SoundConcurrencySettings: SoundConcurrency;
        ConcurrencySet: TSet<SoundConcurrency>;
        ConcurrencyOverrides: SoundConcurrencySettings;
        MaxConcurrentPlayCount: number;
        Duration: number;
        MaxDistance: number;
        TotalSamples: number;
        Priority: number;
        AttenuationSettings: SoundAttenuation;
        Modulation: SoundModulation;
        SoundSubmixObject: SoundSubmix;
        SoundSubmixSends: TArray<SoundSubmixSendInfo>;
        SourceEffectChain: SoundEffectSourcePresetChain;
        BusSends: TArray<SoundSourceBusSendInfo>;
        PreEffectBusSends: TArray<SoundSourceBusSendInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundBase;
        static Load(InName: string): SoundBase;
    }
    
    class FocusEvent {
        constructor();
    }
    
    class KeyEvent extends InputEvent {
        constructor();
    }
    
    class PaintContext {
        constructor();
    }
    
    class MotionEvent extends InputEvent {
        constructor();
    }
    
    class CharacterEvent extends InputEvent {
        constructor();
    }
    
    enum EDragPivot { MouseDown, TopLeft, TopCenter, TopRight, CenterLeft, CenterCenter, CenterRight, BottomLeft, BottomCenter, BottomRight, EDragPivot_MAX}
    class DragDropOperation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tag: string;
        Payload: Object;
        DefaultDragVisual: Widget;
        Pivot: EDragPivot;
        Offset: Vector2D;
        OnDrop: $MulticastDelegate<(Operation: DragDropOperation) => void>;
        OnDragCancelled: $MulticastDelegate<(Operation: DragDropOperation) => void>;
        OnDragged: $MulticastDelegate<(Operation: DragDropOperation) => void>;
        Drop(PointerEvent: PointerEvent): void;
        Dragged(PointerEvent: PointerEvent): void;
        DragCancelled(PointerEvent: PointerEvent): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DragDropOperation;
        static Load(InName: string): DragDropOperation;
    }
    
    class AnalogInputEvent extends KeyEvent {
        constructor();
    }
    
    class UserWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColorAndOpacity: LinearColor;
        ColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        ForegroundColor: SlateColor;
        ForegroundColorDelegate: $Delegate<() => SlateColor>;
        Padding: Margin;
        ActiveSequencePlayers: TArray<UMGSequencePlayer>;
        StoppedSequencePlayers: TArray<UMGSequencePlayer>;
        NamedSlotBindings: TArray<NamedSlotBinding>;
        WidgetTree: WidgetTree;
        DesignTimeSize: Vector2D;
        DesignSizeMode: EDesignPreviewSizeMode;
        PaletteCategory: string;
        PreviewBackground: Texture2D;
        Priority: number;
        bSupportsKeyboardFocus: boolean;
        bIsFocusable: boolean;
        bStopAction: boolean;
        bHasScriptImplementedTick: boolean;
        bHasScriptImplementedPaint: boolean;
        bCookedWidgetTree: boolean;
        TickFrequency: EWidgetTickFrequency;
        InputComponent: InputComponent;
        AnimationCallbacks: TArray<AnimationEventBinding>;
        UnregisterInputComponent(): void;
        UnbindFromAnimationStarted(Animation: WidgetAnimation, Delegate: $Delegate<() => void>): void;
        UnbindFromAnimationFinished(Animation: WidgetAnimation, Delegate: $Delegate<() => void>): void;
        UnbindAllFromAnimationStarted(Animation: WidgetAnimation): void;
        UnbindAllFromAnimationFinished(Animation: WidgetAnimation): void;
        Tick(MyGeometry: Geometry, InDeltaTime: number): void;
        StopListeningForInputAction(ActionName: string, EventType: number): void;
        StopListeningForAllInputActions(): void;
        StopAnimationsAndLatentActions(): void;
        StopAnimation(InAnimation: WidgetAnimation): void;
        StopAllAnimations(): void;
        SetPositionInViewport(Position: Vector2D, bRemoveDPIScale: boolean): void;
        SetPlaybackSpeed(InAnimation: WidgetAnimation, PlaybackSpeed: number): void;
        SetPadding(InPadding: Margin): void;
        SetOwningPlayer(LocalPlayerController: PlayerController): void;
        SetNumLoopsToPlay(InAnimation: WidgetAnimation, NumLoopsToPlay: number): void;
        SetInputActionPriority(NewPriority: number): void;
        SetInputActionBlocking(bShouldBlock: boolean): void;
        SetForegroundColor(InForegroundColor: SlateColor): void;
        SetDesiredSizeInViewport(Size: Vector2D): void;
        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
        SetAnchorsInViewport(Anchors: Anchors): void;
        SetAlignmentInViewport(Alignment: Vector2D): void;
        ReverseAnimation(InAnimation: WidgetAnimation): void;
        RemoveFromViewport(): void;
        RegisterInputComponent(): void;
        PreConstruct(IsDesignTime: boolean): void;
        PlaySound(SoundToPlay: SoundBase): void;
        PlayAnimationTimeRange(InAnimation: WidgetAnimation, StartAtTime: number, EndAtTime: number, NumLoopsToPlay: number, PlayMode: number, PlaybackSpeed: number, bRestoreState: boolean): UMGSequencePlayer;
        PlayAnimationReverse(InAnimation: WidgetAnimation, PlaybackSpeed: number, bRestoreState: boolean): UMGSequencePlayer;
        PlayAnimationForward(InAnimation: WidgetAnimation, PlaybackSpeed: number, bRestoreState: boolean): UMGSequencePlayer;
        PlayAnimation(InAnimation: WidgetAnimation, StartAtTime: number, NumLoopsToPlay: number, PlayMode: number, PlaybackSpeed: number, bRestoreState: boolean): UMGSequencePlayer;
        PauseAnimation(InAnimation: WidgetAnimation): number;
        OnTouchStarted(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;
        OnTouchMoved(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;
        OnTouchGesture(MyGeometry: Geometry, GestureEvent: PointerEvent): EventReply;
        OnTouchForceChanged(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;
        OnTouchEnded(MyGeometry: Geometry, InTouchEvent: PointerEvent): EventReply;
        OnRemovedFromFocusPath(InFocusEvent: FocusEvent): void;
        OnPreviewMouseButtonDown(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;
        OnPreviewKeyDown(MyGeometry: Geometry, InKeyEvent: KeyEvent): EventReply;
        OnPaint(Context: $Ref<PaintContext>): void;
        OnMouseWheel(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;
        OnMouseMove(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;
        OnMouseLeave(MouseEvent: PointerEvent): void;
        OnMouseEnter(MyGeometry: Geometry, MouseEvent: PointerEvent): void;
        OnMouseCaptureLost(): void;
        OnMouseButtonUp(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;
        OnMouseButtonDown(MyGeometry: Geometry, MouseEvent: PointerEvent): EventReply;
        OnMouseButtonDoubleClick(InMyGeometry: Geometry, InMouseEvent: PointerEvent): EventReply;
        OnMotionDetected(MyGeometry: Geometry, InMotionEvent: MotionEvent): EventReply;
        OnKeyUp(MyGeometry: Geometry, InKeyEvent: KeyEvent): EventReply;
        OnKeyDown(MyGeometry: Geometry, InKeyEvent: KeyEvent): EventReply;
        OnKeyChar(MyGeometry: Geometry, InCharacterEvent: CharacterEvent): EventReply;
        OnInitialized(): void;
        OnFocusReceived(MyGeometry: Geometry, InFocusEvent: FocusEvent): EventReply;
        OnFocusLost(InFocusEvent: FocusEvent): void;
        OnDrop(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: DragDropOperation): boolean;
        OnDragOver(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: DragDropOperation): boolean;
        OnDragLeave(PointerEvent: PointerEvent, Operation: DragDropOperation): void;
        OnDragEnter(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: DragDropOperation): void;
        OnDragDetected(MyGeometry: Geometry, PointerEvent: PointerEvent, Operation: $Ref<DragDropOperation>): void;
        OnDragCancelled(PointerEvent: PointerEvent, Operation: DragDropOperation): void;
        OnAnimationStarted(Animation: WidgetAnimation): void;
        OnAnimationFinished(Animation: WidgetAnimation): void;
        OnAnalogValueChanged(MyGeometry: Geometry, InAnalogInputEvent: AnalogInputEvent): EventReply;
        OnAddedToFocusPath(InFocusEvent: FocusEvent): void;
        ListenForInputAction(ActionName: string, EventType: number, bConsume: boolean, Callback: $Delegate<() => void>): void;
        IsPlayingAnimation(): boolean;
        IsListeningForInputAction(ActionName: string): boolean;
        IsInViewport(): boolean;
        IsInteractable(): boolean;
        IsAnyAnimationPlaying(): boolean;
        IsAnimationPlayingForward(InAnimation: WidgetAnimation): boolean;
        IsAnimationPlaying(InAnimation: WidgetAnimation): boolean;
        GetOwningPlayerPawn(): Pawn;
        GetIsVisible(): boolean;
        GetAnimationCurrentTime(InAnimation: WidgetAnimation): number;
        GetAnchorsInViewport(): Anchors;
        GetAlignmentInViewport(): Vector2D;
        Destruct(): void;
        Construct(): void;
        CancelLatentActions(): void;
        BindToAnimationStarted(Animation: WidgetAnimation, Delegate: $Delegate<() => void>): void;
        BindToAnimationFinished(Animation: WidgetAnimation, Delegate: $Delegate<() => void>): void;
        BindToAnimationEvent(Animation: WidgetAnimation, Delegate: $Delegate<() => void>, AnimationEvent: EWidgetAnimationEvent, UserTag: string): void;
        AddToViewport(ZOrder: number): void;
        AddToPlayerScreen(ZOrder: number): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserWidget;
        static Load(InName: string): UserWidget;
    }
    
    class ViewTargetTransitionParams {
        constructor(BlendTime: number, BlendFunction: number, BlendExp: number, bLockOutgoing: boolean);
        BlendTime: number;
        BlendFunction: number;
        BlendExp: number;
        bLockOutgoing: boolean;
    }
    
    class UpdateLevelVisibilityLevelInfo {
        constructor(PackageName: string, FileName: string, bIsVisible: boolean);
        PackageName: string;
        FileName: string;
        bIsVisible: boolean;
    }
    
    class HapticFeedbackEffect_Base extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Base;
        static Load(InName: string): HapticFeedbackEffect_Base;
    }
    
    class LatentActionInfo {
        constructor(Linkage: number, UUID: number, ExecutionFunction: string, CallbackTarget: Object);
        Linkage: number;
        UUID: number;
        ExecutionFunction: string;
        CallbackTarget: Object;
    }
    
    class UpdateLevelStreamingLevelStatus {
        constructor(PackageName: string, LODIndex: number, bNewShouldBeLoaded: boolean, bNewShouldBeVisible: boolean, bNewShouldBlockOnLoad: boolean);
        PackageName: string;
        LODIndex: number;
        bNewShouldBeLoaded: boolean;
        bNewShouldBeVisible: boolean;
        bNewShouldBlockOnLoad: boolean;
    }
    
    class ForceFeedbackParameters {
        constructor(Tag: string, bLooping: boolean, bIgnoreTimeDilation: boolean, bPlayWhilePaused: boolean);
        Tag: string;
        bLooping: boolean;
        bIgnoreTimeDilation: boolean;
        bPlayWhilePaused: boolean;
    }
    
    class PlayerController extends Controller {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Player: Player;
        AcknowledgedPawn: Pawn;
        ControllingDirTrackInst: InterpTrackInstDirector;
        MyHUD: HUD;
        PlayerCameraManager: PlayerCameraManager;
        PlayerCameraManagerClass: Class;
        bAutoManageActiveCameraTarget: boolean;
        TargetViewRotation: Rotator;
        SmoothTargetViewRotationSpeed: number;
        HiddenActors: TArray<Actor>;
        HiddenPrimitiveComponents: TArray<TWeakObjectPtr<PrimitiveComponent>>;
        LastSpectatorStateSynchTime: number;
        LastSpectatorSyncLocation: Vector;
        LastSpectatorSyncRotation: Rotator;
        ClientCap: number;
        CheatManager: CheatManager;
        CheatClass: Class;
        PlayerInput: PlayerInput;
        ActiveForceFeedbackEffects: TArray<ActiveForceFeedbackEffect>;
        bPlayerIsWaiting: boolean;
        NetPlayerIndex: number;
        PendingSwapConnection: NetConnection;
        NetConnection: NetConnection;
        InputYawScale: number;
        InputPitchScale: number;
        InputRollScale: number;
        bShowMouseCursor: boolean;
        bEnableClickEvents: boolean;
        bEnableTouchEvents: boolean;
        bEnableMouseOverEvents: boolean;
        bEnableTouchOverEvents: boolean;
        bForceFeedbackEnabled: boolean;
        ForceFeedbackScale: number;
        ClickEventKeys: TArray<Key>;
        DefaultMouseCursor: number;
        CurrentMouseCursor: number;
        DefaultClickTraceChannel: number;
        CurrentClickTraceChannel: number;
        HitResultTraceDistance: number;
        SeamlessTravelCount: number;
        LastCompletedSeamlessTravelCount: number;
        InactiveStateInputComponent: InputComponent;
        bShouldPerformFullTickWhenPaused: boolean;
        CurrentTouchInterface: TouchInterface;
        SpectatorPawn: SpectatorPawn;
        bIsLocalPlayerController: boolean;
        SpawnLocation: Vector;
        WasInputKeyJustReleased(Key: Key): boolean;
        WasInputKeyJustPressed(Key: Key): boolean;
        ToggleSpeaking(bInSpeaking: boolean): void;
        TestServerLevelVisibilityChange(PackageName: string, FileName: string): void;
        SwitchLevel(URL: string): void;
        StopHapticEffect(Hand: EControllerHand): void;
        StartFire(FireModeNum: number): void;
        SetVirtualJoystickVisibility(bVisible: boolean): void;
        SetViewTargetWithBlend(NewViewTarget: Actor, BlendTime: number, BlendFunc: number, BlendExp: number, bLockOutgoing: boolean): void;
        SetName(S: string): void;
        SetMouseLocation(X: number, Y: number): void;
        SetMouseCursorWidget(Cursor: number, CursorWidget: UserWidget): void;
        SetHapticsByValue(Frequency: number, Amplitude: number, Hand: EControllerHand): void;
        SetDisableHaptics(bNewDisabled: boolean): void;
        SetControllerLightColor(Color: Color): void;
        SetCinematicMode(bInCinematicMode: boolean, bHidePlayer: boolean, bAffectsHUD: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean): void;
        SetAudioListenerOverride(AttachToComponent: SceneComponent, Location: Vector, Rotation: Rotator): void;
        SetAudioListenerAttenuationOverride(AttachToComponent: SceneComponent, AttenuationLocationOVerride: Vector): void;
        ServerViewSelf(TransitionParams: ViewTargetTransitionParams): void;
        ServerViewPrevPlayer(): void;
        ServerViewNextPlayer(): void;
        ServerVerifyViewTarget(): void;
        ServerUpdateMultipleLevelsVisibility(LevelVisibilities: TArray<UpdateLevelVisibilityLevelInfo>): void;
        ServerUpdateLevelVisibility(LevelVisibility: UpdateLevelVisibilityLevelInfo): void;
        ServerUpdateCamera(CamLoc: Vector_NetQuantize, CamPitchAndYaw: number): void;
        ServerUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
        ServerToggleAILogging(): void;
        ServerShortTimeout(): void;
        ServerSetSpectatorWaiting(bWaiting: boolean): void;
        ServerSetSpectatorLocation(NewLoc: Vector, NewRot: Rotator): void;
        ServerRestartPlayer(): void;
        ServerPause(): void;
        ServerNotifyLoadedWorld(WorldPackageName: string): void;
        ServerMutePlayer(PlayerId: UniqueNetIdRepl): void;
        ServerExecRPC(Msg: string): void;
        ServerExec(Msg: string): void;
        ServerCheckClientPossessionReliable(): void;
        ServerCheckClientPossession(): void;
        ServerChangeName(S: string): void;
        ServerCamera(NewMode: string): void;
        ServerAcknowledgePossession(P: Pawn): void;
        SendToConsole(Command: string): void;
        RestartLevel(): void;
        ResetControllerLightColor(): void;
        ProjectWorldLocationToScreen(WorldLocation: Vector, ScreenLocation: $Ref<Vector2D>, bPlayerViewportRelative: boolean): boolean;
        PlayHapticEffect(HapticEffect: HapticFeedbackEffect_Base, Hand: EControllerHand, Scale: number, bLoop: boolean): void;
        PlayDynamicForceFeedback(Intensity: number, Duration: number, bAffectsLeftLarge: boolean, bAffectsLeftSmall: boolean, bAffectsRightLarge: boolean, bAffectsRightSmall: boolean, Action: number, LatentInfo: LatentActionInfo): void;
        Pause(): void;
        OnServerStartedVisualLogger(bIsLogging: boolean): void;
        LocalTravel(URL: string): void;
        K2_ClientPlayForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect, Tag: string, bLooping: boolean, bIgnoreTimeDilation: boolean, bPlayWhilePaused: boolean): void;
        IsInputKeyDown(Key: Key): boolean;
        GetViewportSize(SizeX: $Ref<number>, SizeY: $Ref<number>): void;
        GetSpectatorPawn(): SpectatorPawn;
        GetMousePosition(LocationX: $Ref<number>, LocationY: $Ref<number>): boolean;
        GetInputVectorKeyState(Key: Key): Vector;
        GetInputTouchState(FingerIndex: number, LocationX: $Ref<number>, LocationY: $Ref<number>, bIsCurrentlyPressed: $Ref<boolean>): void;
        GetInputMouseDelta(DeltaX: $Ref<number>, DeltaY: $Ref<number>): void;
        GetInputMotionState(Tilt: $Ref<Vector>, RotationRate: $Ref<Vector>, Gravity: $Ref<Vector>, Acceleration: $Ref<Vector>): void;
        GetInputKeyTimeDown(Key: Key): number;
        GetInputAnalogStickState(WhichStick: number, StickX: $Ref<number>, StickY: $Ref<number>): void;
        GetInputAnalogKeyState(Key: Key): number;
        GetHUD(): HUD;
        GetHitResultUnderFingerForObjects(FingerIndex: number, ObjectTypes: TArray<number>, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;
        GetHitResultUnderFingerByChannel(FingerIndex: number, TraceChannel: number, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;
        GetHitResultUnderFinger(FingerIndex: number, TraceChannel: number, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;
        GetHitResultUnderCursorForObjects(ObjectTypes: TArray<number>, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;
        GetHitResultUnderCursorByChannel(TraceChannel: number, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;
        GetHitResultUnderCursor(TraceChannel: number, bTraceComplex: boolean, HitResult: $Ref<HitResult>): boolean;
        GetFocalLocation(): Vector;
        FOV(NewFOV: number): void;
        EnableCheats(): void;
        DeprojectScreenPositionToWorld(ScreenX: number, ScreenY: number, WorldLocation: $Ref<Vector>, WorldDirection: $Ref<Vector>): boolean;
        DeprojectMousePositionToWorld(WorldLocation: $Ref<Vector>, WorldDirection: $Ref<Vector>): boolean;
        ConsoleKey(Key: Key): void;
        ClientWasKicked(KickReason: string): void;
        ClientVoiceHandshakeComplete(): void;
        ClientUpdateMultipleLevelsStreamingStatus(LevelStatuses: TArray<UpdateLevelStreamingLevelStatus>): void;
        ClientUpdateLevelStreamingStatus(PackageName: string, bNewShouldBeLoaded: boolean, bNewShouldBeVisible: boolean, bNewShouldBlockOnLoad: boolean, LODIndex: number): void;
        ClientUnmutePlayer(PlayerId: UniqueNetIdRepl): void;
        ClientTravelInternal(URL: string, TravelType: number, bSeamless: boolean, MapPackageGuid: Guid): void;
        ClientTravel(URL: string, TravelType: number, bSeamless: boolean, MapPackageGuid: Guid): void;
        ClientTeamMessage(SenderPlayerState: PlayerState, S: string, Type: string, MsgLifeTime: number): void;
        ClientStopForceFeedback(ForceFeedbackEffect: ForceFeedbackEffect, Tag: string): void;
        ClientStopCameraShake(Shake: Class, bImmediately: boolean): void;
        ClientStopCameraAnim(AnimToStop: CameraAnim): void;
        ClientStartOnlineSession(): void;
        ClientSpawnCameraLensEffect(LensEffectEmitterClass: Class): void;
        ClientSetViewTarget(A: Actor, TransitionParams: ViewTargetTransitionParams): void;
        ClientSetSpectatorWaiting(bWaiting: boolean): void;
        ClientSetHUD(NewHUDClass: Class): void;
        ClientSetForceMipLevelsToBeResident(Material: MaterialInterface, ForceDuration: number, CinematicTextureGroups: number): void;
        ClientSetCinematicMode(bInCinematicMode: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean, bAffectsHUD: boolean): void;
        ClientSetCameraMode(NewCamMode: string): void;
        ClientSetCameraFade(bEnableFading: boolean, FadeColor: Color, FadeAlpha: Vector2D, FadeTime: number, bFadeAudio: boolean): void;
        ClientSetBlockOnAsyncLoading(): void;
        ClientReturnToMainMenuWithTextReason(ReturnReason: string): void;
        ClientReturnToMainMenu(ReturnReason: string): void;
        ClientRetryClientRestart(NewPawn: Pawn): void;
        ClientRestart(NewPawn: Pawn): void;
        ClientReset(): void;
        ClientRepObjRef(Object: Object): void;
        ClientReceiveLocalizedMessage(Message: Class, Switch: number, RelatedPlayerState_1: PlayerState, RelatedPlayerState_2: PlayerState, OptionalObject: Object): void;
        ClientPrestreamTextures(ForcedActor: Actor, ForceDuration: number, bEnableStreaming: boolean, CinematicTextureGroups: number): void;
        ClientPrepareMapChange(LevelName: string, bFirst: boolean, bLast: boolean): void;
        ClientPlaySoundAtLocation(Sound: SoundBase, Location: Vector, VolumeMultiplier: number, PitchMultiplier: number): void;
        ClientPlaySound(Sound: SoundBase, VolumeMultiplier: number, PitchMultiplier: number): void;
        ClientPlayForceFeedback_Internal(ForceFeedbackEffect: ForceFeedbackEffect, Params: ForceFeedbackParameters): void;
        ClientPlayCameraShake(Shake: Class, Scale: number, PlaySpace: number, UserPlaySpaceRot: Rotator): void;
        ClientPlayCameraAnim(AnimToPlay: CameraAnim, Scale: number, Rate: number, BlendInTime: number, BlendOutTime: number, bLoop: boolean, bRandomStartTime: boolean, Space: number, CustomPlaySpace: Rotator): void;
        ClientMutePlayer(PlayerId: UniqueNetIdRepl): void;
        ClientMessage(S: string, Type: string, MsgLifeTime: number): void;
        ClientIgnoreMoveInput(bIgnore: boolean): void;
        ClientIgnoreLookInput(bIgnore: boolean): void;
        ClientGotoState(NewState: string): void;
        ClientGameEnded(EndGameFocus: Actor, bIsWinner: boolean): void;
        ClientForceGarbageCollection(): void;
        ClientFlushLevelStreaming(): void;
        ClientEndOnlineSession(): void;
        ClientEnableNetworkVoice(bEnable: boolean): void;
        ClientCommitMapChange(): void;
        ClientClearCameraLensEffects(): void;
        ClientCapBandwidth(Cap: number): void;
        ClientCancelPendingMapChange(): void;
        ClientAddTextureStreamingLoc(InLoc: Vector, Duration: number, bOverrideLocation: boolean): void;
        ClearAudioListenerOverride(): void;
        ClearAudioListenerAttenuationOverride(): void;
        CanRestartPlayer(): boolean;
        Camera(NewMode: string): void;
        AddYawInput(Val: number): void;
        AddRollInput(Val: number): void;
        AddPitchInput(Val: number): void;
        ActivateTouchInterface(NewTouchInterface: TouchInterface): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerController;
        static Load(InName: string): PlayerController;
    }
    
    class Controller extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerState: PlayerState;
        OnInstigatedAnyDamage: $MulticastDelegate<(Damage: number, DamageType: DamageType, DamagedActor: Actor, DamageCauser: Actor) => void>;
        StateName: string;
        Pawn: Pawn;
        Character: Character;
        TransformComponent: SceneComponent;
        ControlRotation: Rotator;
        bAttachToPawn: boolean;
        UnPossess(): void;
        StopMovement(): void;
        SetInitialLocationAndRotation(NewLocation: Vector, NewRotation: Rotator): void;
        SetIgnoreMoveInput(bNewMoveInput: boolean): void;
        SetIgnoreLookInput(bNewLookInput: boolean): void;
        SetControlRotation(NewRotation: Rotator): void;
        ResetIgnoreMoveInput(): void;
        ResetIgnoreLookInput(): void;
        ResetIgnoreInputFlags(): void;
        ReceiveUnPossess(UnpossessedPawn: Pawn): void;
        ReceivePossess(PossessedPawn: Pawn): void;
        ReceiveInstigatedAnyDamage(Damage: number, DamageType: DamageType, DamagedActor: Actor, DamageCauser: Actor): void;
        Possess(InPawn: Pawn): void;
        OnRep_PlayerState(): void;
        OnRep_Pawn(): void;
        LineOfSightTo(Other: Actor, ViewPoint: Vector, bAlternateChecks: boolean): boolean;
        K2_GetPawn(): Pawn;
        IsPlayerController(): boolean;
        IsMoveInputIgnored(): boolean;
        IsLookInputIgnored(): boolean;
        IsLocalPlayerController(): boolean;
        IsLocalController(): boolean;
        GetViewTarget(): Actor;
        GetDesiredRotation(): Rotator;
        GetControlRotation(): Rotator;
        ClientSetRotation(NewRotation: Rotator, bResetCamera: boolean): void;
        ClientSetLocation(NewLocation: Vector, NewRotation: Rotator): void;
        CastToPlayerController(): PlayerController;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Controller;
        static Load(InName: string): Controller;
    }
    
    class Pawn extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseControllerRotationPitch: boolean;
        bUseControllerRotationYaw: boolean;
        bUseControllerRotationRoll: boolean;
        bCanAffectNavigationGeneration: boolean;
        BaseEyeHeight: number;
        AutoPossessPlayer: number;
        AutoPossessAI: EAutoPossessAI;
        RemoteViewPitch: number;
        AIControllerClass: Class;
        PlayerState: PlayerState;
        LastHitBy: Controller;
        Controller: Controller;
        ControlInputVector: Vector;
        LastControlInputVector: Vector;
        SpawnDefaultController(): void;
        SetCanAffectNavigationGeneration(bNewValue: boolean, bForceUpdate: boolean): void;
        ReceiveUnpossessed(OldController: Controller): void;
        ReceivePossessed(NewController: Controller): void;
        PawnMakeNoise(Loudness: number, NoiseLocation: Vector, bUseNoiseMakerLocation: boolean, NoiseMaker: Actor): void;
        OnRep_PlayerState(): void;
        OnRep_Controller(): void;
        LaunchPawn(LaunchVelocity: Vector, bXYOverride: boolean, bZOverride: boolean): void;
        K2_GetMovementInputVector(): Vector;
        IsPlayerControlled(): boolean;
        IsPawnControlled(): boolean;
        IsMoveInputIgnored(): boolean;
        IsLocallyControlled(): boolean;
        IsControlled(): boolean;
        IsBotControlled(): boolean;
        GetPendingMovementInputVector(): Vector;
        GetNavAgentLocation(): Vector;
        GetMovementComponent(): PawnMovementComponent;
        static GetMovementBaseActor(Pawn: Pawn): Actor;
        GetLastMovementInputVector(): Vector;
        GetControlRotation(): Rotator;
        GetController(): Controller;
        GetBaseAimRotation(): Rotator;
        DetachFromControllerPendingDestroy(): void;
        ConsumeMovementInputVector(): Vector;
        AddMovementInput(WorldDirection: Vector, ScaleValue: number, bForce: boolean): void;
        AddControllerYawInput(Val: number): void;
        AddControllerRollInput(Val: number): void;
        AddControllerPitchInput(Val: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Pawn;
        static Load(InName: string): Pawn;
    }
    
    class PrimitiveComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinDrawDistance: number;
        LDMaxDrawDistance: number;
        CachedMaxDrawDistance: number;
        DepthPriorityGroup: number;
        ViewOwnerDepthPriorityGroup: number;
        IndirectLightingCacheQuality: number;
        LightmapType: ELightmapType;
        ExcludeForSpecificHLODLevels: TArray<number>;
        bEnableAutoLODGeneration: boolean;
        bUseMaxLODAsImposter: boolean;
        bBatchImpostersAsInstances: boolean;
        bNeverDistanceCull: boolean;
        bAlwaysCreatePhysicsState: boolean;
        bGenerateOverlapEvents: boolean;
        bMultiBodyOverlap: boolean;
        bTraceComplexOnMove: boolean;
        bReturnMaterialOnMove: boolean;
        bUseViewOwnerDepthPriorityGroup: boolean;
        bAllowCullDistanceVolume: boolean;
        bHasMotionBlurVelocityMeshes: boolean;
        bVisibleInReflectionCaptures: boolean;
        bVisibleInRayTracing: boolean;
        bRenderInMainPass: boolean;
        bRenderInDepthPass: boolean;
        bReceivesDecals: boolean;
        bOwnerNoSee: boolean;
        bOnlyOwnerSee: boolean;
        bTreatAsBackgroundForOcclusion: boolean;
        bUseAsOccluder: boolean;
        bSelectable: boolean;
        bForceMipStreaming: boolean;
        bHasPerInstanceHitProxies: boolean;
        CastShadow: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bAffectDistanceFieldLighting: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastVolumetricTranslucentShadow: boolean;
        bSelfShadowOnly: boolean;
        bCastFarShadow: boolean;
        bCastInsetShadow: boolean;
        bCastCinematicShadow: boolean;
        bCastHiddenShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bLightAsIfStatic: boolean;
        bLightAttachmentsAsGroup: boolean;
        bExcludeFromLightAttachmentGroup: boolean;
        bReceiveMobileCSMShadows: boolean;
        bSingleSampleShadowFromStationaryLights: boolean;
        bIgnoreRadialImpulse: boolean;
        bIgnoreRadialForce: boolean;
        bApplyImpulseOnDamage: boolean;
        bReplicatePhysicsToAutonomousProxy: boolean;
        AlwaysLoadOnClient: boolean;
        AlwaysLoadOnServer: boolean;
        bUseEditorCompositing: boolean;
        bRenderCustomDepth: boolean;
        bHasCustomNavigableGeometry: number;
        CanBeCharacterBase: number;
        CanCharacterStepUpOn: number;
        LightingChannels: LightingChannels;
        CustomDepthStencilWriteMask: ERendererStencilMask;
        CustomDepthStencilValue: number;
        CustomPrimitiveData: CustomPrimitiveData;
        TranslucencySortPriority: number;
        VisibilityId: number;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMinCoverage: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        LpvBiasMultiplier: number;
        BoundsScale: number;
        MoveIgnoreActors: TArray<Actor>;
        MoveIgnoreComponents: TArray<PrimitiveComponent>;
        BodyInstance: BodyInstance;
        OnComponentHit: $MulticastDelegate<(HitComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, NormalImpulse: Vector, Hit: HitResult) => void>;
        OnComponentBeginOverlap: $MulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, SweepResult: HitResult) => void>;
        OnComponentEndOverlap: $MulticastDelegate<(OverlappedComponent: PrimitiveComponent, OtherActor: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number) => void>;
        OnComponentWake: $MulticastDelegate<(WakingComponent: PrimitiveComponent, BoneName: string) => void>;
        OnComponentSleep: $MulticastDelegate<(SleepingComponent: PrimitiveComponent, BoneName: string) => void>;
        OnBeginCursorOver: $MulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
        OnEndCursorOver: $MulticastDelegate<(TouchedComponent: PrimitiveComponent) => void>;
        OnClicked: $MulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonPressed: Key) => void>;
        OnReleased: $MulticastDelegate<(TouchedComponent: PrimitiveComponent, ButtonReleased: Key) => void>;
        OnInputTouchBegin: $MulticastDelegate<(FingerIndex: number, TouchedComponent: PrimitiveComponent) => void>;
        OnInputTouchEnd: $MulticastDelegate<(FingerIndex: number, TouchedComponent: PrimitiveComponent) => void>;
        OnInputTouchEnter: $MulticastDelegate<(FingerIndex: number, TouchedComponent: PrimitiveComponent) => void>;
        OnInputTouchLeave: $MulticastDelegate<(FingerIndex: number, TouchedComponent: PrimitiveComponent) => void>;
        LODParentPrimitive: PrimitiveComponent;
        WakeRigidBody(BoneName: string): void;
        WakeAllRigidBodies(): void;
        SetWalkableSlopeOverride(NewOverride: WalkableSlopeOverride): void;
        SetUseCCD(InUseCCD: boolean, BoneName: string): void;
        SetTranslucentSortPriority(NewTranslucentSortPriority: number): void;
        SetSingleSampleShadowFromStationaryLights(bNewSingleSampleShadowFromStationaryLights: boolean): void;
        SetSimulatePhysics(bSimulate: boolean): void;
        SetRenderInMainPass(bValue: boolean): void;
        SetRenderCustomDepth(bValue: boolean): void;
        SetReceivesDecals(bNewReceivesDecals: boolean): void;
        SetPhysMaterialOverride(NewPhysMaterial: PhysicalMaterial): void;
        SetPhysicsMaxAngularVelocityInRadians(NewMaxAngVel: number, bAddToCurrent: boolean, BoneName: string): void;
        SetPhysicsMaxAngularVelocityInDegrees(NewMaxAngVel: number, bAddToCurrent: boolean, BoneName: string): void;
        SetPhysicsMaxAngularVelocity(NewMaxAngVel: number, bAddToCurrent: boolean, BoneName: string): void;
        SetPhysicsLinearVelocity(NewVel: Vector, bAddToCurrent: boolean, BoneName: string): void;
        SetPhysicsAngularVelocityInRadians(NewAngVel: Vector, bAddToCurrent: boolean, BoneName: string): void;
        SetPhysicsAngularVelocityInDegrees(NewAngVel: Vector, bAddToCurrent: boolean, BoneName: string): void;
        SetPhysicsAngularVelocity(NewAngVel: Vector, bAddToCurrent: boolean, BoneName: string): void;
        SetOwnerNoSee(bNewOwnerNoSee: boolean): void;
        SetOnlyOwnerSee(bNewOnlyOwnerSee: boolean): void;
        SetNotifyRigidBodyCollision(bNewNotifyRigidBodyCollision: boolean): void;
        SetMaterialByName(MaterialSlotName: string, Material: MaterialInterface): void;
        SetMaterial(ElementIndex: number, Material: MaterialInterface): void;
        SetMassScale(BoneName: string, InMassScale: number): void;
        SetMassOverrideInKg(BoneName: string, MassInKg: number, bOverrideMass: boolean): void;
        SetLinearDamping(InDamping: number): void;
        SetLightAttachmentsAsGroup(bInLightAttachmentsAsGroup: boolean): void;
        SetGenerateOverlapEvents(bInGenerateOverlapEvents: boolean): void;
        SetExcludeFromLightAttachmentGroup(bInExcludeFromLightAttachmentGroup: boolean): void;
        SetEnableGravity(bGravityEnabled: boolean): void;
        SetCustomPrimitiveDataVector4(DataIndex: number, Value: Vector4): void;
        SetCustomPrimitiveDataVector3(DataIndex: number, Value: Vector): void;
        SetCustomPrimitiveDataVector2(DataIndex: number, Value: Vector2D): void;
        SetCustomPrimitiveDataFloat(DataIndex: number, Value: number): void;
        SetCustomDepthStencilWriteMask(WriteMaskBit: ERendererStencilMask): void;
        SetCustomDepthStencilValue(Value: number): void;
        SetCullDistance(NewCullDistance: number): void;
        SetConstraintMode(ConstraintMode: number): void;
        SetCollisionResponseToChannel(Channel: number, NewResponse: number): void;
        SetCollisionResponseToAllChannels(NewResponse: number): void;
        SetCollisionProfileName(InCollisionProfileName: string): void;
        SetCollisionObjectType(Channel: number): void;
        SetCollisionEnabled(NewType: number): void;
        SetCenterOfMass(CenterOfMassOffset: Vector, BoneName: string): void;
        SetCastShadow(NewCastShadow: boolean): void;
        SetCastInsetShadow(bInCastInsetShadow: boolean): void;
        SetBoundsScale(NewBoundsScale: number): void;
        SetAngularDamping(InDamping: number): void;
        SetAllUseCCD(InUseCCD: boolean): void;
        SetAllPhysicsLinearVelocity(NewVel: Vector, bAddToCurrent: boolean): void;
        SetAllPhysicsAngularVelocityInRadians(NewAngVel: Vector, bAddToCurrent: boolean): void;
        SetAllPhysicsAngularVelocityInDegrees(NewAngVel: Vector, bAddToCurrent: boolean): void;
        SetAllMassScale(InMassScale: number): void;
        ScaleByMomentOfInertia(InputVector: Vector, BoneName: string): Vector;
        PutRigidBodyToSleep(BoneName: string): void;
        K2_SphereTraceComponent(TraceStart: Vector, TraceEnd: Vector, SphereRadius: number, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;
        K2_SphereOverlapComponent(InSphereCentre: Vector, InSphereRadius: number, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;
        K2_LineTraceComponent(TraceStart: Vector, TraceEnd: Vector, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;
        K2_IsQueryCollisionEnabled(): boolean;
        K2_IsPhysicsCollisionEnabled(): boolean;
        K2_IsCollisionEnabled(): boolean;
        K2_BoxOverlapComponent(InBoxCentre: Vector, InBox: Box, bTraceComplex: boolean, bShowTrace: boolean, bPersistentShowTrace: boolean, HitLocation: $Ref<Vector>, HitNormal: $Ref<Vector>, BoneName: $Ref<string>, OutHit: $Ref<HitResult>): boolean;
        IsOverlappingComponent(OtherComp: PrimitiveComponent): boolean;
        IsOverlappingActor(Other: Actor): boolean;
        IsGravityEnabled(): boolean;
        IsAnyRigidBodyAwake(): boolean;
        IgnoreComponentWhenMoving(Component: PrimitiveComponent, bShouldIgnore: boolean): void;
        IgnoreActorWhenMoving(Actor: Actor, bShouldIgnore: boolean): void;
        GetWalkableSlopeOverride(): WalkableSlopeOverride;
        GetPhysicsLinearVelocityAtPoint(Point: Vector, BoneName: string): Vector;
        GetPhysicsLinearVelocity(BoneName: string): Vector;
        GetPhysicsAngularVelocityInRadians(BoneName: string): Vector;
        GetPhysicsAngularVelocityInDegrees(BoneName: string): Vector;
        GetPhysicsAngularVelocity(BoneName: string): Vector;
        GetOverlappingComponents(OutOverlappingComponents: $Ref<TArray<PrimitiveComponent>>): void;
        GetOverlappingActors(OverlappingActors: $Ref<TArray<Actor>>, ClassFilter: Class): void;
        GetNumMaterials(): number;
        GetMaterialFromCollisionFaceIndex(FaceIndex: number, SectionIndex: $Ref<number>): MaterialInterface;
        GetMaterial(ElementIndex: number): MaterialInterface;
        GetMassScale(BoneName: string): number;
        GetMass(): number;
        GetLinearDamping(): number;
        GetInertiaTensor(BoneName: string): Vector;
        GetGenerateOverlapEvents(): boolean;
        GetCollisionResponseToChannel(Channel: number): number;
        GetCollisionProfileName(): string;
        GetCollisionObjectType(): number;
        GetCollisionEnabled(): number;
        GetClosestPointOnCollision(Point: Vector, OutPointOnBody: $Ref<Vector>, BoneName: string): number;
        GetCenterOfMass(BoneName: string): Vector;
        GetAngularDamping(): number;
        CreateDynamicMaterialInstance(ElementIndex: number, SourceMaterial: MaterialInterface, OptionalName: string): MaterialInstanceDynamic;
        CreateAndSetMaterialInstanceDynamicFromMaterial(ElementIndex: number, Parent: MaterialInterface): MaterialInstanceDynamic;
        CreateAndSetMaterialInstanceDynamic(ElementIndex: number): MaterialInstanceDynamic;
        CopyArrayOfMoveIgnoreComponents(): TArray<PrimitiveComponent>;
        CopyArrayOfMoveIgnoreActors(): TArray<Actor>;
        ClearMoveIgnoreComponents(): void;
        ClearMoveIgnoreActors(): void;
        CanCharacterStepUp(Pawn: Pawn): boolean;
        AddTorqueInRadians(Torque: Vector, BoneName: string, bAccelChange: boolean): void;
        AddTorqueInDegrees(Torque: Vector, BoneName: string, bAccelChange: boolean): void;
        AddTorque(Torque: Vector, BoneName: string, bAccelChange: boolean): void;
        AddRadialImpulse(Origin: Vector, Radius: number, Strength: number, Falloff: number, bVelChange: boolean): void;
        AddRadialForce(Origin: Vector, Radius: number, Strength: number, Falloff: number, bAccelChange: boolean): void;
        AddImpulseAtLocation(Impulse: Vector, Location: Vector, BoneName: string): void;
        AddImpulse(Impulse: Vector, BoneName: string, bVelChange: boolean): void;
        AddForceAtLocationLocal(Force: Vector, Location: Vector, BoneName: string): void;
        AddForceAtLocation(Force: Vector, Location: Vector, BoneName: string): void;
        AddForce(Force: Vector, BoneName: string, bAccelChange: boolean): void;
        AddAngularImpulseInRadians(Impulse: Vector, BoneName: string, bVelChange: boolean): void;
        AddAngularImpulseInDegrees(Impulse: Vector, BoneName: string, bVelChange: boolean): void;
        AddAngularImpulse(Impulse: Vector, BoneName: string, bVelChange: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimitiveComponent;
        static Load(InName: string): PrimitiveComponent;
    }
    
    class BrushComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Brush: Model;
        BrushBodySetup: BodySetup;
        PrePivot: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushComponent;
        static Load(InName: string): BrushComponent;
    }
    
    class BuilderPoly {
        constructor(VertexIndices: TArray<number>, Direction: number, ItemName: string, PolyFlags: number);
        VertexIndices: TArray<number>;
        Direction: number;
        ItemName: string;
        PolyFlags: number;
    }
    
    class BrushBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BitmapFilename: string;
        ToolTip: string;
        NotifyBadParams: boolean;
        Vertices: TArray<Vector>;
        Polys: TArray<BuilderPoly>;
        Layer: string;
        MergeCoplanars: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushBuilder;
        static Load(InName: string): BrushBuilder;
    }
    
    class GeomSelection {
        constructor(Type: number, Index: number, SelectionIndex: number);
        Type: number;
        Index: number;
        SelectionIndex: number;
    }
    
    class Brush extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrushType: number;
        BrushColor: Color;
        PolyFlags: number;
        bColored: boolean;
        bSolidWhenSelected: boolean;
        bPlaceableFromClassBrowser: boolean;
        bNotForClientOrServer: boolean;
        Brush: Model;
        BrushComponent: BrushComponent;
        BrushBuilder: BrushBuilder;
        bInManipulation: boolean;
        SavedSelections: TArray<GeomSelection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Brush;
        static Load(InName: string): Brush;
    }
    
    class Volume extends Brush {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Volume;
        static Load(InName: string): Volume;
    }
    
    class PhysicsVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TerminalVelocity: number;
        Priority: number;
        FluidFriction: number;
        bWaterVolume: boolean;
        bPhysicsOnContact: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsVolume;
        static Load(InName: string): PhysicsVolume;
    }
    
    enum EDetachmentRule { KeepRelative, KeepWorld, EDetachmentRule_MAX}
    class SceneComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsVolume: TWeakObjectPtr<PhysicsVolume>;
        AttachParent: SceneComponent;
        AttachSocketName: string;
        AttachChildren: TArray<SceneComponent>;
        ClientAttachedChildren: TArray<SceneComponent>;
        RelativeLocation: Vector;
        RelativeRotation: Rotator;
        RelativeScale3D: Vector;
        ComponentVelocity: Vector;
        bComponentToWorldUpdated: boolean;
        bAbsoluteLocation: boolean;
        bAbsoluteRotation: boolean;
        bAbsoluteScale: boolean;
        bVisible: boolean;
        bHiddenInGame: boolean;
        bShouldBeAttached: boolean;
        bShouldSnapLocationWhenAttached: boolean;
        bShouldSnapRotationWhenAttached: boolean;
        bShouldUpdatePhysicsVolume: boolean;
        bBoundsChangeTriggersStreamingDataRebuild: boolean;
        bUseAttachParentBound: boolean;
        bVisualizeComponent: boolean;
        Mobility: number;
        DetailMode: number;
        PhysicsVolumeChangedDelegate: $MulticastDelegate<(NewVolume: PhysicsVolume) => void>;
        ToggleVisibility(bPropagateToChildren: boolean): void;
        SnapTo(InParent: SceneComponent, InSocketName: string): boolean;
        SetWorldScale3D(NewScale: Vector): void;
        SetVisibility(bNewVisibility: boolean, bPropagateToChildren: boolean): void;
        SetShouldUpdatePhysicsVolume(bInShouldUpdatePhysicsVolume: boolean): void;
        SetRelativeScale3D(NewScale3D: Vector): void;
        SetMobility(NewMobility: number): void;
        SetHiddenInGame(NewHidden: boolean, bPropagateToChildren: boolean): void;
        SetAbsolute(bNewAbsoluteLocation: boolean, bNewAbsoluteRotation: boolean, bNewAbsoluteScale: boolean): void;
        ResetRelativeTransform(): void;
        OnRep_Visibility(OldValue: boolean): void;
        OnRep_Transform(): void;
        OnRep_AttachSocketName(): void;
        OnRep_AttachParent(): void;
        OnRep_AttachChildren(): void;
        K2_SetWorldTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetWorldRotation(NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetWorldLocationAndRotation(NewLocation: Vector, NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetWorldLocation(NewLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetRelativeTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetRelativeRotation(NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetRelativeLocationAndRotation(NewLocation: Vector, NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetRelativeLocation(NewLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_GetComponentToWorld(): Transform;
        K2_GetComponentScale(): Vector;
        K2_GetComponentRotation(): Rotator;
        K2_GetComponentLocation(): Vector;
        K2_DetachFromComponent(LocationRule: EDetachmentRule, RotationRule: EDetachmentRule, ScaleRule: EDetachmentRule, bCallModify: boolean): void;
        K2_AttachToComponent(Parent: SceneComponent, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule, bWeldSimulatedBodies: boolean): boolean;
        K2_AttachTo(InParent: SceneComponent, InSocketName: string, AttachType: number, bWeldSimulatedBodies: boolean): boolean;
        K2_AddWorldTransform(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddWorldRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddWorldOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddRelativeRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddRelativeLocation(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddLocalTransform(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddLocalRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddLocalOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        IsVisible(): boolean;
        IsSimulatingPhysics(BoneName: string): boolean;
        IsAnySimulatingPhysics(): boolean;
        GetUpVector(): Vector;
        GetSocketTransform(InSocketName: string, TransformSpace: number): Transform;
        GetSocketRotation(InSocketName: string): Rotator;
        GetSocketQuaternion(InSocketName: string): Quat;
        GetSocketLocation(InSocketName: string): Vector;
        GetShouldUpdatePhysicsVolume(): boolean;
        GetRightVector(): Vector;
        GetRelativeTransform(): Transform;
        GetPhysicsVolume(): PhysicsVolume;
        GetParentComponents(Parents: $Ref<TArray<SceneComponent>>): void;
        GetNumChildrenComponents(): number;
        GetForwardVector(): Vector;
        GetComponentVelocity(): Vector;
        GetChildrenComponents(bIncludeAllDescendants: boolean, Children: $Ref<TArray<SceneComponent>>): void;
        GetChildComponent(ChildIndex: number): SceneComponent;
        GetAttachSocketName(): string;
        GetAttachParent(): SceneComponent;
        GetAllSocketNames(): TArray<string>;
        DoesSocketExist(InSocketName: string): boolean;
        DetachFromParent(bMaintainWorldPosition: boolean, bCallModify: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneComponent;
        static Load(InName: string): SceneComponent;
    }
    
    class RepAttachment {
        constructor(AttachParent: Actor, LocationOffset: Vector_NetQuantize100, RelativeScale3D: Vector_NetQuantize100, RotationOffset: Rotator, AttachSocket: string, AttachComponent: SceneComponent);
        AttachParent: Actor;
        LocationOffset: Vector_NetQuantize100;
        RelativeScale3D: Vector_NetQuantize100;
        RotationOffset: Rotator;
        AttachSocket: string;
        AttachComponent: SceneComponent;
    }
    
    enum ESpawnActorCollisionHandlingMethod { Undefined, AlwaysSpawn, AdjustIfPossibleButAlwaysSpawn, AdjustIfPossibleButDontSpawnIfColliding, DontSpawnIfColliding, ESpawnActorCollisionHandlingMethod_MAX}
    class InterpFilter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Caption: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpFilter;
        static Load(InName: string): InterpFilter;
    }
    
    class InterpGroupDirector extends InterpGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupDirector;
        static Load(InName: string): InterpGroupDirector;
    }
    
    class InterpData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InterpLength: number;
        PathBuildTime: number;
        InterpGroups: TArray<InterpGroup>;
        CurveEdSetup: InterpCurveEdSetup;
        InterpFilters: TArray<InterpFilter>;
        SelectedFilter: InterpFilter;
        DefaultFilters: TArray<InterpFilter>;
        EdSectionStart: number;
        EdSectionEnd: number;
        bShouldBakeAndPrune: boolean;
        CachedDirectorGroup: InterpGroupDirector;
        AllEventNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpData;
        static Load(InName: string): InterpData;
    }
    
    class InterpGroupActorInfo {
        constructor(ObjectName: string, Actors: TArray<Actor>);
        ObjectName: string;
        Actors: TArray<Actor>;
    }
    
    class CameraCutInfo {
        constructor(Location: Vector, TimeStamp: number);
        Location: Vector;
        TimeStamp: number;
    }
    
    class MatineeActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatineeData: InterpData;
        MatineeControllerName: string;
        PlayRate: number;
        bPlayOnLevelLoad: boolean;
        bForceStartPos: boolean;
        ForceStartPosition: number;
        bLooping: boolean;
        bRewindOnPlay: boolean;
        bNoResetOnRewind: boolean;
        bRewindIfAlreadyPlaying: boolean;
        bDisableRadioFilter: boolean;
        bClientSideOnly: boolean;
        bSkipUpdateIfNotVisible: boolean;
        bIsSkippable: boolean;
        PreferredSplitScreenNum: number;
        bDisableMovementInput: boolean;
        bDisableLookAtInput: boolean;
        bHidePlayer: boolean;
        bHideHud: boolean;
        GroupActorInfos: TArray<InterpGroupActorInfo>;
        bShouldShowGore: boolean;
        GroupInst: TArray<InterpGroupInst>;
        CameraCuts: TArray<CameraCutInfo>;
        SpriteComponent: BillboardComponent;
        bIsBeingEdited: boolean;
        bIsScrubbing: boolean;
        bIsPlaying: boolean;
        bReversePlayback: boolean;
        bPaused: boolean;
        bPendingStop: boolean;
        InterpPosition: number;
        ReplicationForceIsPlaying: number;
        OnPlay: $MulticastDelegate<() => void>;
        OnStop: $MulticastDelegate<() => void>;
        OnPause: $MulticastDelegate<() => void>;
        Stop(): void;
        SetPosition(NewPosition: number, bJump: boolean): void;
        SetLoopingState(bNewLooping: boolean): void;
        Reverse(): void;
        Play(): void;
        Pause(): void;
        EnableGroupByName(GroupName: string, bEnable: boolean): void;
        ChangePlaybackDirection(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeActor;
        static Load(InName: string): MatineeActor;
    }
    
    class ChildActorComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildActorClass: Class;
        ChildActor: Actor;
        ChildActorTemplate: Actor;
        SetChildActorClass(InClass: Class): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChildActorComponent;
        static Load(InName: string): ChildActorComponent;
    }
    
    class Actor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryActorTick: ActorTickFunction;
        bHidden: boolean;
        bNetTemporary: boolean;
        bNetStartup: boolean;
        bOnlyRelevantToOwner: boolean;
        bAlwaysRelevant: boolean;
        bReplicateMovement: boolean;
        bTearOff: boolean;
        bExchangedRoles: boolean;
        bNetLoadOnClient: boolean;
        bNetUseOwnerRelevancy: boolean;
        bRelevantForNetworkReplays: boolean;
        bRelevantForLevelBounds: boolean;
        bReplayRewindable: boolean;
        bAllowTickBeforeBeginPlay: boolean;
        bAutoDestroyWhenFinished: boolean;
        bBlockInput: boolean;
        bCanBeDamaged: boolean;
        bCollideWhenPlacing: boolean;
        bFindCameraComponentWhenViewTarget: boolean;
        bGenerateOverlapEventsDuringLevelStreaming: boolean;
        bIgnoresOriginShifting: boolean;
        bEnableAutoLODGeneration: boolean;
        bIsEditorOnlyActor: boolean;
        bActorSeamlessTraveled: boolean;
        bReplicates: boolean;
        bCanBeInCluster: boolean;
        bAllowReceiveTickEventOnDedicatedServer: boolean;
        bActorEnableCollision: boolean;
        bActorIsBeingDestroyed: boolean;
        UpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
        DefaultUpdateOverlapsMethodDuringLevelStreaming: EActorUpdateOverlapsMethod;
        RemoteRole: number;
        ReplicatedMovement: RepMovement;
        InitialLifeSpan: number;
        CustomTimeDilation: number;
        AttachmentReplication: RepAttachment;
        Owner: Actor;
        NetDriverName: string;
        Role: number;
        NetDormancy: number;
        SpawnCollisionHandlingMethod: ESpawnActorCollisionHandlingMethod;
        AutoReceiveInput: number;
        InputPriority: number;
        InputComponent: InputComponent;
        NetCullDistanceSquared: number;
        NetTag: number;
        NetUpdateFrequency: number;
        MinNetUpdateFrequency: number;
        NetPriority: number;
        Instigator: Pawn;
        Children: TArray<Actor>;
        RootComponent: SceneComponent;
        PivotOffset: Vector;
        ControllingMatineeActors: TArray<MatineeActor>;
        Layers: TArray<string>;
        ParentComponentActor: TWeakObjectPtr<Actor>;
        ParentComponent: TWeakObjectPtr<ChildActorComponent>;
        GroupActor: Actor;
        SpriteScale: number;
        HiddenEditorViews: bigint;
        ActorLabel: string;
        FolderPath: string;
        bHiddenEd: boolean;
        bIsEditorPreviewActor: boolean;
        bHiddenEdLayer: boolean;
        bHiddenEdLevel: boolean;
        bLockLocation: boolean;
        bActorLabelEditable: boolean;
        bEditable: boolean;
        bListedInSceneOutliner: boolean;
        bOptimizeBPComponentData: boolean;
        bHiddenEdTemporary: boolean;
        Tags: TArray<string>;
        OnTakeAnyDamage: $MulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor) => void>;
        OnTakePointDamage: $MulticastDelegate<(DamagedActor: Actor, Damage: number, InstigatedBy: Controller, HitLocation: Vector, FHitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
        OnTakeRadialDamage: $MulticastDelegate<(DamagedActor: Actor, Damage: number, DamageType: DamageType, Origin: Vector, HitInfo: HitResult, InstigatedBy: Controller, DamageCauser: Actor) => void>;
        OnActorBeginOverlap: $MulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
        OnActorEndOverlap: $MulticastDelegate<(OverlappedActor: Actor, OtherActor: Actor) => void>;
        OnBeginCursorOver: $MulticastDelegate<(TouchedActor: Actor) => void>;
        OnEndCursorOver: $MulticastDelegate<(TouchedActor: Actor) => void>;
        OnClicked: $MulticastDelegate<(TouchedActor: Actor, ButtonPressed: Key) => void>;
        OnReleased: $MulticastDelegate<(TouchedActor: Actor, ButtonReleased: Key) => void>;
        OnInputTouchBegin: $MulticastDelegate<(FingerIndex: number, TouchedActor: Actor) => void>;
        OnInputTouchEnd: $MulticastDelegate<(FingerIndex: number, TouchedActor: Actor) => void>;
        OnInputTouchEnter: $MulticastDelegate<(FingerIndex: number, TouchedActor: Actor) => void>;
        OnInputTouchLeave: $MulticastDelegate<(FingerIndex: number, TouchedActor: Actor) => void>;
        OnActorHit: $MulticastDelegate<(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult) => void>;
        OnDestroyed: $MulticastDelegate<(DestroyedActor: Actor) => void>;
        OnEndPlay: $MulticastDelegate<(Actor: Actor, EndPlayReason: number) => void>;
        InstanceComponents: TArray<ActorComponent>;
        BlueprintCreatedComponents: TArray<ActorComponent>;
        WasRecentlyRendered(Tolerance: number): boolean;
        UserConstructionScript(): void;
        TearOff(): void;
        SnapRootComponentTo(InParentActor: Actor, InSocketName: string): void;
        SetTickGroup(NewTickGroup: number): void;
        SetTickableWhenPaused(bTickableWhenPaused: boolean): void;
        SetReplicates(bInReplicates: boolean): void;
        SetReplicateMovement(bInReplicateMovement: boolean): void;
        SetOwner(NewOwner: Actor): void;
        SetNetDormancy(NewDormancy: number): void;
        SetLifeSpan(InLifespan: number): void;
        SetIsTemporarilyHiddenInEditor(bIsHidden: boolean): void;
        SetFolderPath(NewFolderPath: string): void;
        SetActorTickInterval(TickInterval: number): void;
        SetActorTickEnabled(bEnabled: boolean): void;
        SetActorScale3D(NewScale3D: Vector): void;
        SetActorRelativeScale3D(NewRelativeScale: Vector): void;
        SetActorLabel(NewActorLabel: string, bMarkDirty: boolean): void;
        SetActorHiddenInGame(bNewHidden: boolean): void;
        SetActorEnableCollision(bNewActorEnableCollision: boolean): void;
        RemoveTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
        RemoveTickPrerequisiteActor(PrerequisiteActor: Actor): void;
        ReceiveTick(DeltaSeconds: number): void;
        ReceiveRadialDamage(DamageReceived: number, DamageType: DamageType, Origin: Vector, HitInfo: HitResult, InstigatedBy: Controller, DamageCauser: Actor): void;
        ReceivePointDamage(Damage: number, DamageType: DamageType, HitLocation: Vector, HitNormal: Vector, HitComponent: PrimitiveComponent, BoneName: string, ShotFromDirection: Vector, InstigatedBy: Controller, DamageCauser: Actor, HitInfo: HitResult): void;
        ReceiveHit(MyComp: PrimitiveComponent, Other: Actor, OtherComp: PrimitiveComponent, bSelfMoved: boolean, HitLocation: Vector, HitNormal: Vector, NormalImpulse: Vector, Hit: HitResult): void;
        ReceiveEndPlay(EndPlayReason: number): void;
        ReceiveDestroyed(): void;
        ReceiveBeginPlay(): void;
        ReceiveAnyDamage(Damage: number, DamageType: DamageType, InstigatedBy: Controller, DamageCauser: Actor): void;
        ReceiveActorOnReleased(ButtonReleased: Key): void;
        ReceiveActorOnInputTouchLeave(FingerIndex: number): void;
        ReceiveActorOnInputTouchEnter(FingerIndex: number): void;
        ReceiveActorOnInputTouchEnd(FingerIndex: number): void;
        ReceiveActorOnInputTouchBegin(FingerIndex: number): void;
        ReceiveActorOnClicked(ButtonPressed: Key): void;
        ReceiveActorEndOverlap(OtherActor: Actor): void;
        ReceiveActorEndCursorOver(): void;
        ReceiveActorBeginOverlap(OtherActor: Actor): void;
        ReceiveActorBeginCursorOver(): void;
        PrestreamTextures(Seconds: number, bEnableStreaming: boolean, CinematicTextureGroups: number): void;
        OnRep_ReplicateMovement(): void;
        OnRep_ReplicatedMovement(): void;
        OnRep_Owner(): void;
        OnRep_Instigator(): void;
        OnRep_AttachmentReplication(): void;
        MakeNoise(Loudness: number, NoiseInstigator: Pawn, NoiseLocation: Vector, MaxRange: number, Tag: string): void;
        MakeMIDForMaterial(Parent: MaterialInterface): MaterialInstanceDynamic;
        K2_TeleportTo(DestLocation: Vector, DestRotation: Rotator): boolean;
        K2_SetActorTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): boolean;
        K2_SetActorRotation(NewRotation: Rotator, bTeleportPhysics: boolean): boolean;
        K2_SetActorRelativeTransform(NewRelativeTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetActorRelativeRotation(NewRelativeRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetActorRelativeLocation(NewRelativeLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_SetActorLocationAndRotation(NewLocation: Vector, NewRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): boolean;
        K2_SetActorLocation(NewLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): boolean;
        K2_OnReset(): void;
        K2_OnEndViewTarget(PC: PlayerController): void;
        K2_OnBecomeViewTarget(PC: PlayerController): void;
        K2_GetRootComponent(): SceneComponent;
        K2_GetComponentsByClass(ComponentClass: Class): TArray<ActorComponent>;
        K2_GetActorRotation(): Rotator;
        K2_GetActorLocation(): Vector;
        K2_DetachFromActor(LocationRule: EDetachmentRule, RotationRule: EDetachmentRule, ScaleRule: EDetachmentRule): void;
        K2_DestroyComponent(Component: ActorComponent): void;
        K2_DestroyActor(): void;
        K2_AttachToComponent(Parent: SceneComponent, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule, bWeldSimulatedBodies: boolean): void;
        K2_AttachToActor(ParentActor: Actor, SocketName: string, LocationRule: EAttachmentRule, RotationRule: EAttachmentRule, ScaleRule: EAttachmentRule, bWeldSimulatedBodies: boolean): void;
        K2_AttachRootComponentToActor(InParentActor: Actor, InSocketName: string, AttachLocationType: number, bWeldSimulatedBodies: boolean): void;
        K2_AttachRootComponentTo(InParent: SceneComponent, InSocketName: string, AttachLocationType: number, bWeldSimulatedBodies: boolean): void;
        K2_AddActorWorldTransform(DeltaTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddActorWorldRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddActorWorldOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddActorLocalTransform(NewTransform: Transform, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddActorLocalRotation(DeltaRotation: Rotator, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        K2_AddActorLocalOffset(DeltaLocation: Vector, bSweep: boolean, SweepHitResult: $Ref<HitResult>, bTeleport: boolean): void;
        IsTemporarilyHiddenInEditor(bIncludeParent: boolean): boolean;
        IsSelectable(): boolean;
        IsOverlappingActor(Other: Actor): boolean;
        IsHiddenEdAtStartup(): boolean;
        IsHiddenEd(): boolean;
        IsEditable(): boolean;
        IsChildActor(): boolean;
        IsActorTickEnabled(): boolean;
        IsActorBeingDestroyed(): boolean;
        HasAuthority(): boolean;
        GetVerticalDistanceTo(OtherActor: Actor): number;
        GetVelocity(): Vector;
        GetTransform(): Transform;
        GetTickableWhenPaused(): boolean;
        GetSquaredDistanceTo(OtherActor: Actor): number;
        GetRemoteRole(): number;
        GetParentComponent(): ChildActorComponent;
        GetParentActor(): Actor;
        GetOwner(): Actor;
        GetOverlappingComponents(OverlappingComponents: $Ref<TArray<PrimitiveComponent>>): void;
        GetOverlappingActors(OverlappingActors: $Ref<TArray<Actor>>, ClassFilter: Class): void;
        GetLocalRole(): number;
        GetLifeSpan(): number;
        GetInstigatorController(): Controller;
        GetInstigator(): Pawn;
        GetInputVectorAxisValue(InputAxisKey: Key): Vector;
        GetInputAxisValue(InputAxisName: string): number;
        GetInputAxisKeyValue(InputAxisKey: Key): number;
        GetHorizontalDotProductTo(OtherActor: Actor): number;
        GetHorizontalDistanceTo(OtherActor: Actor): number;
        GetGameTimeSinceCreation(): number;
        GetFolderPath(): string;
        GetDotProductTo(OtherActor: Actor): number;
        GetDistanceTo(OtherActor: Actor): number;
        GetComponentsByTag(ComponentClass: Class, Tag: string): TArray<ActorComponent>;
        GetComponentsByInterface(Interface: Class): TArray<ActorComponent>;
        GetComponentByClass(ComponentClass: Class): ActorComponent;
        GetAttachParentSocketName(): string;
        GetAttachParentActor(): Actor;
        GetAttachedActors(OutActors: $Ref<TArray<Actor>>, bResetArray: boolean): void;
        GetAllChildActors(ChildActors: $Ref<TArray<Actor>>, bIncludeDescendants: boolean): void;
        GetActorUpVector(): Vector;
        GetActorTimeDilation(): number;
        GetActorTickInterval(): number;
        GetActorScale3D(): Vector;
        GetActorRightVector(): Vector;
        GetActorRelativeScale3D(): Vector;
        GetActorLabel(): string;
        GetActorForwardVector(): Vector;
        GetActorEyesViewPoint(OutLocation: $Ref<Vector>, OutRotation: $Ref<Rotator>): void;
        GetActorEnableCollision(): boolean;
        GetActorBounds(bOnlyCollidingComponents: boolean, Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>): void;
        ForceNetUpdate(): void;
        FlushNetDormancy(): void;
        EnableInput(PlayerController: PlayerController): void;
        DisableInput(PlayerController: PlayerController): void;
        DetachRootComponentFromParent(bMaintainWorldPosition: boolean): void;
        AddTickPrerequisiteComponent(PrerequisiteComponent: ActorComponent): void;
        AddTickPrerequisiteActor(PrerequisiteActor: Actor): void;
        AddComponent(TemplateName: string, bManualAttachment: boolean, RelativeTransform: Transform, ComponentTemplateContext: Object): ActorComponent;
        ActorHasTag(Tag: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Actor;
        static Load(InName: string): Actor;
    }
    
    class ModelComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ModelBodySetup: BodySetup;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ModelComponent;
        static Load(InName: string): ModelComponent;
    }
    
    class LevelActorContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Actors: TArray<Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelActorContainer;
        static Load(InName: string): LevelActorContainer;
    }
    
    class LevelScriptBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FriendlyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelScriptBlueprint;
        static Load(InName: string): LevelScriptBlueprint;
    }
    
    class LevelScriptActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInputEnabled: boolean;
        WorldOriginLocationChanged(OldOriginLocation: IntVector, NewOriginLocation: IntVector): void;
        SetCinematicMode(bCinematicMode: boolean, bHidePlayer: boolean, bAffectsHUD: boolean, bAffectsMovement: boolean, bAffectsTurning: boolean): void;
        RemoteEvent(EventName: string): boolean;
        LevelReset(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelScriptActor;
        static Load(InName: string): LevelScriptActor;
    }
    
    class NavigationObjectBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleComponent: CapsuleComponent;
        GoodSprite: BillboardComponent;
        BadSprite: BillboardComponent;
        bIsPIEPlayerStart: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationObjectBase;
        static Load(InName: string): NavigationObjectBase;
    }
    
    class NavigationDataChunk extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavigationDataName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationDataChunk;
        static Load(InName: string): NavigationDataChunk;
    }
    
    class MapBuildDataRegistry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelLightingQuality: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MapBuildDataRegistry;
        static Load(InName: string): MapBuildDataRegistry;
    }
    
    class MaterialProxySettings {
        constructor(TextureSize: IntPoint, GutterSpace: number, MetallicConstant: number, RoughnessConstant: number, SpecularConstant: number, OpacityConstant: number, OpacityMaskConstant: number, AmbientOcclusionConstant: number, TextureSizingType: number, MaterialMergeType: number, BlendMode: number, bAllowTwoSidedMaterial: boolean, bNormalMap: boolean, bMetallicMap: boolean, bRoughnessMap: boolean, bSpecularMap: boolean, bEmissiveMap: boolean, bOpacityMap: boolean, bOpacityMaskMap: boolean, bAmbientOcclusionMap: boolean, DiffuseTextureSize: IntPoint, NormalTextureSize: IntPoint, MetallicTextureSize: IntPoint, RoughnessTextureSize: IntPoint, SpecularTextureSize: IntPoint, EmissiveTextureSize: IntPoint, OpacityTextureSize: IntPoint, OpacityMaskTextureSize: IntPoint, AmbientOcclusionTextureSize: IntPoint);
        TextureSize: IntPoint;
        GutterSpace: number;
        MetallicConstant: number;
        RoughnessConstant: number;
        SpecularConstant: number;
        OpacityConstant: number;
        OpacityMaskConstant: number;
        AmbientOcclusionConstant: number;
        TextureSizingType: number;
        MaterialMergeType: number;
        BlendMode: number;
        bAllowTwoSidedMaterial: boolean;
        bNormalMap: boolean;
        bMetallicMap: boolean;
        bRoughnessMap: boolean;
        bSpecularMap: boolean;
        bEmissiveMap: boolean;
        bOpacityMap: boolean;
        bOpacityMaskMap: boolean;
        bAmbientOcclusionMap: boolean;
        DiffuseTextureSize: IntPoint;
        NormalTextureSize: IntPoint;
        MetallicTextureSize: IntPoint;
        RoughnessTextureSize: IntPoint;
        SpecularTextureSize: IntPoint;
        EmissiveTextureSize: IntPoint;
        OpacityTextureSize: IntPoint;
        OpacityMaskTextureSize: IntPoint;
        AmbientOcclusionTextureSize: IntPoint;
    }
    
    class LevelSimplificationDetails {
        constructor(bCreatePackagePerAsset: boolean, DetailsPercentage: number, StaticMeshMaterialSettings: MaterialProxySettings, bOverrideLandscapeExportLOD: boolean, LandscapeExportLOD: number, LandscapeMaterialSettings: MaterialProxySettings, bBakeFoliageToLandscape: boolean, bBakeGrassToLandscape: boolean, bGenerateMeshNormalMap: boolean, bGenerateMeshMetallicMap: boolean, bGenerateMeshRoughnessMap: boolean, bGenerateMeshSpecularMap: boolean, bGenerateLandscapeNormalMap: boolean, bGenerateLandscapeMetallicMap: boolean, bGenerateLandscapeRoughnessMap: boolean, bGenerateLandscapeSpecularMap: boolean);
        bCreatePackagePerAsset: boolean;
        DetailsPercentage: number;
        StaticMeshMaterialSettings: MaterialProxySettings;
        bOverrideLandscapeExportLOD: boolean;
        LandscapeExportLOD: number;
        LandscapeMaterialSettings: MaterialProxySettings;
        bBakeFoliageToLandscape: boolean;
        bBakeGrassToLandscape: boolean;
        bGenerateMeshNormalMap: boolean;
        bGenerateMeshMetallicMap: boolean;
        bGenerateMeshRoughnessMap: boolean;
        bGenerateMeshSpecularMap: boolean;
        bGenerateLandscapeNormalMap: boolean;
        bGenerateLandscapeMetallicMap: boolean;
        bGenerateLandscapeRoughnessMap: boolean;
        bGenerateLandscapeSpecularMap: boolean;
    }
    
    class NavAgentSelector {
        constructor(bSupportsAgent0: boolean, bSupportsAgent1: boolean, bSupportsAgent2: boolean, bSupportsAgent3: boolean, bSupportsAgent4: boolean, bSupportsAgent5: boolean, bSupportsAgent6: boolean, bSupportsAgent7: boolean, bSupportsAgent8: boolean, bSupportsAgent9: boolean, bSupportsAgent10: boolean, bSupportsAgent11: boolean, bSupportsAgent12: boolean, bSupportsAgent13: boolean, bSupportsAgent14: boolean, bSupportsAgent15: boolean);
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
    }
    
    class NavigationSystemConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavigationSystemClass: SoftClassPath;
        SupportedAgentsMask: NavAgentSelector;
        DefaultAgentName: string;
        bIsOverriden: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemConfig;
        static Load(InName: string): NavigationSystemConfig;
    }
    
    class LightmassWorldInfoSettings {
        constructor(StaticLightingLevelScale: number, NumIndirectLightingBounces: number, NumSkyLightingBounces: number, IndirectLightingQuality: number, IndirectLightingSmoothness: number, EnvironmentColor: Color, EnvironmentIntensity: number, EmissiveBoost: number, DiffuseBoost: number, VolumeLightingMethod: number, bUseAmbientOcclusion: boolean, bGenerateAmbientOcclusionMaterialMask: boolean, bVisualizeMaterialDiffuse: boolean, bVisualizeAmbientOcclusion: boolean, bCompressLightmaps: boolean, VolumetricLightmapDetailCellSize: number, VolumetricLightmapMaximumBrickMemoryMb: number, VolumetricLightmapSphericalHarmonicSmoothing: number, VolumeLightSamplePlacementScale: number, DirectIlluminationOcclusionFraction: number, IndirectIlluminationOcclusionFraction: number, OcclusionExponent: number, FullyOccludedSamplesFraction: number, MaxOcclusionDistance: number);
        StaticLightingLevelScale: number;
        NumIndirectLightingBounces: number;
        NumSkyLightingBounces: number;
        IndirectLightingQuality: number;
        IndirectLightingSmoothness: number;
        EnvironmentColor: Color;
        EnvironmentIntensity: number;
        EmissiveBoost: number;
        DiffuseBoost: number;
        VolumeLightingMethod: number;
        bUseAmbientOcclusion: boolean;
        bGenerateAmbientOcclusionMaterialMask: boolean;
        bVisualizeMaterialDiffuse: boolean;
        bVisualizeAmbientOcclusion: boolean;
        bCompressLightmaps: boolean;
        VolumetricLightmapDetailCellSize: number;
        VolumetricLightmapMaximumBrickMemoryMb: number;
        VolumetricLightmapSphericalHarmonicSmoothing: number;
        VolumeLightSamplePlacementScale: number;
        DirectIlluminationOcclusionFraction: number;
        IndirectIlluminationOcclusionFraction: number;
        OcclusionExponent: number;
        FullyOccludedSamplesFraction: number;
        MaxOcclusionDistance: number;
    }
    
    class ReverbEffect extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Density: number;
        Diffusion: number;
        Gain: number;
        GainHF: number;
        DecayTime: number;
        DecayHFRatio: number;
        ReflectionsGain: number;
        ReflectionsDelay: number;
        LateGain: number;
        LateDelay: number;
        AirAbsorptionGainHF: number;
        RoomRolloffFactor: number;
        bChanged: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReverbEffect;
        static Load(InName: string): ReverbEffect;
    }
    
    class ReverbSettings {
        constructor(bApplyReverb: boolean, ReverbType: number, ReverbEffect: ReverbEffect, ReverbPluginEffect: SoundEffectSubmixPreset, Volume: number, FadeTime: number);
        bApplyReverb: boolean;
        ReverbType: number;
        ReverbEffect: ReverbEffect;
        ReverbPluginEffect: SoundEffectSubmixPreset;
        Volume: number;
        FadeTime: number;
    }
    
    class InteriorSettings {
        constructor(bIsWorldSettings: boolean, ExteriorVolume: number, ExteriorTime: number, ExteriorLPF: number, ExteriorLPFTime: number, InteriorVolume: number, InteriorTime: number, InteriorLPF: number, InteriorLPFTime: number);
        bIsWorldSettings: boolean;
        ExteriorVolume: number;
        ExteriorTime: number;
        ExteriorLPF: number;
        ExteriorLPFTime: number;
        InteriorVolume: number;
        InteriorTime: number;
        InteriorLPF: number;
        InteriorLPFTime: number;
    }
    
    class MeshProxySettings {
        constructor(ScreenSize: number, VoxelSize: number, MaterialSettings: MaterialProxySettings, TextureWidth: number, TextureHeight: number, bExportNormalMap: boolean, bExportMetallicMap: boolean, bExportRoughnessMap: boolean, bExportSpecularMap: boolean, bBakeVertexData: boolean, MergeDistance: number, UnresolvedGeometryColor: Color, MaxRayCastDist: number, HardAngleThreshold: number, LightMapResolution: number, NormalCalculationMethod: number, LandscapeCullingPrecision: number, bCalculateCorrectLODModel: boolean, bOverrideVoxelSize: boolean, bOverrideTransferDistance: boolean, bUseHardAngleThreshold: boolean, bComputeLightMapResolution: boolean, bRecalculateNormals: boolean, bUseLandscapeCulling: boolean, bAllowAdjacency: boolean, bAllowDistanceField: boolean, bReuseMeshLightmapUVs: boolean, bCreateCollision: boolean, bAllowVertexColors: boolean, bGenerateLightmapUVs: boolean);
        ScreenSize: number;
        VoxelSize: number;
        MaterialSettings: MaterialProxySettings;
        TextureWidth: number;
        TextureHeight: number;
        bExportNormalMap: boolean;
        bExportMetallicMap: boolean;
        bExportRoughnessMap: boolean;
        bExportSpecularMap: boolean;
        bBakeVertexData: boolean;
        MergeDistance: number;
        UnresolvedGeometryColor: Color;
        MaxRayCastDist: number;
        HardAngleThreshold: number;
        LightMapResolution: number;
        NormalCalculationMethod: number;
        LandscapeCullingPrecision: number;
        bCalculateCorrectLODModel: boolean;
        bOverrideVoxelSize: boolean;
        bOverrideTransferDistance: boolean;
        bUseHardAngleThreshold: boolean;
        bComputeLightMapResolution: boolean;
        bRecalculateNormals: boolean;
        bUseLandscapeCulling: boolean;
        bAllowAdjacency: boolean;
        bAllowDistanceField: boolean;
        bReuseMeshLightmapUVs: boolean;
        bCreateCollision: boolean;
        bAllowVertexColors: boolean;
        bGenerateLightmapUVs: boolean;
    }
    
    enum EUVOutput { DoNotOutputChannel, OutputChannel, EUVOutput_MAX}
    enum EMeshLODSelectionType { AllLODs, SpecificLOD, CalculateLOD, LowestDetailLOD, EMeshLODSelectionType_MAX}
    class MeshMergingSettings {
        constructor(TargetLightMapResolution: number, OutputUVs: FixSizeArray<EUVOutput>, MaterialSettings: MaterialProxySettings, GutterSize: number, SpecificLOD: number, LODSelectionType: EMeshLODSelectionType, bGenerateLightMapUV: boolean, bComputedLightMapResolution: boolean, bPivotPointAtZero: boolean, bMergePhysicsData: boolean, bMergeMaterials: boolean, bCreateMergedMaterial: boolean, bBakeVertexDataToMesh: boolean, bUseVertexDataForBakingMaterial: boolean, bUseTextureBinning: boolean, bReuseMeshLightmapUVs: boolean, bMergeEquivalentMaterials: boolean, bUseLandscapeCulling: boolean, bIncludeImposters: boolean, bAllowDistanceField: boolean, bImportVertexColors: boolean, bCalculateCorrectLODModel: boolean, bExportNormalMap: boolean, bExportMetallicMap: boolean, bExportRoughnessMap: boolean, bExportSpecularMap: boolean, MergedMaterialAtlasResolution: number, ExportSpecificLOD: number);
        TargetLightMapResolution: number;
        OutputUVs: FixSizeArray<EUVOutput>;
        MaterialSettings: MaterialProxySettings;
        GutterSize: number;
        SpecificLOD: number;
        LODSelectionType: EMeshLODSelectionType;
        bGenerateLightMapUV: boolean;
        bComputedLightMapResolution: boolean;
        bPivotPointAtZero: boolean;
        bMergePhysicsData: boolean;
        bMergeMaterials: boolean;
        bCreateMergedMaterial: boolean;
        bBakeVertexDataToMesh: boolean;
        bUseVertexDataForBakingMaterial: boolean;
        bUseTextureBinning: boolean;
        bReuseMeshLightmapUVs: boolean;
        bMergeEquivalentMaterials: boolean;
        bUseLandscapeCulling: boolean;
        bIncludeImposters: boolean;
        bAllowDistanceField: boolean;
        bImportVertexColors: boolean;
        bCalculateCorrectLODModel: boolean;
        bExportNormalMap: boolean;
        bExportMetallicMap: boolean;
        bExportRoughnessMap: boolean;
        bExportSpecularMap: boolean;
        MergedMaterialAtlasResolution: number;
        ExportSpecificLOD: number;
    }
    
    class HierarchicalSimplification {
        constructor(TransitionScreenSize: number, OverrideDrawDistance: number, bUseOverrideDrawDistance: boolean, bAllowSpecificExclusion: boolean, bSimplifyMesh: boolean, bOnlyGenerateClustersForVolumes: boolean, bReusePreviousLevelClusters: boolean, ProxySetting: MeshProxySettings, MergeSetting: MeshMergingSettings, DesiredBoundRadius: number, DesiredFillingPercentage: number, MinNumberOfActorsToBuild: number);
        TransitionScreenSize: number;
        OverrideDrawDistance: number;
        bUseOverrideDrawDistance: boolean;
        bAllowSpecificExclusion: boolean;
        bSimplifyMesh: boolean;
        bOnlyGenerateClustersForVolumes: boolean;
        bReusePreviousLevelClusters: boolean;
        ProxySetting: MeshProxySettings;
        MergeSetting: MeshMergingSettings;
        DesiredBoundRadius: number;
        DesiredFillingPercentage: number;
        MinNumberOfActorsToBuild: number;
    }
    
    class BookmarkBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BookmarkBase;
        static Load(InName: string): BookmarkBase;
    }
    
    class BookMark extends BookmarkBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Location: Vector;
        Rotation: Rotator;
        HiddenLevels: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BookMark;
        static Load(InName: string): BookMark;
    }
    
    class BroadphaseSettings {
        constructor(bUseMBPOnClient: boolean, bUseMBPOnServer: boolean, bUseMBPOuterBounds: boolean, MBPBounds: Box, MBPOuterBounds: Box, MBPNumSubdivs: number);
        bUseMBPOnClient: boolean;
        bUseMBPOnServer: boolean;
        bUseMBPOuterBounds: boolean;
        MBPBounds: Box;
        MBPOuterBounds: Box;
        MBPNumSubdivs: number;
    }
    
    class NetViewer {
        constructor(Connection: NetConnection, InViewer: Actor, ViewTarget: Actor, ViewLocation: Vector, ViewDir: Vector);
        Connection: NetConnection;
        InViewer: Actor;
        ViewTarget: Actor;
        ViewLocation: Vector;
        ViewDir: Vector;
    }
    
    class WorldSettings extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VisibilityCellSize: number;
        VisibilityAggressiveness: number;
        bPrecomputeVisibility: boolean;
        bPlaceCellsOnlyAlongCameraTracks: boolean;
        bEnableWorldBoundsChecks: boolean;
        bEnableNavigationSystem: boolean;
        bEnableAISystem: boolean;
        bEnableWorldComposition: boolean;
        bUseClientSideLevelStreamingVolumes: boolean;
        bEnableWorldOriginRebasing: boolean;
        bWorldGravitySet: boolean;
        bGlobalGravitySet: boolean;
        bMinimizeBSPSections: boolean;
        bForceNoPrecomputedLighting: boolean;
        bHighPriorityLoading: boolean;
        bHighPriorityLoadingLocal: boolean;
        bOverrideDefaultBroadphaseSettings: boolean;
        NavigationSystemConfig: NavigationSystemConfig;
        NavigationSystemConfigOverride: NavigationSystemConfig;
        WorldToMeters: number;
        KillZ: number;
        KillZDamageType: Class;
        WorldGravityZ: number;
        GlobalGravityZ: number;
        DefaultPhysicsVolumeClass: Class;
        PhysicsCollisionHandlerClass: Class;
        DefaultGameMode: Class;
        GameNetworkManagerClass: Class;
        PackedLightAndShadowMapTextureSize: number;
        DefaultColorScale: Vector;
        DefaultMaxDistanceFieldOcclusionDistance: number;
        GlobalDistanceFieldViewDistance: number;
        DynamicIndirectShadowsSelfShadowingIntensity: number;
        LightmassSettings: LightmassWorldInfoSettings;
        DefaultReverbSettings: ReverbSettings;
        DefaultAmbientZoneSettings: InteriorSettings;
        MonoCullingDistance: number;
        DefaultBaseSoundMix: SoundMix;
        bEnableHierarchicalLODSystem: boolean;
        HLODSetupAsset: TSoftObjectPtr<Class>;
        OverrideBaseMaterial: TSoftObjectPtr<MaterialInterface>;
        HierarchicalLODSetup: TArray<HierarchicalSimplification>;
        NumHLODLevels: number;
        bGenerateSingleClusterForLevel: boolean;
        BookMarks: FixSizeArray<BookMark>;
        TimeDilation: number;
        MatineeTimeDilation: number;
        DemoPlayTimeDilation: number;
        MinGlobalTimeDilation: number;
        MaxGlobalTimeDilation: number;
        MinUndilatedFrameTime: number;
        MaxUndilatedFrameTime: number;
        BroadphaseSettings: BroadphaseSettings;
        Pauser: PlayerState;
        ReplicationViewers: TArray<NetViewer>;
        AssetUserData: TArray<AssetUserData>;
        PauserPlayerState: PlayerState;
        MaxNumberOfBookmarks: number;
        DefaultBookmarkClass: Class;
        BookmarkArray: TArray<BookmarkBase>;
        LastBookmarkClass: Class;
        OnRep_WorldGravityZ(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldSettings;
        static Load(InName: string): WorldSettings;
    }
    
    class ReplicatedStaticActorDestructionInfo {
        constructor(ObjClass: Class);
        ObjClass: Class;
    }
    
    class Level extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningWorld: World;
        Model: Model;
        ModelComponents: TArray<ModelComponent>;
        ActorCluster: LevelActorContainer;
        LevelScriptBlueprint: LevelScriptBlueprint;
        TextureStreamingResourceGuids: TArray<Guid>;
        NumTextureStreamingUnbuiltComponents: number;
        NumTextureStreamingDirtyResources: number;
        LevelScriptActor: LevelScriptActor;
        NavListStart: NavigationObjectBase;
        NavListEnd: NavigationObjectBase;
        NavDataChunks: TArray<NavigationDataChunk>;
        LightmapTotalSize: number;
        ShadowmapTotalSize: number;
        StaticNavigableGeometry: TArray<Vector>;
        StreamingTextureGuids: TArray<Guid>;
        LevelBuildDataId: Guid;
        MapBuildData: MapBuildDataRegistry;
        LightBuildLevelOffset: IntVector;
        bIsLightingScenario: boolean;
        bTextureStreamingRotationChanged: boolean;
        bStaticComponentsRegisteredInStreamingManager: boolean;
        bIsVisible: boolean;
        bLocked: boolean;
        LevelSimplification: FixSizeArray<LevelSimplificationDetails>;
        LevelColor: LinearColor;
        bLevelOkayForPlacementWhileCheckedIn: boolean;
        WorldSettings: WorldSettings;
        AssetUserData: TArray<AssetUserData>;
        DestroyedReplicatedStaticActors: TArray<ReplicatedStaticActorDestructionInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Level;
        static Load(InName: string): Level;
    }
    
    class LineBatchComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LineBatchComponent;
        static Load(InName: string): LineBatchComponent;
    }
    
    class GameNetworkManager extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BadPacketLossThreshold: number;
        SeverePacketLossThreshold: number;
        BadPingThreshold: number;
        SeverePingThreshold: number;
        AdjustedNetSpeed: number;
        LastNetSpeedUpdateTime: number;
        TotalNetBandwidth: number;
        MinDynamicBandwidth: number;
        MaxDynamicBandwidth: number;
        bIsStandbyCheckingEnabled: boolean;
        bHasStandbyCheatTriggered: boolean;
        StandbyRxCheatTime: number;
        StandbyTxCheatTime: number;
        PercentMissingForRxStandby: number;
        PercentMissingForTxStandby: number;
        PercentForBadPing: number;
        JoinInProgressStandbyWaitTime: number;
        MoveRepSize: number;
        MAXPOSITIONERRORSQUARED: number;
        MAXNEARZEROVELOCITYSQUARED: number;
        CLIENTADJUSTUPDATECOST: number;
        MAXCLIENTUPDATEINTERVAL: number;
        MaxClientForcedUpdateDuration: number;
        ServerForcedUpdateHitchThreshold: number;
        ServerForcedUpdateHitchCooldown: number;
        MaxMoveDeltaTime: number;
        MaxClientSmoothingDeltaTime: number;
        ClientNetSendMoveDeltaTime: number;
        ClientNetSendMoveDeltaTimeThrottled: number;
        ClientNetSendMoveDeltaTimeStationary: number;
        ClientNetSendMoveThrottleAtNetSpeed: number;
        ClientNetSendMoveThrottleOverPlayerCount: number;
        ClientAuthorativePosition: boolean;
        ClientErrorUpdateRateLimit: number;
        ClientNetCamUpdateDeltaTime: number;
        ClientNetCamUpdatePositionLimit: number;
        bMovementTimeDiscrepancyDetection: boolean;
        bMovementTimeDiscrepancyResolution: boolean;
        MovementTimeDiscrepancyMaxTimeMargin: number;
        MovementTimeDiscrepancyMinTimeMargin: number;
        MovementTimeDiscrepancyResolutionRate: number;
        MovementTimeDiscrepancyDriftAllowance: number;
        bMovementTimeDiscrepancyForceCorrectionsDuringResolution: boolean;
        bUseDistanceBasedRelevancy: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameNetworkManager;
        static Load(InName: string): GameNetworkManager;
    }
    
    class PhysicsCollisionHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImpactThreshold: number;
        ImpactReFireDelay: number;
        DefaultImpactSound: SoundBase;
        LastImpactSoundTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsCollisionHandler;
        static Load(InName: string): PhysicsCollisionHandler;
    }
    
    class LevelStreamingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StreamingLevelNames: TArray<string>;
        bEditorPreVisOnly: boolean;
        bDisabled: boolean;
        StreamingUsage: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingVolume;
        static Load(InName: string): LevelStreamingVolume;
    }
    
    class LevelStreaming extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PackageName: string;
        WorldAsset: TSoftObjectPtr<World>;
        PackageNameToLoad: string;
        LODPackageNames: TArray<string>;
        LevelTransform: Transform;
        LevelLODIndex: number;
        StreamingPriority: number;
        bShouldBeVisibleInEditor: boolean;
        bShouldBeVisible: boolean;
        bShouldBeLoaded: boolean;
        bLocked: boolean;
        bIsStatic: boolean;
        bShouldBlockOnLoad: boolean;
        bShouldBlockOnUnload: boolean;
        bDisableDistanceStreaming: boolean;
        bDrawOnLevelStatusMap: boolean;
        DrawColor: Color;
        LevelColor: LinearColor;
        EditorStreamingVolumes: TArray<LevelStreamingVolume>;
        MinTimeBetweenVolumeUnloadRequests: number;
        Keywords: TArray<string>;
        OnLevelLoaded: $MulticastDelegate<() => void>;
        OnLevelUnloaded: $MulticastDelegate<() => void>;
        OnLevelShown: $MulticastDelegate<() => void>;
        OnLevelHidden: $MulticastDelegate<() => void>;
        LoadedLevel: Level;
        PendingUnloadLevel: Level;
        FolderPath: string;
        ShouldBeLoaded(): boolean;
        SetShouldBeVisible(bInShouldBeVisible: boolean): void;
        SetShouldBeLoaded(bInShouldBeLoaded: boolean): void;
        SetPriority(NewPriority: number): void;
        SetLevelLODIndex(LODIndex: number): void;
        IsStreamingStatePending(): boolean;
        IsLevelVisible(): boolean;
        IsLevelLoaded(): boolean;
        GetWorldAssetPackageFName(): string;
        GetLoadedLevel(): Level;
        GetLevelScriptActor(): LevelScriptActor;
        CreateInstance(UniqueInstanceName: string): LevelStreaming;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreaming;
        static Load(InName: string): LevelStreaming;
    }
    
    class LevelStreamingWrapper {
        constructor(StreamingLevel: LevelStreaming);
        StreamingLevel: LevelStreaming;
    }
    
    class StreamingLevelsToConsider {
        constructor(StreamingLevels: TArray<LevelStreamingWrapper>);
        StreamingLevels: TArray<LevelStreamingWrapper>;
    }
    
    class RollbackNetStartupActorInfo {
        constructor(Archetype: Object, Level: Level, ObjReferences: TArray<Object>);
        Archetype: Object;
        Level: Level;
        ObjReferences: TArray<Object>;
    }
    
    class MulticastRecordOptions {
        constructor(FuncPathName: string, bServerSkip: boolean, bClientSkip: boolean);
        FuncPathName: string;
        bServerSkip: boolean;
        bClientSkip: boolean;
    }
    
    class DemoNetDriver extends NetDriver {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RollbackNetStartupActors: TMap<string, RollbackNetStartupActorInfo>;
        CheckpointSaveMaxMSPerFrame: number;
        MulticastRecordOptions: TArray<MulticastRecordOptions>;
        bIsLocalReplay: boolean;
        SpectatorControllers: TArray<PlayerController>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DemoNetDriver;
        static Load(InName: string): DemoNetDriver;
    }
    
    class ParticleEventManager extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleEventManager;
        static Load(InName: string): ParticleEventManager;
    }
    
    class NavigationSystemBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemBase;
        static Load(InName: string): NavigationSystemBase;
    }
    
    class GameSession extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxSpectators: number;
        MaxPlayers: number;
        MaxPartySize: number;
        MaxSplitscreensPerConnection: number;
        bRequiresPushToTalk: boolean;
        SessionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameSession;
        static Load(InName: string): GameSession;
    }
    
    class GameStateBase extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GameModeClass: Class;
        AuthorityGameMode: GameModeBase;
        SpectatorClass: Class;
        PlayerArray: TArray<PlayerState>;
        bReplicatedHasBegunPlay: boolean;
        ReplicatedWorldTimeSeconds: number;
        ServerWorldTimeSecondsDelta: number;
        ServerWorldTimeSecondsUpdateFrequency: number;
        OnRep_SpectatorClass(): void;
        OnRep_ReplicatedWorldTimeSeconds(): void;
        OnRep_ReplicatedHasBegunPlay(): void;
        OnRep_GameModeClass(): void;
        HasMatchStarted(): boolean;
        HasBegunPlay(): boolean;
        GetServerWorldTimeSeconds(): number;
        GetPlayerStartTime(Controller: Controller): number;
        GetPlayerRespawnDelay(Controller: Controller): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameStateBase;
        static Load(InName: string): GameStateBase;
    }
    
    class ServerStatReplicator extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUpdateStatNet: boolean;
        bOverwriteClientStats: boolean;
        Channels: number;
        InRate: number;
        OutRate: number;
        OutSaturation: number;
        MaxPacketOverhead: number;
        InRateClientMax: number;
        InRateClientMin: number;
        InRateClientAvg: number;
        InPacketsClientMax: number;
        InPacketsClientMin: number;
        InPacketsClientAvg: number;
        OutRateClientMax: number;
        OutRateClientMin: number;
        OutRateClientAvg: number;
        OutPacketsClientMax: number;
        OutPacketsClientMin: number;
        OutPacketsClientAvg: number;
        NetNumClients: number;
        InPackets: number;
        OutPackets: number;
        InBunches: number;
        OutBunches: number;
        OutLoss: number;
        InLoss: number;
        VoiceBytesSent: number;
        VoiceBytesRecv: number;
        VoicePacketsSent: number;
        VoicePacketsRecv: number;
        PercentInVoice: number;
        PercentOutVoice: number;
        NumActorChannels: number;
        NumConsideredActors: number;
        PrioritizedActors: number;
        NumRelevantActors: number;
        NumRelevantDeletedActors: number;
        NumReplicatedActorAttempts: number;
        NumReplicatedActors: number;
        NumActors: number;
        NumNetActors: number;
        NumDormantActors: number;
        NumInitiallyDormantActors: number;
        NumNetGUIDsAckd: number;
        NumNetGUIDsPending: number;
        NumNetGUIDsUnAckd: number;
        ObjPathBytes: number;
        NetGUIDOutRate: number;
        NetGUIDInRate: number;
        NetSaturated: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ServerStatReplicator;
        static Load(InName: string): ServerStatReplicator;
    }
    
    class GameModeBase extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OptionsString: string;
        GameSessionClass: Class;
        GameStateClass: Class;
        PlayerControllerClass: Class;
        PlayerStateClass: Class;
        HUDClass: Class;
        DefaultPawnClass: Class;
        SpectatorClass: Class;
        ReplaySpectatorPlayerControllerClass: Class;
        ServerStatReplicatorClass: Class;
        GameSession: GameSession;
        GameState: GameStateBase;
        ServerStatReplicator: ServerStatReplicator;
        DefaultPlayerName: string;
        bUseSeamlessTravel: boolean;
        bStartPlayersAsSpectators: boolean;
        bPauseable: boolean;
        StartPlay(): void;
        SpawnDefaultPawnFor(NewPlayer: Controller, StartSpot: Actor): Pawn;
        SpawnDefaultPawnAtTransform(NewPlayer: Controller, SpawnTransform: Transform): Pawn;
        ShouldReset(ActorToReset: Actor): boolean;
        ReturnToMainMenuHost(): void;
        RestartPlayerAtTransform(NewPlayer: Controller, SpawnTransform: Transform): void;
        RestartPlayerAtPlayerStart(NewPlayer: Controller, StartSpot: Actor): void;
        RestartPlayer(NewPlayer: Controller): void;
        ResetLevel(): void;
        PlayerCanRestart(Player: PlayerController): boolean;
        MustSpectate(NewPlayerController: PlayerController): boolean;
        K2_PostLogin(NewPlayer: PlayerController): void;
        K2_OnSwapPlayerControllers(OldPC: PlayerController, NewPC: PlayerController): void;
        K2_OnRestartPlayer(NewPlayer: Controller): void;
        K2_OnLogout(ExitingController: Controller): void;
        K2_OnChangeName(Other: Controller, NewName: string, bNameChange: boolean): void;
        K2_FindPlayerStart(Player: Controller, IncomingName: string): Actor;
        InitStartSpot(StartSpot: Actor, NewPlayer: Controller): void;
        InitializeHUDForPlayer(NewPlayer: PlayerController): void;
        HasMatchStarted(): boolean;
        HandleStartingNewPlayer(NewPlayer: PlayerController): void;
        GetNumSpectators(): number;
        GetNumPlayers(): number;
        GetDefaultPawnClassForController(InController: Controller): Class;
        FindPlayerStart(Player: Controller, IncomingName: string): Actor;
        ChoosePlayerStart(Player: Controller): Actor;
        ChangeName(Controller: Controller, NewName: string, bNameChange: boolean): void;
        CanSpectate(Viewer: PlayerController, ViewTarget: PlayerState): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameModeBase;
        static Load(InName: string): GameModeBase;
    }
    
    class AISystemBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AISystemClassName: SoftClassPath;
        AISystemModuleName: string;
        bInstantiateAISystemOnClient: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISystemBase;
        static Load(InName: string): AISystemBase;
    }
    
    class AvoidanceManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultTimeToLive: number;
        LockTimeAfterAvoid: number;
        LockTimeAfterClean: number;
        DeltaTimeToPredict: number;
        ArtificialRadiusExpansion: number;
        TestHeightDifference: number;
        HeightCheckMargin: number;
        RegisterMovementComponent(MovementComp: MovementComponent, AvoidanceWeight: number): boolean;
        GetObjectCount(): number;
        GetNewAvoidanceUID(): number;
        GetAvoidanceVelocityForComponent(MovementComp: MovementComponent): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AvoidanceManager;
        static Load(InName: string): AvoidanceManager;
    }
    
    class LevelCollection {
        constructor(GameState: GameStateBase, NetDriver: NetDriver, DemoNetDriver: DemoNetDriver, PersistentLevel: Level, Levels: TSet<Level>);
        GameState: GameStateBase;
        NetDriver: NetDriver;
        DemoNetDriver: DemoNetDriver;
        PersistentLevel: Level;
        Levels: TSet<Level>;
    }
    
    class MaterialParameterCollectionInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Collection: MaterialParameterCollection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollectionInstance;
        static Load(InName: string): MaterialParameterCollectionInstance;
    }
    
    class LevelViewportInfo {
        constructor(CamPosition: Vector, CamRotation: Rotator, CamOrthoZoom: number, CamUpdated: boolean);
        CamPosition: Vector;
        CamRotation: Rotator;
        CamOrthoZoom: number;
        CamUpdated: boolean;
    }
    
    class WorldComposition extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TilesStreaming: TArray<LevelStreaming>;
        TilesStreamingTimeThreshold: number;
        bLoadAllTilesDuringCinematic: boolean;
        bRebaseOriginIn3DSpace: boolean;
        bLockTilesLocation: boolean;
        RebaseOriginDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldComposition;
        static Load(InName: string): WorldComposition;
    }
    
    class PSCPoolElem {
        constructor(PSC: ParticleSystemComponent);
        PSC: ParticleSystemComponent;
    }
    
    class PSCPool {
        constructor(FreeElements: TArray<PSCPoolElem>, InUseComponents_Auto: TArray<ParticleSystemComponent>, InUseComponents_Manual: TArray<ParticleSystemComponent>);
        FreeElements: TArray<PSCPoolElem>;
        InUseComponents_Auto: TArray<ParticleSystemComponent>;
        InUseComponents_Manual: TArray<ParticleSystemComponent>;
    }
    
    class WorldPSCPool {
        constructor(WorldParticleSystemPools: TMap<ParticleSystem, PSCPool>);
        WorldParticleSystemPools: TMap<ParticleSystem, PSCPool>;
    }
    
    class World extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Layers: TArray<Layer>;
        ActiveGroupActors: TArray<Actor>;
        ThumbnailInfo: ThumbnailInfo;
        PersistentLevel: Level;
        NetDriver: NetDriver;
        LineBatcher: LineBatchComponent;
        PersistentLineBatcher: LineBatchComponent;
        ForegroundLineBatcher: LineBatchComponent;
        NetworkManager: GameNetworkManager;
        PhysicsCollisionHandler: PhysicsCollisionHandler;
        ExtraReferencedObjects: TArray<Object>;
        PerModuleDataObjects: TArray<Object>;
        LevelSequenceActors: TArray<Actor>;
        StreamingLevels: TArray<LevelStreaming>;
        StreamingLevelsToConsider: StreamingLevelsToConsider;
        StreamingLevelsPrefix: string;
        CurrentLevelPendingVisibility: Level;
        CurrentLevelPendingInvisibility: Level;
        DemoNetDriver: DemoNetDriver;
        MyParticleEventManager: ParticleEventManager;
        DefaultPhysicsVolume: PhysicsVolume;
        bAreConstraintsDirty: boolean;
        NavigationSystem: NavigationSystemBase;
        AuthorityGameMode: GameModeBase;
        GameState: GameStateBase;
        AISystem: AISystemBase;
        AvoidanceManager: AvoidanceManager;
        Levels: TArray<Level>;
        LevelCollections: TArray<LevelCollection>;
        CurrentLevel: Level;
        OwningGameInstance: GameInstance;
        ParameterCollectionInstances: TArray<MaterialParameterCollectionInstance>;
        CanvasForRenderingToTarget: Canvas;
        CanvasForDrawMaterialToRenderTarget: Canvas;
        EditorViews: TArray<LevelViewportInfo>;
        ComponentsThatNeedEndOfFrameUpdate: TArray<ActorComponent>;
        ComponentsThatNeedEndOfFrameUpdate_OnGameThread: TArray<ActorComponent>;
        SelectedLevels: TArray<Level>;
        WorldComposition: WorldComposition;
        PSCPool: WorldPSCPool;
        K2_GetWorldSettings(): WorldSettings;
        HandleTimelineScrubbed(): void;
        SpawnActor(Class: Class, Transform: Transform, SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod, Owner: Actor, Instigator: Pawn): Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): World;
        static Load(InName: string): World;
    }
    
    class Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExecuteUbergraph(EntryPoint: number): void;
        IsValid(): boolean;
        GetWorld(): World;
        GetOuter(): Object;
        GetName(): string;
        GetClass(): Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Object;
        static Load(InName: string): Object;
    }
    
    class GCObjectReferencer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GCObjectReferencer;
        static Load(InName: string): GCObjectReferencer;
    }
    
    class TextBuffer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBuffer;
        static Load(InName: string): TextBuffer;
    }
    
    class ScriptStruct extends Struct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScriptStruct;
        static Load(InName: string): ScriptStruct;
    }
    
    class DelegateFunction extends Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DelegateFunction;
        static Load(InName: string): DelegateFunction;
    }
    
    class SparseDelegateFunction extends DelegateFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SparseDelegateFunction;
        static Load(InName: string): SparseDelegateFunction;
    }
    
    class DynamicClass extends Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicClass;
        static Load(InName: string): DynamicClass;
    }
    
    class Enum extends Field {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Enum;
        static Load(InName: string): Enum;
    }
    
    class EnumProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnumProperty;
        static Load(InName: string): EnumProperty;
    }
    
    class LinkerPlaceholderClass extends Class {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderClass;
        static Load(InName: string): LinkerPlaceholderClass;
    }
    
    class LinkerPlaceholderExportObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderExportObject;
        static Load(InName: string): LinkerPlaceholderExportObject;
    }
    
    class LinkerPlaceholderFunction extends Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinkerPlaceholderFunction;
        static Load(InName: string): LinkerPlaceholderFunction;
    }
    
    class MetaData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MetaData;
        static Load(InName: string): MetaData;
    }
    
    class ObjectRedirector extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectRedirector;
        static Load(InName: string): ObjectRedirector;
    }
    
    class ArrayProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArrayProperty;
        static Load(InName: string): ArrayProperty;
    }
    
    class ObjectPropertyBase extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectPropertyBase;
        static Load(InName: string): ObjectPropertyBase;
    }
    
    class BoolProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoolProperty;
        static Load(InName: string): BoolProperty;
    }
    
    class NumericProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NumericProperty;
        static Load(InName: string): NumericProperty;
    }
    
    class ByteProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ByteProperty;
        static Load(InName: string): ByteProperty;
    }
    
    class ObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectProperty;
        static Load(InName: string): ObjectProperty;
    }
    
    class ClassProperty extends ObjectProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassProperty;
        static Load(InName: string): ClassProperty;
    }
    
    class DelegateProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DelegateProperty;
        static Load(InName: string): DelegateProperty;
    }
    
    class DoubleProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DoubleProperty;
        static Load(InName: string): DoubleProperty;
    }
    
    class FloatProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatProperty;
        static Load(InName: string): FloatProperty;
    }
    
    class IntProperty extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IntProperty;
        static Load(InName: string): IntProperty;
    }
    
    class Int16Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int16Property;
        static Load(InName: string): Int16Property;
    }
    
    class Int64Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int64Property;
        static Load(InName: string): Int64Property;
    }
    
    class Int8Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int8Property;
        static Load(InName: string): Int8Property;
    }
    
    class InterfaceProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterfaceProperty;
        static Load(InName: string): InterfaceProperty;
    }
    
    class LazyObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LazyObjectProperty;
        static Load(InName: string): LazyObjectProperty;
    }
    
    class MapProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MapProperty;
        static Load(InName: string): MapProperty;
    }
    
    class MulticastDelegateProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MulticastDelegateProperty;
        static Load(InName: string): MulticastDelegateProperty;
    }
    
    class MulticastInlineDelegateProperty extends MulticastDelegateProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MulticastInlineDelegateProperty;
        static Load(InName: string): MulticastInlineDelegateProperty;
    }
    
    class MulticastSparseDelegateProperty extends MulticastDelegateProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MulticastSparseDelegateProperty;
        static Load(InName: string): MulticastSparseDelegateProperty;
    }
    
    class NameProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NameProperty;
        static Load(InName: string): NameProperty;
    }
    
    class SetProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SetProperty;
        static Load(InName: string): SetProperty;
    }
    
    class SoftObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoftObjectProperty;
        static Load(InName: string): SoftObjectProperty;
    }
    
    class SoftClassProperty extends SoftObjectProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoftClassProperty;
        static Load(InName: string): SoftClassProperty;
    }
    
    class StrProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StrProperty;
        static Load(InName: string): StrProperty;
    }
    
    class UInt16Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UInt16Property;
        static Load(InName: string): UInt16Property;
    }
    
    class UInt32Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UInt32Property;
        static Load(InName: string): UInt32Property;
    }
    
    class UInt64Property extends NumericProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UInt64Property;
        static Load(InName: string): UInt64Property;
    }
    
    class WeakObjectProperty extends ObjectPropertyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WeakObjectProperty;
        static Load(InName: string): WeakObjectProperty;
    }
    
    class TextProperty extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextProperty;
        static Load(InName: string): TextProperty;
    }
    
    class InputCoreTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputCoreTypes;
        static Load(InName: string): InputCoreTypes;
    }
    
    class FontFaceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFaceInterface;
        static Load(InName: string): FontFaceInterface;
    }
    
    class FontProviderInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontProviderInterface;
        static Load(InName: string): FontProviderInterface;
    }
    
    class SlateTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateTypes;
        static Load(InName: string): SlateTypes;
    }
    
    class SlateWidgetStyleContainerBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleContainerBase;
        static Load(InName: string): SlateWidgetStyleContainerBase;
    }
    
    class SlateWidgetStyleAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomStyle: SlateWidgetStyleContainerBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleAsset;
        static Load(InName: string): SlateWidgetStyleAsset;
    }
    
    class SlateWidgetStyleContainerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleContainerInterface;
        static Load(InName: string): SlateWidgetStyleContainerInterface;
    }
    
    class SlateWidgetStyle {
        constructor();
    }
    
    class SlateSound {
        constructor(ResourceObject: Object);
        ResourceObject: Object;
    }
    
    class ButtonStyle extends SlateWidgetStyle {
        constructor(Normal: SlateBrush, Hovered: SlateBrush, Pressed: SlateBrush, Disabled: SlateBrush, NormalPadding: Margin, PressedPadding: Margin, PressedSlateSound: SlateSound, HoveredSlateSound: SlateSound, PressedSound: string, HoveredSound: string);
        Normal: SlateBrush;
        Hovered: SlateBrush;
        Pressed: SlateBrush;
        Disabled: SlateBrush;
        NormalPadding: Margin;
        PressedPadding: Margin;
        PressedSlateSound: SlateSound;
        HoveredSlateSound: SlateSound;
        PressedSound: string;
        HoveredSound: string;
    }
    
    class ButtonWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ButtonStyle: ButtonStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ButtonWidgetStyle;
        static Load(InName: string): ButtonWidgetStyle;
    }
    
    class CheckBoxStyle extends SlateWidgetStyle {
        constructor(CheckBoxType: number, UncheckedImage: SlateBrush, UncheckedHoveredImage: SlateBrush, UncheckedPressedImage: SlateBrush, CheckedImage: SlateBrush, CheckedHoveredImage: SlateBrush, CheckedPressedImage: SlateBrush, UndeterminedImage: SlateBrush, UndeterminedHoveredImage: SlateBrush, UndeterminedPressedImage: SlateBrush, Padding: Margin, ForegroundColor: SlateColor, BorderBackgroundColor: SlateColor, CheckedSlateSound: SlateSound, UncheckedSlateSound: SlateSound, HoveredSlateSound: SlateSound, CheckedSound: string, UncheckedSound: string, HoveredSound: string);
        CheckBoxType: number;
        UncheckedImage: SlateBrush;
        UncheckedHoveredImage: SlateBrush;
        UncheckedPressedImage: SlateBrush;
        CheckedImage: SlateBrush;
        CheckedHoveredImage: SlateBrush;
        CheckedPressedImage: SlateBrush;
        UndeterminedImage: SlateBrush;
        UndeterminedHoveredImage: SlateBrush;
        UndeterminedPressedImage: SlateBrush;
        Padding: Margin;
        ForegroundColor: SlateColor;
        BorderBackgroundColor: SlateColor;
        CheckedSlateSound: SlateSound;
        UncheckedSlateSound: SlateSound;
        HoveredSlateSound: SlateSound;
        CheckedSound: string;
        UncheckedSound: string;
        HoveredSound: string;
    }
    
    class CheckBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CheckBoxStyle: CheckBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckBoxWidgetStyle;
        static Load(InName: string): CheckBoxWidgetStyle;
    }
    
    class ComboButtonStyle extends SlateWidgetStyle {
        constructor(ButtonStyle: ButtonStyle, DownArrowImage: SlateBrush, MenuBorderBrush: SlateBrush, MenuBorderPadding: Margin);
        ButtonStyle: ButtonStyle;
        DownArrowImage: SlateBrush;
        MenuBorderBrush: SlateBrush;
        MenuBorderPadding: Margin;
    }
    
    class ComboBoxStyle extends SlateWidgetStyle {
        constructor(ComboButtonStyle: ComboButtonStyle, PressedSlateSound: SlateSound, SelectionChangeSlateSound: SlateSound, PressedSound: string, SelectionChangeSound: string);
        ComboButtonStyle: ComboButtonStyle;
        PressedSlateSound: SlateSound;
        SelectionChangeSlateSound: SlateSound;
        PressedSound: string;
        SelectionChangeSound: string;
    }
    
    class ComboBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComboBoxStyle: ComboBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboBoxWidgetStyle;
        static Load(InName: string): ComboBoxWidgetStyle;
    }
    
    class ComboButtonWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComboButtonStyle: ComboButtonStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboButtonWidgetStyle;
        static Load(InName: string): ComboButtonWidgetStyle;
    }
    
    class FontOutlineSettings {
        constructor(OutlineSize: number, bSeparateFillAlpha: boolean, bApplyOutlineToDropShadows: boolean, OutlineMaterial: Object, OutlineColor: LinearColor);
        OutlineSize: number;
        bSeparateFillAlpha: boolean;
        bApplyOutlineToDropShadows: boolean;
        OutlineMaterial: Object;
        OutlineColor: LinearColor;
    }
    
    class SlateFontInfo {
        constructor(FontObject: Object, FontMaterial: Object, OutlineSettings: FontOutlineSettings, TypefaceFontName: string, Size: number, FontName: string, Hinting: EFontHinting);
        FontObject: Object;
        FontMaterial: Object;
        OutlineSettings: FontOutlineSettings;
        TypefaceFontName: string;
        Size: number;
        FontName: string;
        Hinting: EFontHinting;
    }
    
    class ScrollBarStyle extends SlateWidgetStyle {
        constructor(HorizontalBackgroundImage: SlateBrush, VerticalBackgroundImage: SlateBrush, VerticalTopSlotImage: SlateBrush, HorizontalTopSlotImage: SlateBrush, VerticalBottomSlotImage: SlateBrush, HorizontalBottomSlotImage: SlateBrush, NormalThumbImage: SlateBrush, HoveredThumbImage: SlateBrush, DraggedThumbImage: SlateBrush);
        HorizontalBackgroundImage: SlateBrush;
        VerticalBackgroundImage: SlateBrush;
        VerticalTopSlotImage: SlateBrush;
        HorizontalTopSlotImage: SlateBrush;
        VerticalBottomSlotImage: SlateBrush;
        HorizontalBottomSlotImage: SlateBrush;
        NormalThumbImage: SlateBrush;
        HoveredThumbImage: SlateBrush;
        DraggedThumbImage: SlateBrush;
    }
    
    class EditableTextBoxStyle extends SlateWidgetStyle {
        constructor(BackgroundImageNormal: SlateBrush, BackgroundImageHovered: SlateBrush, BackgroundImageFocused: SlateBrush, BackgroundImageReadOnly: SlateBrush, Padding: Margin, Font: SlateFontInfo, ForegroundColor: SlateColor, BackgroundColor: SlateColor, ReadOnlyForegroundColor: SlateColor, HScrollBarPadding: Margin, VScrollBarPadding: Margin, ScrollBarStyle: ScrollBarStyle);
        BackgroundImageNormal: SlateBrush;
        BackgroundImageHovered: SlateBrush;
        BackgroundImageFocused: SlateBrush;
        BackgroundImageReadOnly: SlateBrush;
        Padding: Margin;
        Font: SlateFontInfo;
        ForegroundColor: SlateColor;
        BackgroundColor: SlateColor;
        ReadOnlyForegroundColor: SlateColor;
        HScrollBarPadding: Margin;
        VScrollBarPadding: Margin;
        ScrollBarStyle: ScrollBarStyle;
    }
    
    class EditableTextBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditableTextBoxStyle: EditableTextBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableTextBoxWidgetStyle;
        static Load(InName: string): EditableTextBoxWidgetStyle;
    }
    
    class EditableTextStyle extends SlateWidgetStyle {
        constructor(Font: SlateFontInfo, ColorAndOpacity: SlateColor, BackgroundImageSelected: SlateBrush, BackgroundImageComposing: SlateBrush, CaretImage: SlateBrush);
        Font: SlateFontInfo;
        ColorAndOpacity: SlateColor;
        BackgroundImageSelected: SlateBrush;
        BackgroundImageComposing: SlateBrush;
        CaretImage: SlateBrush;
    }
    
    class EditableTextWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditableTextStyle: EditableTextStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableTextWidgetStyle;
        static Load(InName: string): EditableTextWidgetStyle;
    }
    
    class ProgressBarStyle extends SlateWidgetStyle {
        constructor(BackgroundImage: SlateBrush, FillImage: SlateBrush, MarqueeImage: SlateBrush);
        BackgroundImage: SlateBrush;
        FillImage: SlateBrush;
        MarqueeImage: SlateBrush;
    }
    
    class ProgressWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProgressBarStyle: ProgressBarStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProgressWidgetStyle;
        static Load(InName: string): ProgressWidgetStyle;
    }
    
    class ScrollBarWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScrollBarStyle: ScrollBarStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBarWidgetStyle;
        static Load(InName: string): ScrollBarWidgetStyle;
    }
    
    class ScrollBoxStyle extends SlateWidgetStyle {
        constructor(TopShadowBrush: SlateBrush, BottomShadowBrush: SlateBrush, LeftShadowBrush: SlateBrush, RightShadowBrush: SlateBrush);
        TopShadowBrush: SlateBrush;
        BottomShadowBrush: SlateBrush;
        LeftShadowBrush: SlateBrush;
        RightShadowBrush: SlateBrush;
    }
    
    class ScrollBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScrollBoxStyle: ScrollBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBoxWidgetStyle;
        static Load(InName: string): ScrollBoxWidgetStyle;
    }
    
    class SlateSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bExplicitCanvasChildZOrder: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateSettings;
        static Load(InName: string): SlateSettings;
    }
    
    class SpinBoxStyle extends SlateWidgetStyle {
        constructor(BackgroundBrush: SlateBrush, HoveredBackgroundBrush: SlateBrush, ActiveFillBrush: SlateBrush, InactiveFillBrush: SlateBrush, ArrowsImage: SlateBrush, ForegroundColor: SlateColor, TextPadding: Margin);
        BackgroundBrush: SlateBrush;
        HoveredBackgroundBrush: SlateBrush;
        ActiveFillBrush: SlateBrush;
        InactiveFillBrush: SlateBrush;
        ArrowsImage: SlateBrush;
        ForegroundColor: SlateColor;
        TextPadding: Margin;
    }
    
    class SpinBoxWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpinBoxStyle: SpinBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpinBoxWidgetStyle;
        static Load(InName: string): SpinBoxWidgetStyle;
    }
    
    class TextBlockStyle extends SlateWidgetStyle {
        constructor(Font: SlateFontInfo, ColorAndOpacity: SlateColor, ShadowOffset: Vector2D, ShadowColorAndOpacity: LinearColor, SelectedBackgroundColor: SlateColor, HighlightColor: LinearColor, HighlightShape: SlateBrush, StrikeBrush: SlateBrush, UnderlineBrush: SlateBrush);
        Font: SlateFontInfo;
        ColorAndOpacity: SlateColor;
        ShadowOffset: Vector2D;
        ShadowColorAndOpacity: LinearColor;
        SelectedBackgroundColor: SlateColor;
        HighlightColor: LinearColor;
        HighlightShape: SlateBrush;
        StrikeBrush: SlateBrush;
        UnderlineBrush: SlateBrush;
    }
    
    class TextBlockWidgetStyle extends SlateWidgetStyleContainerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextBlockStyle: TextBlockStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBlockWidgetStyle;
        static Load(InName: string): TextBlockWidgetStyle;
    }
    
    class ToolMenuBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuBase;
        static Load(InName: string): ToolMenuBase;
    }
    
    enum EColorVisionDeficiency { NormalVision, Deuteranope, Protanope, Tritanope, EColorVisionDeficiency_MAX}
    enum EAssetEditorOpenLocation { Default, NewWindow, MainWindow, ContentBrowser, LastDockedWindowOrNewWindow, LastDockedWindowOrMainWindow, LastDockedWindowOrContentBrowser, EAssetEditorOpenLocation_MAX}
    class EditorStyleSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableHighDPIAwareness: boolean;
        bEnableUserEditorLayoutManagement: boolean;
        ColorVisionDeficiencyPreviewType: EColorVisionDeficiency;
        ColorVisionDeficiencySeverity: number;
        bColorVisionDeficiencyCorrection: boolean;
        bColorVisionDeficiencyCorrectionPreviewWithDeficiency: boolean;
        SelectionColor: LinearColor;
        PressedSelectionColor: LinearColor;
        InactiveSelectionColor: LinearColor;
        KeyboardFocusColor: LinearColor;
        EditorWindowBackgroundColor: LinearColor;
        EditorMainWindowBackgroundOverride: SlateBrush;
        EditorChildWindowBackgroundOverride: SlateBrush;
        bResetEditorWindowBackgroundSettings: boolean;
        bUseSmallToolBarIcons: boolean;
        bUseGrid: boolean;
        RegularColor: LinearColor;
        RuleColor: LinearColor;
        CenterColor: LinearColor;
        GridSnapSize: number;
        bEnableWindowAnimations: boolean;
        bShowFriendlyNames: boolean;
        bExpandConfigurationMenus: boolean;
        bShowProjectMenus: boolean;
        bShowLaunchMenus: boolean;
        LogBackgroundColor: LinearColor;
        LogSelectionBackgroundColor: LinearColor;
        LogNormalColor: LinearColor;
        LogCommandColor: LinearColor;
        LogWarningColor: LinearColor;
        LogErrorColor: LinearColor;
        bShowAllAdvancedDetails: boolean;
        bShowHiddenPropertiesWhilePlaying: boolean;
        LogFontSize: number;
        LogTimestampMode: number;
        bPromoteOutputLogWarningsDuringPIE: boolean;
        AssetEditorOpenLocation: EAssetEditorOpenLocation;
        bEnableColorizedEditorTabs: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorStyleSettings;
        static Load(InName: string): EditorStyleSettings;
    }
    
    enum EMobileCSMQuality { NoFiltering, PCF_1x1, PCF_2x2, EMobileCSMQuality_MAX}
    class MaterialQualityOverrides {
        constructor(bDiscardQualityDuringCook: boolean, bEnableOverride: boolean, bForceFullyRough: boolean, bForceNonMetal: boolean, bForceDisableLMDirectionality: boolean, bForceLQReflections: boolean, bDisableMaterialNormalCalculation: boolean, MobileCSMQuality: EMobileCSMQuality);
        bDiscardQualityDuringCook: boolean;
        bEnableOverride: boolean;
        bForceFullyRough: boolean;
        bForceNonMetal: boolean;
        bForceDisableLMDirectionality: boolean;
        bForceLQReflections: boolean;
        bDisableMaterialNormalCalculation: boolean;
        MobileCSMQuality: EMobileCSMQuality;
    }
    
    class ShaderPlatformQualitySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QualityOverrides: FixSizeArray<MaterialQualityOverrides>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShaderPlatformQualitySettings;
        static Load(InName: string): ShaderPlatformQualitySettings;
    }
    
    class MaterialShaderQualitySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForwardSettingMap: TMap<string, ShaderPlatformQualitySettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialShaderQualitySettings;
        static Load(InName: string): MaterialShaderQualitySettings;
    }
    
    class MeshDescription extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshDescription;
        static Load(InName: string): MeshDescription;
    }
    
    class ClothingAssetFactoryBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetFactoryBase;
        static Load(InName: string): ClothingAssetFactoryBase;
    }
    
    class NetAnalyticsDataConfig {
        constructor(DataName: string, bEnabled: boolean);
        DataName: string;
        bEnabled: boolean;
    }
    
    class NetAnalyticsAggregatorConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NetAnalyticsData: TArray<NetAnalyticsDataConfig>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetAnalyticsAggregatorConfig;
        static Load(InName: string): NetAnalyticsAggregatorConfig;
    }
    
    class AssetRegistryImpl extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegistryImpl;
        static Load(InName: string): AssetRegistryImpl;
    }
    
    class AssetData {
        constructor(ObjectPath: string, PackageName: string, PackagePath: string, AssetName: string, AssetClass: string);
        ObjectPath: string;
        PackageName: string;
        PackagePath: string;
        AssetName: string;
        AssetClass: string;
    }
    
    class ARFilter {
        constructor(PackageNames: TArray<string>, PackagePaths: TArray<string>, ObjectPaths: TArray<string>, ClassNames: TArray<string>, RecursiveClassesExclusionSet: TSet<string>, bRecursivePaths: boolean, bRecursiveClasses: boolean, bIncludeOnlyOnDiskAssets: boolean);
        PackageNames: TArray<string>;
        PackagePaths: TArray<string>;
        ObjectPaths: TArray<string>;
        ClassNames: TArray<string>;
        RecursiveClassesExclusionSet: TSet<string>;
        bRecursivePaths: boolean;
        bRecursiveClasses: boolean;
        bIncludeOnlyOnDiskAssets: boolean;
    }
    
    class TagAndValue {
        constructor(Tag: string, Value: string);
        Tag: string;
        Value: string;
    }
    
    class AssetRegistryDependencyOptions {
        constructor(bIncludeSoftPackageReferences: boolean, bIncludeHardPackageReferences: boolean, bIncludeSearchableNames: boolean, bIncludeSoftManagementReferences: boolean, bIncludeHardManagementReferences: boolean);
        bIncludeSoftPackageReferences: boolean;
        bIncludeHardPackageReferences: boolean;
        bIncludeSearchableNames: boolean;
        bIncludeSoftManagementReferences: boolean;
        bIncludeHardManagementReferences: boolean;
    }
    
    class AssetRegistry extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UseFilterToExcludeAssets(AssetDataList: $Ref<TArray<AssetData>>, Filter: ARFilter): void;
        SearchAllAssets(bSynchronousSearch: boolean): void;
        ScanPathsSynchronous(InPaths: TArray<string>, bForceRescan: boolean): void;
        ScanModifiedAssetFiles(InFilePaths: TArray<string>): void;
        ScanFilesSynchronous(InFilePaths: TArray<string>, bForceRescan: boolean): void;
        RunAssetsThroughFilter(AssetDataList: $Ref<TArray<AssetData>>, Filter: ARFilter): void;
        PrioritizeSearchPath(PathToPrioritize: string): void;
        K2_GetReferencers(PackageName: string, ReferenceOptions: AssetRegistryDependencyOptions, OutReferencers: $Ref<TArray<string>>): boolean;
        K2_GetDependencies(PackageName: string, DependencyOptions: AssetRegistryDependencyOptions, OutDependencies: $Ref<TArray<string>>): boolean;
        IsLoadingAssets(): boolean;
        HasAssets(PackagePath: string, bRecursive: boolean): boolean;
        GetSubPaths(InBasePath: string, OutPathList: $Ref<TArray<string>>, bInRecurse: boolean): void;
        GetAssetsByPath(PackagePath: string, OutAssetData: $Ref<TArray<AssetData>>, bRecursive: boolean, bIncludeOnlyOnDiskAssets: boolean): boolean;
        GetAssetsByPackageName(PackageName: string, OutAssetData: $Ref<TArray<AssetData>>, bIncludeOnlyOnDiskAssets: boolean): boolean;
        GetAssetsByClass(ClassName: string, OutAssetData: $Ref<TArray<AssetData>>, bSearchSubClasses: boolean): boolean;
        GetAssets(Filter: ARFilter, OutAssetData: $Ref<TArray<AssetData>>): boolean;
        GetAssetByObjectPath(ObjectPath: string, bIncludeOnlyOnDiskAssets: boolean): AssetData;
        GetAllCachedPaths(OutPathList: $Ref<TArray<string>>): void;
        GetAllAssets(OutAssetData: $Ref<TArray<AssetData>>, bIncludeOnlyOnDiskAssets: boolean): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegistry;
        static Load(InName: string): AssetRegistry;
    }
    
    class AssetRegistryHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ToSoftObjectPath(InAssetData: AssetData): SoftObjectPath;
        static SetFilterTagsAndValues(InFilter: ARFilter, InTagsAndValues: TArray<TagAndValue>): ARFilter;
        static IsValid(InAssetData: AssetData): boolean;
        static IsUAsset(InAssetData: AssetData): boolean;
        static IsRedirector(InAssetData: AssetData): boolean;
        static IsAssetLoaded(InAssetData: AssetData): boolean;
        static GetTagValue(InAssetData: AssetData, InTagName: string, OutTagValue: $Ref<string>): boolean;
        static GetFullName(InAssetData: AssetData): string;
        static GetExportTextName(InAssetData: AssetData): string;
        static GetClass(InAssetData: AssetData): Class;
        static GetAssetRegistry(): AssetRegistry;
        static GetAsset(InAssetData: AssetData): Object;
        static CreateAssetData(InAsset: Object, bAllowBlueprintClass: boolean): AssetData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegistryHelpers;
        static Load(InName: string): AssetRegistryHelpers;
    }
    
    class AutoCompleteCommand {
        constructor(Command: string, Desc: string);
        Command: string;
        Desc: string;
    }
    
    class ConsoleSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxScrollbackSize: number;
        ManualAutoCompleteList: TArray<AutoCompleteCommand>;
        AutoCompleteMapPaths: TArray<string>;
        BackgroundOpacityPercentage: number;
        bOrderTopToBottom: boolean;
        bDisplayHelpInAutoComplete: boolean;
        InputColor: Color;
        HistoryColor: Color;
        AutoCompleteCommandColor: Color;
        AutoCompleteCVarColor: Color;
        AutoCompleteFadedColor: Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConsoleSettings;
        static Load(InName: string): ConsoleSettings;
    }
    
    enum EFourPlayerSplitScreenType { Grid, Vertical, Horizontal, EFourPlayerSplitScreenType_MAX}
    class GameModeName {
        constructor(Name: string, GameMode: SoftClassPath);
        Name: string;
        GameMode: SoftClassPath;
    }
    
    class GameMapsSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorStartupMap: SoftObjectPath;
        LocalMapOptions: string;
        TransitionMap: SoftObjectPath;
        bUseSplitscreen: boolean;
        TwoPlayerSplitscreenLayout: number;
        ThreePlayerSplitscreenLayout: number;
        FourPlayerSplitscreenLayout: EFourPlayerSplitScreenType;
        bOffsetPlayerGamepadIds: boolean;
        GameInstanceClass: SoftClassPath;
        GameDefaultMap: SoftObjectPath;
        ServerDefaultMap: SoftObjectPath;
        GlobalDefaultGameMode: SoftClassPath;
        GlobalDefaultServerGameMode: SoftClassPath;
        GameModeMapPrefixes: TArray<GameModeName>;
        GameModeClassAliases: TArray<GameModeName>;
        SetSkipAssigningGamepadToPlayer1(bSkipFirstPlayer: boolean): void;
        GetSkipAssigningGamepadToPlayer1(): boolean;
        static GetGameMapsSettings(): GameMapsSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameMapsSettings;
        static Load(InName: string): GameMapsSettings;
    }
    
    class GameNetworkManagerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinDynamicBandwidth: number;
        MaxDynamicBandwidth: number;
        TotalNetBandwidth: number;
        BadPingThreshold: number;
        bIsStandbyCheckingEnabled: boolean;
        StandbyRxCheatTime: number;
        StandbyTxCheatTime: number;
        PercentMissingForRxStandby: number;
        PercentMissingForTxStandby: number;
        PercentForBadPing: number;
        JoinInProgressStandbyWaitTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameNetworkManagerSettings;
        static Load(InName: string): GameNetworkManagerSettings;
    }
    
    class GameSessionSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxSpectators: number;
        MaxPlayers: number;
        bRequiresPushToTalk: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameSessionSettings;
        static Load(InName: string): GameSessionSettings;
    }
    
    class GeneralEngineSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeneralEngineSettings;
        static Load(InName: string): GeneralEngineSettings;
    }
    
    class GeneralProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompanyName: string;
        CompanyDistinguishedName: string;
        CopyrightNotice: string;
        Description: string;
        Homepage: string;
        LicensingTerms: string;
        PrivacyPolicy: string;
        ProjectID: Guid;
        ProjectName: string;
        ProjectVersion: string;
        SupportContact: string;
        ProjectDisplayedTitle: string;
        ProjectDebugTitleInfo: string;
        bShouldWindowPreserveAspectRatio: boolean;
        bUseBorderlessWindow: boolean;
        bStartInVR: boolean;
        bStartInAR: boolean;
        bSupportAR: boolean;
        bAllowWindowResize: boolean;
        bAllowClose: boolean;
        bAllowMaximize: boolean;
        bAllowMinimize: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeneralProjectSettings;
        static Load(InName: string): GeneralProjectSettings;
    }
    
    class HudSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowHUD: boolean;
        DebugDisplay: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HudSettings;
        static Load(InName: string): HudSettings;
    }
    
    class HandlerComponentFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HandlerComponentFactory;
        static Load(InName: string): HandlerComponentFactory;
    }
    
    class PacketHandlerProfileConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Components: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PacketHandlerProfileConfig;
        static Load(InName: string): PacketHandlerProfileConfig;
    }
    
    class ClothConfigBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothConfigBase;
        static Load(InName: string): ClothConfigBase;
    }
    
    class ClothingSimulationFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationFactory;
        static Load(InName: string): ClothingSimulationFactory;
    }
    
    class ClothVertBoneData {
        constructor(NumInfluences: number, BoneIndices: FixSizeArray<number>, BoneWeights: FixSizeArray<number>);
        NumInfluences: number;
        BoneIndices: FixSizeArray<number>;
        BoneWeights: FixSizeArray<number>;
    }
    
    class ClothPhysicalMeshDataBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Vertices: TArray<Vector>;
        Normals: TArray<Vector>;
        VertexColors: TArray<Color>;
        Indices: TArray<number>;
        InverseMasses: TArray<number>;
        BoneData: TArray<ClothVertBoneData>;
        NumFixedVerts: number;
        MaxBoneWeights: number;
        SelfCollisionIndices: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPhysicalMeshDataBase;
        static Load(InName: string): ClothPhysicalMeshDataBase;
    }
    
    class JsonUtilitiesDummyObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JsonUtilitiesDummyObject;
        static Load(InName: string): JsonUtilitiesDummyObject;
    }
    
    enum EMultiBoxType { MenuBar, ToolBar, VerticalToolBar, Menu, ButtonRow, ToolMenuBar, EMultiBoxType_MAX}
    class ToolMenuOwner {
        constructor();
    }
    
    class ToolMenuContext {
        constructor(ContextObjects: TArray<Object>);
        ContextObjects: TArray<Object>;
    }
    
    enum EMultiBlockType { None, ButtonRow, EditableText, Heading, MenuEntry, MenuSeparator, ToolBarButton, ToolBarComboButton, ToolBarSeparator, Widget, EMultiBlockType_MAX}
    enum EUserInterfaceActionType { None, Button, ToggleButton, RadioButton, Check, CollapsedButton, EUserInterfaceActionType_MAX}
    enum EToolMenuInsertType { Default, Before, After, First, EToolMenuInsertType_MAX}
    class ToolMenuInsert {
        constructor(Name: string, Position: EToolMenuInsertType);
        Name: string;
        Position: EToolMenuInsertType;
    }
    
    class ScriptSlateIcon {
        constructor(StyleSetName: string, StyleName: string, SmallStyleName: string);
        StyleSetName: string;
        StyleName: string;
        SmallStyleName: string;
    }
    
    class ToolMenuEntryScriptDataAdvanced {
        constructor(TutorialHighlight: string, EntryType: EMultiBlockType, UserInterfaceActionType: EUserInterfaceActionType, bIsSubMenu: boolean, bOpenSubMenuOnClick: boolean, bShouldCloseWindowAfterMenuSelection: boolean, bSimpleComboBox: boolean);
        TutorialHighlight: string;
        EntryType: EMultiBlockType;
        UserInterfaceActionType: EUserInterfaceActionType;
        bIsSubMenu: boolean;
        bOpenSubMenuOnClick: boolean;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bSimpleComboBox: boolean;
    }
    
    class ToolMenuEntryScriptData {
        constructor(Menu: string, Section: string, Name: string, Label: string, ToolTip: string, Icon: ScriptSlateIcon, OwnerName: string, InsertPosition: ToolMenuInsert, Advanced: ToolMenuEntryScriptDataAdvanced);
        Menu: string;
        Section: string;
        Name: string;
        Label: string;
        ToolTip: string;
        Icon: ScriptSlateIcon;
        OwnerName: string;
        InsertPosition: ToolMenuInsert;
        Advanced: ToolMenuEntryScriptDataAdvanced;
    }
    
    class ToolMenuEntryScript extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Data: ToolMenuEntryScriptData;
        RegisterMenuEntry(): void;
        IsVisible(Context: ToolMenuContext): boolean;
        InitEntry(OwnerName: string, Menu: string, Section: string, Name: string, Label: string, ToolTip: string): void;
        GetToolTip(Context: ToolMenuContext): string;
        GetLabel(Context: ToolMenuContext): string;
        GetIcon(Context: ToolMenuContext): ScriptSlateIcon;
        GetCheckState(Context: ToolMenuContext): ECheckBoxState;
        Execute(Context: ToolMenuContext): void;
        ConstructMenuEntry(Menu: ToolMenu, SectionName: string, Context: ToolMenuContext): void;
        CanExecute(Context: ToolMenuContext): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuEntryScript;
        static Load(InName: string): ToolMenuEntryScript;
    }
    
    class ToolMenuEntry {
        constructor(Name: string, Owner: ToolMenuOwner, Type: EMultiBlockType, UserInterfaceActionType: EUserInterfaceActionType, TutorialHighlightName: string, InsertPosition: ToolMenuInsert, bShouldCloseWindowAfterMenuSelection: boolean, ScriptObject: ToolMenuEntryScript);
        Name: string;
        Owner: ToolMenuOwner;
        Type: EMultiBlockType;
        UserInterfaceActionType: EUserInterfaceActionType;
        TutorialHighlightName: string;
        InsertPosition: ToolMenuInsert;
        bShouldCloseWindowAfterMenuSelection: boolean;
        ScriptObject: ToolMenuEntryScript;
    }
    
    class ToolMenuSectionDynamic extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstructSections(Menu: ToolMenu, Context: ToolMenuContext): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuSectionDynamic;
        static Load(InName: string): ToolMenuSectionDynamic;
    }
    
    class ToolMenuSection {
        constructor(Name: string, Blocks: TArray<ToolMenuEntry>, InsertPosition: ToolMenuInsert, Context: ToolMenuContext, ToolMenuSectionDynamic: ToolMenuSectionDynamic);
        Name: string;
        Blocks: TArray<ToolMenuEntry>;
        InsertPosition: ToolMenuInsert;
        Context: ToolMenuContext;
        ToolMenuSectionDynamic: ToolMenuSectionDynamic;
    }
    
    class ToolMenu extends ToolMenuBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MenuName: string;
        MenuParent: string;
        StyleName: string;
        TutorialHighlightName: string;
        MenuType: EMultiBoxType;
        bShouldCloseWindowAfterMenuSelection: boolean;
        bCloseSelfOnly: boolean;
        bSearchable: boolean;
        bToolBarIsFocusable: boolean;
        bToolBarForceSmallIcons: boolean;
        bPreventCustomization: boolean;
        MenuOwner: ToolMenuOwner;
        Context: ToolMenuContext;
        Sections: TArray<ToolMenuSection>;
        SubMenuParent: ToolMenu;
        SubMenuSourceEntryName: string;
        InitMenu(Owner: ToolMenuOwner, Name: string, Parent: string, Type: EMultiBoxType): void;
        AddSubMenuScript(Owner: string, SectionName: string, Name: string, Label: string, ToolTip: string): ToolMenu;
        AddSectionScript(SectionName: string, Label: string, InsertName: string, InsertType: EToolMenuInsertType): void;
        AddMenuEntryObject(InObject: ToolMenuEntryScript): void;
        AddMenuEntry(SectionName: string, Args: ToolMenuEntry): void;
        AddDynamicSectionScript(SectionName: string, Object: ToolMenuSectionDynamic): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenu;
        static Load(InName: string): ToolMenu;
    }
    
    class ToolMenuContextBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuContextBase;
        static Load(InName: string): ToolMenuContextBase;
    }
    
    class SlateTabManagerContext extends ToolMenuContextBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateTabManagerContext;
        static Load(InName: string): SlateTabManagerContext;
    }
    
    enum ECustomizedToolMenuVisibility { None, Visible, Hidden, ECustomizedToolMenuVisibility_MAX}
    class CustomizedToolMenuEntry {
        constructor(Visibility: ECustomizedToolMenuVisibility);
        Visibility: ECustomizedToolMenuVisibility;
    }
    
    class CustomizedToolMenuSection {
        constructor(Visibility: ECustomizedToolMenuVisibility);
        Visibility: ECustomizedToolMenuVisibility;
    }
    
    class CustomizedToolMenuNameArray {
        constructor(Names: TArray<string>);
        Names: TArray<string>;
    }
    
    class CustomizedToolMenu {
        constructor(Name: string, Entries: TMap<string, CustomizedToolMenuEntry>, Sections: TMap<string, CustomizedToolMenuSection>, EntryOrder: TMap<string, CustomizedToolMenuNameArray>, SectionOrder: TArray<string>);
        Name: string;
        Entries: TMap<string, CustomizedToolMenuEntry>;
        Sections: TMap<string, CustomizedToolMenuSection>;
        EntryOrder: TMap<string, CustomizedToolMenuNameArray>;
        SectionOrder: TArray<string>;
    }
    
    class ToolMenus extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomizedMenus: TArray<CustomizedToolMenu>;
        Menus: TMap<string, ToolMenu>;
        UnregisterOwnerByName(InOwnerName: string): void;
        SetSectionPosition(MenuName: string, SectionName: string, OtherSectionName: string, PositionType: EToolMenuInsertType): void;
        SetSectionLabel(MenuName: string, SectionName: string, Label: string): void;
        RemoveSection(MenuName: string, Section: string): void;
        RemoveMenu(MenuName: string): void;
        RemoveEntry(MenuName: string, Section: string, Name: string): void;
        RegisterMenu(Name: string, Parent: string, Type: EMultiBoxType, bWarnIfAlreadyRegistered: boolean): ToolMenu;
        RefreshMenuWidget(Name: string): boolean;
        RefreshAllWidgets(): void;
        IsMenuRegistered(Name: string): boolean;
        static Get(): ToolMenus;
        FindMenu(Name: string): ToolMenu;
        static FindContext(InContext: ToolMenuContext, InClass: Class): Object;
        ExtendMenu(Name: string): ToolMenu;
        static AddMenuEntryObject(MenuEntryObject: ToolMenuEntryScript): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenus;
        static Load(InName: string): ToolMenus;
    }
    
    class ToolMenuContextExtensions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FindByClass(Context: ToolMenuContext, InClass: Class): Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuContextExtensions;
        static Load(InName: string): ToolMenuContextExtensions;
    }
    
    enum EToolMenuStringCommandType { Command, Python, Custom, EToolMenuStringCommandType_MAX}
    class ToolMenuStringCommand {
        constructor(Type: EToolMenuStringCommandType, CustomType: string, String: string);
        Type: EToolMenuStringCommandType;
        CustomType: string;
        String: string;
    }
    
    class ToolMenuEntryExtensions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetToolTip(Target: $Ref<ToolMenuEntry>, ToolTip: string): void;
        static SetStringCommand(Target: $Ref<ToolMenuEntry>, Type: EToolMenuStringCommandType, CustomType: string, String: string): void;
        static SetLabel(Target: $Ref<ToolMenuEntry>, Label: string): void;
        static SetIcon(Target: $Ref<ToolMenuEntry>, StyleSetName: string, StyleName: string, SmallStyleName: string): void;
        static MakeToolMenuOwner(Name: string): ToolMenuOwner;
        static MakeStringCommand(Type: EToolMenuStringCommandType, CustomType: string, String: string): ToolMenuStringCommand;
        static MakeScriptSlateIcon(StyleSetName: string, StyleName: string, SmallStyleName: string): ScriptSlateIcon;
        static InitMenuEntry(InOwner: string, InName: string, InLabel: string, InToolTip: string, CommandType: EToolMenuStringCommandType, CustomCommandType: string, CommandString: string): ToolMenuEntry;
        static GetToolTip(Target: ToolMenuEntry): string;
        static GetLabel(Target: ToolMenuEntry): string;
        static BreakToolMenuOwner(InValue: ToolMenuOwner, Name: $Ref<string>): void;
        static BreakStringCommand(InValue: ToolMenuStringCommand, Type: $Ref<EToolMenuStringCommandType>, CustomType: $Ref<string>, String: $Ref<string>): void;
        static BreakScriptSlateIcon(InValue: ScriptSlateIcon, StyleSetName: $Ref<string>, StyleName: $Ref<string>, SmallStyleName: $Ref<string>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuEntryExtensions;
        static Load(InName: string): ToolMenuEntryExtensions;
    }
    
    class ToolMenuSectionExtensions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetLabel(Section: $Ref<ToolMenuSection>, Label: string): void;
        static GetLabel(Section: ToolMenuSection): string;
        static AddEntryObject(Section: $Ref<ToolMenuSection>, InObject: ToolMenuEntryScript): void;
        static AddEntry(Section: $Ref<ToolMenuSection>, Args: ToolMenuEntry): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolMenuSectionExtensions;
        static Load(InName: string): ToolMenuSectionExtensions;
    }
    
    enum EPIEPreviewDeviceType { Unset, Android, IOS, TVOS, Switch, MAX}
    class PIEPreviewDeviceSpecification extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewDeviceType: EPIEPreviewDeviceType;
        GPUFamily: string;
        GLVersion: string;
        VulkanVersion: string;
        AndroidVersion: string;
        DeviceMake: string;
        DeviceModel: string;
        DeviceBuildNumber: string;
        UsingHoudini: boolean;
        Hardware: string;
        Chipset: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PIEPreviewDeviceSpecification;
        static Load(InName: string): PIEPreviewDeviceSpecification;
    }
    
    class BlueprintFunctionLibrary extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionLibrary;
        static Load(InName: string): BlueprintFunctionLibrary;
    }
    
    class GameplayTag {
        constructor(TagName: string);
        TagName: string;
    }
    
    class GameplayTagContainer {
        constructor(GameplayTags: TArray<GameplayTag>, ParentTags: TArray<GameplayTag>);
        GameplayTags: TArray<GameplayTag>;
        ParentTags: TArray<GameplayTag>;
    }
    
    class GameplayTagQuery {
        constructor(TokenStreamVersion: number, TagDictionary: TArray<GameplayTag>, QueryTokenStream: TArray<number>, UserDescription: string, AutoDescription: string);
        TokenStreamVersion: number;
        TagDictionary: TArray<GameplayTag>;
        QueryTokenStream: TArray<number>;
        UserDescription: string;
        AutoDescription: string;
    }
    
    class GameplayTagAssetInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HasMatchingGameplayTag(TagToCheck: GameplayTag): boolean;
        HasAnyMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
        HasAllMatchingGameplayTags(TagContainer: GameplayTagContainer): boolean;
        GetOwnedGameplayTags(TagContainer: $Ref<GameplayTagContainer>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagAssetInterface;
        static Load(InName: string): GameplayTagAssetInterface;
    }
    
    class BlueprintGameplayTagLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RemoveGameplayTag(TagContainer: $Ref<GameplayTagContainer>, Tag: GameplayTag): boolean;
        static NotEqual_TagTag(A: GameplayTag, B: string): boolean;
        static NotEqual_TagContainerTagContainer(A: GameplayTagContainer, B: string): boolean;
        static NotEqual_GameplayTagContainer(A: GameplayTagContainer, B: GameplayTagContainer): boolean;
        static NotEqual_GameplayTag(A: GameplayTag, B: GameplayTag): boolean;
        static MatchesTag(TagOne: GameplayTag, TagTwo: GameplayTag, bExactMatch: boolean): boolean;
        static MatchesAnyTags(TagOne: GameplayTag, OtherContainer: GameplayTagContainer, bExactMatch: boolean): boolean;
        static MakeLiteralGameplayTagContainer(Value: GameplayTagContainer): GameplayTagContainer;
        static MakeLiteralGameplayTag(Value: GameplayTag): GameplayTag;
        static MakeGameplayTagQuery(TagQuery: GameplayTagQuery): GameplayTagQuery;
        static MakeGameplayTagContainerFromTag(SingleTag: GameplayTag): GameplayTagContainer;
        static MakeGameplayTagContainerFromArray(GameplayTags: TArray<GameplayTag>): GameplayTagContainer;
        static IsTagQueryEmpty(TagQuery: GameplayTagQuery): boolean;
        static IsGameplayTagValid(GameplayTag: GameplayTag): boolean;
        static HasTag(TagContainer: GameplayTagContainer, Tag: GameplayTag, bExactMatch: boolean): boolean;
        static HasAnyTags(TagContainer: GameplayTagContainer, OtherContainer: GameplayTagContainer, bExactMatch: boolean): boolean;
        static HasAllTags(TagContainer: GameplayTagContainer, OtherContainer: GameplayTagContainer, bExactMatch: boolean): boolean;
        static HasAllMatchingGameplayTags(TagContainerInterface: GameplayTagAssetInterface, OtherContainer: GameplayTagContainer): boolean;
        static GetTagName(GameplayTag: GameplayTag): string;
        static GetNumGameplayTagsInContainer(TagContainer: GameplayTagContainer): number;
        static GetDebugStringFromGameplayTagContainer(TagContainer: GameplayTagContainer): string;
        static GetDebugStringFromGameplayTag(GameplayTag: GameplayTag): string;
        static GetAllActorsOfClassMatchingTagQuery(WorldContextObject: Object, ActorClass: Class, GameplayTagQuery: GameplayTagQuery, OutActors: $Ref<TArray<Actor>>): void;
        static EqualEqual_GameplayTagContainer(A: GameplayTagContainer, B: GameplayTagContainer): boolean;
        static EqualEqual_GameplayTag(A: GameplayTag, B: GameplayTag): boolean;
        static DoesTagAssetInterfaceHaveTag(TagContainerInterface: GameplayTagAssetInterface, Tag: GameplayTag): boolean;
        static DoesContainerMatchTagQuery(TagContainer: GameplayTagContainer, TagQuery: GameplayTagQuery): boolean;
        static BreakGameplayTagContainer(GameplayTagContainer: GameplayTagContainer, GameplayTags: $Ref<TArray<GameplayTag>>): void;
        static AppendGameplayTagContainers(InOutTagContainer: $Ref<GameplayTagContainer>, InTagContainer: GameplayTagContainer): void;
        static AddGameplayTag(TagContainer: $Ref<GameplayTagContainer>, Tag: GameplayTag): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintGameplayTagLibrary;
        static Load(InName: string): BlueprintGameplayTagLibrary;
    }
    
    class EditableGameplayTagQueryExpression extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression;
        static Load(InName: string): EditableGameplayTagQueryExpression;
    }
    
    class EditableGameplayTagQuery extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UserDescription: string;
        RootExpression: EditableGameplayTagQueryExpression;
        TagQueryExportText_Helper: GameplayTagQuery;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQuery;
        static Load(InName: string): EditableGameplayTagQuery;
    }
    
    class EditableGameplayTagQueryExpression_AnyTagsMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tags: GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AnyTagsMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AnyTagsMatch;
    }
    
    class EditableGameplayTagQueryExpression_AllTagsMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tags: GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AllTagsMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AllTagsMatch;
    }
    
    class EditableGameplayTagQueryExpression_NoTagsMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tags: GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_NoTagsMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_NoTagsMatch;
    }
    
    class EditableGameplayTagQueryExpression_AnyExprMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expressions: TArray<EditableGameplayTagQueryExpression>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AnyExprMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AnyExprMatch;
    }
    
    class EditableGameplayTagQueryExpression_AllExprMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expressions: TArray<EditableGameplayTagQueryExpression>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_AllExprMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_AllExprMatch;
    }
    
    class EditableGameplayTagQueryExpression_NoExprMatch extends EditableGameplayTagQueryExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expressions: TArray<EditableGameplayTagQueryExpression>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGameplayTagQueryExpression_NoExprMatch;
        static Load(InName: string): EditableGameplayTagQueryExpression_NoExprMatch;
    }
    
    enum EGameplayTagSourceType { Native, DefaultTagList, TagList, RestrictedTagList, DataTable, Invalid, EGameplayTagSourceType_MAX}
    class TableRowBase {
        constructor();
    }
    
    class GameplayTagTableRow extends TableRowBase {
        constructor(Tag: string, DevComment: string);
        Tag: string;
        DevComment: string;
    }
    
    class GameplayTagsList extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConfigFileName: string;
        GameplayTagList: TArray<GameplayTagTableRow>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsList;
        static Load(InName: string): GameplayTagsList;
    }
    
    class RestrictedGameplayTagTableRow extends GameplayTagTableRow {
        constructor(bAllowNonRestrictedChildren: boolean);
        bAllowNonRestrictedChildren: boolean;
    }
    
    class RestrictedGameplayTagsList extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConfigFileName: string;
        RestrictedGameplayTagList: TArray<RestrictedGameplayTagTableRow>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RestrictedGameplayTagsList;
        static Load(InName: string): RestrictedGameplayTagsList;
    }
    
    class GameplayTagSource {
        constructor(SourceName: string, SourceType: EGameplayTagSourceType, SourceTagList: GameplayTagsList, SourceRestrictedTagList: RestrictedGameplayTagsList);
        SourceName: string;
        SourceType: EGameplayTagSourceType;
        SourceTagList: GameplayTagsList;
        SourceRestrictedTagList: RestrictedGameplayTagsList;
    }
    
    class DataTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RowStruct: ScriptStruct;
        bStripFromClientBuilds: boolean;
        bIgnoreExtraFields: boolean;
        bIgnoreMissingFields: boolean;
        ImportKeyField: string;
        AssetImportData: AssetImportData;
        ImportPath: string;
        RowStructName: string;
        RowsSerializedWithTags: TArray<number>;
        TemporarilyReferencedObjects: TSet<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataTable;
        static Load(InName: string): DataTable;
    }
    
    class GameplayTagsManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TagSources: TArray<GameplayTagSource>;
        GameplayTagTables: TArray<DataTable>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsManager;
        static Load(InName: string): GameplayTagsManager;
    }
    
    class GameplayTagCategoryRemap {
        constructor(BaseCategory: string, RemapCategories: TArray<string>);
        BaseCategory: string;
        RemapCategories: TArray<string>;
    }
    
    class GameplayTagRedirect {
        constructor(OldTagName: string, NewTagName: string);
        OldTagName: string;
        NewTagName: string;
    }
    
    class RestrictedConfigInfo {
        constructor(RestrictedConfigName: string, Owners: TArray<string>);
        RestrictedConfigName: string;
        Owners: TArray<string>;
    }
    
    class GameplayTagsSettings extends GameplayTagsList {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportTagsFromConfig: boolean;
        WarnOnInvalidTags: boolean;
        FastReplication: boolean;
        InvalidTagCharacters: string;
        CategoryRemapping: TArray<GameplayTagCategoryRemap>;
        GameplayTagTableList: TArray<SoftObjectPath>;
        GameplayTagRedirects: TArray<GameplayTagRedirect>;
        CommonlyReplicatedTags: TArray<string>;
        NumBitsForContainerSize: number;
        NetIndexFirstBitSegment: number;
        RestrictedConfigFiles: TArray<RestrictedConfigInfo>;
        RestrictedTagList: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsSettings;
        static Load(InName: string): GameplayTagsSettings;
    }
    
    class GameplayTagsDeveloperSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeveloperConfigName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsDeveloperSettings;
        static Load(InName: string): GameplayTagsDeveloperSettings;
    }
    
    class InputBehavior extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputBehavior;
        static Load(InName: string): InputBehavior;
    }
    
    class AnyButtonInputBehavior extends InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ButtonNumber: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnyButtonInputBehavior;
        static Load(InName: string): AnyButtonInputBehavior;
    }
    
    class InteractiveGizmoBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveGizmoBuilder;
        static Load(InName: string): InteractiveGizmoBuilder;
    }
    
    class AxisAngleGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisAngleGizmoBuilder;
        static Load(InName: string): AxisAngleGizmoBuilder;
    }
    
    class BehaviorInfo {
        constructor(Behavior: InputBehavior);
        Behavior: InputBehavior;
    }
    
    class InputBehaviorSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Behaviors: TArray<BehaviorInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputBehaviorSet;
        static Load(InName: string): InputBehaviorSet;
    }
    
    class InteractiveGizmo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputBehaviors: InputBehaviorSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveGizmo;
        static Load(InName: string): InteractiveGizmo;
    }
    
    class GizmoAxisSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HasTangentVectors(): boolean;
        GetTangentVectors(TangentXOut: $Ref<Vector>, TangentYOut: $Ref<Vector>): void;
        GetOrigin(): Vector;
        GetDirection(): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoAxisSource;
        static Load(InName: string): GizmoAxisSource;
    }
    
    class GizmoFloatParameterSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetParameter(NewValue: number): void;
        GetParameter(): number;
        EndModify(): void;
        BeginModify(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoFloatParameterSource;
        static Load(InName: string): GizmoFloatParameterSource;
    }
    
    class GizmoClickTarget extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateHoverState(bHovering: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoClickTarget;
        static Load(InName: string): GizmoClickTarget;
    }
    
    class GizmoStateTarget extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EndUpdate(): void;
        BeginUpdate(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoStateTarget;
        static Load(InName: string): GizmoStateTarget;
    }
    
    class AxisAngleGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        AngleSource: GizmoFloatParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        RotationOrigin: Vector;
        RotationAxis: Vector;
        RotationPlaneX: Vector;
        RotationPlaneY: Vector;
        InteractionStartPoint: Vector;
        InteractionCurPoint: Vector;
        InteractionStartAngle: number;
        InteractionCurAngle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisAngleGizmo;
        static Load(InName: string): AxisAngleGizmo;
    }
    
    class AxisPositionGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisPositionGizmoBuilder;
        static Load(InName: string): AxisPositionGizmoBuilder;
    }
    
    class AxisPositionGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        ParameterSource: GizmoFloatParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        InteractionOrigin: Vector;
        InteractionAxis: Vector;
        InteractionStartPoint: Vector;
        InteractionCurPoint: Vector;
        InteractionStartParameter: number;
        InteractionCurParameter: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisPositionGizmo;
        static Load(InName: string): AxisPositionGizmo;
    }
    
    class GizmoConstantAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Origin: Vector;
        Direction: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoConstantAxisSource;
        static Load(InName: string): GizmoConstantAxisSource;
    }
    
    class GizmoWorldAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Origin: Vector;
        AxisIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoWorldAxisSource;
        static Load(InName: string): GizmoWorldAxisSource;
    }
    
    class GizmoComponentAxisSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: SceneComponent;
        AxisIndex: number;
        bLocalAxes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoComponentAxisSource;
        static Load(InName: string): GizmoComponentAxisSource;
    }
    
    class ClickDragInputBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClickDragInputBehavior;
        static Load(InName: string): ClickDragInputBehavior;
    }
    
    class InteractiveToolBuilder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolBuilder;
        static Load(InName: string): InteractiveToolBuilder;
    }
    
    class ClickDragToolBuilder extends InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClickDragToolBuilder;
        static Load(InName: string): ClickDragToolBuilder;
    }
    
    class InteractiveTool extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputBehaviors: InputBehaviorSet;
        ToolPropertyObjects: TArray<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveTool;
        static Load(InName: string): InteractiveTool;
    }
    
    class ClickDragTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClickDragTool;
        static Load(InName: string): ClickDragTool;
    }
    
    class InternalToolFrameworkActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternalToolFrameworkActor;
        static Load(InName: string): InternalToolFrameworkActor;
    }
    
    class GizmoActor extends InternalToolFrameworkActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoActor;
        static Load(InName: string): GizmoActor;
    }
    
    class GizmoBaseComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Color: LinearColor;
        HoverSizeMultiplier: number;
        PixelHitDistanceThreshold: number;
        UpdateWorldLocalState(bWorldIn: boolean): void;
        UpdateHoverState(bHoveringIn: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseComponent;
        static Load(InName: string): GizmoBaseComponent;
    }
    
    class GizmoArrowComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Direction: Vector;
        Gap: number;
        Length: number;
        Thickness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoArrowComponent;
        static Load(InName: string): GizmoArrowComponent;
    }
    
    class GizmoCircleComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Normal: Vector;
        Radius: number;
        Thickness: number;
        NumSides: number;
        bViewAligned: boolean;
        bOnlyAllowFrontFacingHits: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoCircleComponent;
        static Load(InName: string): GizmoCircleComponent;
    }
    
    class GizmoTransformSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetTransform(NewTransform: Transform): void;
        GetTransform(): Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoTransformSource;
        static Load(InName: string): GizmoTransformSource;
    }
    
    class GizmoVec2ParameterSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetParameter(NewValue: Vector2D): void;
        GetParameter(): Vector2D;
        EndModify(): void;
        BeginModify(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoVec2ParameterSource;
        static Load(InName: string): GizmoVec2ParameterSource;
    }
    
    class GizmoRectangleComponent extends GizmoBaseComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DirectionX: Vector;
        DirectionY: Vector;
        OffsetX: number;
        OffsetY: number;
        LengthX: number;
        LengthY: number;
        Thickness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoRectangleComponent;
        static Load(InName: string): GizmoRectangleComponent;
    }
    
    class GizmoLambdaHitTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLambdaHitTarget;
        static Load(InName: string): GizmoLambdaHitTarget;
    }
    
    class GizmoComponentHitTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoComponentHitTarget;
        static Load(InName: string): GizmoComponentHitTarget;
    }
    
    class InputBehaviorSource extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputBehaviorSource;
        static Load(InName: string): InputBehaviorSource;
    }
    
    class InputRouter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoInvalidateOnHover: boolean;
        bAutoInvalidateOnCapture: boolean;
        ActiveInputBehaviors: InputBehaviorSet;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputRouter;
        static Load(InName: string): InputRouter;
    }
    
    class ActiveGizmo {
        constructor();
    }
    
    class InteractiveGizmoManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveGizmos: TArray<ActiveGizmo>;
        GizmoBuilders: TMap<string, InteractiveGizmoBuilder>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveGizmoManager;
        static Load(InName: string): InteractiveGizmoManager;
    }
    
    class InteractiveToolPropertySet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CachedProperties: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolPropertySet;
        static Load(InName: string): InteractiveToolPropertySet;
    }
    
    class ToolContextTransactionProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolContextTransactionProvider;
        static Load(InName: string): ToolContextTransactionProvider;
    }
    
    class InteractiveToolManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveLeftTool: InteractiveTool;
        ActiveRightTool: InteractiveTool;
        ToolBuilders: TMap<string, InteractiveToolBuilder>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolManager;
        static Load(InName: string): InteractiveToolManager;
    }
    
    class ToolFrameworkComponent extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToolFrameworkComponent;
        static Load(InName: string): ToolFrameworkComponent;
    }
    
    class InteractiveToolsContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputRouter: InputRouter;
        ToolManager: InteractiveToolManager;
        GizmoManager: InteractiveGizmoManager;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveToolsContext;
        static Load(InName: string): InteractiveToolsContext;
    }
    
    class KeyAsModifierInputBehavior extends InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KeyAsModifierInputBehavior;
        static Load(InName: string): KeyAsModifierInputBehavior;
    }
    
    class MeshSurfacePointToolBuilder extends InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointToolBuilder;
        static Load(InName: string): MeshSurfacePointToolBuilder;
    }
    
    class SingleSelectionTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleSelectionTool;
        static Load(InName: string): SingleSelectionTool;
    }
    
    class MeshSurfacePointTool extends SingleSelectionTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointTool;
        static Load(InName: string): MeshSurfacePointTool;
    }
    
    class MeshSurfacePointToolMouseBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSurfacePointToolMouseBehavior;
        static Load(InName: string): MeshSurfacePointToolMouseBehavior;
    }
    
    class MouseHoverBehavior extends InputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MouseHoverBehavior;
        static Load(InName: string): MouseHoverBehavior;
    }
    
    class MultiClickSequenceInputBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiClickSequenceInputBehavior;
        static Load(InName: string): MultiClickSequenceInputBehavior;
    }
    
    class MultiSelectionTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiSelectionTool;
        static Load(InName: string): MultiSelectionTool;
    }
    
    class GizmoBaseFloatParameterSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseFloatParameterSource;
        static Load(InName: string): GizmoBaseFloatParameterSource;
    }
    
    class GizmoFloatParameterChange {
        constructor(InitialValue: number, CurrentValue: number);
        InitialValue: number;
        CurrentValue: number;
    }
    
    class GizmoLocalFloatParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: number;
        LastChange: GizmoFloatParameterChange;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLocalFloatParameterSource;
        static Load(InName: string): GizmoLocalFloatParameterSource;
    }
    
    class GizmoBaseVec2ParameterSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseVec2ParameterSource;
        static Load(InName: string): GizmoBaseVec2ParameterSource;
    }
    
    class GizmoVec2ParameterChange {
        constructor(InitialValue: Vector2D, CurrentValue: Vector2D);
        InitialValue: Vector2D;
        CurrentValue: Vector2D;
    }
    
    class GizmoLocalVec2ParameterSource extends GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: Vector2D;
        LastChange: GizmoVec2ParameterChange;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLocalVec2ParameterSource;
        static Load(InName: string): GizmoLocalVec2ParameterSource;
    }
    
    class GizmoAxisTranslationParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Parameter: number;
        LastChange: GizmoFloatParameterChange;
        CurTranslationAxis: Vector;
        CurTranslationOrigin: Vector;
        InitialTransform: Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoAxisTranslationParameterSource;
        static Load(InName: string): GizmoAxisTranslationParameterSource;
    }
    
    class GizmoPlaneTranslationParameterSource extends GizmoBaseVec2ParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Parameter: Vector2D;
        LastChange: GizmoVec2ParameterChange;
        CurTranslationOrigin: Vector;
        CurTranslationNormal: Vector;
        CurTranslationAxisX: Vector;
        CurTranslationAxisY: Vector;
        InitialTransform: Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoPlaneTranslationParameterSource;
        static Load(InName: string): GizmoPlaneTranslationParameterSource;
    }
    
    class GizmoAxisRotationParameterSource extends GizmoBaseFloatParameterSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        TransformSource: GizmoTransformSource;
        Angle: number;
        LastChange: GizmoFloatParameterChange;
        CurRotationAxis: Vector;
        CurRotationOrigin: Vector;
        InitialTransform: Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoAxisRotationParameterSource;
        static Load(InName: string): GizmoAxisRotationParameterSource;
    }
    
    class PlanePositionGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanePositionGizmoBuilder;
        static Load(InName: string): PlanePositionGizmoBuilder;
    }
    
    class PlanePositionGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisSource: GizmoAxisSource;
        ParameterSource: GizmoVec2ParameterSource;
        HitTarget: GizmoClickTarget;
        StateTarget: GizmoStateTarget;
        bInInteraction: boolean;
        InteractionOrigin: Vector;
        InteractionNormal: Vector;
        InteractionAxisX: Vector;
        InteractionAxisY: Vector;
        InteractionStartPoint: Vector;
        InteractionCurPoint: Vector;
        InteractionStartParameter: Vector2D;
        InteractionCurParameter: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanePositionGizmo;
        static Load(InName: string): PlanePositionGizmo;
    }
    
    class SelectionSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SelectionSet;
        static Load(InName: string): SelectionSet;
    }
    
    class MeshSelectionSet extends SelectionSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Vertices: TArray<number>;
        Edges: TArray<number>;
        Faces: TArray<number>;
        Groups: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSelectionSet;
        static Load(InName: string): MeshSelectionSet;
    }
    
    class SingleClickInputBehavior extends AnyButtonInputBehavior {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HitTestOnRelease: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleClickInputBehavior;
        static Load(InName: string): SingleClickInputBehavior;
    }
    
    class SingleClickToolBuilder extends InteractiveToolBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleClickToolBuilder;
        static Load(InName: string): SingleClickToolBuilder;
    }
    
    class SingleClickTool extends InteractiveTool {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SingleClickTool;
        static Load(InName: string): SingleClickTool;
    }
    
    class GizmoNilStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoNilStateTarget;
        static Load(InName: string): GizmoNilStateTarget;
    }
    
    class GizmoLambdaStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoLambdaStateTarget;
        static Load(InName: string): GizmoLambdaStateTarget;
    }
    
    class GizmoObjectModifyStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoObjectModifyStateTarget;
        static Load(InName: string): GizmoObjectModifyStateTarget;
    }
    
    class GizmoTransformChangeStateTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransactionManager: ToolContextTransactionProvider;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoTransformChangeStateTarget;
        static Load(InName: string): GizmoTransformChangeStateTarget;
    }
    
    class TransformGizmoActor extends GizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TranslateX: PrimitiveComponent;
        TranslateY: PrimitiveComponent;
        TranslateZ: PrimitiveComponent;
        TranslateYZ: PrimitiveComponent;
        TranslateXZ: PrimitiveComponent;
        TranslateXY: PrimitiveComponent;
        RotateX: PrimitiveComponent;
        RotateY: PrimitiveComponent;
        RotateZ: PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformGizmoActor;
        static Load(InName: string): TransformGizmoActor;
    }
    
    class TransformGizmoBuilder extends InteractiveGizmoBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformGizmoBuilder;
        static Load(InName: string): TransformGizmoBuilder;
    }
    
    class TransformProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRotatePerObject: boolean;
        bSetPivotMode: boolean;
        SharedTransform: Transform;
        InitialSharedTransform: Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformProxy;
        static Load(InName: string): TransformProxy;
    }
    
    class TransformGizmo extends InteractiveGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveTarget: TransformProxy;
        ActiveComponents: TArray<PrimitiveComponent>;
        ActiveGizmos: TArray<InteractiveGizmo>;
        AxisXSource: GizmoComponentAxisSource;
        AxisYSource: GizmoComponentAxisSource;
        AxisZSource: GizmoComponentAxisSource;
        StateTarget: GizmoTransformChangeStateTarget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransformGizmo;
        static Load(InName: string): TransformGizmo;
    }
    
    class GizmoBaseTransformSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoBaseTransformSource;
        static Load(InName: string): GizmoBaseTransformSource;
    }
    
    class GizmoComponentWorldTransformSource extends GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: SceneComponent;
        bModifyComponentOnTransform: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoComponentWorldTransformSource;
        static Load(InName: string): GizmoComponentWorldTransformSource;
    }
    
    class GizmoTransformProxyTransformSource extends GizmoBaseTransformSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Proxy: TransformProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoTransformProxyTransformSource;
        static Load(InName: string): GizmoTransformProxyTransformSource;
    }
    
    class NavDataConfig extends NavAgentProperties {
        constructor(Name: string, Color: Color, DefaultQueryExtent: Vector, NavigationDataClass: Class, NavDataClass: TSoftObjectPtr<Class>);
        Name: string;
        Color: Color;
        DefaultQueryExtent: Vector;
        NavigationDataClass: Class;
        NavDataClass: TSoftObjectPtr<Class>;
    }
    
    enum ERuntimeGenerationType { Static, DynamicModifiersOnly, Dynamic, LegacyGeneration, ERuntimeGenerationType_MAX}
    class SupportedAreaData {
        constructor(AreaClassName: string, AreaID: number, AreaClass: Class);
        AreaClassName: string;
        AreaID: number;
        AreaClass: Class;
    }
    
    class NavigationData extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderingComp: PrimitiveComponent;
        NavDataConfig: NavDataConfig;
        bEnableDrawing: boolean;
        bForceRebuildOnLoad: boolean;
        bAutoDestroyWhenNoNavigation: boolean;
        bCanBeMainNavData: boolean;
        bCanSpawnOnRebuild: boolean;
        bRebuildAtRuntime: boolean;
        RuntimeGeneration: ERuntimeGenerationType;
        ObservedPathsTickInterval: number;
        DataVersion: number;
        SupportedAreas: TArray<SupportedAreaData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationData;
        static Load(InName: string): NavigationData;
    }
    
    class AbstractNavData extends NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AbstractNavData;
        static Load(InName: string): AbstractNavData;
    }
    
    class CrowdManagerBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdManagerBase;
        static Load(InName: string): CrowdManagerBase;
    }
    
    class NavAreaBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAreaBase;
        static Load(InName: string): NavAreaBase;
    }
    
    class NavArea extends NavAreaBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultCost: number;
        FixedAreaEnteringCost: number;
        DrawColor: Color;
        SupportedAgents: NavAgentSelector;
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea;
        static Load(InName: string): NavArea;
    }
    
    class NavArea_Default extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_Default;
        static Load(InName: string): NavArea_Default;
    }
    
    class NavArea_LowHeight extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_LowHeight;
        static Load(InName: string): NavArea_LowHeight;
    }
    
    class NavArea_Null extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_Null;
        static Load(InName: string): NavArea_Null;
    }
    
    class NavArea_Obstacle extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavArea_Obstacle;
        static Load(InName: string): NavArea_Obstacle;
    }
    
    class NavAreaMeta extends NavArea {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAreaMeta;
        static Load(InName: string): NavAreaMeta;
    }
    
    class NavAreaMeta_SwitchByAgent extends NavAreaMeta {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Agent0Area: Class;
        Agent1Area: Class;
        Agent2Area: Class;
        Agent3Area: Class;
        Agent4Area: Class;
        Agent5Area: Class;
        Agent6Area: Class;
        Agent7Area: Class;
        Agent8Area: Class;
        Agent9Area: Class;
        Agent10Area: Class;
        Agent11Area: Class;
        Agent12Area: Class;
        Agent13Area: Class;
        Agent14Area: Class;
        Agent15Area: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAreaMeta_SwitchByAgent;
        static Load(InName: string): NavAreaMeta_SwitchByAgent;
    }
    
    class NavCollisionCylinder {
        constructor(Offset: Vector, Radius: number, Height: number);
        Offset: Vector;
        Radius: number;
        Height: number;
    }
    
    class NavCollisionBox {
        constructor(Offset: Vector, Extent: Vector);
        Offset: Vector;
        Extent: Vector;
    }
    
    class NavCollision extends NavCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CylinderCollision: TArray<NavCollisionCylinder>;
        BoxCollision: TArray<NavCollisionBox>;
        AreaClass: Class;
        bGatherConvexGeometry: boolean;
        bCreateOnClient: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavCollision;
        static Load(InName: string): NavCollision;
    }
    
    class NavigationGraph extends NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationGraph;
        static Load(InName: string): NavigationGraph;
    }
    
    class NavigationGraphNode extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationGraphNode;
        static Load(InName: string): NavigationGraphNode;
    }
    
    class NavGraphNode {
        constructor(Owner: Object);
        Owner: Object;
    }
    
    class NavigationGraphNodeComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: NavGraphNode;
        NextNodeComponent: NavigationGraphNodeComponent;
        PrevNodeComponent: NavigationGraphNodeComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationGraphNodeComponent;
        static Load(InName: string): NavigationGraphNodeComponent;
    }
    
    class NavigationInvokerComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TileGenerationRadius: number;
        TileRemovalRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationInvokerComponent;
        static Load(InName: string): NavigationInvokerComponent;
    }
    
    class NavigationPath extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PathUpdatedNotifier: $MulticastDelegate<(AffectedPath: NavigationPath, PathEvent: number) => void>;
        PathPoints: TArray<Vector>;
        RecalculateOnInvalidation: number;
        IsValid(): boolean;
        IsStringPulled(): boolean;
        IsPartial(): boolean;
        GetPathLength(): number;
        GetPathCost(): number;
        GetDebugString(): string;
        EnableRecalculationOnInvalidation(DoRecalculation: number): void;
        EnableDebugDrawing(bShouldDrawDebugData: boolean, PathColor: LinearColor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationPath;
        static Load(InName: string): NavigationPath;
    }
    
    class NavigationPathGenerator extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationPathGenerator;
        static Load(InName: string): NavigationPathGenerator;
    }
    
    class NavigationFilterArea {
        constructor(AreaClass: Class, TravelCostOverride: number, EnteringCostOverride: number, bIsExcluded: boolean, bOverrideTravelCost: boolean, bOverrideEnteringCost: boolean);
        AreaClass: Class;
        TravelCostOverride: number;
        EnteringCostOverride: number;
        bIsExcluded: boolean;
        bOverrideTravelCost: boolean;
        bOverrideEnteringCost: boolean;
    }
    
    class NavigationFilterFlags {
        constructor(bNavFlag0: boolean, bNavFlag1: boolean, bNavFlag2: boolean, bNavFlag3: boolean, bNavFlag4: boolean, bNavFlag5: boolean, bNavFlag6: boolean, bNavFlag7: boolean, bNavFlag8: boolean, bNavFlag9: boolean, bNavFlag10: boolean, bNavFlag11: boolean, bNavFlag12: boolean, bNavFlag13: boolean, bNavFlag14: boolean, bNavFlag15: boolean);
        bNavFlag0: boolean;
        bNavFlag1: boolean;
        bNavFlag2: boolean;
        bNavFlag3: boolean;
        bNavFlag4: boolean;
        bNavFlag5: boolean;
        bNavFlag6: boolean;
        bNavFlag7: boolean;
        bNavFlag8: boolean;
        bNavFlag9: boolean;
        bNavFlag10: boolean;
        bNavFlag11: boolean;
        bNavFlag12: boolean;
        bNavFlag13: boolean;
        bNavFlag14: boolean;
        bNavFlag15: boolean;
    }
    
    class NavigationQueryFilter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Areas: TArray<NavigationFilterArea>;
        IncludeFlags: NavigationFilterFlags;
        ExcludeFlags: NavigationFilterFlags;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationQueryFilter;
        static Load(InName: string): NavigationQueryFilter;
    }
    
    enum ENavDataGatheringModeConfig { Invalid, Instant, Lazy, ENavDataGatheringModeConfig_MAX}
    enum FNavigationSystemRunMode { InvalidMode, GameMode, EditorMode, SimulationMode, PIEMode, FNavigationSystemRunMode_MAX}
    class NavMeshBoundsVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SupportedAgents: NavAgentSelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavMeshBoundsVolume;
        static Load(InName: string): NavMeshBoundsVolume;
    }
    
    class NavigationSystemV1 extends NavigationSystemBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MainNavData: NavigationData;
        AbstractNavData: NavigationData;
        DefaultAgentName: string;
        CrowdManagerClass: TSoftObjectPtr<Class>;
        bAutoCreateNavigationData: boolean;
        bSpawnNavDataInNavBoundsLevel: boolean;
        bAllowClientSideNavigation: boolean;
        bShouldDiscardSubLevelNavData: boolean;
        bTickWhilePaused: boolean;
        bSupportRebuilding: boolean;
        bInitialBuildingLocked: boolean;
        bSkipAgentHeightCheckWhenPickingNavData: boolean;
        DataGatheringMode: ENavDataGatheringModeConfig;
        bGenerateNavigationOnlyAroundNavigationInvokers: boolean;
        ActiveTilesUpdateInterval: number;
        SupportedAgents: TArray<NavDataConfig>;
        SupportedAgentsMask: NavAgentSelector;
        NavDataSet: TArray<NavigationData>;
        NavDataRegistrationQueue: TArray<NavigationData>;
        OnNavDataRegisteredEvent: $MulticastDelegate<(NavData: NavigationData) => void>;
        OnNavigationGenerationFinishedDelegate: $MulticastDelegate<(NavData: NavigationData) => void>;
        OperationMode: FNavigationSystemRunMode;
        DirtyAreasUpdateFreq: number;
        UnregisterNavigationInvoker(Invoker: Actor): void;
        static SimpleMoveToLocation(Controller: Controller, Goal: Vector): void;
        static SimpleMoveToActor(Controller: Controller, Goal: Actor): void;
        SetMaxSimultaneousTileGenerationJobsCount(MaxNumberOfJobs: number): void;
        SetGeometryGatheringMode(NewMode: ENavDataGatheringModeConfig): void;
        ResetMaxSimultaneousTileGenerationJobsCount(): void;
        RegisterNavigationInvoker(Invoker: Actor, TileGenerationRadius: number, TileRemovalRadius: number): void;
        static ProjectPointToNavigation(WorldContextObject: Object, Point: Vector, NavData: NavigationData, FilterClass: Class, QueryExtent: Vector): Vector;
        OnNavigationBoundsUpdated(NavVolume: NavMeshBoundsVolume): void;
        static NavigationRaycast(WorldContextObject: Object, RayStart: Vector, RayEnd: Vector, HitLocation: $Ref<Vector>, FilterClass: Class, Querier: Controller): boolean;
        K2_ReplaceAreaInOctreeData(Object: Object, OldArea: Class, NewArea: Class): boolean;
        static K2_ProjectPointToNavigation(WorldContextObject: Object, Point: Vector, ProjectedLocation: $Ref<Vector>, NavData: NavigationData, FilterClass: Class, QueryExtent: Vector): boolean;
        static K2_GetRandomReachablePointInRadius(WorldContextObject: Object, Origin: Vector, RandomLocation: $Ref<Vector>, Radius: number, NavData: NavigationData, FilterClass: Class): boolean;
        static K2_GetRandomPointInNavigableRadius(WorldContextObject: Object, Origin: Vector, RandomLocation: $Ref<Vector>, Radius: number, NavData: NavigationData, FilterClass: Class): boolean;
        static K2_GetRandomLocationInNavigableRadius(WorldContextObject: Object, Origin: Vector, RandomLocation: $Ref<Vector>, Radius: number, NavData: NavigationData, FilterClass: Class): boolean;
        static IsNavigationBeingBuiltOrLocked(WorldContextObject: Object): boolean;
        static IsNavigationBeingBuilt(WorldContextObject: Object): boolean;
        static GetRandomReachablePointInRadius(WorldContextObject: Object, Origin: Vector, Radius: number, NavData: NavigationData, FilterClass: Class): Vector;
        static GetRandomPointInNavigableRadius(WorldContextObject: Object, Origin: Vector, Radius: number, NavData: NavigationData, FilterClass: Class): Vector;
        static GetPathLength(WorldContextObject: Object, PathStart: Vector, PathEnd: Vector, PathLength: $Ref<number>, NavData: NavigationData, FilterClass: Class): number;
        static GetPathCost(WorldContextObject: Object, PathStart: Vector, PathEnd: Vector, PathCost: $Ref<number>, NavData: NavigationData, FilterClass: Class): number;
        static GetNavigationSystem(WorldContextObject: Object): NavigationSystemV1;
        static FindPathToLocationSynchronously(WorldContextObject: Object, PathStart: Vector, PathEnd: Vector, PathfindingContext: Actor, FilterClass: Class): NavigationPath;
        static FindPathToActorSynchronously(WorldContextObject: Object, PathStart: Vector, GoalActor: Actor, TetherDistance: number, PathfindingContext: Actor, FilterClass: Class): NavigationPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemV1;
        static Load(InName: string): NavigationSystemV1;
    }
    
    class NavigationSystemModuleConfig extends NavigationSystemConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bStrictlyStatic: boolean;
        bCreateOnClient: boolean;
        bAutoSpawnMissingNavData: boolean;
        bSpawnNavDataInNavBoundsLevel: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationSystemModuleConfig;
        static Load(InName: string): NavigationSystemModuleConfig;
    }
    
    class NavTestRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavTestRenderingComponent;
        static Load(InName: string): NavTestRenderingComponent;
    }
    
    class NavigationTestingActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleComponent: CapsuleComponent;
        EdRenderComp: NavTestRenderingComponent;
        InvokerComponent: NavigationInvokerComponent;
        bActAsNavigationInvoker: boolean;
        NavAgentProps: NavAgentProperties;
        QueryingExtent: Vector;
        MyNavData: NavigationData;
        ProjectedLocation: Vector;
        bProjectedLocationValid: boolean;
        bSearchStart: boolean;
        bBacktracking: boolean;
        bUseHierarchicalPathfinding: boolean;
        bGatherDetailedInfo: boolean;
        bDrawDistanceToWall: boolean;
        bShowNodePool: boolean;
        bShowBestPath: boolean;
        bShowDiffWithPreviousStep: boolean;
        bShouldBeVisibleInGame: boolean;
        CostDisplayMode: number;
        TextCanvasOffset: Vector2D;
        bPathExist: boolean;
        bPathIsPartial: boolean;
        bPathSearchOutOfNodes: boolean;
        PathfindingTime: number;
        PathCost: number;
        PathfindingSteps: number;
        OtherActor: NavigationTestingActor;
        FilterClass: Class;
        ShowStepIndex: number;
        OffsetFromCornersDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationTestingActor;
        static Load(InName: string): NavigationTestingActor;
    }
    
    class NavigationLinkBase {
        constructor(LeftProjectHeight: number, MaxFallDownLength: number, SnapRadius: number, SnapHeight: number, SupportedAgents: NavAgentSelector, bSupportsAgent0: boolean, bSupportsAgent1: boolean, bSupportsAgent2: boolean, bSupportsAgent3: boolean, bSupportsAgent4: boolean, bSupportsAgent5: boolean, bSupportsAgent6: boolean, bSupportsAgent7: boolean, bSupportsAgent8: boolean, bSupportsAgent9: boolean, bSupportsAgent10: boolean, bSupportsAgent11: boolean, bSupportsAgent12: boolean, bSupportsAgent13: boolean, bSupportsAgent14: boolean, bSupportsAgent15: boolean, Description: string, Direction: number, bUseSnapHeight: boolean, bSnapToCheapestArea: boolean, bCustomFlag0: boolean, bCustomFlag1: boolean, bCustomFlag2: boolean, bCustomFlag3: boolean, bCustomFlag4: boolean, bCustomFlag5: boolean, bCustomFlag6: boolean, bCustomFlag7: boolean, AreaClass: Class);
        LeftProjectHeight: number;
        MaxFallDownLength: number;
        SnapRadius: number;
        SnapHeight: number;
        SupportedAgents: NavAgentSelector;
        bSupportsAgent0: boolean;
        bSupportsAgent1: boolean;
        bSupportsAgent2: boolean;
        bSupportsAgent3: boolean;
        bSupportsAgent4: boolean;
        bSupportsAgent5: boolean;
        bSupportsAgent6: boolean;
        bSupportsAgent7: boolean;
        bSupportsAgent8: boolean;
        bSupportsAgent9: boolean;
        bSupportsAgent10: boolean;
        bSupportsAgent11: boolean;
        bSupportsAgent12: boolean;
        bSupportsAgent13: boolean;
        bSupportsAgent14: boolean;
        bSupportsAgent15: boolean;
        Description: string;
        Direction: number;
        bUseSnapHeight: boolean;
        bSnapToCheapestArea: boolean;
        bCustomFlag0: boolean;
        bCustomFlag1: boolean;
        bCustomFlag2: boolean;
        bCustomFlag3: boolean;
        bCustomFlag4: boolean;
        bCustomFlag5: boolean;
        bCustomFlag6: boolean;
        bCustomFlag7: boolean;
        AreaClass: Class;
    }
    
    class NavigationLink extends NavigationLinkBase {
        constructor(Left: Vector, Right: Vector);
        Left: Vector;
        Right: Vector;
    }
    
    class NavLinkComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Links: TArray<NavigationLink>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkComponent;
        static Load(InName: string): NavLinkComponent;
    }
    
    class NavRelevantComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAttachToOwnersRoot: boolean;
        CachedNavParent: Object;
        SetNavigationRelevancy(bRelevant: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavRelevantComponent;
        static Load(InName: string): NavRelevantComponent;
    }
    
    class NavLinkCustomComponent extends NavRelevantComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NavLinkUserId: number;
        EnabledAreaClass: Class;
        DisabledAreaClass: Class;
        SupportedAgents: NavAgentSelector;
        LinkRelativeStart: Vector;
        LinkRelativeEnd: Vector;
        LinkDirection: number;
        bLinkEnabled: boolean;
        bNotifyWhenEnabled: boolean;
        bNotifyWhenDisabled: boolean;
        bCreateBoxObstacle: boolean;
        ObstacleOffset: Vector;
        ObstacleExtent: Vector;
        ObstacleAreaClass: Class;
        BroadcastRadius: number;
        BroadcastInterval: number;
        BroadcastChannel: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkCustomComponent;
        static Load(InName: string): NavLinkCustomComponent;
    }
    
    class NavLinkCustomInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkCustomInterface;
        static Load(InName: string): NavLinkCustomInterface;
    }
    
    class NavLinkHostInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkHostInterface;
        static Load(InName: string): NavLinkHostInterface;
    }
    
    class NavLinkRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkRenderingComponent;
        static Load(InName: string): NavLinkRenderingComponent;
    }
    
    class NavigationSegmentLink extends NavigationLinkBase {
        constructor(LeftStart: Vector, LeftEnd: Vector, RightStart: Vector, RightEnd: Vector);
        LeftStart: Vector;
        LeftEnd: Vector;
        RightStart: Vector;
        RightEnd: Vector;
    }
    
    class NavLinkDefinition extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Links: TArray<NavigationLink>;
        SegmentLinks: TArray<NavigationSegmentLink>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkDefinition;
        static Load(InName: string): NavLinkDefinition;
    }
    
    class NavLinkTrivial extends NavLinkDefinition {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkTrivial;
        static Load(InName: string): NavLinkTrivial;
    }
    
    class NavMeshRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavMeshRenderingComponent;
        static Load(InName: string): NavMeshRenderingComponent;
    }
    
    class NavModifierComponent extends NavRelevantComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AreaClass: Class;
        FailsafeExtent: Vector;
        bIncludeAgentHeight: boolean;
        SetAreaClass(NewAreaClass: Class): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavModifierComponent;
        static Load(InName: string): NavModifierComponent;
    }
    
    class NavModifierVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AreaClass: Class;
        SetAreaClass(NewAreaClass: Class): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavModifierVolume;
        static Load(InName: string): NavModifierVolume;
    }
    
    class NavNodeInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavNodeInterface;
        static Load(InName: string): NavNodeInterface;
    }
    
    enum ENavSystemOverridePolicy { Override, Append, Skip, ENavSystemOverridePolicy_MAX}
    class NavSystemConfigOverride extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: BillboardComponent;
        NavigationSystemConfig: NavigationSystemConfig;
        OverridePolicy: ENavSystemOverridePolicy;
        bLoadOnClient: boolean;
        ApplyChanges(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavSystemConfigOverride;
        static Load(InName: string): NavSystemConfigOverride;
    }
    
    class RecastFilter_UseDefaultArea extends NavigationQueryFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RecastFilter_UseDefaultArea;
        static Load(InName: string): RecastFilter_UseDefaultArea;
    }
    
    class RecastNavMesh extends NavigationData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDrawTriangleEdges: boolean;
        bDrawPolyEdges: boolean;
        bDrawFilledPolys: boolean;
        bDrawNavMeshEdges: boolean;
        bDrawTileBounds: boolean;
        bDrawPathCollidingGeometry: boolean;
        bDrawTileLabels: boolean;
        bDrawPolygonLabels: boolean;
        bDrawDefaultPolygonCost: boolean;
        bDrawLabelsOnPathNodes: boolean;
        bDrawNavLinks: boolean;
        bDrawFailedNavLinks: boolean;
        bDrawClusters: boolean;
        bDrawOctree: boolean;
        bDrawOctreeDetails: boolean;
        bDrawMarkedForbiddenPolys: boolean;
        bDistinctlyDrawTilesBeingBuilt: boolean;
        bDrawNavMesh: boolean;
        DrawOffset: number;
        bFixedTilePoolSize: boolean;
        TilePoolSize: number;
        TileSizeUU: number;
        CellSize: number;
        CellHeight: number;
        AgentRadius: number;
        AgentHeight: number;
        AgentMaxHeight: number;
        AgentMaxSlope: number;
        AgentMaxStepHeight: number;
        MinRegionArea: number;
        MergeRegionSize: number;
        MaxSimplificationError: number;
        MaxSimultaneousTileGenerationJobsCount: number;
        TileNumberHardLimit: number;
        PolyRefTileBits: number;
        PolyRefNavPolyBits: number;
        PolyRefSaltBits: number;
        NavMeshOriginOffset: Vector;
        DefaultDrawDistance: number;
        DefaultMaxSearchNodes: number;
        DefaultMaxHierarchicalSearchNodes: number;
        RegionPartitioning: number;
        LayerPartitioning: number;
        RegionChunkSplits: number;
        LayerChunkSplits: number;
        bSortNavigationAreasByCost: boolean;
        bPerformVoxelFiltering: boolean;
        bMarkLowHeightAreas: boolean;
        bFilterLowSpanSequences: boolean;
        bFilterLowSpanFromTileCache: boolean;
        bDoFullyAsyncNavDataGathering: boolean;
        bUseBetterOffsetsFromCorners: boolean;
        bStoreEmptyTileLayers: boolean;
        bUseVirtualFilters: boolean;
        bAllowNavLinkAsPathEnd: boolean;
        bUseVoxelCache: boolean;
        TileSetUpdateInterval: number;
        HeuristicScale: number;
        VerticalDeviationFromGroundCompensation: number;
        K2_ReplaceAreaInTileBounds(Bounds: Box, OldArea: Class, NewArea: Class, ReplaceLinks: boolean): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RecastNavMesh;
        static Load(InName: string): RecastNavMesh;
    }
    
    class RecastNavMeshDataChunk extends NavigationDataChunk {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RecastNavMeshDataChunk;
        static Load(InName: string): RecastNavMeshDataChunk;
    }
    
    class PIEPreviewSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WindowPosX: number;
        WindowPosY: number;
        WindowScalingFactor: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PIEPreviewSettings;
        static Load(InName: string): PIEPreviewSettings;
    }
    
    enum EClothingWindMethod { Legacy, Accurate, EClothingWindMethod_MAX}
    class ClothConstraintSetup {
        constructor(Stiffness: number, StiffnessMultiplier: number, StretchLimit: number, CompressionLimit: number);
        Stiffness: number;
        StiffnessMultiplier: number;
        StretchLimit: number;
        CompressionLimit: number;
    }
    
    class ClothConfigNv extends ClothConfigBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WindMethod: EClothingWindMethod;
        VerticalConstraintConfig: ClothConstraintSetup;
        HorizontalConstraintConfig: ClothConstraintSetup;
        BendConstraintConfig: ClothConstraintSetup;
        ShearConstraintConfig: ClothConstraintSetup;
        SelfCollisionRadius: number;
        SelfCollisionStiffness: number;
        SelfCollisionCullScale: number;
        Damping: Vector;
        Friction: number;
        WindDragCoefficient: number;
        WindLiftCoefficient: number;
        LinearDrag: Vector;
        AngularDrag: Vector;
        LinearInertiaScale: Vector;
        AngularInertiaScale: Vector;
        CentrifugalInertiaScale: Vector;
        SolverFrequency: number;
        StiffnessFrequency: number;
        GravityScale: number;
        GravityOverride: Vector;
        bUseGravityOverride: boolean;
        TetherStiffness: number;
        TetherLimit: number;
        CollisionThickness: number;
        AnimDriveSpringStiffness: number;
        AnimDriveDamperStiffness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothConfigNv;
        static Load(InName: string): ClothConfigNv;
    }
    
    class ClothCollisionPrim_Sphere {
        constructor(BoneIndex: number, Radius: number, LocalPosition: Vector);
        BoneIndex: number;
        Radius: number;
        LocalPosition: Vector;
    }
    
    class ClothCollisionPrim_SphereConnection {
        constructor(SphereIndices: FixSizeArray<number>);
        SphereIndices: FixSizeArray<number>;
    }
    
    class ClothCollisionPrim_Convex {
        constructor(Planes: TArray<Plane>, BoneIndex: number);
        Planes: TArray<Plane>;
        BoneIndex: number;
    }
    
    class ClothCollisionPrim_Box {
        constructor(BoneIndex: number, LocalMin: Vector, LocalMax: Vector);
        BoneIndex: number;
        LocalMin: Vector;
        LocalMax: Vector;
    }
    
    class ClothCollisionData {
        constructor(Spheres: TArray<ClothCollisionPrim_Sphere>, SphereConnections: TArray<ClothCollisionPrim_SphereConnection>, Convexes: TArray<ClothCollisionPrim_Convex>, Boxes: TArray<ClothCollisionPrim_Box>);
        Spheres: TArray<ClothCollisionPrim_Sphere>;
        SphereConnections: TArray<ClothCollisionPrim_SphereConnection>;
        Convexes: TArray<ClothCollisionPrim_Convex>;
        Boxes: TArray<ClothCollisionPrim_Box>;
    }
    
    class PointWeightMap {
        constructor(Name: string, CurrentTarget: number, Values: TArray<number>, bEnabled: boolean);
        Name: string;
        CurrentTarget: number;
        Values: TArray<number>;
        bEnabled: boolean;
    }
    
    class ClothLODDataBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicalMeshData: ClothPhysicalMeshDataBase;
        CollisionData: ClothCollisionData;
        ParameterMasks: TArray<PointWeightMap>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothLODDataBase;
        static Load(InName: string): ClothLODDataBase;
    }
    
    class ClothingAssetCustomData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetCustomData;
        static Load(InName: string): ClothingAssetCustomData;
    }
    
    class ClothingAssetCommon extends ClothingAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsAsset: PhysicsAsset;
        ClothSimConfig: ClothConfigBase;
        ClothLodData: TArray<ClothLODDataBase>;
        LodMap: TArray<number>;
        UsedBoneNames: TArray<string>;
        UsedBoneIndices: TArray<number>;
        ReferenceBoneIndex: number;
        CustomData: ClothingAssetCustomData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetCommon;
        static Load(InName: string): ClothingAssetCommon;
    }
    
    class ClothConfig {
        constructor(WindMethod: EClothingWindMethod, VerticalConstraintConfig: ClothConstraintSetup, HorizontalConstraintConfig: ClothConstraintSetup, BendConstraintConfig: ClothConstraintSetup, ShearConstraintConfig: ClothConstraintSetup, SelfCollisionRadius: number, SelfCollisionStiffness: number, SelfCollisionCullScale: number, Damping: Vector, Friction: number, WindDragCoefficient: number, WindLiftCoefficient: number, LinearDrag: Vector, AngularDrag: Vector, LinearInertiaScale: Vector, AngularInertiaScale: Vector, CentrifugalInertiaScale: Vector, SolverFrequency: number, StiffnessFrequency: number, GravityScale: number, GravityOverride: Vector, bUseGravityOverride: boolean, TetherStiffness: number, TetherLimit: number, CollisionThickness: number, AnimDriveSpringStiffness: number, AnimDriveDamperStiffness: number);
        WindMethod: EClothingWindMethod;
        VerticalConstraintConfig: ClothConstraintSetup;
        HorizontalConstraintConfig: ClothConstraintSetup;
        BendConstraintConfig: ClothConstraintSetup;
        ShearConstraintConfig: ClothConstraintSetup;
        SelfCollisionRadius: number;
        SelfCollisionStiffness: number;
        SelfCollisionCullScale: number;
        Damping: Vector;
        Friction: number;
        WindDragCoefficient: number;
        WindLiftCoefficient: number;
        LinearDrag: Vector;
        AngularDrag: Vector;
        LinearInertiaScale: Vector;
        AngularInertiaScale: Vector;
        CentrifugalInertiaScale: Vector;
        SolverFrequency: number;
        StiffnessFrequency: number;
        GravityScale: number;
        GravityOverride: Vector;
        bUseGravityOverride: boolean;
        TetherStiffness: number;
        TetherLimit: number;
        CollisionThickness: number;
        AnimDriveSpringStiffness: number;
        AnimDriveDamperStiffness: number;
    }
    
    class ClothPhysicalMeshData {
        constructor(Vertices: TArray<Vector>, Normals: TArray<Vector>, VertexColors: TArray<Color>, Indices: TArray<number>, MaxDistances: TArray<number>, BackstopDistances: TArray<number>, BackstopRadiuses: TArray<number>, AnimDriveMultipliers: TArray<number>, InverseMasses: TArray<number>, BoneData: TArray<ClothVertBoneData>, MaxBoneWeights: number, NumFixedVerts: number, SelfCollisionIndices: TArray<number>);
        Vertices: TArray<Vector>;
        Normals: TArray<Vector>;
        VertexColors: TArray<Color>;
        Indices: TArray<number>;
        MaxDistances: TArray<number>;
        BackstopDistances: TArray<number>;
        BackstopRadiuses: TArray<number>;
        AnimDriveMultipliers: TArray<number>;
        InverseMasses: TArray<number>;
        BoneData: TArray<ClothVertBoneData>;
        MaxBoneWeights: number;
        NumFixedVerts: number;
        SelfCollisionIndices: TArray<number>;
    }
    
    enum MaskTarget_PhysMesh { None, MaxDistance, BackstopDistance, BackstopRadius, AnimDriveMultiplier, MaskTarget_MAX}
    class ClothParameterMask_PhysMesh {
        constructor(MaskName: string, CurrentTarget: MaskTarget_PhysMesh, MaxValue: number, MinValue: number, Values: TArray<number>, bEnabled: boolean);
        MaskName: string;
        CurrentTarget: MaskTarget_PhysMesh;
        MaxValue: number;
        MinValue: number;
        Values: TArray<number>;
        bEnabled: boolean;
    }
    
    class ClothLODData {
        constructor(PhysicalMeshData: ClothPhysicalMeshData, CollisionData: ClothCollisionData, ParameterMasks: TArray<ClothParameterMask_PhysMesh>);
        PhysicalMeshData: ClothPhysicalMeshData;
        CollisionData: ClothCollisionData;
        ParameterMasks: TArray<ClothParameterMask_PhysMesh>;
    }
    
    class ClothingAssetNv extends ClothingAssetCommon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClothConfig: ClothConfig;
        LodData: TArray<ClothLODData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetNv;
        static Load(InName: string): ClothingAssetNv;
    }
    
    class ClothingSimulationFactoryNv extends ClothingSimulationFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationFactoryNv;
        static Load(InName: string): ClothingSimulationFactoryNv;
    }
    
    class ClothingSimulationInteractorNv extends ClothingSimulationInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetAnimDriveSpringStiffness(InStiffness: number): void;
        SetAnimDriveDamperStiffness(InStiffness: number): void;
        EnableGravityOverride(InVector: Vector): void;
        DisableGravityOverride(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingSimulationInteractorNv;
        static Load(InName: string): ClothingSimulationInteractorNv;
    }
    
    class ClothLODDataNv extends ClothLODDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothLODDataNv;
        static Load(InName: string): ClothLODDataNv;
    }
    
    class ClothPhysicalMeshDataNv extends ClothPhysicalMeshDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxDistances: TArray<number>;
        BackstopDistances: TArray<number>;
        BackstopRadiuses: TArray<number>;
        AnimDriveMultipliers: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPhysicalMeshDataNv;
        static Load(InName: string): ClothPhysicalMeshDataNv;
    }
    
    class ClothingAssetFactory extends ClothingAssetFactoryBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothingAssetFactory;
        static Load(InName: string): ClothingAssetFactory;
    }
    
    enum EMovieSceneCaptureProtocolState { Idle, Initialized, Capturing, Finalizing, EMovieSceneCaptureProtocolState_MAX}
    class MovieSceneCaptureProtocolBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        State: EMovieSceneCaptureProtocolState;
        IsCapturing(): boolean;
        GetState(): EMovieSceneCaptureProtocolState;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureProtocolBase;
        static Load(InName: string): MovieSceneCaptureProtocolBase;
    }
    
    class MovieSceneAudioCaptureProtocolBase extends MovieSceneCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioCaptureProtocolBase;
        static Load(InName: string): MovieSceneAudioCaptureProtocolBase;
    }
    
    class NullAudioCaptureProtocol extends MovieSceneAudioCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NullAudioCaptureProtocol;
        static Load(InName: string): NullAudioCaptureProtocol;
    }
    
    class MasterAudioSubmixCaptureProtocol extends MovieSceneAudioCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FileName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MasterAudioSubmixCaptureProtocol;
        static Load(InName: string): MasterAudioSubmixCaptureProtocol;
    }
    
    class MovieSceneImageCaptureProtocolBase extends MovieSceneCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneImageCaptureProtocolBase;
        static Load(InName: string): MovieSceneImageCaptureProtocolBase;
    }
    
    class CompositionGraphCapturePasses {
        constructor(Value: TArray<string>);
        Value: TArray<string>;
    }
    
    class CompositionGraphCaptureProtocol extends MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IncludeRenderPasses: CompositionGraphCapturePasses;
        bCaptureFramesInHDR: boolean;
        HDRCompressionQuality: number;
        CaptureGamut: number;
        PostProcessingMaterial: SoftObjectPath;
        bDisableScreenPercentage: boolean;
        PostProcessingMaterialPtr: MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositionGraphCaptureProtocol;
        static Load(InName: string): CompositionGraphCaptureProtocol;
    }
    
    class FrameGrabberProtocol extends MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FrameGrabberProtocol;
        static Load(InName: string): FrameGrabberProtocol;
    }
    
    class ImageSequenceProtocol extends FrameGrabberProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol;
        static Load(InName: string): ImageSequenceProtocol;
    }
    
    class CompressedImageSequenceProtocol extends ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompressionQuality: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompressedImageSequenceProtocol;
        static Load(InName: string): CompressedImageSequenceProtocol;
    }
    
    class ImageSequenceProtocol_BMP extends ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_BMP;
        static Load(InName: string): ImageSequenceProtocol_BMP;
    }
    
    class ImageSequenceProtocol_PNG extends CompressedImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_PNG;
        static Load(InName: string): ImageSequenceProtocol_PNG;
    }
    
    class ImageSequenceProtocol_JPG extends CompressedImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_JPG;
        static Load(InName: string): ImageSequenceProtocol_JPG;
    }
    
    class ImageSequenceProtocol_EXR extends ImageSequenceProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCompressed: boolean;
        CaptureGamut: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageSequenceProtocol_EXR;
        static Load(InName: string): ImageSequenceProtocol_EXR;
    }
    
    class MovieSceneCaptureInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureInterface;
        static Load(InName: string): MovieSceneCaptureInterface;
    }
    
    class DirectoryPath {
        constructor(Path: string);
        Path: string;
    }
    
    class CaptureResolution {
        constructor(ResX: number, ResY: number);
        ResX: number;
        ResY: number;
    }
    
    class MovieSceneCaptureSettings {
        constructor(OutputDirectory: DirectoryPath, GameModeOverride: Class, OutputFormat: string, bOverwriteExisting: boolean, bUseRelativeFrameNumbers: boolean, HandleFrames: number, MovieExtension: string, ZeroPadFrameNumbers: number, FrameRate: FrameRate, bUseCustomFrameRate: boolean, CustomFrameRate: FrameRate, Resolution: CaptureResolution, bEnableTextureStreaming: boolean, bCinematicEngineScalability: boolean, bCinematicMode: boolean, bAllowMovement: boolean, bAllowTurning: boolean, bShowPlayer: boolean, bShowHUD: boolean, bUsePathTracer: boolean, PathTracerSamplePerPixel: number);
        OutputDirectory: DirectoryPath;
        GameModeOverride: Class;
        OutputFormat: string;
        bOverwriteExisting: boolean;
        bUseRelativeFrameNumbers: boolean;
        HandleFrames: number;
        MovieExtension: string;
        ZeroPadFrameNumbers: number;
        FrameRate: FrameRate;
        bUseCustomFrameRate: boolean;
        CustomFrameRate: FrameRate;
        Resolution: CaptureResolution;
        bEnableTextureStreaming: boolean;
        bCinematicEngineScalability: boolean;
        bCinematicMode: boolean;
        bAllowMovement: boolean;
        bAllowTurning: boolean;
        bShowPlayer: boolean;
        bShowHUD: boolean;
        bUsePathTracer: boolean;
        PathTracerSamplePerPixel: number;
    }
    
    class MovieSceneCapture extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImageCaptureProtocolType: SoftClassPath;
        AudioCaptureProtocolType: SoftClassPath;
        ImageCaptureProtocol: MovieSceneImageCaptureProtocolBase;
        AudioCaptureProtocol: MovieSceneAudioCaptureProtocolBase;
        Settings: MovieSceneCaptureSettings;
        bUseSeparateProcess: boolean;
        bCloseEditorWhenCaptureStarts: boolean;
        AdditionalCommandLineArguments: string;
        InheritedCommandLineArguments: string;
        SetImageCaptureProtocolType(ProtocolType: Class): void;
        SetAudioCaptureProtocolType(ProtocolType: Class): void;
        GetImageCaptureProtocol(): MovieSceneCaptureProtocolBase;
        GetAudioCaptureProtocol(): MovieSceneCaptureProtocolBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCapture;
        static Load(InName: string): MovieSceneCapture;
    }
    
    class LevelCapture extends MovieSceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoStartCapture: boolean;
        PrerequisiteActorId: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelCapture;
        static Load(InName: string): LevelCapture;
    }
    
    class MovieSceneCaptureEnvironment extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static IsCaptureInProgress(): boolean;
        static GetCaptureFrameNumber(): number;
        static GetCaptureElapsedTime(): number;
        static FindImageCaptureProtocol(): MovieSceneImageCaptureProtocolBase;
        static FindAudioCaptureProtocol(): MovieSceneAudioCaptureProtocolBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCaptureEnvironment;
        static Load(InName: string): MovieSceneCaptureEnvironment;
    }
    
    class CapturedPixelsID {
        constructor(Identifiers: TMap<string, string>);
        Identifiers: TMap<string, string>;
    }
    
    class CapturedPixels {
        constructor();
    }
    
    class FrameMetrics {
        constructor(TotalElapsedTime: number, FrameDelta: number, FrameNumber: number, NumDroppedFrames: number);
        TotalElapsedTime: number;
        FrameDelta: number;
        FrameNumber: number;
        NumDroppedFrames: number;
    }
    
    class UserDefinedCaptureProtocol extends MovieSceneImageCaptureProtocolBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        World: World;
        StopCapturingFinalPixels(): void;
        StartCapturingFinalPixels(StreamID: CapturedPixelsID): void;
        ResolveBuffer(Buffer: Texture, BufferID: CapturedPixelsID): void;
        OnWarmUp(): void;
        OnTick(): void;
        OnStartCapture(): void;
        OnSetup(): boolean;
        OnPreTick(): void;
        OnPixelsReceived(Pixels: CapturedPixels, ID: CapturedPixelsID, FrameMetrics: FrameMetrics): void;
        OnPauseCapture(): void;
        OnFinalize(): void;
        OnCaptureFrame(): void;
        OnCanFinalize(): boolean;
        OnBeginFinalize(): void;
        GetCurrentFrameMetrics(): FrameMetrics;
        GenerateFilename(InFrameMetrics: FrameMetrics): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedCaptureProtocol;
        static Load(InName: string): UserDefinedCaptureProtocol;
    }
    
    enum EDesiredImageFormat { PNG, JPG, BMP, EXR, EDesiredImageFormat_MAX}
    class UserDefinedImageCaptureProtocol extends UserDefinedCaptureProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Format: EDesiredImageFormat;
        bEnableCompression: boolean;
        CompressionQuality: number;
        WriteImageToDisk(PixelData: CapturedPixels, StreamID: CapturedPixelsID, FrameMetrics: FrameMetrics, bCopyImageData: boolean): void;
        GenerateFilenameForCurrentFrame(): string;
        GenerateFilenameForBuffer(Buffer: Texture, StreamID: CapturedPixelsID): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedImageCaptureProtocol;
        static Load(InName: string): UserDefinedImageCaptureProtocol;
    }
    
    class VideoCaptureProtocol extends FrameGrabberProtocol {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseCompression: boolean;
        CompressionQuality: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VideoCaptureProtocol;
        static Load(InName: string): VideoCaptureProtocol;
    }
    
    class LevelSequenceBurnInInitSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnInInitSettings;
        static Load(InName: string): LevelSequenceBurnInInitSettings;
    }
    
    class LevelSequenceBurnInOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseBurnIn: boolean;
        BurnInClass: SoftClassPath;
        Settings: LevelSequenceBurnInInitSettings;
        SetBurnIn(InBurnInClass: SoftClassPath): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnInOptions;
        static Load(InName: string): LevelSequenceBurnInOptions;
    }
    
    class MovieSceneSequenceLoopCount {
        constructor(Value: number);
        Value: number;
    }
    
    class MovieSceneSequencePlaybackSettings {
        constructor(bAutoPlay: boolean, LoopCount: MovieSceneSequenceLoopCount, PlayRate: number, StartTime: number, bRandomStartTime: boolean, bRestoreState: boolean, bDisableMovementInput: boolean, bDisableLookAtInput: boolean, bHidePlayer: boolean, bHideHud: boolean, bDisableCameraCuts: boolean, bPauseAtEnd: boolean);
        bAutoPlay: boolean;
        LoopCount: MovieSceneSequenceLoopCount;
        PlayRate: number;
        StartTime: number;
        bRandomStartTime: boolean;
        bRestoreState: boolean;
        bDisableMovementInput: boolean;
        bDisableLookAtInput: boolean;
        bHidePlayer: boolean;
        bHideHud: boolean;
        bDisableCameraCuts: boolean;
        bPauseAtEnd: boolean;
    }
    
    class MovieSceneRootEvaluationTemplateInstance {
        constructor(DirectorInstances: TMap<MovieSceneSequenceID, Object>);
        DirectorInstances: TMap<MovieSceneSequenceID, Object>;
    }
    
    class MovieSceneSequenceReplProperties {
        constructor(LastKnownPosition: FrameTime, LastKnownStatus: number, LastKnownNumLoops: number);
        LastKnownPosition: FrameTime;
        LastKnownStatus: number;
        LastKnownNumLoops: number;
    }
    
    class MovieScenePlaybackClient extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePlaybackClient;
        static Load(InName: string): MovieScenePlaybackClient;
    }
    
    enum EUpdatePositionMethod { Play, Jump, Scrub, EUpdatePositionMethod_MAX}
    class QualifiedFrameTime {
        constructor(Time: FrameTime, Rate: FrameRate);
        Time: FrameTime;
        Rate: FrameRate;
    }
    
    class MovieSceneSequencePlayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnPlay: $MulticastDelegate<() => void>;
        OnPlayReverse: $MulticastDelegate<() => void>;
        OnStop: $MulticastDelegate<() => void>;
        OnPause: $MulticastDelegate<() => void>;
        OnFinished: $MulticastDelegate<() => void>;
        Status: number;
        bReversePlayback: boolean;
        Sequence: MovieSceneSequence;
        StartTime: FrameNumber;
        DurationFrames: number;
        CurrentNumLoops: number;
        PlaybackSettings: MovieSceneSequencePlaybackSettings;
        RootTemplateInstance: MovieSceneRootEvaluationTemplateInstance;
        NetSyncProps: MovieSceneSequenceReplProperties;
        PlaybackClient: MovieScenePlaybackClient;
        StopAtCurrentTime(): void;
        Stop(): void;
        SetTimeRange(StartTime: number, Duration: number): void;
        SetPlayRate(PlayRate: number): void;
        SetPlaybackRange(NewStartTime: number, NewEndTime: number): void;
        SetPlaybackPosition(NewPlaybackPosition: number): void;
        SetFrameRate(FrameRate: FrameRate): void;
        SetFrameRange(StartFrame: number, Duration: number): void;
        SetDisableCameraCuts(bInDisableCameraCuts: boolean): void;
        ScrubToSeconds(TimeInSeconds: number): void;
        ScrubToMarkedFrame(InLabel: string): boolean;
        ScrubToFrame(NewPosition: FrameTime): void;
        Scrub(): void;
        RPC_OnStopEvent(StoppedTime: FrameTime): void;
        RPC_ExplicitServerUpdateEvent(Method: EUpdatePositionMethod, RelevantTime: FrameTime): void;
        PlayToSeconds(TimeInSeconds: number): void;
        PlayToMarkedFrame(InLabel: string): boolean;
        PlayToFrame(NewPosition: FrameTime): void;
        PlayReverse(): void;
        PlayLooping(NumLoops: number): void;
        Play(): void;
        Pause(): void;
        JumpToSeconds(TimeInSeconds: number): void;
        JumpToPosition(NewPlaybackPosition: number): void;
        JumpToMarkedFrame(InLabel: string): boolean;
        JumpToFrame(NewPosition: FrameTime): void;
        IsReversed(): boolean;
        IsPlaying(): boolean;
        IsPaused(): boolean;
        GoToEndAndStop(): void;
        GetStartTime(): QualifiedFrameTime;
        GetPlayRate(): number;
        GetPlaybackStart(): number;
        GetPlaybackPosition(): number;
        GetPlaybackEnd(): number;
        GetObjectBindings(InObject: Object): TArray<MovieSceneObjectBindingID>;
        GetLength(): number;
        GetFrameRate(): FrameRate;
        GetFrameDuration(): number;
        GetEndTime(): QualifiedFrameTime;
        GetDuration(): QualifiedFrameTime;
        GetDisableCameraCuts(): boolean;
        GetCurrentTime(): QualifiedFrameTime;
        GetBoundObjects(ObjectBinding: MovieSceneObjectBindingID): TArray<Object>;
        ChangePlaybackDirection(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSequencePlayer;
        static Load(InName: string): MovieSceneSequencePlayer;
    }
    
    class LevelSequenceObjectReferenceMap {
        constructor();
    }
    
    class LevelSequenceBindingReference {
        constructor(PackageName: string, ExternalObjectPath: SoftObjectPath, ObjectPath: string);
        PackageName: string;
        ExternalObjectPath: SoftObjectPath;
        ObjectPath: string;
    }
    
    class LevelSequenceBindingReferenceArray {
        constructor(References: TArray<LevelSequenceBindingReference>);
        References: TArray<LevelSequenceBindingReference>;
    }
    
    class LevelSequenceBindingReferences {
        constructor(BindingIdToReferences: TMap<Guid, LevelSequenceBindingReferenceArray>, AnimSequenceInstances: TSet<Guid>);
        BindingIdToReferences: TMap<Guid, LevelSequenceBindingReferenceArray>;
        AnimSequenceInstances: TSet<Guid>;
    }
    
    class LevelSequenceObject {
        constructor(ObjectOrOwner: TLazyObjectPtr<Object>, ComponentName: string, CachedComponent: TWeakObjectPtr<Object>);
        ObjectOrOwner: TLazyObjectPtr<Object>;
        ComponentName: string;
        CachedComponent: TWeakObjectPtr<Object>;
    }
    
    class LevelSequence extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovieScene: MovieScene;
        ObjectReferences: LevelSequenceObjectReferenceMap;
        BindingReferences: LevelSequenceBindingReferences;
        PossessedObjects: TMap<string, LevelSequenceObject>;
        DirectorBlueprint: Blueprint;
        DirectorClass: Class;
        MetaDataObjects: TArray<Object>;
        RemoveMetaDataByClass(InClass: Class): void;
        FindOrAddMetaDataByClass(InClass: Class): Object;
        FindMetaDataByClass(InClass: Class): Object;
        CopyMetaData(InMetaData: Object): Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequence;
        static Load(InName: string): LevelSequence;
    }
    
    class LevelSequencePlayer extends MovieSceneSequencePlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnCameraCut: $MulticastDelegate<(CameraComponent: CameraComponent) => void>;
        GetActiveCameraComponent(): CameraComponent;
        static CreateLevelSequencePlayer(WorldContextObject: Object, LevelSequence: LevelSequence, Settings: MovieSceneSequencePlaybackSettings, OutActor: $Ref<LevelSequenceActor>): LevelSequencePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequencePlayer;
        static Load(InName: string): LevelSequencePlayer;
    }
    
    class LevelSequenceCameraSettings {
        constructor(bOverrideAspectRatioAxisConstraint: boolean, AspectRatioAxisConstraint: number);
        bOverrideAspectRatioAxisConstraint: boolean;
        AspectRatioAxisConstraint: number;
    }
    
    class MovieSceneBindingOverrideData {
        constructor(ObjectBindingId: MovieSceneObjectBindingID, Object: TWeakObjectPtr<Object>, bOverridesDefault: boolean);
        ObjectBindingId: MovieSceneObjectBindingID;
        Object: TWeakObjectPtr<Object>;
        bOverridesDefault: boolean;
    }
    
    class MovieSceneBindingOverrides extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BindingData: TArray<MovieSceneBindingOverrideData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBindingOverrides;
        static Load(InName: string): MovieSceneBindingOverrides;
    }
    
    class LevelSequenceSnapshotSettings {
        constructor(ZeroPadAmount: number, FrameRate: FrameRate);
        ZeroPadAmount: number;
        FrameRate: FrameRate;
    }
    
    class LevelSequencePlayerSnapshot {
        constructor(MasterName: string, MasterTime: QualifiedFrameTime, SourceTime: QualifiedFrameTime, CurrentShotName: string, CurrentShotLocalTime: QualifiedFrameTime, CurrentShotSourceTime: QualifiedFrameTime, SourceTimecode: string, CameraComponent: TSoftObjectPtr<CameraComponent>, Settings: LevelSequenceSnapshotSettings, ActiveShot: LevelSequence, ShotID: MovieSceneSequenceID);
        MasterName: string;
        MasterTime: QualifiedFrameTime;
        SourceTime: QualifiedFrameTime;
        CurrentShotName: string;
        CurrentShotLocalTime: QualifiedFrameTime;
        CurrentShotSourceTime: QualifiedFrameTime;
        SourceTimecode: string;
        CameraComponent: TSoftObjectPtr<CameraComponent>;
        Settings: LevelSequenceSnapshotSettings;
        ActiveShot: LevelSequence;
        ShotID: MovieSceneSequenceID;
    }
    
    class LevelSequenceBurnIn extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameInformation: LevelSequencePlayerSnapshot;
        LevelSequenceActor: LevelSequenceActor;
        SetSettings(InSettings: Object): void;
        GetSettingsClass(): Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceBurnIn;
        static Load(InName: string): LevelSequenceBurnIn;
    }
    
    class LevelSequenceActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlaybackSettings: MovieSceneSequencePlaybackSettings;
        SequencePlayer: LevelSequencePlayer;
        LevelSequence: SoftObjectPath;
        AdditionalEventReceivers: TArray<Actor>;
        CameraSettings: LevelSequenceCameraSettings;
        BurnInOptions: LevelSequenceBurnInOptions;
        BindingOverrides: MovieSceneBindingOverrides;
        bAutoPlay: boolean;
        bOverrideInstanceData: boolean;
        bReplicatePlayback: boolean;
        DefaultInstanceData: Object;
        BurnInInstance: LevelSequenceBurnIn;
        bShowBurnin: boolean;
        ShowBurnin(): void;
        SetSequence(InSequence: LevelSequence): void;
        SetReplicatePlayback(ReplicatePlayback: boolean): void;
        SetEventReceivers(AdditionalReceivers: TArray<Actor>): void;
        SetBindingByTag(BindingTag: string, Actors: TArray<Actor>, bAllowBindingsFromAsset: boolean): void;
        SetBinding(Binding: MovieSceneObjectBindingID, Actors: TArray<Actor>, bAllowBindingsFromAsset: boolean): void;
        ResetBindings(): void;
        ResetBinding(Binding: MovieSceneObjectBindingID): void;
        RemoveBindingByTag(Tag: string, Actor: Actor): void;
        RemoveBinding(Binding: MovieSceneObjectBindingID, Actor: Actor): void;
        OnLevelSequenceLoaded__DelegateSignature(): void;
        LoadSequence(): LevelSequence;
        HideBurnin(): void;
        GetSequencePlayer(): LevelSequencePlayer;
        GetSequence(): LevelSequence;
        FindNamedBindings(Tag: string): TArray<MovieSceneObjectBindingID>;
        FindNamedBinding(Tag: string): MovieSceneObjectBindingID;
        AddBindingByTag(BindingTag: string, Actor: Actor, bAllowBindingsFromAsset: boolean): void;
        AddBinding(Binding: MovieSceneObjectBindingID, Actor: Actor, bAllowBindingsFromAsset: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceActor;
        static Load(InName: string): LevelSequenceActor;
    }
    
    class AutomatedLevelSequenceCapture extends MovieSceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelSequenceAsset: SoftObjectPath;
        ShotName: string;
        bUseCustomStartFrame: boolean;
        CustomStartFrame: FrameNumber;
        bUseCustomEndFrame: boolean;
        CustomEndFrame: FrameNumber;
        WarmUpFrameCount: number;
        DelayBeforeWarmUp: number;
        DelayBeforeShotWarmUp: number;
        DelayEveryFrame: number;
        BurnInOptions: LevelSequenceBurnInOptions;
        bWriteEditDecisionList: boolean;
        bWriteFinalCutProXML: boolean;
        LevelSequenceActor: TWeakObjectPtr<LevelSequenceActor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomatedLevelSequenceCapture;
        static Load(InName: string): AutomatedLevelSequenceCapture;
    }
    
    class MovieSceneTangentData {
        constructor(ArriveTangent: number, LeaveTangent: number, TangentWeightMode: number, ArriveTangentWeight: number, LeaveTangentWeight: number);
        ArriveTangent: number;
        LeaveTangent: number;
        TangentWeightMode: number;
        ArriveTangentWeight: number;
        LeaveTangentWeight: number;
    }
    
    class MovieSceneFloatValue {
        constructor(Value: number, InterpMode: number, TangentMode: number, Tangent: MovieSceneTangentData);
        Value: number;
        InterpMode: number;
        TangentMode: number;
        Tangent: MovieSceneTangentData;
    }
    
    class FloatChannelKeyProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Time: FrameNumber;
        Value: MovieSceneFloatValue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatChannelKeyProxy;
        static Load(InName: string): FloatChannelKeyProxy;
    }
    
    class K2Node extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node;
        static Load(InName: string): K2Node;
    }
    
    class K2Node_GetSequenceBinding extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceSequence: SoftObjectPath;
        Binding: MovieSceneObjectBindingID;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetSequenceBinding;
        static Load(InName: string): K2Node_GetSequenceBinding;
    }
    
    class MovieSceneEventSectionBase extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DirectorBlueprint: TWeakObjectPtr<Blueprint>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSectionBase;
        static Load(InName: string): MovieSceneEventSectionBase;
    }
    
    class MovieSceneEventBlueprintExtension extends BlueprintExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventSections: TArray<MovieSceneEventSectionBase>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventBlueprintExtension;
        static Load(InName: string): MovieSceneEventBlueprintExtension;
    }
    
    class MovieSceneToolsPropertyTrackSettings {
        constructor(ComponentName: string, PropertyName: string);
        ComponentName: string;
        PropertyName: string;
    }
    
    class MovieSceneToolsFbxSettings {
        constructor(FbxPropertyName: string, PropertyPath: MovieSceneToolsPropertyTrackSettings);
        FbxPropertyName: string;
        PropertyPath: MovieSceneToolsPropertyTrackSettings;
    }
    
    class MovieSceneToolsProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultStartTime: number;
        DefaultDuration: number;
        ShotDirectory: string;
        ShotPrefix: string;
        FirstShotNumber: number;
        ShotIncrement: number;
        ShotNumDigits: number;
        TakeNumDigits: number;
        FirstTakeNumber: number;
        TakeSeparator: string;
        SubSequenceSeparator: string;
        FbxSettings: TArray<MovieSceneToolsFbxSettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneToolsProjectSettings;
        static Load(InName: string): MovieSceneToolsProjectSettings;
    }
    
    enum EThumbnailQuality { Draft, Normal, Best, EThumbnailQuality_MAX}
    class MovieSceneUserThumbnailSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDrawThumbnails: boolean;
        bDrawSingleThumbnails: boolean;
        ThumbnailSize: IntPoint;
        Quality: EThumbnailQuality;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneUserThumbnailSettings;
        static Load(InName: string): MovieSceneUserThumbnailSettings;
    }
    
    class MovieSceneUserImportFBXSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMatchByNameOnly: boolean;
        bForceFrontXAxis: boolean;
        bCreateCameras: boolean;
        bReduceKeys: boolean;
        ReduceKeysTolerance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneUserImportFBXSettings;
        static Load(InName: string): MovieSceneUserImportFBXSettings;
    }
    
    class ContentBrowserFrontEndFilterExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentBrowserFrontEndFilterExtension;
        static Load(InName: string): ContentBrowserFrontEndFilterExtension;
    }
    
    class ContentBrowserAssetContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectedObjects: TArray<TWeakObjectPtr<Object>>;
        CommonClass: Class;
        GetSelectedObjects(): TArray<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentBrowserAssetContextMenuContext;
        static Load(InName: string): ContentBrowserAssetContextMenuContext;
    }
    
    class MovieSceneCopyableBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnableObjectTemplate: Object;
        Tracks: TArray<MovieSceneTrack>;
        Binding: MovieSceneBinding;
        Spawnable: MovieSceneSpawnable;
        Possessable: MovieScenePossessable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCopyableBinding;
        static Load(InName: string): MovieSceneCopyableBinding;
    }
    
    class MovieSceneCopyableTrack extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Track: MovieSceneTrack;
        bIsAMasterTrack: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCopyableTrack;
        static Load(InName: string): MovieSceneCopyableTrack;
    }
    
    class Exporter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SupportedClass: Class;
        ExportRootScope: Object;
        FormatExtension: TArray<string>;
        FormatDescription: TArray<string>;
        PreferredFormatIndex: number;
        TextIndent: number;
        bText: boolean;
        bSelectedOnly: boolean;
        bForceFileOperations: boolean;
        ExportTask: AssetExportTask;
        ScriptRunAssetExportTask(Task: AssetExportTask): boolean;
        static RunAssetExportTasks(ExportTasks: TArray<AssetExportTask>): boolean;
        static RunAssetExportTask(Task: AssetExportTask): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Exporter;
        static Load(InName: string): Exporter;
    }
    
    class AssetExportTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Object: Object;
        Exporter: Exporter;
        Filename: string;
        bSelected: boolean;
        bReplaceIdentical: boolean;
        bPrompt: boolean;
        bAutomated: boolean;
        bUseFileArchive: boolean;
        bWriteEmptyFiles: boolean;
        IgnoreObjectList: TArray<Object>;
        Options: Object;
        Errors: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetExportTask;
        static Load(InName: string): AssetExportTask;
    }
    
    class SequencerExportTask extends AssetExportTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SequencerContext: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerExportTask;
        static Load(InName: string): SequencerExportTask;
    }
    
    class MovieSceneTransformMask {
        constructor(Mask: number);
        Mask: number;
    }
    
    class MovieSceneChannel {
        constructor();
    }
    
    class KeyHandleLookupTable {
        constructor();
    }
    
    class MovieSceneKeyHandleMap extends KeyHandleLookupTable {
        constructor();
    }
    
    class MovieSceneFloatChannel extends MovieSceneChannel {
        constructor(PreInfinityExtrap: number, PostInfinityExtrap: number, Times: TArray<FrameNumber>, Values: TArray<MovieSceneFloatValue>, DefaultValue: number, bHasDefaultValue: boolean, KeyHandles: MovieSceneKeyHandleMap, TickResolution: FrameRate);
        PreInfinityExtrap: number;
        PostInfinityExtrap: number;
        Times: TArray<FrameNumber>;
        Values: TArray<MovieSceneFloatValue>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        KeyHandles: MovieSceneKeyHandleMap;
        TickResolution: FrameRate;
    }
    
    enum EShow3DTrajectory { EST_OnlyWhenSelected, EST_Always, EST_Never, EST_MAX}
    class MovieScene3DTransformSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformMask: MovieSceneTransformMask;
        Translation: FixSizeArray<MovieSceneFloatChannel>;
        Rotation: FixSizeArray<MovieSceneFloatChannel>;
        Scale: FixSizeArray<MovieSceneFloatChannel>;
        ManualWeight: MovieSceneFloatChannel;
        bUseQuaternionInterpolation: boolean;
        Show3DTrajectory: EShow3DTrajectory;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformSection;
        static Load(InName: string): MovieScene3DTransformSection;
    }
    
    class SequencerKeyActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyMeshComponent: StaticMeshComponent;
        AssociatedActor: Actor;
        TrackSection: MovieScene3DTransformSection;
        KeyTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerKeyActor;
        static Load(InName: string): SequencerKeyActor;
    }
    
    class MovieSceneKeyStructType extends ScriptStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceTimesProperty: ArrayProperty;
        SourceValuesProperty: ArrayProperty;
        DestTimeProperty: StructProperty;
        DestValueProperty: Property;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneKeyStructType;
        static Load(InName: string): MovieSceneKeyStructType;
    }
    
    class SequencerMeshTrail extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerMeshTrail;
        static Load(InName: string): SequencerMeshTrail;
    }
    
    class SequencerSettingsContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerSettingsContainer;
        static Load(InName: string): SequencerSettingsContainer;
    }
    
    enum EAutoChangeMode { AutoKey, AutoTrack, All, None, EAutoChangeMode_MAX}
    enum EAllowEditsMode { AllEdits, AllowSequencerEditsOnly, AllowLevelEditsOnly, EAllowEditsMode_MAX}
    enum EKeyGroupMode { KeyChanged, KeyGroup, KeyAll, EKeyGroupMode_MAX}
    enum EMovieSceneKeyInterpolation { Auto, User, Break, Linear, Constant, EMovieSceneKeyInterpolation_MAX}
    enum EFrameNumberDisplayFormats { NonDropFrameTimecode, DropFrameTimecode, Seconds, Frames, MAX_Count, EFrameNumberDisplayFormats_MAX}
    class SequencerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoChangeMode: EAutoChangeMode;
        AllowEditsMode: EAllowEditsMode;
        KeyGroupMode: EKeyGroupMode;
        bKeyInterpPropertiesOnly: boolean;
        KeyInterpolation: EMovieSceneKeyInterpolation;
        bAutoSetTrackDefaults: boolean;
        SpawnPosition: number;
        bCreateSpawnableCameras: boolean;
        bShowRangeSlider: boolean;
        bIsSnapEnabled: boolean;
        bSnapKeyTimesToInterval: boolean;
        bSnapKeyTimesToKeys: boolean;
        bSnapSectionTimesToInterval: boolean;
        bSnapSectionTimesToSections: boolean;
        bSnapKeysAndSectionsToPlayRange: boolean;
        bSnapPlayTimeToKeys: boolean;
        bSnapPlayTimeToInterval: boolean;
        bSnapPlayTimeToPressedKey: boolean;
        bSnapPlayTimeToDraggedKey: boolean;
        bSnapCurveValueToInterval: boolean;
        bLabelBrowserVisible: boolean;
        bShowSelectedNodesOnly: boolean;
        bRewindOnRecord: boolean;
        ZoomPosition: number;
        bAutoScrollEnabled: boolean;
        bLinkCurveEditorTimeRange: boolean;
        bSynchronizeCurveEditorSelection: boolean;
        bIsolateCurveEditorToSelection: boolean;
        LoopMode: number;
        bKeepCursorInPlayRangeWhileScrubbing: boolean;
        bKeepCursorInPlayRange: boolean;
        bKeepPlayRangeInSectionBounds: boolean;
        ZeroPadFrames: number;
        bShowCombinedKeyframes: boolean;
        bInfiniteKeyAreas: boolean;
        bShowChannelColors: boolean;
        bDeleteKeysWhenTrimming: boolean;
        bActivateRealtimeViewports: boolean;
        bEvaluateSubSequencesInIsolation: boolean;
        bRerunConstructionScripts: boolean;
        bShowDebugVisualization: boolean;
        bVisualizePreAndPostRoll: boolean;
        bCompileDirectorOnEvaluate: boolean;
        TrajectoryPathCap: number;
        bShowOutlinerInfoColumn: boolean;
        FrameNumberDisplayFormat: EFrameNumberDisplayFormats;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerSettings;
        static Load(InName: string): SequencerSettings;
    }
    
    class SequencerTrackFilterExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequencerTrackFilterExtension;
        static Load(InName: string): SequencerTrackFilterExtension;
    }
    
    class SoundNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildNodes: TArray<SoundNode>;
        GraphNode: EdGraphNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNode;
        static Load(InName: string): SoundNode;
    }
    
    class SoundCue extends SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPrimeOnLoad: boolean;
        FirstNode: SoundNode;
        VolumeMultiplier: number;
        PitchMultiplier: number;
        AttenuationOverrides: SoundAttenuationSettings;
        AllNodes: TArray<SoundNode>;
        SoundCueGraph: EdGraph;
        SubtitlePriority: number;
        bOverrideAttenuation: boolean;
        bExcludeFromRandomNodeBranchCulling: boolean;
        bHasPlayWhenSilent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCue;
        static Load(InName: string): SoundCue;
    }
    
    class VREditorAssetContainer extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DockableWindowCloseSound: SoundBase;
        DockableWindowOpenSound: SoundBase;
        DockableWindowDropSound: SoundBase;
        DockableWindowDragSound: SoundBase;
        DropFromContentBrowserSound: SoundBase;
        RadialMenuOpenSound: SoundBase;
        RadialMenuCloseSound: SoundBase;
        TeleportSound: SoundBase;
        ButtonPressSound: SoundCue;
        AutoScaleSound: SoundBase;
        GenericHMDMesh: StaticMesh;
        PlaneMesh: StaticMesh;
        CylinderMesh: StaticMesh;
        LaserPointerStartMesh: StaticMesh;
        LaserPointerMesh: StaticMesh;
        LaserPointerEndMesh: StaticMesh;
        LaserPointerHoverMesh: StaticMesh;
        VivePreControllerMesh: StaticMesh;
        OculusControllerMesh: StaticMesh;
        GenericControllerMesh: StaticMesh;
        TeleportRootMesh: StaticMesh;
        WindowMesh: StaticMesh;
        WindowSelectionBarMesh: StaticMesh;
        WindowCloseButtonMesh: StaticMesh;
        RadialMenuMainMesh: StaticMesh;
        RadialMenuPointerMesh: StaticMesh;
        PointerCursorMesh: StaticMesh;
        LineSegmentCylinderMesh: StaticMesh;
        JointSphereMesh: StaticMesh;
        DockingButtonMesh: StaticMesh;
        GridMaterial: MaterialInterface;
        LaserPointerMaterial: MaterialInterface;
        LaserPointerTranslucentMaterial: MaterialInterface;
        WorldMovementPostProcessMaterial: Material;
        TextMaterial: MaterialInterface;
        VivePreControllerMaterial: MaterialInterface;
        OculusControllerMaterial: MaterialInterface;
        TeleportMaterial: MaterialInterface;
        WindowMaterial: MaterialInterface;
        WindowTranslucentMaterial: MaterialInterface;
        LineMaterial: Material;
        TranslucentTextMaterial: MaterialInterface;
        TextFont: Font;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorAssetContainer;
        static Load(InName: string): VREditorAssetContainer;
    }
    
    class EditorWorldExtensionActorData {
        constructor(Actor: Actor, bValidForPIE: boolean);
        Actor: Actor;
        bValidForPIE: boolean;
    }
    
    class EditorWorldExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExtensionActors: TArray<EditorWorldExtensionActorData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorWorldExtension;
        static Load(InName: string): EditorWorldExtension;
    }
    
    class TextRenderComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextMaterial: MaterialInterface;
        Font: Font;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        TextRenderColor: Color;
        XScale: number;
        YScale: number;
        WorldSize: number;
        InvDefaultSize: number;
        HorizSpacingAdjust: number;
        VertSpacingAdjust: number;
        bAlwaysRenderAsText: boolean;
        SetYScale(Value: number): void;
        SetXScale(Value: number): void;
        SetWorldSize(Value: number): void;
        SetVertSpacingAdjust(Value: number): void;
        SetVerticalAlignment(Value: number): void;
        SetTextRenderColor(Value: Color): void;
        SetTextMaterial(Material: MaterialInterface): void;
        SetText(Value: string): void;
        SetHorizSpacingAdjust(Value: number): void;
        SetHorizontalAlignment(Value: number): void;
        SetFont(Value: Font): void;
        K2_SetText(Value: string): void;
        GetTextWorldSize(): Vector;
        GetTextLocalSize(): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextRenderComponent;
        static Load(InName: string): TextRenderComponent;
    }
    
    class PostProcessComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: PostProcessSettings;
        Priority: number;
        BlendRadius: number;
        BlendWeight: number;
        bEnabled: boolean;
        bUnbound: boolean;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PostProcessComponent;
        static Load(InName: string): PostProcessComponent;
    }
    
    class VREditorAvatarActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HeadMeshComponent: StaticMeshComponent;
        WorldMovementGridMeshComponent: StaticMeshComponent;
        WorldMovementGridMID: MaterialInstanceDynamic;
        WorldMovementGridOpacity: number;
        bIsDrawingWorldMovementPostProcess: boolean;
        WorldMovementPostProcessMaterial: MaterialInstanceDynamic;
        ScaleProgressMeshComponent: StaticMeshComponent;
        CurrentScaleProgressMeshComponent: StaticMeshComponent;
        UserScaleIndicatorText: TextRenderComponent;
        FixedUserScaleMID: MaterialInstanceDynamic;
        TranslucentFixedUserScaleMID: MaterialInstanceDynamic;
        CurrentUserScaleMID: MaterialInstanceDynamic;
        TranslucentCurrentUserScaleMID: MaterialInstanceDynamic;
        PostProcessComponent: PostProcessComponent;
        VRMode: VREditorMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorAvatarActor;
        static Load(InName: string): VREditorAvatarActor;
    }
    
    class VREditorBaseActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: VREditorMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorBaseActor;
        static Load(InName: string): VREditorBaseActor;
    }
    
    class VREditorFloatingUICreationContext {
        constructor(WidgetClass: Class, PanelID: string, ParentActor: Actor, PanelSpawnOffset: Transform, PanelSize: Vector2D, PanelMesh: StaticMesh, EditorUISize: number, bHideWindowHandles: boolean, bMaskOutWidgetBackground: boolean, bNoCloseButton: boolean);
        WidgetClass: Class;
        PanelID: string;
        ParentActor: Actor;
        PanelSpawnOffset: Transform;
        PanelSize: Vector2D;
        PanelMesh: StaticMesh;
        EditorUISize: number;
        bHideWindowHandles: boolean;
        bMaskOutWidgetBackground: boolean;
        bNoCloseButton: boolean;
    }
    
    enum EWidgetSpace { World, Screen, EWidgetSpace_MAX}
    enum EWidgetTimingPolicy { RealTime, GameTime, EWidgetTimingPolicy_MAX}
    enum EWindowVisibility { Visible, SelfHitTestInvisible, EWindowVisibility_MAX}
    enum EWidgetBlendMode { Opaque, Masked, Transparent, EWidgetBlendMode_MAX}
    class TextureRenderTarget extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetGamma: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget;
        static Load(InName: string): TextureRenderTarget;
    }
    
    class TextureRenderTarget2D extends TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        SizeY: number;
        ClearColor: LinearColor;
        AddressX: number;
        AddressY: number;
        bForceLinearGamma: boolean;
        bHDR: boolean;
        bGPUSharedFlag: boolean;
        RenderTargetFormat: number;
        bAutoGenerateMips: boolean;
        MipsSamplerFilter: number;
        MipsAddressU: number;
        MipsAddressV: number;
        OverrideFormat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTarget2D;
        static Load(InName: string): TextureRenderTarget2D;
    }
    
    enum EWidgetGeometryMode { Plane, Cylinder, EWidgetGeometryMode_MAX}
    class WidgetComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Space: EWidgetSpace;
        TimingPolicy: EWidgetTimingPolicy;
        WidgetClass: Class;
        DrawSize: IntPoint;
        bManuallyRedraw: boolean;
        bRedrawRequested: boolean;
        RedrawTime: number;
        CurrentDrawSize: IntPoint;
        bDrawAtDesiredSize: boolean;
        Pivot: Vector2D;
        bReceiveHardwareInput: boolean;
        bWindowFocusable: boolean;
        WindowVisibility: EWindowVisibility;
        bApplyGammaCorrection: boolean;
        OwnerPlayer: LocalPlayer;
        BackgroundColor: LinearColor;
        TintColorAndOpacity: LinearColor;
        OpacityFromTexture: number;
        BlendMode: EWidgetBlendMode;
        bIsTwoSided: boolean;
        TickWhenOffscreen: boolean;
        Widget: UserWidget;
        BodySetup: BodySetup;
        TranslucentMaterial: MaterialInterface;
        TranslucentMaterial_OneSided: MaterialInterface;
        OpaqueMaterial: MaterialInterface;
        OpaqueMaterial_OneSided: MaterialInterface;
        MaskedMaterial: MaterialInterface;
        MaskedMaterial_OneSided: MaterialInterface;
        RenderTarget: TextureRenderTarget2D;
        MaterialInstance: MaterialInstanceDynamic;
        bAddedToScreen: boolean;
        bEditTimeUsable: boolean;
        SharedLayerName: string;
        LayerZOrder: number;
        GeometryMode: EWidgetGeometryMode;
        CylinderArcAngle: number;
        SetWindowVisibility(InVisibility: EWindowVisibility): void;
        SetWindowFocusable(bInWindowFocusable: boolean): void;
        SetWidgetSpace(NewSpace: EWidgetSpace): void;
        SetWidget(Widget: UserWidget): void;
        SetTwoSided(bWantTwoSided: boolean): void;
        SetTintColorAndOpacity(NewTintColorAndOpacity: LinearColor): void;
        SetTickWhenOffscreen(bWantTickWhenOffscreen: boolean): void;
        SetRedrawTime(InRedrawTime: number): void;
        SetPivot(InPivot: Vector2D): void;
        SetOwnerPlayer(LocalPlayer: LocalPlayer): void;
        SetManuallyRedraw(bUseManualRedraw: boolean): void;
        SetGeometryMode(InGeometryMode: EWidgetGeometryMode): void;
        SetDrawSize(Size: Vector2D): void;
        SetDrawAtDesiredSize(bInDrawAtDesiredSize: boolean): void;
        SetCylinderArcAngle(InCylinderArcAngle: number): void;
        SetBackgroundColor(NewBackgroundColor: LinearColor): void;
        RequestRedraw(): void;
        GetWindowVisiblility(): EWindowVisibility;
        GetWindowFocusable(): boolean;
        GetWidgetSpace(): EWidgetSpace;
        GetUserWidgetObject(): UserWidget;
        GetTwoSided(): boolean;
        GetTickWhenOffscreen(): boolean;
        GetRenderTarget(): TextureRenderTarget2D;
        GetRedrawTime(): number;
        GetPivot(): Vector2D;
        GetOwnerPlayer(): LocalPlayer;
        GetMaterialInstance(): MaterialInstanceDynamic;
        GetManuallyRedraw(): boolean;
        GetGeometryMode(): EWidgetGeometryMode;
        GetDrawSize(): Vector2D;
        GetDrawAtDesiredSize(): boolean;
        GetCylinderArcAngle(): number;
        GetCurrentDrawSize(): Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetComponent;
        static Load(InName: string): WidgetComponent;
    }
    
    enum EVREditorWidgetDrawingPolicy { Always, Hovering, EVREditorWidgetDrawingPolicy_MAX}
    class VREditorWidgetComponent extends WidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DrawingPolicy: EVREditorWidgetDrawingPolicy;
        bIsHovering: boolean;
        bHasEverDrawn: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorWidgetComponent;
        static Load(InName: string): VREditorWidgetComponent;
    }
    
    class VREditorFloatingUI extends VREditorBaseActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreationContext: VREditorFloatingUICreationContext;
        UserWidget: UserWidget;
        WidgetComponent: VREditorWidgetComponent;
        WindowMeshComponent: StaticMeshComponent;
        UserWidgetClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorFloatingUI;
        static Load(InName: string): VREditorFloatingUI;
    }
    
    class VREditorRadialFloatingUI extends VREditorBaseActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetComponents: TArray<VREditorWidgetComponent>;
        WindowMeshComponent: StaticMeshComponent;
        ArrowMeshComponent: StaticMeshComponent;
        CentralWidgetComponent: VREditorWidgetComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorRadialFloatingUI;
        static Load(InName: string): VREditorRadialFloatingUI;
    }
    
    class ViewportDragOperation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportDragOperation;
        static Load(InName: string): ViewportDragOperation;
    }
    
    class ViewportDragOperationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DragOperation: ViewportDragOperation;
        DragOperationSubclass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportDragOperationComponent;
        static Load(InName: string): ViewportDragOperationComponent;
    }
    
    class VREditorDockableWindow extends VREditorFloatingUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DockButtonMeshComponent: StaticMeshComponent;
        SelectionBarMeshComponent: StaticMeshComponent;
        CloseButtonMeshComponent: StaticMeshComponent;
        DockButtonMID: MaterialInstanceDynamic;
        SelectionBarMID: MaterialInstanceDynamic;
        SelectionBarTranslucentMID: MaterialInstanceDynamic;
        CloseButtonMID: MaterialInstanceDynamic;
        CloseButtonTranslucentMID: MaterialInstanceDynamic;
        DragOperationComponent: ViewportDragOperationComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorDockableWindow;
        static Load(InName: string): VREditorDockableWindow;
    }
    
    class ViewportActionKeyInput {
        constructor(ActionType: string, Event: number, bIsInputCaptured: boolean);
        ActionType: string;
        Event: number;
        bIsInputCaptured: boolean;
    }
    
    class ViewportTransformer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewportWorldInteraction: ViewportWorldInteraction;
        Shutdown(): void;
        ShouldCenterTransformGizmoPivot(): boolean;
        OnStopDragging(Interactor: ViewportInteractor): void;
        OnStartDragging(Interactor: ViewportInteractor): void;
        Init(InitViewportWorldInteraction: ViewportWorldInteraction): void;
        CanAlignToActors(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportTransformer;
        static Load(InName: string): ViewportTransformer;
    }
    
    class GizmoHandle {
        constructor();
    }
    
    class GizmoHandleGroup extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GizmoMaterial: MaterialInterface;
        TranslucentGizmoMaterial: MaterialInterface;
        Handles: TArray<GizmoHandle>;
        OwningTransformGizmoActor: BaseTransformGizmo;
        DragOperationComponent: ViewportDragOperationComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoHandleGroup;
        static Load(InName: string): GizmoHandleGroup;
    }
    
    class BaseTransformGizmo extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneComponent: SceneComponent;
        AllHandleGroups: TArray<GizmoHandleGroup>;
        WorldInteraction: ViewportWorldInteraction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BaseTransformGizmo;
        static Load(InName: string): BaseTransformGizmo;
    }
    
    class MouseCursorInteractor extends ViewportInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MouseCursorInteractor;
        static Load(InName: string): MouseCursorInteractor;
    }
    
    class ViewportInteractionAssetContainer extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GizmoHandleSelectedSound: SoundBase;
        GizmoHandleDropSound: SoundBase;
        SelectionChangeSound: SoundBase;
        SelectionDropSound: SoundBase;
        SelectionStartDragSound: SoundBase;
        GridSnapSound: SoundBase;
        ActorSnapSound: SoundBase;
        UndoSound: SoundBase;
        RedoSound: SoundBase;
        GridMesh: StaticMesh;
        TranslationHandleMesh: StaticMesh;
        UniformScaleHandleMesh: StaticMesh;
        ScaleHandleMesh: StaticMesh;
        PlaneTranslationHandleMesh: StaticMesh;
        RotationHandleMesh: StaticMesh;
        RotationHandleSelectedMesh: StaticMesh;
        StartRotationIndicatorMesh: StaticMesh;
        CurrentRotationIndicatorMesh: StaticMesh;
        FreeRotationHandleMesh: StaticMesh;
        GridMaterial: MaterialInterface;
        TransformGizmoMaterial: MaterialInterface;
        TranslucentTransformGizmoMaterial: MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportInteractionAssetContainer;
        static Load(InName: string): ViewportInteractionAssetContainer;
    }
    
    class ViewportWorldInteraction extends EditorWorldExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Interactors: TArray<ViewportInteractor>;
        ViewportTransformer: ViewportTransformer;
        TransformGizmoActor: BaseTransformGizmo;
        SnapGridActor: Actor;
        SnapGridMeshComponent: StaticMeshComponent;
        SnapGridMID: MaterialInstanceDynamic;
        DefaultMouseCursorInteractor: MouseCursorInteractor;
        ActorsToExcludeFromHitTest: TArray<TWeakObjectPtr<Actor>>;
        AssetContainer: ViewportInteractionAssetContainer;
        SetWorldToMetersScale(NewWorldToMetersScale: number, bCompensateRoomWorldScale: boolean): void;
        SetRoomTransformForNextFrame(NewRoomTransform: Transform): void;
        SetHeadTransform(NewHeadTransform: Transform): void;
        RemoveInteractor(Interactor: ViewportInteractor): void;
        GetWorldScaleFactor(): number;
        GetTransformGizmoActor(): BaseTransformGizmo;
        GetRoomTransform(): Transform;
        GetRoomSpaceHeadTransform(): Transform;
        GetInteractors(): TArray<ViewportInteractor>;
        GetHeadTransform(): Transform;
        AddInteractor(Interactor: ViewportInteractor): void;
        AddActorToExcludeFromHitTests(ActorToExcludeFromHitTests: Actor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportWorldInteraction;
        static Load(InName: string): ViewportWorldInteraction;
    }
    
    enum EHitResultGizmoFilterMode { All, NoGizmos, GizmosOnly, EHitResultGizmoFilterMode_MAX}
    enum EViewportInteractionDraggingMode { Nothing, TransformablesWithGizmo, TransformablesAtLaserImpact, AssistingDrag, TransformablesFreely, World, Interactable, Material, EViewportInteractionDraggingMode_MAX}
    class ViewportInteractor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyToActionMap: TMap<Key, ViewportActionKeyInput>;
        WorldInteraction: ViewportWorldInteraction;
        OtherInteractor: ViewportInteractor;
        Tick(DeltaTime: number): void;
        Shutdown(): void;
        SetHitResultGizmoFilterMode(newFilter: EHitResultGizmoFilterMode): void;
        SetDraggingMode(NewDraggingMode: EViewportInteractionDraggingMode): void;
        SetCanCarry(bInCanCarry: boolean): void;
        IsHoveringOverGizmo(): boolean;
        HandleInputKey_BP(Action: ViewportActionKeyInput, Key: Key, Event: number, bOutWasHandled: $Ref<boolean>): void;
        HandleInputAxis_BP(Action: ViewportActionKeyInput, Key: Key, Delta: number, DeltaTime: number, bOutWasHandled: $Ref<boolean>): void;
        GetWorldInteraction(): ViewportWorldInteraction;
        GetTransformAndForwardVector(OutHandTransform: $Ref<Transform>, OutForwardVector: $Ref<Vector>): boolean;
        GetTransform(): Transform;
        GetRoomSpaceTransform(): Transform;
        GetOtherInteractor(): ViewportInteractor;
        GetLastTransform(): Transform;
        GetLastRoomSpaceTransform(): Transform;
        GetLaserPointer(LaserPointerStart: $Ref<Vector>, LaserPointerEnd: $Ref<Vector>, bEvenIfBlocked: boolean, LaserLengthOverride: number): boolean;
        GetHoverLocation(): Vector;
        GetHitResultGizmoFilterMode(): EHitResultGizmoFilterMode;
        GetDraggingMode(): EViewportInteractionDraggingMode;
        CanCarry(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportInteractor;
        static Load(InName: string): ViewportInteractor;
    }
    
    enum ETrackingStatus { NotTracked, InertialOnly, Tracked, ETrackingStatus_MAX}
    class MotionControllerComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerIndex: number;
        Hand: EControllerHand;
        MotionSource: string;
        bDisableLowLatencyUpdate: boolean;
        CurrentTrackingStatus: ETrackingStatus;
        bDisplayDeviceModel: boolean;
        DisplayModelSource: string;
        CustomDisplayMesh: StaticMesh;
        DisplayMeshMaterialOverrides: TArray<MaterialInterface>;
        DisplayComponent: PrimitiveComponent;
        SetTrackingSource(NewSource: EControllerHand): void;
        SetTrackingMotionSource(NewSource: string): void;
        SetShowDeviceModel(bShowControllerModel: boolean): void;
        SetDisplayModelSource(NewDisplayModelSource: string): void;
        SetCustomDisplayMesh(NewDisplayMesh: StaticMesh): void;
        SetAssociatedPlayerIndex(NewPlayer: number): void;
        OnMotionControllerUpdated(): void;
        IsTracked(): boolean;
        GetTrackingSource(): EControllerHand;
        GetParameterValue(InName: string, bValueFound: $Ref<boolean>): number;
        GetHandJointPosition(jointIndex: number, bValueFound: $Ref<boolean>): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MotionControllerComponent;
        static Load(InName: string): MotionControllerComponent;
    }
    
    class InterpCurvePointQuat {
        constructor(InVal: number, OutVal: Quat, ArriveTangent: Quat, LeaveTangent: Quat, InterpMode: number);
        InVal: number;
        OutVal: Quat;
        ArriveTangent: Quat;
        LeaveTangent: Quat;
        InterpMode: number;
    }
    
    class InterpCurveQuat {
        constructor(Points: TArray<InterpCurvePointQuat>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<InterpCurvePointQuat>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
    }
    
    class InterpCurvePointFloat {
        constructor(InVal: number, OutVal: number, ArriveTangent: number, LeaveTangent: number, InterpMode: number);
        InVal: number;
        OutVal: number;
        ArriveTangent: number;
        LeaveTangent: number;
        InterpMode: number;
    }
    
    class InterpCurveFloat {
        constructor(Points: TArray<InterpCurvePointFloat>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<InterpCurvePointFloat>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
    }
    
    class SplineMetadata extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMetadata;
        static Load(InName: string): SplineMetadata;
    }
    
    class SplineCurves {
        constructor(Position: InterpCurveVector, Rotation: InterpCurveQuat, Scale: InterpCurveVector, ReparamTable: InterpCurveFloat, Metadata: SplineMetadata);
        Position: InterpCurveVector;
        Rotation: InterpCurveQuat;
        Scale: InterpCurveVector;
        ReparamTable: InterpCurveFloat;
        Metadata: SplineMetadata;
    }
    
    class SplinePoint {
        constructor(InputKey: number, Position: Vector, ArriveTangent: Vector, LeaveTangent: Vector, Rotation: Rotator, Scale: Vector, Type: number);
        InputKey: number;
        Position: Vector;
        ArriveTangent: Vector;
        LeaveTangent: Vector;
        Rotation: Rotator;
        Scale: Vector;
        Type: number;
    }
    
    class SplineComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineCurves: SplineCurves;
        SplineInfo: InterpCurveVector;
        SplineRotInfo: InterpCurveQuat;
        SplineScaleInfo: InterpCurveVector;
        SplineReparamTable: InterpCurveFloat;
        bAllowSplineEditingPerInstance: boolean;
        ReparamStepsPerSegment: number;
        Duration: number;
        bStationaryEndpoints: boolean;
        bSplineHasBeenEdited: boolean;
        bModifiedByConstructionScript: boolean;
        bInputSplinePointsToConstructionScript: boolean;
        bDrawDebug: boolean;
        bClosedLoop: boolean;
        bLoopPositionOverride: boolean;
        LoopPosition: number;
        DefaultUpVector: Vector;
        EditorUnselectedSplineSegmentColor: LinearColor;
        EditorSelectedSplineSegmentColor: LinearColor;
        bAllowDiscontinuousSpline: boolean;
        bShouldVisualizeScale: boolean;
        ScaleVisualizationWidth: number;
        UpdateSpline(): void;
        SetWorldLocationAtSplinePoint(PointIndex: number, InLocation: Vector): void;
        SetUpVectorAtSplinePoint(PointIndex: number, InUpVector: Vector, CoordinateSpace: number, bUpdateSpline: boolean): void;
        SetUnselectedSplineSegmentColor(SegmentColor: LinearColor): void;
        SetTangentsAtSplinePoint(PointIndex: number, InArriveTangent: Vector, InLeaveTangent: Vector, CoordinateSpace: number, bUpdateSpline: boolean): void;
        SetTangentAtSplinePoint(PointIndex: number, InTangent: Vector, CoordinateSpace: number, bUpdateSpline: boolean): void;
        SetSplineWorldPoints(Points: TArray<Vector>): void;
        SetSplinePointType(PointIndex: number, Type: number, bUpdateSpline: boolean): void;
        SetSplinePoints(Points: TArray<Vector>, CoordinateSpace: number, bUpdateSpline: boolean): void;
        SetSplineLocalPoints(Points: TArray<Vector>): void;
        SetSelectedSplineSegmentColor(SegmentColor: LinearColor): void;
        SetLocationAtSplinePoint(PointIndex: number, InLocation: Vector, CoordinateSpace: number, bUpdateSpline: boolean): void;
        SetDrawDebug(bShow: boolean): void;
        SetDefaultUpVector(UpVector: Vector, CoordinateSpace: number): void;
        SetClosedLoopAtPosition(bInClosedLoop: boolean, Key: number, bUpdateSpline: boolean): void;
        SetClosedLoop(bInClosedLoop: boolean, bUpdateSpline: boolean): void;
        RemoveSplinePoint(Index: number, bUpdateSpline: boolean): void;
        IsClosedLoop(): boolean;
        GetWorldTangentAtDistanceAlongSpline(Distance: number): Vector;
        GetWorldRotationAtTime(Time: number, bUseConstantVelocity: boolean): Rotator;
        GetWorldRotationAtDistanceAlongSpline(Distance: number): Rotator;
        GetWorldLocationAtTime(Time: number, bUseConstantVelocity: boolean): Vector;
        GetWorldLocationAtSplinePoint(PointIndex: number): Vector;
        GetWorldLocationAtDistanceAlongSpline(Distance: number): Vector;
        GetWorldDirectionAtTime(Time: number, bUseConstantVelocity: boolean): Vector;
        GetWorldDirectionAtDistanceAlongSpline(Distance: number): Vector;
        GetVectorPropertyAtSplinePoint(Index: number, PropertyName: string): Vector;
        GetVectorPropertyAtSplineInputKey(InKey: number, PropertyName: string): Vector;
        GetUpVectorAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): Vector;
        GetUpVectorAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        GetUpVectorAtSplineInputKey(InKey: number, CoordinateSpace: number): Vector;
        GetUpVectorAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): Vector;
        GetTransformAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean, bUseScale: boolean): Transform;
        GetTransformAtSplinePoint(PointIndex: number, CoordinateSpace: number, bUseScale: boolean): Transform;
        GetTransformAtSplineInputKey(InKey: number, CoordinateSpace: number, bUseScale: boolean): Transform;
        GetTransformAtDistanceAlongSpline(Distance: number, CoordinateSpace: number, bUseScale: boolean): Transform;
        GetTangentAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): Vector;
        GetTangentAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        GetTangentAtSplineInputKey(InKey: number, CoordinateSpace: number): Vector;
        GetTangentAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): Vector;
        GetSplinePointType(PointIndex: number): number;
        GetSplineLength(): number;
        GetScaleAtTime(Time: number, bUseConstantVelocity: boolean): Vector;
        GetScaleAtSplinePoint(PointIndex: number): Vector;
        GetScaleAtSplineInputKey(InKey: number): Vector;
        GetScaleAtDistanceAlongSpline(Distance: number): Vector;
        GetRotationAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): Rotator;
        GetRotationAtSplinePoint(PointIndex: number, CoordinateSpace: number): Rotator;
        GetRotationAtSplineInputKey(InKey: number, CoordinateSpace: number): Rotator;
        GetRotationAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): Rotator;
        GetRollAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): number;
        GetRollAtSplinePoint(PointIndex: number, CoordinateSpace: number): number;
        GetRollAtSplineInputKey(InKey: number, CoordinateSpace: number): number;
        GetRollAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): number;
        GetRightVectorAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): Vector;
        GetRightVectorAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        GetRightVectorAtSplineInputKey(InKey: number, CoordinateSpace: number): Vector;
        GetRightVectorAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): Vector;
        GetNumberOfSplineSegments(): number;
        GetNumberOfSplinePoints(): number;
        GetLocationAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): Vector;
        GetLocationAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        GetLocationAtSplineInputKey(InKey: number, CoordinateSpace: number): Vector;
        GetLocationAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): Vector;
        GetLocationAndTangentAtSplinePoint(PointIndex: number, Location: $Ref<Vector>, Tangent: $Ref<Vector>, CoordinateSpace: number): void;
        GetLocalLocationAndTangentAtSplinePoint(PointIndex: number, LocalLocation: $Ref<Vector>, LocalTangent: $Ref<Vector>): void;
        GetLeaveTangentAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        GetInputKeyAtDistanceAlongSpline(Distance: number): number;
        GetFloatPropertyAtSplinePoint(Index: number, PropertyName: string): number;
        GetFloatPropertyAtSplineInputKey(InKey: number, PropertyName: string): number;
        GetDistanceAlongSplineAtSplinePoint(PointIndex: number): number;
        GetDirectionAtTime(Time: number, CoordinateSpace: number, bUseConstantVelocity: boolean): Vector;
        GetDirectionAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        GetDirectionAtSplineInputKey(InKey: number, CoordinateSpace: number): Vector;
        GetDirectionAtDistanceAlongSpline(Distance: number, CoordinateSpace: number): Vector;
        GetDefaultUpVector(CoordinateSpace: number): Vector;
        GetArriveTangentAtSplinePoint(PointIndex: number, CoordinateSpace: number): Vector;
        FindUpVectorClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): Vector;
        FindTransformClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number, bUseScale: boolean): Transform;
        FindTangentClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): Vector;
        FindScaleClosestToWorldLocation(WorldLocation: Vector): Vector;
        FindRotationClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): Rotator;
        FindRollClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): number;
        FindRightVectorClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): Vector;
        FindLocationClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): Vector;
        FindInputKeyClosestToWorldLocation(WorldLocation: Vector): number;
        FindDirectionClosestToWorldLocation(WorldLocation: Vector, CoordinateSpace: number): Vector;
        ClearSplinePoints(bUpdateSpline: boolean): void;
        AddSplineWorldPoint(Position: Vector): void;
        AddSplinePointAtIndex(Position: Vector, Index: number, CoordinateSpace: number, bUpdateSpline: boolean): void;
        AddSplinePoint(Position: Vector, CoordinateSpace: number, bUpdateSpline: boolean): void;
        AddSplineLocalPoint(Position: Vector): void;
        AddPoints(Points: TArray<SplinePoint>, bUpdateSpline: boolean): void;
        AddPoint(Point: SplinePoint, bUpdateSpline: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineComponent;
        static Load(InName: string): SplineComponent;
    }
    
    class SplineMeshParams {
        constructor(StartPos: Vector, StartTangent: Vector, StartScale: Vector2D, StartRoll: number, StartOffset: Vector2D, EndPos: Vector, EndScale: Vector2D, EndTangent: Vector, EndRoll: number, EndOffset: Vector2D);
        StartPos: Vector;
        StartTangent: Vector;
        StartScale: Vector2D;
        StartRoll: number;
        StartOffset: Vector2D;
        EndPos: Vector;
        EndScale: Vector2D;
        EndTangent: Vector;
        EndRoll: number;
        EndOffset: Vector2D;
    }
    
    class SplineMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineParams: SplineMeshParams;
        SplineUpDir: Vector;
        SplineBoundaryMin: number;
        CachedMeshBodySetupGuid: Guid;
        BodySetup: BodySetup;
        SplineBoundaryMax: number;
        bAllowSplineEditingPerInstance: boolean;
        bSmoothInterpRollScale: boolean;
        bMeshDirty: boolean;
        ForwardAxis: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        bSelected: boolean;
        UpdateMesh(): void;
        SetStartTangent(StartTangent: Vector, bUpdateMesh: boolean): void;
        SetStartScale(StartScale: Vector2D, bUpdateMesh: boolean): void;
        SetStartRoll(StartRoll: number, bUpdateMesh: boolean): void;
        SetStartPosition(StartPos: Vector, bUpdateMesh: boolean): void;
        SetStartOffset(StartOffset: Vector2D, bUpdateMesh: boolean): void;
        SetStartAndEnd(StartPos: Vector, StartTangent: Vector, EndPos: Vector, EndTangent: Vector, bUpdateMesh: boolean): void;
        SetSplineUpDir(InSplineUpDir: Vector, bUpdateMesh: boolean): void;
        SetForwardAxis(InForwardAxis: number, bUpdateMesh: boolean): void;
        SetEndTangent(EndTangent: Vector, bUpdateMesh: boolean): void;
        SetEndScale(EndScale: Vector2D, bUpdateMesh: boolean): void;
        SetEndRoll(EndRoll: number, bUpdateMesh: boolean): void;
        SetEndPosition(EndPos: Vector, bUpdateMesh: boolean): void;
        SetEndOffset(EndOffset: Vector2D, bUpdateMesh: boolean): void;
        SetBoundaryMin(InBoundaryMin: number, bUpdateMesh: boolean): void;
        SetBoundaryMax(InBoundaryMax: number, bUpdateMesh: boolean): void;
        GetStartTangent(): Vector;
        GetStartScale(): Vector2D;
        GetStartRoll(): number;
        GetStartPosition(): Vector;
        GetStartOffset(): Vector2D;
        GetSplineUpDir(): Vector;
        GetForwardAxis(): number;
        GetEndTangent(): Vector;
        GetEndScale(): Vector2D;
        GetEndRoll(): number;
        GetEndPosition(): Vector;
        GetEndOffset(): Vector2D;
        GetBoundaryMin(): number;
        GetBoundaryMax(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMeshComponent;
        static Load(InName: string): SplineMeshComponent;
    }
    
    class LightComponentBase extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightGuid: Guid;
        Brightness: number;
        Intensity: number;
        LightColor: Color;
        bAffectsWorld: boolean;
        CastShadows: boolean;
        CastStaticShadows: boolean;
        CastDynamicShadows: boolean;
        bAffectTranslucentLighting: boolean;
        bTransmission: boolean;
        bCastVolumetricShadow: boolean;
        bCastDeepShadow: boolean;
        bCastRaytracedShadow: boolean;
        bAffectReflection: boolean;
        bAffectGlobalIllumination: boolean;
        IndirectLightingIntensity: number;
        VolumetricScatteringIntensity: number;
        SamplesPerPixel: number;
        StaticEditorTexture: Texture2D;
        StaticEditorTextureScale: number;
        DynamicEditorTexture: Texture2D;
        DynamicEditorTextureScale: number;
        SetSamplesPerPixel(NewValue: number): void;
        SetCastVolumetricShadow(bNewValue: boolean): void;
        SetCastShadows(bNewValue: boolean): void;
        SetCastRaytracedShadow(bNewValue: boolean): void;
        SetCastDeepShadow(bNewValue: boolean): void;
        SetAffectReflection(bNewValue: boolean): void;
        SetAffectGlobalIllumination(bNewValue: boolean): void;
        GetLightColor(): LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightComponentBase;
        static Load(InName: string): LightComponentBase;
    }
    
    class TextureLightProfile extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Brightness: number;
        TextureMultiplier: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureLightProfile;
        static Load(InName: string): TextureLightProfile;
    }
    
    class LightComponent extends LightComponentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Temperature: number;
        MaxDrawDistance: number;
        MaxDistanceFadeRange: number;
        bUseTemperature: boolean;
        ShadowMapChannel: number;
        MinRoughness: number;
        SpecularScale: number;
        ShadowResolutionScale: number;
        ShadowBias: number;
        ShadowSlopeBias: number;
        ShadowSharpen: number;
        ContactShadowLength: number;
        ContactShadowLengthInWS: boolean;
        InverseSquaredFalloff: boolean;
        CastTranslucentShadows: boolean;
        bCastShadowsFromCinematicObjectsOnly: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bForceCachedShadowsForMovablePrimitives: boolean;
        LightingChannels: LightingChannels;
        LightFunctionMaterial: MaterialInterface;
        LightFunctionScale: Vector;
        IESTexture: TextureLightProfile;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        LightFunctionFadeDistance: number;
        DisabledBrightness: number;
        bEnableLightShaftBloom: boolean;
        BloomScale: number;
        BloomThreshold: number;
        BloomMaxBrightness: number;
        BloomTint: Color;
        bUseRayTracedDistanceFieldShadows: boolean;
        RayStartOffsetDepthScale: number;
        SetVolumetricScatteringIntensity(NewIntensity: number): void;
        SetUseIESBrightness(bNewValue: boolean): void;
        SetTransmission(bNewValue: boolean): void;
        SetTemperature(NewTemperature: number): void;
        SetSpecularScale(NewValue: number): void;
        SetShadowSlopeBias(NewValue: number): void;
        SetShadowBias(NewValue: number): void;
        SetLightFunctionScale(NewLightFunctionScale: Vector): void;
        SetLightFunctionMaterial(NewLightFunctionMaterial: MaterialInterface): void;
        SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;
        SetLightFunctionDisabledBrightness(NewValue: number): void;
        SetLightColor(NewLightColor: LinearColor, bSRGB: boolean): void;
        SetIntensity(NewIntensity: number): void;
        SetIndirectLightingIntensity(NewIntensity: number): void;
        SetIESTexture(NewValue: TextureLightProfile): void;
        SetIESBrightnessScale(NewValue: number): void;
        SetForceCachedShadowsForMovablePrimitives(bNewValue: boolean): void;
        SetEnableLightShaftBloom(bNewValue: boolean): void;
        SetBloomTint(NewValue: Color): void;
        SetBloomThreshold(NewValue: number): void;
        SetBloomScale(NewValue: number): void;
        SetBloomMaxBrightness(NewValue: number): void;
        SetAffectTranslucentLighting(bNewValue: boolean): void;
        SetAffectDynamicIndirectLighting(bNewValue: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightComponent;
        static Load(InName: string): LightComponent;
    }
    
    enum ELightUnits { Unitless, Candelas, Lumens, ELightUnits_MAX}
    class LightmassLightSettings {
        constructor(IndirectLightingSaturation: number, ShadowExponent: number, bUseAreaShadowsForStationaryLight: boolean);
        IndirectLightingSaturation: number;
        ShadowExponent: number;
        bUseAreaShadowsForStationaryLight: boolean;
    }
    
    class LightmassPointLightSettings extends LightmassLightSettings {
        constructor();
    }
    
    class LocalLightComponent extends LightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntensityUnits: ELightUnits;
        Radius: number;
        AttenuationRadius: number;
        LightmassSettings: LightmassPointLightSettings;
        SetIntensityUnits(NewIntensityUnits: ELightUnits): void;
        SetAttenuationRadius(NewRadius: number): void;
        static GetUnitsConversionFactor(SrcUnits: ELightUnits, TargetUnits: ELightUnits, CosHalfConeAngle: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalLightComponent;
        static Load(InName: string): LocalLightComponent;
    }
    
    class PointLightComponent extends LocalLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseInverseSquaredFalloff: boolean;
        LightFalloffExponent: number;
        SourceRadius: number;
        SoftSourceRadius: number;
        SourceLength: number;
        SetSourceRadius(bNewValue: number): void;
        SetSourceLength(NewValue: number): void;
        SetSoftSourceRadius(bNewValue: number): void;
        SetLightFalloffExponent(NewLightFalloffExponent: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PointLightComponent;
        static Load(InName: string): PointLightComponent;
    }
    
    enum EControllerType { Laser, AssistingLaser, UI, Navigation, Unknown, EControllerType_MAX}
    class VREditorTeleporter extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: VREditorMode;
        TeleportDirectionMeshComponent: StaticMeshComponent;
        HMDMeshComponent: StaticMeshComponent;
        LeftMotionControllerMeshComponent: StaticMeshComponent;
        RightMotionControllerMeshComponent: StaticMeshComponent;
        TeleportMID: MaterialInstanceDynamic;
        InteractorTryingTeleport: ViewportInteractor;
        TeleportDone(): void;
        StopAiming(): void;
        StartTeleport(): void;
        StartAiming(Interactor: ViewportInteractor): void;
        Shutdown(): void;
        SetVisibility(bVisible: boolean): void;
        SetColor(Color: LinearColor): void;
        IsTeleporting(): boolean;
        IsAiming(): boolean;
        Init(InMode: VREditorMode): void;
        GetVRMode(): VREditorMode;
        GetSlideDelta(Interactor: VREditorInteractor, Axis: boolean): number;
        GetInteractorTryingTeleport(): ViewportInteractor;
        DoTeleport(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorTeleporter;
        static Load(InName: string): VREditorTeleporter;
    }
    
    class VREditorInteractor extends ViewportInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsUndoRedoSwipeEnabled: boolean;
        MotionControllerComponent: MotionControllerComponent;
        HandMeshComponent: StaticMeshComponent;
        LaserSplineComponent: SplineComponent;
        LaserSplineMeshComponents: TArray<SplineMeshComponent>;
        LaserPointerMID: MaterialInstanceDynamic;
        TranslucentLaserPointerMID: MaterialInstanceDynamic;
        HoverMeshComponent: StaticMeshComponent;
        HoverPointLightComponent: PointLightComponent;
        HandMeshMID: MaterialInstanceDynamic;
        OwningAvatar: Actor;
        ControllerType: EControllerType;
        OverrideControllerType: EControllerType;
        ControllerMotionSource: string;
        VRMode: VREditorMode;
        TryOverrideControllerType(InControllerType: EControllerType): boolean;
        SetupComponent(OwningActor: Actor): void;
        SetForceShowLaser(bInForceShow: boolean): void;
        SetForceLaserColor(InColor: LinearColor): void;
        SetControllerType(InControllerType: EControllerType): void;
        SetControllerHandSide(InControllerHandSide: string): void;
        ReplaceHandMeshComponent(NewMesh: StaticMesh): void;
        IsTouchingTrackpad(): boolean;
        IsHoveringOverUI(): boolean;
        IsClickingOnUI(): boolean;
        Init(InVRMode: VREditorMode): void;
        GetTrackpadPosition(): Vector2D;
        GetTeleportActor(): VREditorTeleporter;
        GetSlideDelta(): number;
        GetSelectAndMoveTriggerValue(): number;
        GetMotionControllerComponent(): MotionControllerComponent;
        GetLastTrackpadPosition(): Vector2D;
        GetLaserStart(): Vector;
        GetLaserEnd(): Vector;
        GetHMDDeviceType(): string;
        GetControllerType(): EControllerType;
        GetControllerSide(): EControllerHand;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorInteractor;
        static Load(InName: string): VREditorInteractor;
    }
    
    class VRButton {
        constructor(ButtonWidget: VREditorWidgetComponent);
        ButtonWidget: VREditorWidgetComponent;
    }
    
    class VRRadialMenuHandler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRRadialMenuHandler;
        static Load(InName: string): VRRadialMenuHandler;
    }
    
    class VREditorUISystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: VREditorMode;
        FloatingUIs: TMap<string, VREditorFloatingUI>;
        PreviewWindowInfo: TMap<string, Actor>;
        InfoDisplayPanel: VREditorFloatingUI;
        QuickRadialMenu: VREditorRadialFloatingUI;
        DraggingUI: VREditorDockableWindow;
        ColorPickerUI: VREditorDockableWindow;
        LaserInteractor: VREditorInteractor;
        UIInteractor: VREditorInteractor;
        VRButtons: TArray<VRButton>;
        RadialMenuHandler: VRRadialMenuHandler;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorUISystem;
        static Load(InName: string): VREditorUISystem;
    }
    
    class VREditorPlacement extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: VREditorMode;
        ViewportWorldInteraction: ViewportWorldInteraction;
        FloatingUIAssetDraggedFrom: WidgetComponent;
        PlacingMaterialOrTextureAsset: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorPlacement;
        static Load(InName: string): VREditorPlacement;
    }
    
    class VREditorMode extends EditorWorldExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AvatarActor: VREditorAvatarActor;
        UISystem: VREditorUISystem;
        TeleportActor: VREditorTeleporter;
        AutoScalerSystem: VREditorAutoScaler;
        WorldInteraction: ViewportWorldInteraction;
        PlacementSystem: VREditorPlacement;
        Interactors: TArray<VREditorInteractor>;
        AssetContainer: VREditorAssetContainer;
        GetWorldScaleFactor(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorMode;
        static Load(InName: string): VREditorMode;
    }
    
    class VREditorAutoScaler extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRMode: VREditorMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorAutoScaler;
        static Load(InName: string): VREditorAutoScaler;
    }
    
    class VREditorBaseUserWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Owner: TWeakObjectPtr<VREditorFloatingUI>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorBaseUserWidget;
        static Load(InName: string): VREditorBaseUserWidget;
    }
    
    class VREditorCameraWidgetComponent extends VREditorWidgetComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorCameraWidgetComponent;
        static Load(InName: string): VREditorCameraWidgetComponent;
    }
    
    class VREditorDockableCameraWindow extends VREditorDockableWindow {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorDockableCameraWindow;
        static Load(InName: string): VREditorDockableCameraWindow;
    }
    
    class DockableWindowDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DockableWindowDragOperation;
        static Load(InName: string): DockableWindowDragOperation;
    }
    
    class VREditorFloatingCameraUI extends VREditorFloatingUI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OffsetFromCamera: Vector;
        LinkedActor: TWeakObjectPtr<Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VREditorFloatingCameraUI;
        static Load(InName: string): VREditorFloatingCameraUI;
    }
    
    class FloatingText extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneComponent: SceneComponent;
        FirstLineComponent: StaticMeshComponent;
        JointSphereComponent: StaticMeshComponent;
        SecondLineComponent: StaticMeshComponent;
        TextComponent: TextRenderComponent;
        MaskedTextMaterial: MaterialInterface;
        TranslucentTextMaterial: MaterialInterface;
        LineMaterial: MaterialInterface;
        LineMaterialMID: MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatingText;
        static Load(InName: string): FloatingText;
    }
    
    class VISettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bScaleWorldFromFloor: boolean;
        bScaleWorldWithDynamicPivot: boolean;
        bAllowSimultaneousWorldScalingAndRotation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VISettings;
        static Load(InName: string): VISettings;
    }
    
    enum EInteractorHand { Right, Left, EInteractorHand_MAX}
    class VRModeSettings extends VISettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableAutoVREditMode: boolean;
        bAutokeySequences: boolean;
        InteractorHand: EInteractorHand;
        bShowWorldMovementGrid: boolean;
        bShowWorldMovementPostProcess: boolean;
        bShowWorldScaleProgressBar: boolean;
        UIBrightness: number;
        GizmoScale: number;
        DoubleClickTime: number;
        TriggerPressedThreshold_Vive: number;
        TriggerPressedThreshold_Rift: number;
        InteractorClass: TSoftObjectPtr<Class>;
        TeleporterClass: TSoftObjectPtr<Class>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRModeSettings;
        static Load(InName: string): VRModeSettings;
    }
    
    enum EGizmoHandleTypes { All, Translate, Rotate, Scale, EGizmoHandleTypes_MAX}
    class VRScoutingInteractor extends VREditorInteractor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FlyingIndicatorComponent: StaticMeshComponent;
        SetGizmoMode(InGizmoMode: EGizmoHandleTypes): void;
        static GetSelectedActors(): TArray<Actor>;
        GetGizmoMode(): EGizmoHandleTypes;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRScoutingInteractor;
        static Load(InName: string): VRScoutingInteractor;
    }
    
    class LevelEditorMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorMenuContext;
        static Load(InName: string): LevelEditorMenuContext;
    }
    
    class LevelEditorContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorContextMenuContext;
        static Load(InName: string): LevelEditorContextMenuContext;
    }
    
    class ActorTransformer extends ViewportTransformer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorTransformer;
        static Load(InName: string): ActorTransformer;
    }
    
    class ViewportInteractableInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ViewportInteractableInterface;
        static Load(InName: string): ViewportInteractableInterface;
    }
    
    class TranslationDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TranslationDragOperation;
        static Load(InName: string): TranslationDragOperation;
    }
    
    class PlaneTranslationDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneTranslationDragOperation;
        static Load(InName: string): PlaneTranslationDragOperation;
    }
    
    class RotateOnAngleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RotateOnAngleDragOperation;
        static Load(InName: string): RotateOnAngleDragOperation;
    }
    
    class ScaleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScaleDragOperation;
        static Load(InName: string): ScaleDragOperation;
    }
    
    class UniformScaleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformScaleDragOperation;
        static Load(InName: string): UniformScaleDragOperation;
    }
    
    class AxisGizmoHandleGroup extends GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AxisGizmoHandleGroup;
        static Load(InName: string): AxisGizmoHandleGroup;
    }
    
    class GizmoHandleMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GizmoHandleMeshComponent;
        static Load(InName: string): GizmoHandleMeshComponent;
    }
    
    class UniformScaleGizmoHandleGroup extends GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformScaleGizmoHandleGroup;
        static Load(InName: string): UniformScaleGizmoHandleGroup;
    }
    
    class PivotTranslationGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotTranslationGizmoHandleGroup;
        static Load(InName: string): PivotTranslationGizmoHandleGroup;
    }
    
    class PivotScaleGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotScaleGizmoHandleGroup;
        static Load(InName: string): PivotScaleGizmoHandleGroup;
    }
    
    class PivotPlaneTranslationGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotPlaneTranslationGizmoHandleGroup;
        static Load(InName: string): PivotPlaneTranslationGizmoHandleGroup;
    }
    
    class PivotRotationGizmoHandleGroup extends AxisGizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootFullRotationHandleComponent: SceneComponent;
        FullRotationHandleMeshComponent: GizmoHandleMeshComponent;
        StartRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
        RootStartRotationIdicatorComponent: SceneComponent;
        DeltaRotationIndicatorMeshComponent: GizmoHandleMeshComponent;
        RootDeltaRotationIndicatorComponent: SceneComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotRotationGizmoHandleGroup;
        static Load(InName: string): PivotRotationGizmoHandleGroup;
    }
    
    class StretchGizmoHandleGroup extends GizmoHandleGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StretchGizmoHandleGroup;
        static Load(InName: string): StretchGizmoHandleGroup;
    }
    
    class PivotTransformGizmo extends BaseTransformGizmo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniformScaleGizmoHandleGroup: UniformScaleGizmoHandleGroup;
        TranslationGizmoHandleGroup: PivotTranslationGizmoHandleGroup;
        ScaleGizmoHandleGroup: PivotScaleGizmoHandleGroup;
        PlaneTranslationGizmoHandleGroup: PivotPlaneTranslationGizmoHandleGroup;
        RotationGizmoHandleGroup: PivotRotationGizmoHandleGroup;
        StretchGizmoHandleGroup: StretchGizmoHandleGroup;
        LastDraggingHandle: ActorComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PivotTransformGizmo;
        static Load(InName: string): PivotTransformGizmo;
    }
    
    class StretchGizmoHandleDragOperation extends ViewportDragOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StretchGizmoHandleDragOperation;
        static Load(InName: string): StretchGizmoHandleDragOperation;
    }
    
    enum ELocalizationTargetConflictStatus { Unknown, ConflictsPresent, Clear, ELocalizationTargetConflictStatus_MAX}
    class FilePath {
        constructor(FilePath: string);
        FilePath: string;
    }
    
    enum ELocalizationGatherPathRoot { Auto, Engine, Project, ELocalizationGatherPathRoot_MAX}
    class GatherTextSearchDirectory {
        constructor(PathRoot: ELocalizationGatherPathRoot, Path: string);
        PathRoot: ELocalizationGatherPathRoot;
        Path: string;
    }
    
    class GatherTextExcludePath {
        constructor(PathRoot: ELocalizationGatherPathRoot, Pattern: string);
        PathRoot: ELocalizationGatherPathRoot;
        Pattern: string;
    }
    
    class GatherTextFileExtension {
        constructor(Pattern: string);
        Pattern: string;
    }
    
    class GatherTextFromTextFilesConfiguration {
        constructor(IsEnabled: boolean, SearchDirectories: TArray<GatherTextSearchDirectory>, ExcludePathWildcards: TArray<GatherTextExcludePath>, FileExtensions: TArray<GatherTextFileExtension>, ShouldGatherFromEditorOnlyData: boolean);
        IsEnabled: boolean;
        SearchDirectories: TArray<GatherTextSearchDirectory>;
        ExcludePathWildcards: TArray<GatherTextExcludePath>;
        FileExtensions: TArray<GatherTextFileExtension>;
        ShouldGatherFromEditorOnlyData: boolean;
    }
    
    class GatherTextIncludePath {
        constructor(PathRoot: ELocalizationGatherPathRoot, Pattern: string);
        PathRoot: ELocalizationGatherPathRoot;
        Pattern: string;
    }
    
    class GatherTextFromPackagesConfiguration {
        constructor(IsEnabled: boolean, IncludePathWildcards: TArray<GatherTextIncludePath>, ExcludePathWildcards: TArray<GatherTextExcludePath>, FileExtensions: TArray<GatherTextFileExtension>, Collections: TArray<string>, ShouldGatherFromEditorOnlyData: boolean, SkipGatherCache: boolean);
        IsEnabled: boolean;
        IncludePathWildcards: TArray<GatherTextIncludePath>;
        ExcludePathWildcards: TArray<GatherTextExcludePath>;
        FileExtensions: TArray<GatherTextFileExtension>;
        Collections: TArray<string>;
        ShouldGatherFromEditorOnlyData: boolean;
        SkipGatherCache: boolean;
    }
    
    class MetaDataKeyName {
        constructor(Name: string);
        Name: string;
    }
    
    class MetaDataTextKeyPattern {
        constructor(Pattern: string);
        Pattern: string;
    }
    
    class MetaDataKeyGatherSpecification {
        constructor(MetaDataKey: MetaDataKeyName, TextNamespace: string, TextKeyPattern: MetaDataTextKeyPattern);
        MetaDataKey: MetaDataKeyName;
        TextNamespace: string;
        TextKeyPattern: MetaDataTextKeyPattern;
    }
    
    class GatherTextFromMetaDataConfiguration {
        constructor(IsEnabled: boolean, IncludePathWildcards: TArray<GatherTextIncludePath>, ExcludePathWildcards: TArray<GatherTextExcludePath>, KeySpecifications: TArray<MetaDataKeyGatherSpecification>, ShouldGatherFromEditorOnlyData: boolean);
        IsEnabled: boolean;
        IncludePathWildcards: TArray<GatherTextIncludePath>;
        ExcludePathWildcards: TArray<GatherTextExcludePath>;
        KeySpecifications: TArray<MetaDataKeyGatherSpecification>;
        ShouldGatherFromEditorOnlyData: boolean;
    }
    
    enum ELocalizedTextCollapseMode { IdenticalTextIdAndSource, IdenticalPackageIdTextIdAndSource, IdenticalNamespaceAndSource, ELocalizedTextCollapseMode_MAX}
    class LocalizationExportingSettings {
        constructor(CollapseMode: ELocalizedTextCollapseMode, ShouldPersistCommentsOnExport: boolean, ShouldAddSourceLocationsAsComments: boolean);
        CollapseMode: ELocalizedTextCollapseMode;
        ShouldPersistCommentsOnExport: boolean;
        ShouldAddSourceLocationsAsComments: boolean;
    }
    
    class LocalizationCompilationSettings {
        constructor(SkipSourceCheck: boolean, ValidateFormatPatterns: boolean, ValidateSafeWhitespace: boolean);
        SkipSourceCheck: boolean;
        ValidateFormatPatterns: boolean;
        ValidateSafeWhitespace: boolean;
    }
    
    class LocalizationImportDialogueSettings {
        constructor(RawAudioPath: DirectoryPath, ImportedDialogueFolder: string, bImportNativeAsSource: boolean);
        RawAudioPath: DirectoryPath;
        ImportedDialogueFolder: string;
        bImportNativeAsSource: boolean;
    }
    
    class CultureStatistics {
        constructor(CultureName: string, WordCount: number);
        CultureName: string;
        WordCount: number;
    }
    
    class LocalizationTargetSettings {
        constructor(Name: string, Guid: Guid, ConflictStatus: ELocalizationTargetConflictStatus, TargetDependencies: TArray<Guid>, AdditionalManifestDependencies: TArray<FilePath>, RequiredModuleNames: TArray<string>, GatherFromTextFiles: GatherTextFromTextFilesConfiguration, GatherFromPackages: GatherTextFromPackagesConfiguration, GatherFromMetaData: GatherTextFromMetaDataConfiguration, ExportSettings: LocalizationExportingSettings, CompileSettings: LocalizationCompilationSettings, ImportDialogueSettings: LocalizationImportDialogueSettings, NativeCultureIndex: number, SupportedCulturesStatistics: TArray<CultureStatistics>);
        Name: string;
        Guid: Guid;
        ConflictStatus: ELocalizationTargetConflictStatus;
        TargetDependencies: TArray<Guid>;
        AdditionalManifestDependencies: TArray<FilePath>;
        RequiredModuleNames: TArray<string>;
        GatherFromTextFiles: GatherTextFromTextFilesConfiguration;
        GatherFromPackages: GatherTextFromPackagesConfiguration;
        GatherFromMetaData: GatherTextFromMetaDataConfiguration;
        ExportSettings: LocalizationExportingSettings;
        CompileSettings: LocalizationCompilationSettings;
        ImportDialogueSettings: LocalizationImportDialogueSettings;
        NativeCultureIndex: number;
        SupportedCulturesStatistics: TArray<CultureStatistics>;
    }
    
    class LocalizationTarget extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: LocalizationTargetSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationTarget;
        static Load(InName: string): LocalizationTarget;
    }
    
    class LocalizationTargetSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetObjects: TArray<LocalizationTarget>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationTargetSet;
        static Load(InName: string): LocalizationTargetSet;
    }
    
    class LocalizationSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EngineTargetSet: LocalizationTargetSet;
        EngineTargetsSettings: TArray<LocalizationTargetSettings>;
        GameTargetSet: LocalizationTargetSet;
        GameTargetsSettings: TArray<LocalizationTargetSettings>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationSettings;
        static Load(InName: string): LocalizationSettings;
    }
    
    class MRMeshComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: MaterialInterface;
        bCreateMeshProxySections: boolean;
        bUpdateNavMeshOnMeshUpdate: boolean;
        bNeverCreateCollisionMesh: boolean;
        CachedBodySetup: BodySetup;
        BodySetups: TArray<BodySetup>;
        WireframeMaterial: MaterialInterface;
        IsConnected(): boolean;
        ForceNavMeshUpdate(): void;
        Clear(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MRMeshComponent;
        static Load(InName: string): MRMeshComponent;
    }
    
    class MeshReconstructorBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StopReconstruction(): void;
        StartReconstruction(): void;
        PauseReconstruction(): void;
        IsReconstructionStarted(): boolean;
        IsReconstructionPaused(): boolean;
        DisconnectMRMesh(): void;
        ConnectMRMesh(Mesh: MRMeshComponent): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshReconstructorBase;
        static Load(InName: string): MeshReconstructorBase;
    }
    
    enum EMeshTrackerVertexColorMode { None, Confidence, Block, EMeshTrackerVertexColorMode_MAX}
    class MockDataMeshTrackerComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnMeshTrackerUpdated: $MulticastDelegate<(Index: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, Confidence: TArray<number>) => void>;
        ScanWorld: boolean;
        RequestNormals: boolean;
        RequestVertexConfidence: boolean;
        VertexColorMode: EMeshTrackerVertexColorMode;
        BlockVertexColors: TArray<Color>;
        VertexColorFromConfidenceZero: LinearColor;
        VertexColorFromConfidenceOne: LinearColor;
        UpdateInterval: number;
        MRMesh: MRMeshComponent;
        OnMockDataMeshTrackerUpdated__DelegateSignature(Index: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, Confidence: TArray<number>): void;
        DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
        ConnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockDataMeshTrackerComponent;
        static Load(InName: string): MockDataMeshTrackerComponent;
    }
    
    enum EARWorldAlignment { Gravity, GravityAndHeading, Camera, EARWorldAlignment_MAX}
    enum EARSessionType { None, Orientation, World, Face, Image, ObjectScanning, PoseTracking, EARSessionType_MAX}
    enum EARPlaneDetectionMode { None, HorizontalPlaneDetection, VerticalPlaneDetection, EARPlaneDetectionMode_MAX}
    enum EARLightEstimationMode { None, AmbientLightEstimate, DirectionalLightEstimate, EARLightEstimationMode_MAX}
    enum EARFrameSyncMode { SyncTickWithCameraImage, SyncTickWithoutCameraImage, EARFrameSyncMode_MAX}
    enum EARCandidateImageOrientation { Landscape, Portrait, EARCandidateImageOrientation_MAX}
    class ARCandidateImage extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CandidateTexture: Texture2D;
        FriendlyName: string;
        Width: number;
        Height: number;
        Orientation: EARCandidateImageOrientation;
        GetPhysicalWidth(): number;
        GetPhysicalHeight(): number;
        GetOrientation(): EARCandidateImageOrientation;
        GetFriendlyName(): string;
        GetCandidateTexture(): Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARCandidateImage;
        static Load(InName: string): ARCandidateImage;
    }
    
    enum EAREnvironmentCaptureProbeType { None, Manual, Automatic, EAREnvironmentCaptureProbeType_MAX}
    class ARCandidateObject extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CandidateObjectData: TArray<number>;
        FriendlyName: string;
        BoundingBox: Box;
        SetFriendlyName(NewName: string): void;
        SetCandidateObjectData(InCandidateObject: TArray<number>): void;
        SetBoundingBox(InBoundingBox: Box): void;
        GetFriendlyName(): string;
        GetCandidateObjectData(): TArray<number>;
        GetBoundingBox(): Box;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARCandidateObject;
        static Load(InName: string): ARCandidateObject;
    }
    
    class ARVideoFormat {
        constructor(FPS: number, Width: number, Height: number);
        FPS: number;
        Width: number;
        Height: number;
    }
    
    enum EARFaceTrackingDirection { FaceRelative, FaceMirrored, EARFaceTrackingDirection_MAX}
    enum EARFaceTrackingUpdate { CurvesAndGeo, CurvesOnly, EARFaceTrackingUpdate_MAX}
    enum EARSessionTrackingFeature { None, PoseDetection2D, PersonSegmentation, PersonSegmentationWithDepth, EARSessionTrackingFeature_MAX}
    class ARSessionConfig extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bGenerateMeshDataFromTrackedGeometry: boolean;
        bGenerateCollisionForMeshData: boolean;
        bGenerateNavMeshForMeshData: boolean;
        bUseMeshDataForOcclusion: boolean;
        bRenderMeshDataInWireframe: boolean;
        bTrackSceneObjects: boolean;
        bUsePersonSegmentationForOcclusion: boolean;
        WorldAlignment: EARWorldAlignment;
        SessionType: EARSessionType;
        PlaneDetectionMode: EARPlaneDetectionMode;
        bHorizontalPlaneDetection: boolean;
        bVerticalPlaneDetection: boolean;
        bEnableAutoFocus: boolean;
        LightEstimationMode: EARLightEstimationMode;
        FrameSyncMode: EARFrameSyncMode;
        bEnableAutomaticCameraOverlay: boolean;
        bEnableAutomaticCameraTracking: boolean;
        bResetCameraTracking: boolean;
        bResetTrackedObjects: boolean;
        CandidateImages: TArray<ARCandidateImage>;
        MaxNumSimultaneousImagesTracked: number;
        EnvironmentCaptureProbeType: EAREnvironmentCaptureProbeType;
        WorldMapData: TArray<number>;
        CandidateObjects: TArray<ARCandidateObject>;
        DesiredVideoFormat: ARVideoFormat;
        FaceTrackingDirection: EARFaceTrackingDirection;
        FaceTrackingUpdate: EARFaceTrackingUpdate;
        SerializedARCandidateImageDatabase: TArray<number>;
        EnabledSessionTrackingFeature: EARSessionTrackingFeature;
        ShouldResetTrackedObjects(): boolean;
        ShouldResetCameraTracking(): boolean;
        ShouldRenderCameraOverlay(): boolean;
        ShouldEnableCameraTracking(): boolean;
        ShouldEnableAutoFocus(): boolean;
        SetWorldMapData(WorldMapData: TArray<number>): void;
        SetSessionTrackingFeatureToEnable(InSessionTrackingFeature: EARSessionTrackingFeature): void;
        SetResetTrackedObjects(bNewValue: boolean): void;
        SetResetCameraTracking(bNewValue: boolean): void;
        SetFaceTrackingUpdate(InUpdate: EARFaceTrackingUpdate): void;
        SetFaceTrackingDirection(InDirection: EARFaceTrackingDirection): void;
        SetEnableAutoFocus(bNewValue: boolean): void;
        SetDesiredVideoFormat(NewFormat: ARVideoFormat): void;
        SetCandidateObjectList(InCandidateObjects: TArray<ARCandidateObject>): void;
        GetWorldMapData(): TArray<number>;
        GetWorldAlignment(): EARWorldAlignment;
        GetSessionType(): EARSessionType;
        GetPlaneDetectionMode(): EARPlaneDetectionMode;
        GetMaxNumSimultaneousImagesTracked(): number;
        GetLightEstimationMode(): EARLightEstimationMode;
        GetFrameSyncMode(): EARFrameSyncMode;
        GetFaceTrackingUpdate(): EARFaceTrackingUpdate;
        GetFaceTrackingDirection(): EARFaceTrackingDirection;
        GetEnvironmentCaptureProbeType(): EAREnvironmentCaptureProbeType;
        GetEnabledSessionTrackingFeature(): EARSessionTrackingFeature;
        GetDesiredVideoFormat(): ARVideoFormat;
        GetCandidateObjectList(): TArray<ARCandidateObject>;
        GetCandidateImageList(): TArray<ARCandidateImage>;
        AddCandidateObject(CandidateObject: ARCandidateObject): void;
        AddCandidateImage(NewCandidateImage: ARCandidateImage): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSessionConfig;
        static Load(InName: string): ARSessionConfig;
    }
    
    enum EARTrackingState { Unknown, Tracking, NotTracking, StoppedTracking, EARTrackingState_MAX}
    enum EARObjectClassification { NotApplicable, Unknown, Wall, Ceiling, Floor, Table, Seat, Face, Image, World, SceneObject, EARObjectClassification_MAX}
    class ARTrackedGeometry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueId: Guid;
        LocalToTrackingTransform: Transform;
        LocalToAlignedTrackingTransform: Transform;
        TrackingState: EARTrackingState;
        UnderlyingMesh: MRMeshComponent;
        ObjectClassification: EARObjectClassification;
        LastUpdateFrameNumber: number;
        DebugName: string;
        IsTracked(): boolean;
        GetUnderlyingMesh(): MRMeshComponent;
        GetTrackingState(): EARTrackingState;
        GetObjectClassification(): EARObjectClassification;
        GetLocalToWorldTransform(): Transform;
        GetLocalToTrackingTransform(): Transform;
        GetLastUpdateTimestamp(): number;
        GetLastUpdateFrameNumber(): number;
        GetDebugName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedGeometry;
        static Load(InName: string): ARTrackedGeometry;
    }
    
    class ARPin extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackedGeometry: ARTrackedGeometry;
        PinnedComponent: SceneComponent;
        LocalToTrackingTransform: Transform;
        LocalToAlignedTrackingTransform: Transform;
        TrackingState: EARTrackingState;
        OnARTrackingStateChanged: $MulticastDelegate<(NewTrackingState: EARTrackingState) => void>;
        OnARTransformUpdated: $MulticastDelegate<(OldToNewTransform: Transform) => void>;
        GetTrackingState(): EARTrackingState;
        GetTrackedGeometry(): ARTrackedGeometry;
        GetPinnedComponent(): SceneComponent;
        GetLocalToWorldTransform(): Transform;
        GetLocalToTrackingTransform(): Transform;
        GetDebugName(): string;
        DebugDraw(World: World, Color: LinearColor, Scale: number, PersistForSeconds: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARPin;
        static Load(InName: string): ARPin;
    }
    
    enum EARLineTraceChannels { None, FeaturePoint, GroundPlane, PlaneUsingExtent, PlaneUsingBoundaryPolygon, EARLineTraceChannels_MAX}
    class ARTraceResult {
        constructor(DistanceFromCamera: number, TraceChannel: EARLineTraceChannels, LocalToTrackingTransform: Transform, TrackedGeometry: ARTrackedGeometry);
        DistanceFromCamera: number;
        TraceChannel: EARLineTraceChannels;
        LocalToTrackingTransform: Transform;
        TrackedGeometry: ARTrackedGeometry;
    }
    
    enum EARWorldMappingState { NotAvailable, StillMappingNotRelocalizable, StillMappingRelocalizable, Mapped, EARWorldMappingState_MAX}
    enum EARTrackingQualityReason { None, Initializing, Relocalizing, ExcessiveMotion, InsufficientFeatures, EARTrackingQualityReason_MAX}
    enum EARTrackingQuality { NotTracking, OrientationOnly, OrientationAndPosition, EARTrackingQuality_MAX}
    enum EARTextureType { CameraImage, CameraDepth, EnvironmentCapture, EARTextureType_MAX}
    class ARTexture extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureType: EARTextureType;
        Timestamp: number;
        ExternalTextureGuid: Guid;
        Size: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTexture;
        static Load(InName: string): ARTexture;
    }
    
    class ARTextureCameraImage extends ARTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTextureCameraImage;
        static Load(InName: string): ARTextureCameraImage;
    }
    
    class ARLightEstimate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARLightEstimate;
        static Load(InName: string): ARLightEstimate;
    }
    
    enum EARDepthQuality { Unkown, Low, High, EARDepthQuality_MAX}
    enum EARDepthAccuracy { Unkown, Approximate, Accurate, EARDepthAccuracy_MAX}
    class ARTextureCameraDepth extends ARTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DepthQuality: EARDepthQuality;
        DepthAccuracy: EARDepthAccuracy;
        bIsTemporallySmoothed: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTextureCameraDepth;
        static Load(InName: string): ARTextureCameraDepth;
    }
    
    enum EARSessionStatus { NotStarted, Running, NotSupported, FatalError, PermissionNotGranted, UnsupportedConfiguration, Other, EARSessionStatus_MAX}
    class ARSessionStatus {
        constructor(AdditionalInfo: string, Status: EARSessionStatus);
        AdditionalInfo: string;
        Status: EARSessionStatus;
    }
    
    class ARSkeletonDefinition {
        constructor(NumJoints: number, JointNames: TArray<string>, ParentIndices: TArray<number>);
        NumJoints: number;
        JointNames: TArray<string>;
        ParentIndices: TArray<number>;
    }
    
    enum EARJointTransformSpace { Model, ParentJoint, EARJointTransformSpace_MAX}
    class ARPose3D {
        constructor(SkeletonDefinition: ARSkeletonDefinition, JointTransforms: TArray<Transform>, IsJointTracked: TArray<boolean>, JointTransformSpace: EARJointTransformSpace);
        SkeletonDefinition: ARSkeletonDefinition;
        JointTransforms: TArray<Transform>;
        IsJointTracked: TArray<boolean>;
        JointTransformSpace: EARJointTransformSpace;
    }
    
    class ARTrackedPose extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetTrackedPoseData(): ARPose3D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedPose;
        static Load(InName: string): ARTrackedPose;
    }
    
    class ARTrackedPoint extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedPoint;
        static Load(InName: string): ARTrackedPoint;
    }
    
    enum EARPlaneOrientation { Horizontal, Vertical, Diagonal, EARPlaneOrientation_MAX}
    class ARPlaneGeometry extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Orientation: EARPlaneOrientation;
        Center: Vector;
        Extent: Vector;
        SubsumedBy: ARPlaneGeometry;
        GetSubsumedBy(): ARPlaneGeometry;
        GetOrientation(): EARPlaneOrientation;
        GetExtent(): Vector;
        GetCenter(): Vector;
        GetBoundaryPolygonInLocalSpace(): TArray<Vector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARPlaneGeometry;
        static Load(InName: string): ARPlaneGeometry;
    }
    
    class ARTrackedImage extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DetectedImage: ARCandidateImage;
        EstimatedSize: Vector2D;
        GetEstimateSize(): Vector2D;
        GetDetectedImage(): ARCandidateImage;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedImage;
        static Load(InName: string): ARTrackedImage;
    }
    
    class AREnvironmentCaptureProbeTexture extends TextureCube {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureType: EARTextureType;
        Timestamp: number;
        ExternalTextureGuid: Guid;
        Size: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AREnvironmentCaptureProbeTexture;
        static Load(InName: string): AREnvironmentCaptureProbeTexture;
    }
    
    class AREnvironmentCaptureProbe extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnvironmentCaptureTexture: AREnvironmentCaptureProbeTexture;
        GetExtent(): Vector;
        GetEnvironmentCaptureTexture(): AREnvironmentCaptureProbeTexture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AREnvironmentCaptureProbe;
        static Load(InName: string): AREnvironmentCaptureProbe;
    }
    
    class ARPose2D {
        constructor(SkeletonDefinition: ARSkeletonDefinition, JointLocations: TArray<Vector2D>, IsJointTracked: TArray<boolean>);
        SkeletonDefinition: ARSkeletonDefinition;
        JointLocations: TArray<Vector2D>;
        IsJointTracked: TArray<boolean>;
    }
    
    class ARBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UnpinComponent(ComponentToUnpin: SceneComponent): void;
        static StopARSession(): void;
        static StartARSession(SessionConfig: ARSessionConfig): void;
        static SetAlignmentTransform(InAlignmentTransform: Transform): void;
        static RemovePin(PinToRemove: ARPin): void;
        static PinComponentToTraceResult(ComponentToPin: SceneComponent, TraceResult: ARTraceResult, DebugName: string): ARPin;
        static PinComponent(ComponentToPin: SceneComponent, PinToWorldTransform: Transform, TrackedGeometry: ARTrackedGeometry, DebugName: string): ARPin;
        static PauseARSession(): void;
        static LineTraceTrackedObjects3D(Start: Vector, End: Vector, bTestFeaturePoints: boolean, bTestGroundPlane: boolean, bTestPlaneExtents: boolean, bTestPlaneBoundaryPolygon: boolean): TArray<ARTraceResult>;
        static LineTraceTrackedObjects(ScreenCoord: Vector2D, bTestFeaturePoints: boolean, bTestGroundPlane: boolean, bTestPlaneExtents: boolean, bTestPlaneBoundaryPolygon: boolean): TArray<ARTraceResult>;
        static IsSessionTypeSupported(SessionType: EARSessionType): boolean;
        static IsSessionTrackingFeatureSupported(SessionType: EARSessionType, SessionTrackingFeature: EARSessionTrackingFeature): boolean;
        static IsARSupported(): boolean;
        static GetWorldMappingStatus(): EARWorldMappingState;
        static GetTrackingQualityReason(): EARTrackingQualityReason;
        static GetTrackingQuality(): EARTrackingQuality;
        static GetSupportedVideoFormats(SessionType: EARSessionType): TArray<ARVideoFormat>;
        static GetSessionConfig(): ARSessionConfig;
        static GetPointCloud(): TArray<Vector>;
        static GetPersonSegmentationImage(): ARTextureCameraImage;
        static GetPersonSegmentationDepthImage(): ARTextureCameraImage;
        static GetCurrentLightEstimate(): ARLightEstimate;
        static GetCameraImage(): ARTextureCameraImage;
        static GetCameraDepth(): ARTextureCameraDepth;
        static GetARSessionStatus(): ARSessionStatus;
        static GetAllTrackedPoses(): TArray<ARTrackedPose>;
        static GetAllTrackedPoints(): TArray<ARTrackedPoint>;
        static GetAllTrackedPlanes(): TArray<ARPlaneGeometry>;
        static GetAllTrackedImages(): TArray<ARTrackedImage>;
        static GetAllTrackedEnvironmentCaptureProbes(): TArray<AREnvironmentCaptureProbe>;
        static GetAllTracked2DPoses(): TArray<ARPose2D>;
        static GetAllPins(): TArray<ARPin>;
        static GetAllGeometries(): TArray<ARTrackedGeometry>;
        static DebugDrawTrackedGeometry(TrackedGeometry: ARTrackedGeometry, WorldContextObject: Object, Color: LinearColor, OutlineThickness: number, PersistForSeconds: number): void;
        static DebugDrawPin(ARPin: ARPin, WorldContextObject: Object, Color: LinearColor, Scale: number, PersistForSeconds: number): void;
        static AddRuntimeCandidateImage(SessionConfig: ARSessionConfig, CandidateTexture: Texture2D, FriendlyName: string, PhysicalWidth: number): ARCandidateImage;
        static AddManualEnvironmentCaptureProbe(Location: Vector, Extent: Vector): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARBlueprintLibrary;
        static Load(InName: string): ARBlueprintLibrary;
    }
    
    class ARTraceResultLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetTrackedGeometry(TraceResult: ARTraceResult): ARTrackedGeometry;
        static GetTraceChannel(TraceResult: ARTraceResult): EARLineTraceChannels;
        static GetLocalToWorldTransform(TraceResult: ARTraceResult): Transform;
        static GetLocalToTrackingTransform(TraceResult: ARTraceResult): Transform;
        static GetDistanceFromCamera(TraceResult: ARTraceResult): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTraceResultLibrary;
        static Load(InName: string): ARTraceResultLibrary;
    }
    
    class BlueprintAsyncActionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Activate(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintAsyncActionBase;
        static Load(InName: string): BlueprintAsyncActionBase;
    }
    
    class ARBaseAsyncTaskBlueprintProxy extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARBaseAsyncTaskBlueprintProxy;
        static Load(InName: string): ARBaseAsyncTaskBlueprintProxy;
    }
    
    class ARSaveWorldAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(SavedWorld: TArray<number>) => void>;
        OnFailed: $MulticastDelegate<(SavedWorld: TArray<number>) => void>;
        static ARSaveWorld(WorldContextObject: Object): ARSaveWorldAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSaveWorldAsyncTaskBlueprintProxy;
        static Load(InName: string): ARSaveWorldAsyncTaskBlueprintProxy;
    }
    
    class ARGetCandidateObjectAsyncTaskBlueprintProxy extends ARBaseAsyncTaskBlueprintProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(SavedObject: ARCandidateObject) => void>;
        OnFailed: $MulticastDelegate<(SavedObject: ARCandidateObject) => void>;
        static ARGetCandidateObject(WorldContextObject: Object, Location: Vector, Extent: Vector): ARGetCandidateObjectAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARGetCandidateObjectAsyncTaskBlueprintProxy;
        static Load(InName: string): ARGetCandidateObjectAsyncTaskBlueprintProxy;
    }
    
    class ARBasicLightEstimate extends ARLightEstimate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AmbientIntensityLumens: number;
        AmbientColorTemperatureKelvin: number;
        AmbientColor: LinearColor;
        GetAmbientIntensityLumens(): number;
        GetAmbientColorTemperatureKelvin(): number;
        GetAmbientColor(): LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARBasicLightEstimate;
        static Load(InName: string): ARBasicLightEstimate;
    }
    
    class AROriginActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AROriginActor;
        static Load(InName: string): AROriginActor;
    }
    
    class GameMode extends GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatchState: string;
        bDelayedStart: boolean;
        NumSpectators: number;
        NumPlayers: number;
        NumBots: number;
        MinRespawnDelay: number;
        NumTravellingPlayers: number;
        EngineMessageClass: Class;
        InactivePlayerArray: TArray<PlayerState>;
        InactivePlayerStateLifeSpan: number;
        MaxInactivePlayers: number;
        bHandleDedicatedServerReplays: boolean;
        StartMatch(): void;
        SetBandwidthLimit(AsyncIOBandwidthLimit: number): void;
        Say(Msg: string): void;
        RestartGame(): void;
        ReadyToStartMatch(): boolean;
        ReadyToEndMatch(): boolean;
        K2_OnSetMatchState(NewState: string): void;
        IsMatchInProgress(): boolean;
        HasMatchEnded(): boolean;
        GetMatchState(): string;
        EndMatch(): void;
        AbortMatch(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameMode;
        static Load(InName: string): GameMode;
    }
    
    class GameState extends GameStateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatchState: string;
        PreviousMatchState: string;
        ElapsedTime: number;
        OnRep_MatchState(): void;
        OnRep_ElapsedTime(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameState;
        static Load(InName: string): GameState;
    }
    
    class ARSharedWorldGameState extends GameState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewImageData: TArray<number>;
        ARWorldData: TArray<number>;
        PreviewImageBytesTotal: number;
        ARWorldBytesTotal: number;
        PreviewImageBytesDelivered: number;
        ARWorldBytesDelivered: number;
        K2_OnARWorldMapIsReady(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSharedWorldGameState;
        static Load(InName: string): ARSharedWorldGameState;
    }
    
    class ARSharedWorldGameMode extends GameMode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BufferSizePerChunk: number;
        SetPreviewImageData(ImageData: TArray<number>): void;
        SetARWorldSharingIsReady(): void;
        SetARSharedWorldData(ARWorldData: TArray<number>): void;
        GetARSharedWorldGameState(): ARSharedWorldGameState;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSharedWorldGameMode;
        static Load(InName: string): ARSharedWorldGameMode;
    }
    
    class ARSharedWorldPlayerController extends PlayerController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ServerMarkReadyForReceiving(): void;
        ClientUpdatePreviewImageData(Offset: number, Buffer: TArray<number>): void;
        ClientUpdateARWorldData(Offset: number, Buffer: TArray<number>): void;
        ClientInitSharedWorld(PreviewImageSize: number, ARWorldDataSize: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSharedWorldPlayerController;
        static Load(InName: string): ARSharedWorldPlayerController;
    }
    
    class SkyLightComponent extends LightComponentBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: number;
        Cubemap: TextureCube;
        SourceCubemapAngle: number;
        CubemapResolution: number;
        SkyDistanceThreshold: number;
        bCaptureEmissiveOnly: boolean;
        bLowerHemisphereIsBlack: boolean;
        LowerHemisphereColor: LinearColor;
        OcclusionMaxDistance: number;
        Contrast: number;
        OcclusionExponent: number;
        MinOcclusion: number;
        OcclusionTint: Color;
        OcclusionCombineMode: number;
        BlendDestinationCubemap: TextureCube;
        SetVolumetricScatteringIntensity(NewIntensity: number): void;
        SetOcclusionTint(InTint: Color): void;
        SetOcclusionExponent(InOcclusionExponent: number): void;
        SetOcclusionContrast(InOcclusionContrast: number): void;
        SetMinOcclusion(InMinOcclusion: number): void;
        SetLowerHemisphereColor(InLowerHemisphereColor: LinearColor): void;
        SetLightColor(NewLightColor: LinearColor): void;
        SetIntensity(NewIntensity: number): void;
        SetIndirectLightingIntensity(NewIntensity: number): void;
        SetCubemapBlend(SourceCubemap: TextureCube, DestinationCubemap: TextureCube, InBlendFraction: number): void;
        SetCubemap(NewCubemap: TextureCube): void;
        RecaptureSky(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyLightComponent;
        static Load(InName: string): SkyLightComponent;
    }
    
    class SkyLight extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightComponent: SkyLightComponent;
        bEnabled: boolean;
        OnRep_bEnabled(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyLight;
        static Load(InName: string): SkyLight;
    }
    
    class ARSkyLight extends SkyLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureProbe: AREnvironmentCaptureProbe;
        SetEnvironmentCaptureProbe(InCaptureProbe: AREnvironmentCaptureProbe): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARSkyLight;
        static Load(InName: string): ARSkyLight;
    }
    
    class ARTraceResultDummy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTraceResultDummy;
        static Load(InName: string): ARTraceResultDummy;
    }
    
    class ARTrackedQRCode extends ARTrackedImage {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QRCode: string;
        Version: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedQRCode;
        static Load(InName: string): ARTrackedQRCode;
    }
    
    enum EARFaceBlendShape { EyeBlinkLeft, EyeLookDownLeft, EyeLookInLeft, EyeLookOutLeft, EyeLookUpLeft, EyeSquintLeft, EyeWideLeft, EyeBlinkRight, EyeLookDownRight, EyeLookInRight, EyeLookOutRight, EyeLookUpRight, EyeSquintRight, EyeWideRight, JawForward, JawLeft, JawRight, JawOpen, MouthClose, MouthFunnel, MouthPucker, MouthLeft, MouthRight, MouthSmileLeft, MouthSmileRight, MouthFrownLeft, MouthFrownRight, MouthDimpleLeft, MouthDimpleRight, MouthStretchLeft, MouthStretchRight, MouthRollLower, MouthRollUpper, MouthShrugLower, MouthShrugUpper, MouthPressLeft, MouthPressRight, MouthLowerDownLeft, MouthLowerDownRight, MouthUpperUpLeft, MouthUpperUpRight, BrowDownLeft, BrowDownRight, BrowInnerUp, BrowOuterUpLeft, BrowOuterUpRight, CheekPuff, CheekSquintLeft, CheekSquintRight, NoseSneerLeft, NoseSneerRight, TongueOut, HeadYaw, HeadPitch, HeadRoll, LeftEyeYaw, LeftEyePitch, LeftEyeRoll, RightEyeYaw, RightEyePitch, RightEyeRoll, MAX}
    enum EAREye { LeftEye, RightEye, EAREye_MAX}
    class ARFaceGeometry extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookAtTarget: Vector;
        bIsTracked: boolean;
        BlendShapes: TMap<EARFaceBlendShape, number>;
        GetWorldSpaceEyeTransform(Eye: EAREye): Transform;
        GetLocalSpaceEyeTransform(Eye: EAREye): Transform;
        GetBlendShapeValue(BlendShape: EARFaceBlendShape): number;
        GetBlendShapes(): TMap<EARFaceBlendShape, number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARFaceGeometry;
        static Load(InName: string): ARFaceGeometry;
    }
    
    class ARTrackedObject extends ARTrackedGeometry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DetectedObject: ARCandidateObject;
        GetDetectedObject(): ARCandidateObject;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackedObject;
        static Load(InName: string): ARTrackedObject;
    }
    
    class ARTrackableNotifyComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAddTrackedGeometry: $MulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
        OnUpdateTrackedGeometry: $MulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
        OnRemoveTrackedGeometry: $MulticastDelegate<(TrackedGeometry: ARTrackedGeometry) => void>;
        OnAddTrackedPlane: $MulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
        OnUpdateTrackedPlane: $MulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
        OnRemoveTrackedPlane: $MulticastDelegate<(TrackedPlane: ARPlaneGeometry) => void>;
        OnAddTrackedPoint: $MulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
        OnUpdateTrackedPoint: $MulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
        OnRemoveTrackedPoint: $MulticastDelegate<(TrackedPoint: ARTrackedPoint) => void>;
        OnAddTrackedImage: $MulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
        OnUpdateTrackedImage: $MulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
        OnRemoveTrackedImage: $MulticastDelegate<(TrackedImage: ARTrackedImage) => void>;
        OnAddTrackedFace: $MulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
        OnUpdateTrackedFace: $MulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
        OnRemoveTrackedFace: $MulticastDelegate<(TrackedFace: ARFaceGeometry) => void>;
        OnAddTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
        OnUpdateTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
        OnRemoveTrackedEnvProbe: $MulticastDelegate<(TrackedEnvProbe: AREnvironmentCaptureProbe) => void>;
        OnAddTrackedObject: $MulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
        OnUpdateTrackedObject: $MulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
        OnRemoveTrackedObject: $MulticastDelegate<(TrackedObject: ARTrackedObject) => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTrackableNotifyComponent;
        static Load(InName: string): ARTrackableNotifyComponent;
    }
    
    class ARTypesDummyClass extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ARTypesDummyClass;
        static Load(InName: string): ARTypesDummyClass;
    }
    
    enum ESpectatorScreenMode { Disabled, SingleEyeLetterboxed, Undistorted, Distorted, SingleEye, SingleEyeCroppedToFill, Texture, TexturePlusEye, ESpectatorScreenMode_MAX}
    class XRDeviceId {
        constructor(SystemName: string, DeviceId: number);
        SystemName: string;
        DeviceId: number;
    }
    
    enum EXRTrackedDeviceType { HeadMountedDisplay, Controller, TrackingReference, Other, Invalid, Any, EXRTrackedDeviceType_MAX}
    class HeadMountedDisplayFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UpdateExternalTrackingHMDPosition(ExternalTrackingTransform: Transform): void;
        static SetWorldToMetersScale(WorldContext: Object, NewScale: number): void;
        static SetTrackingOrigin(Origin: number): void;
        static SetSpectatorScreenTexture(InTexture: Texture): void;
        static SetSpectatorScreenModeTexturePlusEyeLayout(EyeRectMin: Vector2D, EyeRectMax: Vector2D, TextureRectMin: Vector2D, TextureRectMax: Vector2D, bDrawEyeFirst: boolean, bClearBlack: boolean, bUseAlpha: boolean): void;
        static SetSpectatorScreenMode(Mode: ESpectatorScreenMode): void;
        static SetClippingPlanes(Near: number, Far: number): void;
        static ResetOrientationAndPosition(Yaw: number, Options: number): void;
        static IsSpectatorScreenModeControllable(): boolean;
        static IsInLowPersistenceMode(): boolean;
        static IsHeadMountedDisplayEnabled(): boolean;
        static IsHeadMountedDisplayConnected(): boolean;
        static IsDeviceTracking(XRDeviceId: XRDeviceId): boolean;
        static HasValidTrackingPosition(): boolean;
        static GetWorldToMetersScale(WorldContext: Object): number;
        static GetVRFocusState(bUseFocus: $Ref<boolean>, bHasFocus: $Ref<boolean>): void;
        static GetTrackingToWorldTransform(WorldContext: Object): Transform;
        static GetTrackingSensorParameters(Origin: $Ref<Vector>, Rotation: $Ref<Rotator>, LeftFOV: $Ref<number>, RightFOV: $Ref<number>, TopFOV: $Ref<number>, BottomFOV: $Ref<number>, Distance: $Ref<number>, NearPlane: $Ref<number>, FarPlane: $Ref<number>, IsActive: $Ref<boolean>, Index: number): void;
        static GetTrackingOrigin(): number;
        static GetScreenPercentage(): number;
        static GetPositionalTrackingCameraParameters(CameraOrigin: $Ref<Vector>, CameraRotation: $Ref<Rotator>, HFOV: $Ref<number>, VFOV: $Ref<number>, CameraDistance: $Ref<number>, NearPlane: $Ref<number>, FarPlane: $Ref<number>): void;
        static GetPixelDensity(): number;
        static GetOrientationAndPosition(DeviceRotation: $Ref<Rotator>, DevicePosition: $Ref<Vector>): void;
        static GetNumOfTrackingSensors(): number;
        static GetHMDWornState(): number;
        static GetHMDDeviceName(): string;
        static GetDeviceWorldPose(WorldContext: Object, XRDeviceId: XRDeviceId, bIsTracked: $Ref<boolean>, Orientation: $Ref<Rotator>, bHasPositionalTracking: $Ref<boolean>, Position: $Ref<Vector>): void;
        static GetDevicePose(XRDeviceId: XRDeviceId, bIsTracked: $Ref<boolean>, Orientation: $Ref<Rotator>, bHasPositionalTracking: $Ref<boolean>, Position: $Ref<Vector>): void;
        static EnumerateTrackedDevices(SystemId: string, DeviceType: EXRTrackedDeviceType): TArray<XRDeviceId>;
        static EnableLowPersistenceMode(bEnable: boolean): void;
        static EnableHMD(bEnable: boolean): boolean;
        static CalibrateExternalTrackingToHMD(ExternalTrackingTransform: Transform): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HeadMountedDisplayFunctionLibrary;
        static Load(InName: string): HeadMountedDisplayFunctionLibrary;
    }
    
    class MotionTrackedDeviceFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetIsControllerMotionTrackingEnabledByDefault(Enable: boolean): void;
        static IsMotionTrackingEnabledForSource(PlayerIndex: number, SourceName: string): boolean;
        static IsMotionTrackingEnabledForDevice(PlayerIndex: number, Hand: EControllerHand): boolean;
        static IsMotionTrackingEnabledForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
        static IsMotionTrackedDeviceCountManagementNecessary(): boolean;
        static IsMotionSourceTracking(PlayerIndex: number, SourceName: string): boolean;
        static GetMotionTrackingEnabledControllerCount(): number;
        static GetMaximumMotionTrackedControllerCount(): number;
        static GetActiveTrackingSystemName(): string;
        static EnumerateMotionSources(): TArray<string>;
        static EnableMotionTrackingOfSource(PlayerIndex: number, SourceName: string): boolean;
        static EnableMotionTrackingOfDevice(PlayerIndex: number, Hand: EControllerHand): boolean;
        static EnableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): boolean;
        static DisableMotionTrackingOfSource(PlayerIndex: number, SourceName: string): void;
        static DisableMotionTrackingOfDevice(PlayerIndex: number, Hand: EControllerHand): void;
        static DisableMotionTrackingOfControllersForPlayer(PlayerIndex: number): void;
        static DisableMotionTrackingOfAllControllers(): void;
        static DisableMotionTrackingForComponent(MotionControllerComponent: MotionControllerComponent): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MotionTrackedDeviceFunctionLibrary;
        static Load(InName: string): MotionTrackedDeviceFunctionLibrary;
    }
    
    class VRNotificationsComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HMDTrackingInitializingAndNeedsHMDToBeTrackedDelegate: $MulticastDelegate<() => void>;
        HMDTrackingInitializedDelegate: $MulticastDelegate<() => void>;
        HMDRecenteredDelegate: $MulticastDelegate<() => void>;
        HMDLostDelegate: $MulticastDelegate<() => void>;
        HMDReconnectedDelegate: $MulticastDelegate<() => void>;
        HMDConnectCanceledDelegate: $MulticastDelegate<() => void>;
        HMDPutOnHeadDelegate: $MulticastDelegate<() => void>;
        HMDRemovedFromHeadDelegate: $MulticastDelegate<() => void>;
        VRControllerRecenteredDelegate: $MulticastDelegate<() => void>;
        VRNotificationsDelegate__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VRNotificationsComponent;
        static Load(InName: string): VRNotificationsComponent;
    }
    
    class XRAssetFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static AddNamedDeviceVisualizationComponentBlocking(Target: Actor, SystemName: string, DeviceName: string, bManualAttachment: boolean, RelativeTransform: Transform, XRDeviceId: $Ref<XRDeviceId>): PrimitiveComponent;
        static AddDeviceVisualizationComponentBlocking(Target: Actor, XRDeviceId: XRDeviceId, bManualAttachment: boolean, RelativeTransform: Transform): PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): XRAssetFunctionLibrary;
        static Load(InName: string): XRAssetFunctionLibrary;
    }
    
    class AsyncTask_LoadXRDeviceVisComponent extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnModelLoaded: $MulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
        OnLoadFailure: $MulticastDelegate<(LoadedComponent: PrimitiveComponent) => void>;
        SpawnedComponent: PrimitiveComponent;
        static AddNamedDeviceVisualizationComponentAsync(Target: Actor, SystemName: string, DeviceName: string, bManualAttachment: boolean, RelativeTransform: Transform, XRDeviceId: $Ref<XRDeviceId>, NewComponent: $Ref<PrimitiveComponent>): AsyncTask_LoadXRDeviceVisComponent;
        static AddDeviceVisualizationComponentAsync(Target: Actor, XRDeviceId: XRDeviceId, bManualAttachment: boolean, RelativeTransform: Transform, NewComponent: $Ref<PrimitiveComponent>): AsyncTask_LoadXRDeviceVisComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncTask_LoadXRDeviceVisComponent;
        static Load(InName: string): AsyncTask_LoadXRDeviceVisComponent;
    }
    
    class XRLoadingScreenFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ShowLoadingScreen(): void;
        static SetLoadingScreen(Texture: Texture, Scale: Vector2D, Offset: Vector, bShowLoadingMovie: boolean, bShowOnSet: boolean): void;
        static HideLoadingScreen(): void;
        static ClearLoadingScreenSplashes(): void;
        static AddLoadingScreenSplash(Texture: Texture, Translation: Vector, Rotation: Rotator, Size: Vector2D, DeltaRotation: Rotator, bClearBeforeAdd: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): XRLoadingScreenFunctionLibrary;
        static Load(InName: string): XRLoadingScreenFunctionLibrary;
    }
    
    class CookerStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Assets: TArray<TWeakObjectPtr<Object>>;
        SizeBefore: number;
        SizeAfter: number;
        Path: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookerStats;
        static Load(InName: string): CookerStats;
    }
    
    class LightingBuildInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Object: TWeakObjectPtr<Object>;
        LightingTime: number;
        UnmappedTexelsPercentage: number;
        UnmappedTexelsMemory: number;
        TotalTexelMemory: number;
        LevelName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightingBuildInfo;
        static Load(InName: string): LightingBuildInfo;
    }
    
    class PrimitiveStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Object: TWeakObjectPtr<Object>;
        Actors: TArray<TWeakObjectPtr<Actor>>;
        Type: string;
        Count: number;
        Sections: number;
        HWInstances: number;
        InstSections: number;
        Triangles: number;
        InstTriangles: number;
        ResourceSize: number;
        VertexColorMem: number;
        InstVertexColorMem: number;
        LightsLM: number;
        LightsOther: number;
        LightsTotal: number;
        ObjLightCost: number;
        LightMapData: number;
        LMSMResolution: number;
        RadiusMin: number;
        RadiusMax: number;
        RadiusAvg: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimitiveStats;
        static Load(InName: string): PrimitiveStats;
    }
    
    class StaticMeshLightingInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshActor: TWeakObjectPtr<Actor>;
        StaticMesh: TWeakObjectPtr<StaticMesh>;
        LevelName: string;
        TextureMapping: string;
        bTextureMapping: boolean;
        bHasLightmapTexCoords: boolean;
        StaticLightingResolution: number;
        TextureLightMapMemoryUsage: number;
        VertexLightMapMemoryUsage: number;
        LightMapLightCount: number;
        TextureShadowMapMemoryUsage: number;
        VertexShadowMapMemoryUsage: number;
        ShadowMapLightCount: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshLightingInfo;
        static Load(InName: string): StaticMeshLightingInfo;
    }
    
    class TextureStats extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Texture: TWeakObjectPtr<Texture>;
        Actors: TArray<TWeakObjectPtr<Actor>>;
        Type: string;
        MaxDim: Vector2D;
        CurrentDim: Vector2D;
        Format: number;
        Group: number;
        LODBias: number;
        CurrentKB: number;
        FullyLoadedKB: number;
        NumUses: number;
        LastTimeRendered: number;
        Path: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureStats;
        static Load(InName: string): TextureStats;
    }
    
    class PreviewSceneProfile {
        constructor(ProfileName: string, bSharedProfile: boolean, bUseSkyLighting: boolean, DirectionalLightIntensity: number, DirectionalLightColor: LinearColor, SkyLightIntensity: number, bRotateLightingRig: boolean, bShowEnvironment: boolean, bShowFloor: boolean, EnvironmentColor: LinearColor, EnvironmentIntensity: number, EnvironmentCubeMap: TSoftObjectPtr<TextureCube>, EnvironmentCubeMapPath: string, bPostProcessingEnabled: boolean, PostProcessingSettings: PostProcessSettings, LightingRigRotation: number, RotationSpeed: number, DirectionalLightRotation: Rotator);
        ProfileName: string;
        bSharedProfile: boolean;
        bUseSkyLighting: boolean;
        DirectionalLightIntensity: number;
        DirectionalLightColor: LinearColor;
        SkyLightIntensity: number;
        bRotateLightingRig: boolean;
        bShowEnvironment: boolean;
        bShowFloor: boolean;
        EnvironmentColor: LinearColor;
        EnvironmentIntensity: number;
        EnvironmentCubeMap: TSoftObjectPtr<TextureCube>;
        EnvironmentCubeMapPath: string;
        bPostProcessingEnabled: boolean;
        PostProcessingSettings: PostProcessSettings;
        LightingRigRotation: number;
        RotationSpeed: number;
        DirectionalLightRotation: Rotator;
    }
    
    class LocalProfiles extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<PreviewSceneProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalProfiles;
        static Load(InName: string): LocalProfiles;
    }
    
    class SharedProfiles extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<PreviewSceneProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SharedProfiles;
        static Load(InName: string): SharedProfiles;
    }
    
    class AssetViewerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<PreviewSceneProfile>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetViewerSettings;
        static Load(InName: string): AssetViewerSettings;
    }
    
    class PropertyEntry {
        constructor(Property: number, bUseCustomSize: boolean, CustomSize: IntPoint, bUseConstantValue: boolean, ConstantValue: number);
        Property: number;
        bUseCustomSize: boolean;
        CustomSize: IntPoint;
        bUseConstantValue: boolean;
        ConstantValue: number;
    }
    
    class MaterialOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Properties: TArray<PropertyEntry>;
        TextureSize: IntPoint;
        LODIndices: TArray<number>;
        bUseMeshData: boolean;
        bUseSpecificUVIndex: boolean;
        TextureCoordinateIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialOptions;
        static Load(InName: string): MaterialOptions;
    }
    
    class AssetBakeOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetBakeOptions;
        static Load(InName: string): AssetBakeOptions;
    }
    
    enum EMaterialBakeMethod { IndividualMaterial, AtlasMaterial, BinnedMaterial, EMaterialBakeMethod_MAX}
    class MaterialMergeOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Method: EMaterialBakeMethod;
        BlendMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialMergeOptions;
        static Load(InName: string): MaterialMergeOptions;
    }
    
    class MaterialInstanceConstant extends MaterialInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterStateId: Guid;
        K2_GetVectorParameterValue(ParameterName: string): LinearColor;
        K2_GetTextureParameterValue(ParameterName: string): Texture;
        K2_GetScalarParameterValue(ParameterName: string): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceConstant;
        static Load(InName: string): MaterialInstanceConstant;
    }
    
    class MaterialEditingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UpdateMaterialInstance(Instance: MaterialInstanceConstant): void;
        static UpdateMaterialFunction(MaterialFunction: MaterialFunctionInterface, PreviewMaterial: Material): void;
        static SetMaterialUsage(Material: Material, Usage: number, bNeedsRecompile: $Ref<boolean>): boolean;
        static SetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant, ParameterName: string, Value: LinearColor): boolean;
        static SetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant, ParameterName: string, Value: Texture): boolean;
        static SetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant, ParameterName: string, Value: number): boolean;
        static SetMaterialInstanceParent(Instance: MaterialInstanceConstant, NewParent: MaterialInterface): void;
        static RecompileMaterial(Material: Material): void;
        static LayoutMaterialFunctionExpressions(MaterialFunction: MaterialFunction): void;
        static LayoutMaterialExpressions(Material: Material): void;
        static HasMaterialUsage(Material: Material, Usage: number): boolean;
        GetVectorParameterSource(Material: MaterialInterface, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;
        static GetVectorParameterNames(Material: MaterialInterface, ParameterNames: $Ref<TArray<string>>): void;
        GetTextureParameterSource(Material: MaterialInterface, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;
        static GetTextureParameterNames(Material: MaterialInterface, ParameterNames: $Ref<TArray<string>>): void;
        GetStaticSwitchParameterSource(Material: MaterialInterface, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;
        static GetStaticSwitchParameterNames(Material: MaterialInterface, ParameterNames: $Ref<TArray<string>>): void;
        GetScalarParameterSource(Material: MaterialInterface, ParameterName: string, ParameterSource: $Ref<SoftObjectPath>): boolean;
        static GetScalarParameterNames(Material: MaterialInterface, ParameterNames: $Ref<TArray<string>>): void;
        static GetNumMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): number;
        static GetNumMaterialExpressions(Material: Material): number;
        static GetMaterialSelectedNodes(Material: Material): TSet<Object>;
        static GetMaterialInstanceVectorParameterValue(Instance: MaterialInstanceConstant, ParameterName: string): LinearColor;
        static GetMaterialInstanceTextureParameterValue(Instance: MaterialInstanceConstant, ParameterName: string): Texture;
        static GetMaterialInstanceStaticSwitchParameterValue(Instance: MaterialInstanceConstant, ParameterName: string): boolean;
        static GetMaterialInstanceScalarParameterValue(Instance: MaterialInstanceConstant, ParameterName: string): number;
        static GetMaterialDefaultVectorParameterValue(Material: Material, ParameterName: string): LinearColor;
        static GetMaterialDefaultTextureParameterValue(Material: Material, ParameterName: string): Texture;
        static GetMaterialDefaultStaticSwitchParameterValue(Material: Material, ParameterName: string): boolean;
        static GetMaterialDefaultScalarParameterValue(Material: Material, ParameterName: string): number;
        static GetChildInstances(Parent: MaterialInterface, ChildInstances: $Ref<TArray<AssetData>>): void;
        static DeleteMaterialExpressionInFunction(MaterialFunction: MaterialFunction, Expression: MaterialExpression): void;
        static DeleteMaterialExpression(Material: Material, Expression: MaterialExpression): void;
        static DeleteAllMaterialExpressionsInFunction(MaterialFunction: MaterialFunction): void;
        static DeleteAllMaterialExpressions(Material: Material): void;
        static CreateMaterialExpressionInFunction(MaterialFunction: MaterialFunction, ExpressionClass: Class, NodePosX: number, NodePosY: number): MaterialExpression;
        static CreateMaterialExpression(Material: Material, ExpressionClass: Class, NodePosX: number, NodePosY: number): MaterialExpression;
        static ConnectMaterialProperty(FromExpression: MaterialExpression, FromOutputName: string, Property: number): boolean;
        static ConnectMaterialExpressions(FromExpression: MaterialExpression, FromOutputName: string, ToExpression: MaterialExpression, ToInputName: string): boolean;
        static ClearAllMaterialInstanceParameters(Instance: MaterialInstanceConstant): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditingLibrary;
        static Load(InName: string): MaterialEditingLibrary;
    }
    
    class MaterialEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaliOfflineCompilerPath: FilePath;
        DefaultPreviewWidth: number;
        DefaultPreviewHeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorSettings;
        static Load(InName: string): MaterialEditorSettings;
    }
    
    class CurveEditorFilterBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorFilterBase;
        static Load(InName: string): CurveEditorFilterBase;
    }
    
    class CurveEditorBakeFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseSnapRateForInterval: boolean;
        BakeInterval: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorBakeFilter;
        static Load(InName: string): CurveEditorBakeFilter;
    }
    
    class CurveEditorEulerFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorEulerFilter;
        static Load(InName: string): CurveEditorEulerFilter;
    }
    
    class CurveEditorKeyProxy extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorKeyProxy;
        static Load(InName: string): CurveEditorKeyProxy;
    }
    
    class CurveEditorReduceFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Tolerance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorReduceFilter;
        static Load(InName: string): CurveEditorReduceFilter;
    }
    
    enum ECurveEditorTangentVisibility { AllTangents, SelectedKeys, NoTangents, ECurveEditorTangentVisibility_MAX}
    enum ECurveEditorZoomPosition { CurrentTime, MousePosition, ECurveEditorZoomPosition_MAX}
    class CurveEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoFrameCurveEditor: boolean;
        bShowCurveEditorCurveToolTips: boolean;
        TangentVisibility: ECurveEditorTangentVisibility;
        ZoomPosition: ECurveEditorZoomPosition;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorSettings;
        static Load(InName: string): CurveEditorSettings;
    }
    
    class RichCurveKeyProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: RichCurveKey;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichCurveKeyProxy;
        static Load(InName: string): RichCurveKeyProxy;
    }
    
    class CameraRig_Crane extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CranePitch: number;
        CraneYaw: number;
        CraneArmLength: number;
        bLockMountPitch: boolean;
        bLockMountYaw: boolean;
        TransformComponent: SceneComponent;
        CraneYawControl: SceneComponent;
        CranePitchControl: SceneComponent;
        CraneCameraMount: SceneComponent;
        PreviewMesh_CraneArm: StaticMeshComponent;
        PreviewMesh_CraneBase: StaticMeshComponent;
        PreviewMesh_CraneMount: StaticMeshComponent;
        PreviewMesh_CraneCounterWeight: StaticMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraRig_Crane;
        static Load(InName: string): CameraRig_Crane;
    }
    
    class CameraRig_Rail extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentPositionOnRail: number;
        bLockOrientationToRail: boolean;
        bShowRailVisualization: boolean;
        PreviewMeshScale: number;
        TransformComponent: SceneComponent;
        RailSplineComponent: SplineComponent;
        RailCameraMount: SceneComponent;
        PreviewMesh_Rail: SplineMeshComponent;
        PreviewRailMeshSegments: TArray<SplineMeshComponent>;
        PreviewRailStaticMesh: StaticMesh;
        PreviewMesh_Mount: StaticMeshComponent;
        GetRailSplineComponent(): SplineComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraRig_Rail;
        static Load(InName: string): CameraRig_Rail;
    }
    
    class CameraLookatTrackingSettings {
        constructor(bEnableLookAtTracking: boolean, bDrawDebugLookAtTrackingPosition: boolean, LookAtTrackingInterpSpeed: number, ActorToTrack: TSoftObjectPtr<Actor>, RelativeOffset: Vector, bAllowRoll: boolean);
        bEnableLookAtTracking: boolean;
        bDrawDebugLookAtTrackingPosition: boolean;
        LookAtTrackingInterpSpeed: number;
        ActorToTrack: TSoftObjectPtr<Actor>;
        RelativeOffset: Vector;
        bAllowRoll: boolean;
    }
    
    class CameraFilmbackSettings {
        constructor(SensorWidth: number, SensorHeight: number, SensorAspectRatio: number);
        SensorWidth: number;
        SensorHeight: number;
        SensorAspectRatio: number;
    }
    
    class CameraLensSettings {
        constructor(MinFocalLength: number, MaxFocalLength: number, MinFStop: number, MaxFStop: number, MinimumFocusDistance: number, DiaphragmBladeCount: number);
        MinFocalLength: number;
        MaxFocalLength: number;
        MinFStop: number;
        MaxFStop: number;
        MinimumFocusDistance: number;
        DiaphragmBladeCount: number;
    }
    
    enum ECameraFocusMethod { None, Manual, Tracking, ECameraFocusMethod_MAX}
    class CameraTrackingFocusSettings {
        constructor(ActorToTrack: TSoftObjectPtr<Actor>, RelativeOffset: Vector, bDrawDebugTrackingFocusPoint: boolean);
        ActorToTrack: TSoftObjectPtr<Actor>;
        RelativeOffset: Vector;
        bDrawDebugTrackingFocusPoint: boolean;
    }
    
    class CameraFocusSettings {
        constructor(FocusMethod: ECameraFocusMethod, ManualFocusDistance: number, TrackingFocusSettings: CameraTrackingFocusSettings, bDrawDebugFocusPlane: boolean, DebugFocusPlaneColor: Color, bSmoothFocusChanges: boolean, FocusSmoothingInterpSpeed: number, FocusOffset: number);
        FocusMethod: ECameraFocusMethod;
        ManualFocusDistance: number;
        TrackingFocusSettings: CameraTrackingFocusSettings;
        bDrawDebugFocusPlane: boolean;
        DebugFocusPlaneColor: Color;
        bSmoothFocusChanges: boolean;
        FocusSmoothingInterpSpeed: number;
        FocusOffset: number;
    }
    
    class NamedFilmbackPreset {
        constructor(Name: string, FilmbackSettings: CameraFilmbackSettings);
        Name: string;
        FilmbackSettings: CameraFilmbackSettings;
    }
    
    class NamedLensPreset {
        constructor(Name: string, LensSettings: CameraLensSettings);
        Name: string;
        LensSettings: CameraLensSettings;
    }
    
    class CineCameraComponent extends CameraComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FilmbackSettings: CameraFilmbackSettings;
        Filmback: CameraFilmbackSettings;
        LensSettings: CameraLensSettings;
        FocusSettings: CameraFocusSettings;
        CurrentFocalLength: number;
        CurrentAperture: number;
        CurrentFocusDistance: number;
        CurrentHorizontalFOV: number;
        FocusPlaneVisualizationMesh: StaticMesh;
        FocusPlaneVisualizationMaterial: Material;
        DebugFocusPlaneComponent: StaticMeshComponent;
        DebugFocusPlaneMID: MaterialInstanceDynamic;
        FilmbackPresets: TArray<NamedFilmbackPreset>;
        LensPresets: TArray<NamedLensPreset>;
        DefaultFilmbackPresetName: string;
        DefaultFilmbackPreset: string;
        DefaultLensPresetName: string;
        DefaultLensFocalLength: number;
        DefaultLensFStop: number;
        SetLensPresetByName(InPresetName: string): void;
        SetFilmbackPresetByName(InPresetName: string): void;
        SetCurrentFocalLength(InFocalLength: number): void;
        GetVerticalFieldOfView(): number;
        static GetLensPresetsCopy(): TArray<NamedLensPreset>;
        GetLensPresetName(): string;
        GetHorizontalFieldOfView(): number;
        GetFilmbackPresetName(): string;
        GetDefaultFilmbackPresetName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CineCameraComponent;
        static Load(InName: string): CineCameraComponent;
    }
    
    class CineCameraActor extends CameraActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookatTrackingSettings: CameraLookatTrackingSettings;
        GetCineCameraComponent(): CineCameraComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CineCameraActor;
        static Load(InName: string): CineCameraActor;
    }
    
    class Subsystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Subsystem;
        static Load(InName: string): Subsystem;
    }
    
    class DynamicSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicSubsystem;
        static Load(InName: string): DynamicSubsystem;
    }
    
    class EditorSubsystem extends DynamicSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSubsystem;
        static Load(InName: string): EditorSubsystem;
    }
    
    class AudioGenerator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioGenerator;
        static Load(InName: string): AudioGenerator;
    }
    
    enum EFFTSize { DefaultSize, Min, Small, Medium, Large, Max, EFFTSize_MAX}
    enum EFFTPeakInterpolationMethod { NearestNeighbor, Linear, Quadratic, EFFTPeakInterpolationMethod_MAX}
    enum EFFTWindowType { None, Hamming, Hann, Blackman, EFFTWindowType_MAX}
    class AudioMixerBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TrimAudioCache(InMegabytesToFree: number): number;
        static StopRecordingOutput(WorldContextObject: Object, ExportType: EAudioRecordingExportType, Name: string, Path: string, SubmixToRecord: SoundSubmix, ExistingSoundWaveToOverwrite: SoundWave): SoundWave;
        static StopAnalyzingOutput(WorldContextObject: Object, SubmixToStopAnalyzing: SoundSubmix): void;
        static StartRecordingOutput(WorldContextObject: Object, ExpectedDuration: number, SubmixToRecord: SoundSubmix): void;
        static StartAnalyzingOutput(WorldContextObject: Object, SubmixToAnalyze: SoundSubmix, FFTSize: EFFTSize, InterpolationMethod: EFFTPeakInterpolationMethod, WindowType: EFFTWindowType, HopSize: number): void;
        static SetBypassSourceEffectChainEntry(WorldContextObject: Object, PresetChain: SoundEffectSourcePresetChain, EntryIndex: number, bBypassed: boolean): void;
        static ResumeRecordingOutput(WorldContextObject: Object, SubmixToPause: SoundSubmix): void;
        static RemoveSourceEffectFromPresetChain(WorldContextObject: Object, PresetChain: SoundEffectSourcePresetChain, EntryIndex: number): void;
        static RemoveMasterSubmixEffect(WorldContextObject: Object, SubmixEffectPreset: SoundEffectSubmixPreset): void;
        static PrimeSoundForPlayback(SoundWave: SoundWave, OnLoadCompletion: $Delegate<(LoadedSoundWave: SoundWave, WasCancelled: boolean) => void>): void;
        static PrimeSoundCueForPlayback(SoundCue: SoundCue): void;
        static PauseRecordingOutput(WorldContextObject: Object, SubmixToPause: SoundSubmix): void;
        static GetPhaseForFrequencies(WorldContextObject: Object, Frequencies: TArray<number>, Phases: $Ref<TArray<number>>, SubmixToAnalyze: SoundSubmix): void;
        static GetNumberOfEntriesInSourceEffectChain(WorldContextObject: Object, PresetChain: SoundEffectSourcePresetChain): number;
        static GetMagnitudeForFrequencies(WorldContextObject: Object, Frequencies: TArray<number>, Magnitudes: $Ref<TArray<number>>, SubmixToAnalyze: SoundSubmix): void;
        static ClearMasterSubmixEffects(WorldContextObject: Object): void;
        static AddSourceEffectToPresetChain(WorldContextObject: Object, PresetChain: SoundEffectSourcePresetChain, Entry: SourceEffectChainEntry): void;
        static AddMasterSubmixEffect(WorldContextObject: Object, SubmixEffectPreset: SoundEffectSubmixPreset): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioMixerBlueprintLibrary;
        static Load(InName: string): AudioMixerBlueprintLibrary;
    }
    
    enum ESubmixEffectDynamicsProcessorType { Compressor, Limiter, Expander, Gate, Count, ESubmixEffectDynamicsProcessorType_MAX}
    enum ESubmixEffectDynamicsPeakMode { MeanSquared, RootMeanSquared, Peak, Count, ESubmixEffectDynamicsPeakMode_MAX}
    class SubmixEffectDynamicsProcessorSettings {
        constructor(DynamicsProcessorType: ESubmixEffectDynamicsProcessorType, PeakMode: ESubmixEffectDynamicsPeakMode, LookAheadMsec: number, AttackTimeMsec: number, ReleaseTimeMsec: number, ThresholdDb: number, Ratio: number, KneeBandwidthDb: number, InputGainDb: number, OutputGainDb: number, bChannelLinked: boolean, bAnalogMode: boolean);
        DynamicsProcessorType: ESubmixEffectDynamicsProcessorType;
        PeakMode: ESubmixEffectDynamicsPeakMode;
        LookAheadMsec: number;
        AttackTimeMsec: number;
        ReleaseTimeMsec: number;
        ThresholdDb: number;
        Ratio: number;
        KneeBandwidthDb: number;
        InputGainDb: number;
        OutputGainDb: number;
        bChannelLinked: boolean;
        bAnalogMode: boolean;
    }
    
    class SubmixEffectDynamicsProcessorPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: SubmixEffectDynamicsProcessorSettings;
        SetSettings(InSettings: SubmixEffectDynamicsProcessorSettings): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectDynamicsProcessorPreset;
        static Load(InName: string): SubmixEffectDynamicsProcessorPreset;
    }
    
    class SubmixEffectEQBand {
        constructor(Frequency: number, Bandwidth: number, GainDb: number, bEnabled: boolean);
        Frequency: number;
        Bandwidth: number;
        GainDb: number;
        bEnabled: boolean;
    }
    
    class SubmixEffectSubmixEQSettings {
        constructor(EQBands: TArray<SubmixEffectEQBand>);
        EQBands: TArray<SubmixEffectEQBand>;
    }
    
    class SubmixEffectSubmixEQPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: SubmixEffectSubmixEQSettings;
        SetSettings(InSettings: SubmixEffectSubmixEQSettings): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectSubmixEQPreset;
        static Load(InName: string): SubmixEffectSubmixEQPreset;
    }
    
    class SubmixEffectReverbSettings {
        constructor(Density: number, Diffusion: number, Gain: number, GainHF: number, DecayTime: number, DecayHFRatio: number, ReflectionsGain: number, ReflectionsDelay: number, LateGain: number, LateDelay: number, AirAbsorptionGainHF: number, WetLevel: number, DryLevel: number);
        Density: number;
        Diffusion: number;
        Gain: number;
        GainHF: number;
        DecayTime: number;
        DecayHFRatio: number;
        ReflectionsGain: number;
        ReflectionsDelay: number;
        LateGain: number;
        LateDelay: number;
        AirAbsorptionGainHF: number;
        WetLevel: number;
        DryLevel: number;
    }
    
    class SubmixEffectReverbPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: SubmixEffectReverbSettings;
        SetSettingsWithReverbEffect(InReverbEffect: ReverbEffect, WetLevel: number, DryLevel: number): void;
        SetSettings(InSettings: SubmixEffectReverbSettings): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectReverbPreset;
        static Load(InName: string): SubmixEffectReverbPreset;
    }
    
    class SubmixEffectReverbFastSettings {
        constructor(Density: number, Diffusion: number, Gain: number, GainHF: number, DecayTime: number, DecayHFRatio: number, ReflectionsGain: number, ReflectionsDelay: number, LateGain: number, LateDelay: number, AirAbsorptionGainHF: number, WetLevel: number, DryLevel: number);
        Density: number;
        Diffusion: number;
        Gain: number;
        GainHF: number;
        DecayTime: number;
        DecayHFRatio: number;
        ReflectionsGain: number;
        ReflectionsDelay: number;
        LateGain: number;
        LateDelay: number;
        AirAbsorptionGainHF: number;
        WetLevel: number;
        DryLevel: number;
    }
    
    class SubmixEffectReverbFastPreset extends SoundEffectSubmixPreset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: SubmixEffectReverbFastSettings;
        SetSettingsWithReverbEffect(InReverbEffect: ReverbEffect, WetLevel: number, DryLevel: number): void;
        SetSettings(InSettings: SubmixEffectReverbFastSettings): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubmixEffectReverbFastPreset;
        static Load(InName: string): SubmixEffectReverbFastPreset;
    }
    
    class SoundWaveProcedural extends SoundWave {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundWaveProcedural;
        static Load(InName: string): SoundWaveProcedural;
    }
    
    class AudioComponentParam {
        constructor(ParamName: string, FloatParam: number, BoolParam: boolean, IntParam: number, SoundWaveParam: SoundWave);
        ParamName: string;
        FloatParam: number;
        BoolParam: boolean;
        IntParam: number;
        SoundWaveParam: SoundWave;
    }
    
    enum EAudioComponentPlayState { Playing, Stopped, Paused, FadingIn, FadingOut, Count, EAudioComponentPlayState_MAX}
    class SoundWaveSpectralData {
        constructor(FrequencyHz: number, Magnitude: number, NormalizedMagnitude: number);
        FrequencyHz: number;
        Magnitude: number;
        NormalizedMagnitude: number;
    }
    
    class SoundWaveSpectralDataPerSound {
        constructor(SpectralData: TArray<SoundWaveSpectralData>, PlaybackTime: number, SoundWave: SoundWave);
        SpectralData: TArray<SoundWaveSpectralData>;
        PlaybackTime: number;
        SoundWave: SoundWave;
    }
    
    class SoundWaveEnvelopeDataPerSound {
        constructor(Envelope: number, PlaybackTime: number, SoundWave: SoundWave);
        Envelope: number;
        PlaybackTime: number;
        SoundWave: SoundWave;
    }
    
    enum EAudioFaderCurve { Linear, Logarithmic, SCurve, Sin, Count, EAudioFaderCurve_MAX}
    class AudioComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sound: SoundBase;
        InstanceParameters: TArray<AudioComponentParam>;
        SoundClassOverride: SoundClass;
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bShouldRemainActiveIfDropped: boolean;
        bAllowSpatialization: boolean;
        bOverrideAttenuation: boolean;
        bOverrideSubtitlePriority: boolean;
        bIsUISound: boolean;
        bEnableLowPassFilter: boolean;
        bOverridePriority: boolean;
        bSuppressSubtitles: boolean;
        bAutoManageAttachment: boolean;
        AudioComponentUserID: string;
        PitchModulationMin: number;
        PitchModulationMax: number;
        VolumeModulationMin: number;
        VolumeModulationMax: number;
        VolumeMultiplier: number;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        Priority: number;
        SubtitlePriority: number;
        SourceEffectChain: SoundEffectSourcePresetChain;
        VolumeWeightedPriorityScale: number;
        HighFrequencyGainMultiplier: number;
        PitchMultiplier: number;
        LowPassFilterFrequency: number;
        AttenuationSettings: SoundAttenuation;
        AttenuationOverrides: SoundAttenuationSettings;
        ConcurrencySettings: SoundConcurrency;
        ConcurrencySet: TSet<SoundConcurrency>;
        AutoAttachLocationRule: EAttachmentRule;
        AutoAttachRotationRule: EAttachmentRule;
        AutoAttachScaleRule: EAttachmentRule;
        OnAudioFinished: $MulticastDelegate<() => void>;
        OnAudioPlaybackPercent: $MulticastDelegate<(PlayingSoundWave: SoundWave, PlaybackPercent: number) => void>;
        OnAudioSingleEnvelopeValue: $MulticastDelegate<(PlayingSoundWave: SoundWave, EnvelopeValue: number) => void>;
        OnAudioMultiEnvelopeValue: $MulticastDelegate<(AverageEnvelopeValue: number, MaxEnvelope: number, NumWaveInstances: number) => void>;
        Modulation: SoundModulation;
        OnQueueSubtitles: $Delegate<(Subtitles: TArray<SubtitleCue>, CueDuration: number) => void>;
        AutoAttachParent: TWeakObjectPtr<SceneComponent>;
        AutoAttachSocketName: string;
        StopDelayed(DelayTime: number): void;
        Stop(): void;
        SetWaveParameter(InName: string, InWave: SoundWave): void;
        SetVolumeMultiplier(NewVolumeMultiplier: number): void;
        SetUISound(bInUISound: boolean): void;
        SetSubmixSend(Submix: SoundSubmix, SendLevel: number): void;
        SetSourceBusSendPreEffect(SoundSourceBus: SoundSourceBus, SourceBusSendLevel: number): void;
        SetSourceBusSendPostEffect(SoundSourceBus: SoundSourceBus, SourceBusSendLevel: number): void;
        SetSound(NewSound: SoundBase): void;
        SetPitchMultiplier(NewPitchMultiplier: number): void;
        SetPaused(bPause: boolean): void;
        SetLowPassFilterFrequency(InLowPassFilterFrequency: number): void;
        SetLowPassFilterEnabled(InLowPassFilterEnabled: boolean): void;
        SetIntParameter(InName: string, InInt: number): void;
        SetFloatParameter(InName: string, InFloat: number): void;
        SetBoolParameter(InName: string, InBool: boolean): void;
        Play(StartTime: number): void;
        IsPlaying(): boolean;
        HasCookedFFTData(): boolean;
        HasCookedAmplitudeEnvelopeData(): boolean;
        GetPlayState(): EAudioComponentPlayState;
        GetCookedFFTDataForAllPlayingSounds(OutSoundWaveSpectralData: $Ref<TArray<SoundWaveSpectralDataPerSound>>): boolean;
        GetCookedFFTData(FrequenciesToGet: TArray<number>, OutSoundWaveSpectralData: $Ref<TArray<SoundWaveSpectralData>>): boolean;
        GetCookedEnvelopeDataForAllPlayingSounds(OutEnvelopeData: $Ref<TArray<SoundWaveEnvelopeDataPerSound>>): boolean;
        GetCookedEnvelopeData(OutEnvelopeData: $Ref<number>): boolean;
        FadeOut(FadeOutDuration: number, FadeVolumeLevel: number, FadeCurve: EAudioFaderCurve): void;
        FadeIn(FadeInDuration: number, FadeVolumeLevel: number, StartTime: number, FadeCurve: EAudioFaderCurve): void;
        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<SoundAttenuationSettings>): boolean;
        AdjustVolume(AdjustVolumeDuration: number, AdjustVolumeLevel: number, FadeCurve: EAudioFaderCurve): void;
        AdjustAttenuation(InAttenuationSettings: SoundAttenuationSettings): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioComponent;
        static Load(InName: string): AudioComponent;
    }
    
    class SynthComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bAllowSpatialization: boolean;
        bOverrideAttenuation: boolean;
        bOutputToBusOnly: boolean;
        AttenuationSettings: SoundAttenuation;
        AttenuationOverrides: SoundAttenuationSettings;
        ConcurrencySettings: SoundConcurrency;
        ConcurrencySet: TSet<SoundConcurrency>;
        SoundClass: SoundClass;
        SourceEffectChain: SoundEffectSourcePresetChain;
        SoundSubmix: SoundSubmix;
        SoundSubmixSends: TArray<SoundSubmixSendInfo>;
        BusSends: TArray<SoundSourceBusSendInfo>;
        Modulation: SoundModulation;
        PreEffectBusSends: TArray<SoundSourceBusSendInfo>;
        bIsUISound: boolean;
        bIsPreviewSound: boolean;
        EnvelopeFollowerAttackTime: number;
        EnvelopeFollowerReleaseTime: number;
        OnAudioEnvelopeValue: $MulticastDelegate<(EnvelopeValue: number) => void>;
        Synth: SynthSound;
        AudioComponent: AudioComponent;
        Stop(): void;
        Start(): void;
        SetVolumeMultiplier(VolumeMultiplier: number): void;
        SetSubmixSend(Submix: SoundSubmix, SendLevel: number): void;
        IsPlaying(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SynthComponent;
        static Load(InName: string): SynthComponent;
    }
    
    class SynthSound extends SoundWaveProcedural {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningSynthComponent: SynthComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SynthSound;
        static Load(InName: string): SynthSound;
    }
    
    class HardwareTargetingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetedHardwareClass: number;
        AppliedTargetedHardwareClass: number;
        DefaultGraphicsPerformance: number;
        AppliedDefaultGraphicsPerformance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HardwareTargetingSettings;
        static Load(InName: string): HardwareTargetingSettings;
    }
    
    class ClassViewerProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InternalOnlyPaths: TArray<DirectoryPath>;
        InternalOnlyClasses: TArray<SoftClassPath>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassViewerProjectSettings;
        static Load(InName: string): ClassViewerProjectSettings;
    }
    
    class LocalizedTemplateString {
        constructor(Language: string, Text: string);
        Language: string;
        Text: string;
    }
    
    class TemplateFolderRename {
        constructor(From: string, To: string);
        From: string;
        To: string;
    }
    
    class TemplateReplacement {
        constructor(Extensions: TArray<string>, From: string, To: string, bCaseSensitive: boolean);
        Extensions: TArray<string>;
        From: string;
        To: string;
        bCaseSensitive: boolean;
    }
    
    enum ETemplateSetting { Languages, HardwareTarget, GraphicsPreset, StarterContent, XR, Raytracing, All, ETemplateSetting_MAX}
    enum EFeaturePackDetailLevel { Standard, High, EFeaturePackDetailLevel_MAX}
    class FeaturePackLevelSet {
        constructor(DetailLevels: TArray<EFeaturePackDetailLevel>, MountName: string);
        DetailLevels: TArray<EFeaturePackDetailLevel>;
        MountName: string;
    }
    
    class TemplateProjectDefs extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalizedDisplayNames: TArray<LocalizedTemplateString>;
        LocalizedDescriptions: TArray<LocalizedTemplateString>;
        FoldersToIgnore: TArray<string>;
        FilesToIgnore: TArray<string>;
        FolderRenames: TArray<TemplateFolderRename>;
        FilenameReplacements: TArray<TemplateReplacement>;
        ReplacementsInFiles: TArray<TemplateReplacement>;
        SortKey: string;
        Categories: TArray<string>;
        ClassTypes: string;
        AssetTypes: string;
        bAllowProjectCreation: boolean;
        bIsEnterprise: boolean;
        bIsBlank: boolean;
        HiddenSettings: TArray<ETemplateSetting>;
        PacksToInclude: TArray<string>;
        EditDetailLevelPreference: EFeaturePackDetailLevel;
        SharedContentPacks: TArray<FeaturePackLevelSet>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateProjectDefs;
        static Load(InName: string): TemplateProjectDefs;
    }
    
    class DefaultTemplateProjectDefs extends TemplateProjectDefs {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultTemplateProjectDefs;
        static Load(InName: string): DefaultTemplateProjectDefs;
    }
    
    class TemplateCategoryDef {
        constructor(Key: string, LocalizedDisplayNames: TArray<LocalizedTemplateString>, LocalizedDescriptions: TArray<LocalizedTemplateString>, Icon: string, IsMajorCategory: boolean);
        Key: string;
        LocalizedDisplayNames: TArray<LocalizedTemplateString>;
        LocalizedDescriptions: TArray<LocalizedTemplateString>;
        Icon: string;
        IsMajorCategory: boolean;
    }
    
    class TemplateCategories extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Categories: TArray<TemplateCategoryDef>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateCategories;
        static Load(InName: string): TemplateCategories;
    }
    
    class SourceControlState {
        constructor(Filename: string, bIsValid: boolean, bIsUnknown: boolean, bCanCheckIn: boolean, bCanCheckOut: boolean, bIsCheckedOut: boolean, bIsCurrent: boolean, bIsSourceControlled: boolean, bIsAdded: boolean, bIsDeleted: boolean, bIsIgnored: boolean, bCanEdit: boolean, bCanDelete: boolean, bIsModified: boolean, bCanAdd: boolean, bIsConflicted: boolean, bCanRevert: boolean, bIsCheckedOutOther: boolean, CheckedOutOther: string);
        Filename: string;
        bIsValid: boolean;
        bIsUnknown: boolean;
        bCanCheckIn: boolean;
        bCanCheckOut: boolean;
        bIsCheckedOut: boolean;
        bIsCurrent: boolean;
        bIsSourceControlled: boolean;
        bIsAdded: boolean;
        bIsDeleted: boolean;
        bIsIgnored: boolean;
        bCanEdit: boolean;
        bCanDelete: boolean;
        bIsModified: boolean;
        bCanAdd: boolean;
        bIsConflicted: boolean;
        bCanRevert: boolean;
        bIsCheckedOutOther: boolean;
        CheckedOutOther: string;
    }
    
    class SourceControlHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RevertUnchangedFiles(InFiles: TArray<string>, bSilent: boolean): boolean;
        static RevertUnchangedFile(InFile: string, bSilent: boolean): boolean;
        static RevertFiles(InFiles: TArray<string>, bSilent: boolean): boolean;
        static RevertFile(InFile: string, bSilent: boolean): boolean;
        static QueryFileState(InFile: string, bSilent: boolean): SourceControlState;
        static MarkFilesForAdd(InFiles: TArray<string>, bSilent: boolean): boolean;
        static MarkFileForDelete(InFile: string, bSilent: boolean): boolean;
        static MarkFileForAdd(InFile: string, bSilent: boolean): boolean;
        static LastErrorMsg(): string;
        static IsEnabled(): boolean;
        static IsAvailable(): boolean;
        static CurrentProvider(): string;
        static CopyFile(InSourceFile: string, InDestFile: string, bSilent: boolean): boolean;
        static CheckOutOrAddFile(InFile: string, bSilent: boolean): boolean;
        static CheckOutFiles(InFiles: TArray<string>, bSilent: boolean): boolean;
        static CheckOutFile(InFile: string, bSilent: boolean): boolean;
        static CheckInFiles(InFiles: TArray<string>, InDescription: string, bSilent: boolean): boolean;
        static CheckInFile(InFile: string, InDescription: string, bSilent: boolean): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SourceControlHelpers;
        static Load(InName: string): SourceControlHelpers;
    }
    
    enum EditConditionTestEnum { First, Second, EditConditionTestEnum_MAX}
    class EditConditionTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolProperty: boolean;
        EnumProperty: EditConditionTestEnum;
        ByteEnumProperty: number;
        DoubleProperty: number;
        IntegerProperty: number;
        UintBitfieldProperty: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditConditionTestObject;
        static Load(InName: string): EditConditionTestObject;
    }
    
    class BlueprintCompilerExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintCompilerExtension;
        static Load(InName: string): BlueprintCompilerExtension;
    }
    
    class FavoritedBlueprintPaletteItem {
        constructor();
    }
    
    class BlueprintPaletteFavorites extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomFavorites: TArray<string>;
        CurrentFavorites: TArray<FavoritedBlueprintPaletteItem>;
        CurrentProfile: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintPaletteFavorites;
        static Load(InName: string): BlueprintPaletteFavorites;
    }
    
    class K2Node_BaseAsyncTask extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProxyFactoryFunctionName: string;
        ProxyFactoryClass: Class;
        ProxyClass: Class;
        ProxyActivateFunctionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BaseAsyncTask;
        static Load(InName: string): K2Node_BaseAsyncTask;
    }
    
    class K2Node_AsyncAction extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AsyncAction;
        static Load(InName: string): K2Node_AsyncAction;
    }
    
    class SSCSEditorMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SSCSEditorMenuContext;
        static Load(InName: string): SSCSEditorMenuContext;
    }
    
    class BlueprintNodeSpawner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintNodeSpawner;
        static Load(InName: string): BlueprintNodeSpawner;
    }
    
    class BlueprintEventNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventFunc: Function;
        CustomEventName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEventNodeSpawner;
        static Load(InName: string): BlueprintEventNodeSpawner;
    }
    
    class BlueprintBoundEventNodeSpawner extends BlueprintEventNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventDelegate: MulticastDelegateProperty;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintBoundEventNodeSpawner;
        static Load(InName: string): BlueprintBoundEventNodeSpawner;
    }
    
    class BlueprintBoundNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintBoundNodeSpawner;
        static Load(InName: string): BlueprintBoundNodeSpawner;
    }
    
    class BlueprintComponentNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentClass: Class;
        ComponentName: string;
        ComponentAssetName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintComponentNodeSpawner;
        static Load(InName: string): BlueprintComponentNodeSpawner;
    }
    
    class BlueprintFieldNodeSpawner extends BlueprintNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Field: Field;
        OwnerClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFieldNodeSpawner;
        static Load(InName: string): BlueprintFieldNodeSpawner;
    }
    
    class BlueprintDelegateNodeSpawner extends BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintDelegateNodeSpawner;
        static Load(InName: string): BlueprintDelegateNodeSpawner;
    }
    
    class BlueprintEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDrawMidpointArrowsInBlueprints: boolean;
        bShowGraphInstructionText: boolean;
        bSplitContextTargetSettings: boolean;
        bExposeAllMemberComponentFunctions: boolean;
        bShowContextualFavorites: boolean;
        bExposeDeprecatedFunctions: boolean;
        bCompactCallOnMemberNodes: boolean;
        bFlattenFavoritesMenus: boolean;
        bFavorPureCastNodes: boolean;
        bAutoCastObjectConnections: boolean;
        bShowViewportOnSimulate: boolean;
        bShowInheritedVariables: boolean;
        bAlwaysShowInterfacesInOverrides: boolean;
        bShowParentClassInOverrides: boolean;
        bShowEmptySections: boolean;
        bSpawnDefaultBlueprintNodes: boolean;
        bHideConstructionScriptComponentsInDetailsView: boolean;
        bHostFindInBlueprintsInGlobalTab: boolean;
        bNavigateToNativeFunctionsFromCallNodes: boolean;
        Bookmarks: TMap<Guid, EditedDocumentInfo>;
        BookmarkNodes: TArray<BPEditorBookmarkNode>;
        bIncludeCommentNodesInBookmarksTab: boolean;
        bShowBookmarksForCurrentDocumentOnlyInTab: boolean;
        GraphEditorQuickJumps: TMap<number, EditedDocumentInfo>;
        SaveOnCompile: number;
        bJumpToNodeErrors: boolean;
        bAllowExplicitImpureNodeDisabling: boolean;
        bShowActionMenuItemSignatures: boolean;
        bBlueprintNodeUniqueNames: boolean;
        bShowDetailedCompileResults: boolean;
        CompileEventDisplayThresholdMs: number;
        NodeTemplateCacheCapMB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEditorSettings;
        static Load(InName: string): BlueprintEditorSettings;
    }
    
    class BlueprintFunctionNodeSpawner extends BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionNodeSpawner;
        static Load(InName: string): BlueprintFunctionNodeSpawner;
    }
    
    class BlueprintVariableNodeSpawner extends BlueprintFieldNodeSpawner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalVarOuter: EdGraph;
        LocalVarDesc: BPVariableDescription;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintVariableNodeSpawner;
        static Load(InName: string): BlueprintVariableNodeSpawner;
    }
    
    class EdGraphSchema extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema;
        static Load(InName: string): EdGraphSchema;
    }
    
    class BlueprintCallableFunctionRedirect {
        constructor(ClassName: string, OldFunctionName: string, NewFunctionName: string, BlueprintParamName: string, ClassParamName: string);
        ClassName: string;
        OldFunctionName: string;
        NewFunctionName: string;
        BlueprintParamName: string;
        ClassParamName: string;
    }
    
    class EdGraphSchema_K2 extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditoronlyBPFunctionRedirects: TArray<BlueprintCallableFunctionRedirect>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_K2;
        static Load(InName: string): EdGraphSchema_K2;
    }
    
    class K2Node_EditablePinBase extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsEditable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EditablePinBase;
        static Load(InName: string): K2Node_EditablePinBase;
    }
    
    class MemberReference {
        constructor(MemberParent: Object, MemberScope: string, MemberName: string, MemberGuid: Guid, bSelfContext: boolean, bWasDeprecated: boolean);
        MemberParent: Object;
        MemberScope: string;
        MemberName: string;
        MemberGuid: Guid;
        bSelfContext: boolean;
        bWasDeprecated: boolean;
    }
    
    class K2Node_Event extends K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventSignatureName: string;
        EventSignatureClass: Class;
        EventReference: MemberReference;
        bOverrideFunction: boolean;
        bInternalEvent: boolean;
        CustomFunctionName: string;
        FunctionFlags: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Event;
        static Load(InName: string): K2Node_Event;
    }
    
    class K2Node_ActorBoundEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegatePropertyName: string;
        DelegateOwnerClass: Class;
        EventOwner: Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ActorBoundEvent;
        static Load(InName: string): K2Node_ActorBoundEvent;
    }
    
    class K2Node_CallFunction extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsPureFunc: boolean;
        bIsConstFunc: boolean;
        bWantsEnumToExecExpansion: boolean;
        bIsInterfaceCall: boolean;
        bIsFinalFunction: boolean;
        bIsBeadFunction: boolean;
        FunctionReference: MemberReference;
        CallFunctionName: string;
        CallFunctionClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallFunction;
        static Load(InName: string): K2Node_CallFunction;
    }
    
    class K2Node_AddComponent extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHasExposedVariable: boolean;
        TemplateBlueprint: string;
        TemplateType: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AddComponent;
        static Load(InName: string): K2Node_AddComponent;
    }
    
    class K2Node_BaseMCDelegate extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegateReference: MemberReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BaseMCDelegate;
        static Load(InName: string): K2Node_BaseMCDelegate;
    }
    
    class K2Node_AddDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AddDelegate;
        static Load(InName: string): K2Node_AddDelegate;
    }
    
    class K2Node_AddPinInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AddPinInterface;
        static Load(InName: string): K2Node_AddPinInterface;
    }
    
    class K2Node_AssignDelegate extends K2Node_AddDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AssignDelegate;
        static Load(InName: string): K2Node_AssignDelegate;
    }
    
    class K2Node_AssignmentStatement extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AssignmentStatement;
        static Load(InName: string): K2Node_AssignmentStatement;
    }
    
    class K2Node_BitmaskLiteral extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BitflagsEnum: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BitmaskLiteral;
        static Load(InName: string): K2Node_BitmaskLiteral;
    }
    
    class K2Node_Variable extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VariableReference: MemberReference;
        SelfContextInfo: number;
        VariableSourceClass: Class;
        VariableName: string;
        bSelfContext: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Variable;
        static Load(InName: string): K2Node_Variable;
    }
    
    class K2Node_StructOperation extends K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StructType: ScriptStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_StructOperation;
        static Load(InName: string): K2Node_StructOperation;
    }
    
    class OptionalPinFromProperty {
        constructor(PropertyName: string, PropertyFriendlyName: string, PropertyTooltip: string, CategoryName: string, bShowPin: boolean, bCanToggleVisibility: boolean, bPropertyIsCustomized: boolean, bHasOverridePin: boolean, bIsMarkedForAdvancedDisplay: boolean, bIsOverrideEnabled: boolean, bIsSetValuePinVisible: boolean, bIsOverridePinVisible: boolean);
        PropertyName: string;
        PropertyFriendlyName: string;
        PropertyTooltip: string;
        CategoryName: string;
        bShowPin: boolean;
        bCanToggleVisibility: boolean;
        bPropertyIsCustomized: boolean;
        bHasOverridePin: boolean;
        bIsMarkedForAdvancedDisplay: boolean;
        bIsOverrideEnabled: boolean;
        bIsSetValuePinVisible: boolean;
        bIsOverridePinVisible: boolean;
    }
    
    class K2Node_StructMemberGet extends K2Node_StructOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShowPinForProperties: TArray<OptionalPinFromProperty>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_StructMemberGet;
        static Load(InName: string): K2Node_StructMemberGet;
    }
    
    class K2Node_BreakStruct extends K2Node_StructMemberGet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMadeAfterOverridePinRemoval: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_BreakStruct;
        static Load(InName: string): K2Node_BreakStruct;
    }
    
    class K2Node_CallArrayFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallArrayFunction;
        static Load(InName: string): K2Node_CallArrayFunction;
    }
    
    class K2Node_CallDataTableFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallDataTableFunction;
        static Load(InName: string): K2Node_CallDataTableFunction;
    }
    
    class K2Node_CallDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallDelegate;
        static Load(InName: string): K2Node_CallDelegate;
    }
    
    class K2Node_CallFunctionOnMember extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MemberVariableToCallOn: MemberReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallFunctionOnMember;
        static Load(InName: string): K2Node_CallFunctionOnMember;
    }
    
    class K2Node_CallMaterialParameterCollectionFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallMaterialParameterCollectionFunction;
        static Load(InName: string): K2Node_CallMaterialParameterCollectionFunction;
    }
    
    class K2Node_CallParentFunction extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CallParentFunction;
        static Load(InName: string): K2Node_CallParentFunction;
    }
    
    class K2Node_CastByteToEnum extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        bSafe: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CastByteToEnum;
        static Load(InName: string): K2Node_CastByteToEnum;
    }
    
    class K2Node_DynamicCast extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetType: Class;
        bIsPureCast: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DynamicCast;
        static Load(InName: string): K2Node_DynamicCast;
    }
    
    class K2Node_ClassDynamicCast extends K2Node_DynamicCast {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ClassDynamicCast;
        static Load(InName: string): K2Node_ClassDynamicCast;
    }
    
    class K2Node_ClearDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ClearDelegate;
        static Load(InName: string): K2Node_ClearDelegate;
    }
    
    class K2Node_CommutativeAssociativeBinaryOperator extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumAdditionalInputs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CommutativeAssociativeBinaryOperator;
        static Load(InName: string): K2Node_CommutativeAssociativeBinaryOperator;
    }
    
    class K2Node_ComponentBoundEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegatePropertyName: string;
        DelegateOwnerClass: Class;
        ComponentPropertyName: string;
        DelegatePropertyDisplayName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ComponentBoundEvent;
        static Load(InName: string): K2Node_ComponentBoundEvent;
    }
    
    class KismetUserDeclaredFunctionMetadata {
        constructor(ToolTip: string, Category: string, Keywords: string, CompactNodeTitle: string, InstanceTitleColor: LinearColor, DeprecationMessage: string, bIsDeprecated: boolean, bCallInEditor: boolean, HasLatentFunctions: number);
        ToolTip: string;
        Category: string;
        Keywords: string;
        CompactNodeTitle: string;
        InstanceTitleColor: LinearColor;
        DeprecationMessage: string;
        bIsDeprecated: boolean;
        bCallInEditor: boolean;
        HasLatentFunctions: number;
    }
    
    class K2Node_Tunnel extends K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OutputSourceNode: K2Node_Tunnel;
        InputSinkNode: K2Node_Tunnel;
        bCanHaveInputs: boolean;
        bCanHaveOutputs: boolean;
        MetaData: KismetUserDeclaredFunctionMetadata;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Tunnel;
        static Load(InName: string): K2Node_Tunnel;
    }
    
    class K2Node_Composite extends K2Node_Tunnel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: EdGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Composite;
        static Load(InName: string): K2Node_Composite;
    }
    
    class K2Node_ConstructObjectFromClass extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConstructObjectFromClass;
        static Load(InName: string): K2Node_ConstructObjectFromClass;
    }
    
    class K2Node_ConvertAsset extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertAsset;
        static Load(InName: string): K2Node_ConvertAsset;
    }
    
    class K2Node_Copy extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Copy;
        static Load(InName: string): K2Node_Copy;
    }
    
    class K2Node_CreateDelegate extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectedFunctionName: string;
        SelectedFunctionGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CreateDelegate;
        static Load(InName: string): K2Node_CreateDelegate;
    }
    
    class K2Node_CustomEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeprecationMessage: string;
        bIsDeprecated: boolean;
        bCallInEditor: boolean;
        MetaData: KismetUserDeclaredFunctionMetadata;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CustomEvent;
        static Load(InName: string): K2Node_CustomEvent;
    }
    
    class K2Node_DeadClass extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DeadClass;
        static Load(InName: string): K2Node_DeadClass;
    }
    
    class K2Node_DelegateSet extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelegatePropertyName: string;
        DelegatePropertyClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DelegateSet;
        static Load(InName: string): K2Node_DelegateSet;
    }
    
    class K2Node_TemporaryVariable extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VariableType: EdGraphPinType;
        bIsPersistent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_TemporaryVariable;
        static Load(InName: string): K2Node_TemporaryVariable;
    }
    
    class K2Node_DoOnceMultiInput extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumAdditionalInputs: number;
        DataNode: K2Node_TemporaryVariable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_DoOnceMultiInput;
        static Load(InName: string): K2Node_DoOnceMultiInput;
    }
    
    class K2Node_EaseFunction extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EaseFunctionName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EaseFunction;
        static Load(InName: string): K2Node_EaseFunction;
    }
    
    class K2Node_EnumEquality extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EnumEquality;
        static Load(InName: string): K2Node_EnumEquality;
    }
    
    class K2Node_EnumInequality extends K2Node_EnumEquality {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EnumInequality;
        static Load(InName: string): K2Node_EnumInequality;
    }
    
    class K2Node_EnumLiteral extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EnumLiteral;
        static Load(InName: string): K2Node_EnumLiteral;
    }
    
    class K2Node_EventNodeInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_EventNodeInterface;
        static Load(InName: string): K2Node_EventNodeInterface;
    }
    
    class K2Node_ExecutionSequence extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ExecutionSequence;
        static Load(InName: string): K2Node_ExecutionSequence;
    }
    
    class K2Node_ForEachElementInEnum extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ForEachElementInEnum;
        static Load(InName: string): K2Node_ForEachElementInEnum;
    }
    
    class K2Node_FormatText extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FormatText;
        static Load(InName: string): K2Node_FormatText;
    }
    
    class K2Node_FunctionTerminator extends K2Node_EditablePinBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FunctionReference: MemberReference;
        SignatureClass: Class;
        SignatureName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionTerminator;
        static Load(InName: string): K2Node_FunctionTerminator;
    }
    
    class K2Node_FunctionEntry extends K2Node_FunctionTerminator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomGeneratedFunctionName: string;
        MetaData: KismetUserDeclaredFunctionMetadata;
        LocalVariables: TArray<BPVariableDescription>;
        bEnforceConstCorrectness: boolean;
        ExtraFlags: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionEntry;
        static Load(InName: string): K2Node_FunctionEntry;
    }
    
    class K2Node_FunctionResult extends K2Node_FunctionTerminator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_FunctionResult;
        static Load(InName: string): K2Node_FunctionResult;
    }
    
    class K2Node_GenericCreateObject extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GenericCreateObject;
        static Load(InName: string): K2Node_GenericCreateObject;
    }
    
    class K2Node_GetArrayItem extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bReturnByRefDesired: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetArrayItem;
        static Load(InName: string): K2Node_GetArrayItem;
    }
    
    class K2Node_GetClassDefaults extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintSubscribedTo: Blueprint;
        ShowPinForProperties: TArray<OptionalPinFromProperty>;
        bExcludeObjectContainers: boolean;
        bExcludeObjectArrays: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetClassDefaults;
        static Load(InName: string): K2Node_GetClassDefaults;
    }
    
    class K2Node_GetDataTableRow extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetDataTableRow;
        static Load(InName: string): K2Node_GetDataTableRow;
    }
    
    class K2Node_GetEnumeratorName extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEnumeratorName;
        static Load(InName: string): K2Node_GetEnumeratorName;
    }
    
    class K2Node_GetEnumeratorNameAsString extends K2Node_GetEnumeratorName {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEnumeratorNameAsString;
        static Load(InName: string): K2Node_GetEnumeratorNameAsString;
    }
    
    class K2Node_GetInputAxisKeyValue extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisKey: Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputAxisKeyValue;
        static Load(InName: string): K2Node_GetInputAxisKeyValue;
    }
    
    class K2Node_GetInputAxisValue extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputAxisValue;
        static Load(InName: string): K2Node_GetInputAxisValue;
    }
    
    class K2Node_GetInputVectorAxisValue extends K2Node_GetInputAxisKeyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetInputVectorAxisValue;
        static Load(InName: string): K2Node_GetInputVectorAxisValue;
    }
    
    class K2Node_GetNumEnumEntries extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetNumEnumEntries;
        static Load(InName: string): K2Node_GetNumEnumEntries;
    }
    
    class K2Node_GetSubsystem extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetSubsystem;
        static Load(InName: string): K2Node_GetSubsystem;
    }
    
    class K2Node_GetSubsystemFromPC extends K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetSubsystemFromPC;
        static Load(InName: string): K2Node_GetSubsystemFromPC;
    }
    
    class K2Node_GetEngineSubsystem extends K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEngineSubsystem;
        static Load(InName: string): K2Node_GetEngineSubsystem;
    }
    
    class K2Node_GetEditorSubsystem extends K2Node_GetSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_GetEditorSubsystem;
        static Load(InName: string): K2Node_GetEditorSubsystem;
    }
    
    class K2Node_IfThenElse extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_IfThenElse;
        static Load(InName: string): K2Node_IfThenElse;
    }
    
    class K2Node_InputAction extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputActionName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputAction;
        static Load(InName: string): K2Node_InputAction;
    }
    
    class K2Node_InputActionEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputActionName: string;
        InputKeyEvent: number;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputActionEvent;
        static Load(InName: string): K2Node_InputActionEvent;
    }
    
    class K2Node_InputAxisEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisName: string;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputAxisEvent;
        static Load(InName: string): K2Node_InputAxisEvent;
    }
    
    class K2Node_InputAxisKeyEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisKey: Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputAxisKeyEvent;
        static Load(InName: string): K2Node_InputAxisKeyEvent;
    }
    
    class K2Node_InputKey extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputKey: Key;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        bControl: boolean;
        bAlt: boolean;
        bShift: boolean;
        bCommand: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputKey;
        static Load(InName: string): K2Node_InputKey;
    }
    
    class InputChord {
        constructor(Key: Key, bShift: boolean, bCtrl: boolean, bAlt: boolean, bCmd: boolean);
        Key: Key;
        bShift: boolean;
        bCtrl: boolean;
        bAlt: boolean;
        bCmd: boolean;
    }
    
    class K2Node_InputKeyEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputChord: InputChord;
        InputKeyEvent: number;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputKeyEvent;
        static Load(InName: string): K2Node_InputKeyEvent;
    }
    
    class K2Node_InputTouch extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputTouch;
        static Load(InName: string): K2Node_InputTouch;
    }
    
    class K2Node_InputTouchEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputKeyEvent: number;
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputTouchEvent;
        static Load(InName: string): K2Node_InputTouchEvent;
    }
    
    class K2Node_InputVectorAxisEvent extends K2Node_InputAxisKeyEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InputVectorAxisEvent;
        static Load(InName: string): K2Node_InputVectorAxisEvent;
    }
    
    class K2Node_Knot extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Knot;
        static Load(InName: string): K2Node_Knot;
    }
    
    class K2Node_Literal extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectRef: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Literal;
        static Load(InName: string): K2Node_Literal;
    }
    
    class K2Node_LoadAsset extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LoadAsset;
        static Load(InName: string): K2Node_LoadAsset;
    }
    
    class K2Node_LoadAssetClass extends K2Node_LoadAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LoadAssetClass;
        static Load(InName: string): K2Node_LoadAssetClass;
    }
    
    class K2Node_LocalVariable extends K2Node_TemporaryVariable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomVariableName: string;
        VariableTooltip: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LocalVariable;
        static Load(InName: string): K2Node_LocalVariable;
    }
    
    class GraphReference {
        constructor(MacroGraph: EdGraph, GraphBlueprint: Blueprint, GraphGuid: Guid);
        MacroGraph: EdGraph;
        GraphBlueprint: Blueprint;
        GraphGuid: Guid;
    }
    
    class K2Node_MacroInstance extends K2Node_Tunnel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MacroGraph: EdGraph;
        MacroGraphReference: GraphReference;
        ResolvedWildcardType: EdGraphPinType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MacroInstance;
        static Load(InName: string): K2Node_MacroInstance;
    }
    
    class K2Node_MakeContainer extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumInputs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeContainer;
        static Load(InName: string): K2Node_MakeContainer;
    }
    
    class K2Node_MakeArray extends K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeArray;
        static Load(InName: string): K2Node_MakeArray;
    }
    
    class K2Node_MakeMap extends K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeMap;
        static Load(InName: string): K2Node_MakeMap;
    }
    
    class K2Node_MakeSet extends K2Node_MakeContainer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeSet;
        static Load(InName: string): K2Node_MakeSet;
    }
    
    class K2Node_StructMemberSet extends K2Node_StructOperation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShowPinForProperties: TArray<OptionalPinFromProperty>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_StructMemberSet;
        static Load(InName: string): K2Node_StructMemberSet;
    }
    
    class K2Node_MakeStruct extends K2Node_StructMemberSet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMadeAfterOverridePinRemoval: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeStruct;
        static Load(InName: string): K2Node_MakeStruct;
    }
    
    class K2Node_MakeVariable extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VariableType: BPVariableDescription;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MakeVariable;
        static Load(InName: string): K2Node_MakeVariable;
    }
    
    class K2Node_MathExpression extends K2Node_Composite {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Expression: string;
        bMadeAfterRotChange: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MathExpression;
        static Load(InName: string): K2Node_MathExpression;
    }
    
    class K2Node_MatineeController extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MatineeActor: MatineeActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MatineeController;
        static Load(InName: string): K2Node_MatineeController;
    }
    
    class K2Node_Message extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Message;
        static Load(InName: string): K2Node_Message;
    }
    
    class K2Node_MultiGate extends K2Node_ExecutionSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataNode: K2Node_TemporaryVariable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_MultiGate;
        static Load(InName: string): K2Node_MultiGate;
    }
    
    class K2Node_PureAssignmentStatement extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PureAssignmentStatement;
        static Load(InName: string): K2Node_PureAssignmentStatement;
    }
    
    class K2Node_RemoveDelegate extends K2Node_BaseMCDelegate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_RemoveDelegate;
        static Load(InName: string): K2Node_RemoveDelegate;
    }
    
    class K2Node_Select extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumOptionPins: number;
        IndexPinType: EdGraphPinType;
        Enum: Enum;
        EnumEntries: TArray<string>;
        EnumEntryFriendlyNames: TArray<string>;
        bReconstructNode: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Select;
        static Load(InName: string): K2Node_Select;
    }
    
    class K2Node_Self extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Self;
        static Load(InName: string): K2Node_Self;
    }
    
    class K2Node_SetFieldsInStruct extends K2Node_MakeStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SetFieldsInStruct;
        static Load(InName: string): K2Node_SetFieldsInStruct;
    }
    
    class K2Node_SetVariableOnPersistentFrame extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SetVariableOnPersistentFrame;
        static Load(InName: string): K2Node_SetVariableOnPersistentFrame;
    }
    
    class K2Node_SpawnActor extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SpawnActor;
        static Load(InName: string): K2Node_SpawnActor;
    }
    
    class K2Node_SpawnActorFromClass extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SpawnActorFromClass;
        static Load(InName: string): K2Node_SpawnActorFromClass;
    }
    
    class K2Node_Switch extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHasDefaultPin: boolean;
        FunctionName: string;
        FunctionClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Switch;
        static Load(InName: string): K2Node_Switch;
    }
    
    class K2Node_SwitchEnum extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        EnumEntries: TArray<string>;
        EnumFriendlyNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchEnum;
        static Load(InName: string): K2Node_SwitchEnum;
    }
    
    class K2Node_SwitchInteger extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchInteger;
        static Load(InName: string): K2Node_SwitchInteger;
    }
    
    class K2Node_SwitchName extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchName;
        static Load(InName: string): K2Node_SwitchName;
    }
    
    class K2Node_SwitchString extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinNames: TArray<string>;
        bIsCaseSensitive: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_SwitchString;
        static Load(InName: string): K2Node_SwitchString;
    }
    
    class K2Node_Timeline extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimelineName: string;
        bAutoPlay: boolean;
        TimelineGuid: Guid;
        bLoop: boolean;
        bReplicated: boolean;
        bIgnoreTimeDilation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_Timeline;
        static Load(InName: string): K2Node_Timeline;
    }
    
    enum ETunnelBoundaryType { Unknown, EntrySite, InputSite, OutputSite, ETunnelBoundaryType_MAX}
    class K2Node_TunnelBoundary extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseName: string;
        TunnelBoundaryType: ETunnelBoundaryType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_TunnelBoundary;
        static Load(InName: string): K2Node_TunnelBoundary;
    }
    
    class K2Node_VariableGet extends K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsPureGet: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_VariableGet;
        static Load(InName: string): K2Node_VariableGet;
    }
    
    class K2Node_VariableSet extends K2Node_Variable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_VariableSet;
        static Load(InName: string): K2Node_VariableSet;
    }
    
    class K2Node_VariableSetRef extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_VariableSetRef;
        static Load(InName: string): K2Node_VariableSetRef;
    }
    
    class NodeDependingOnEnumInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NodeDependingOnEnumInterface;
        static Load(InName: string): NodeDependingOnEnumInterface;
    }
    
    enum EGraphPanningMouseButton { Right, Middle, Both, EGraphPanningMouseButton_MAX}
    class GraphEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataPinStyle: number;
        PanningMouseButton: EGraphPanningMouseButton;
        PaddingAbovePin: number;
        PaddingBelowPin: number;
        PaddingRightOfInput: number;
        PaddingLeftOfOutput: number;
        PaddingTowardsNodeEdge: number;
        bTreatSplinesLikePins: boolean;
        SplineHoverTolerance: number;
        ForwardSplineHorizontalDeltaRange: number;
        ForwardSplineVerticalDeltaRange: number;
        ForwardSplineTangentFromHorizontalDelta: Vector2D;
        ForwardSplineTangentFromVerticalDelta: Vector2D;
        BackwardSplineHorizontalDeltaRange: number;
        BackwardSplineVerticalDeltaRange: number;
        BackwardSplineTangentFromHorizontalDelta: Vector2D;
        BackwardSplineTangentFromVerticalDelta: Vector2D;
        DefaultPinTypeColor: LinearColor;
        ExecutionPinTypeColor: LinearColor;
        BooleanPinTypeColor: LinearColor;
        BytePinTypeColor: LinearColor;
        ClassPinTypeColor: LinearColor;
        IntPinTypeColor: LinearColor;
        Int64PinTypeColor: LinearColor;
        FloatPinTypeColor: LinearColor;
        NamePinTypeColor: LinearColor;
        SoftObjectPinTypeColor: LinearColor;
        SoftClassPinTypeColor: LinearColor;
        DelegatePinTypeColor: LinearColor;
        ObjectPinTypeColor: LinearColor;
        InterfacePinTypeColor: LinearColor;
        StringPinTypeColor: LinearColor;
        TextPinTypeColor: LinearColor;
        StructPinTypeColor: LinearColor;
        WildcardPinTypeColor: LinearColor;
        VectorPinTypeColor: LinearColor;
        RotatorPinTypeColor: LinearColor;
        TransformPinTypeColor: LinearColor;
        IndexPinTypeColor: LinearColor;
        EventNodeTitleColor: LinearColor;
        FunctionCallNodeTitleColor: LinearColor;
        PureFunctionCallNodeTitleColor: LinearColor;
        ParentFunctionCallNodeTitleColor: LinearColor;
        FunctionTerminatorNodeTitleColor: LinearColor;
        ExecBranchNodeTitleColor: LinearColor;
        ExecSequenceNodeTitleColor: LinearColor;
        ResultNodeTitleColor: LinearColor;
        DefaultCommentNodeTitleColor: LinearColor;
        PreviewNodeTitleColor: LinearColor;
        DefaultDataWireThickness: number;
        DefaultExecutionWireThickness: number;
        TraceAttackColor: LinearColor;
        TraceAttackWireThickness: number;
        TraceAttackHoldPeriod: number;
        TraceDecayPeriod: number;
        TraceDecayExponent: number;
        TraceSustainColor: LinearColor;
        TraceSustainWireThickness: number;
        TraceSustainHoldPeriod: number;
        TraceReleaseColor: LinearColor;
        TraceReleaseWireThickness: number;
        TraceReleasePeriod: number;
        TraceReleaseExponent: number;
        TracePositionBonusPeriod: number;
        TracePositionExponent: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GraphEditorSettings;
        static Load(InName: string): GraphEditorSettings;
    }
    
    class AnimationConduitGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationConduitGraphSchema;
        static Load(InName: string): AnimationConduitGraphSchema;
    }
    
    class AnimationGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendOptions: AnimGraphBlendOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationGraph;
        static Load(InName: string): AnimationGraph;
    }
    
    enum EBlueprintUsage { NoProperties, DoesNotUseBlueprint, UsesBlueprint, EBlueprintUsage_MAX}
    class AnimGraphNode_Base extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShowPinForProperties: TArray<OptionalPinFromProperty>;
        BlueprintUsage: EBlueprintUsage;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Base;
        static Load(InName: string): AnimGraphNode_Base;
    }
    
    class AnimNode_Base {
        constructor();
    }
    
    class PoseLinkBase {
        constructor(LinkID: number, SourceLinkID: number);
        LinkID: number;
        SourceLinkID: number;
    }
    
    class PoseLink extends PoseLinkBase {
        constructor();
    }
    
    class AnimNode_Root extends AnimNode_Base {
        constructor(Result: PoseLink, Name: string, Group: string);
        Result: PoseLink;
        Name: string;
        Group: string;
    }
    
    class AnimNode_StateResult extends AnimNode_Root {
        constructor();
    }
    
    class AnimGraphNode_StateResult extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_StateResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateResult;
        static Load(InName: string): AnimGraphNode_StateResult;
    }
    
    class AnimGraphNode_CustomTransitionResult extends AnimGraphNode_StateResult {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CustomTransitionResult;
        static Load(InName: string): AnimGraphNode_CustomTransitionResult;
    }
    
    class AnimationCustomTransitionGraph extends AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyResultNode: AnimGraphNode_CustomTransitionResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationCustomTransitionGraph;
        static Load(InName: string): AnimationCustomTransitionGraph;
    }
    
    class AnimationGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PN_SequenceName: string;
        NAME_NeverAsPin: string;
        NAME_PinHiddenByDefault: string;
        NAME_PinShownByDefault: string;
        NAME_AlwaysAsPin: string;
        NAME_CustomizeProperty: string;
        NAME_OnEvaluate: string;
        DefaultEvaluationHandlerName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationGraphSchema;
        static Load(InName: string): AnimationGraphSchema;
    }
    
    class AnimationCustomTransitionSchema extends AnimationGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationCustomTransitionSchema;
        static Load(InName: string): AnimationCustomTransitionSchema;
    }
    
    class AnimationStateGraph extends AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyResultNode: AnimGraphNode_StateResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateGraph;
        static Load(InName: string): AnimationStateGraph;
    }
    
    class AnimationStateGraphSchema extends AnimationGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateGraphSchema;
        static Load(InName: string): AnimationStateGraphSchema;
    }
    
    class AnimStateEntryNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateEntryNode;
        static Load(InName: string): AnimStateEntryNode;
    }
    
    class AnimGraphNode_StateMachineBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorStateMachineGraph: AnimationStateMachineGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateMachineBase;
        static Load(InName: string): AnimGraphNode_StateMachineBase;
    }
    
    class AnimationStateMachineGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryNode: AnimStateEntryNode;
        OwnerAnimGraphNode: AnimGraphNode_StateMachineBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateMachineGraph;
        static Load(InName: string): AnimationStateMachineGraph;
    }
    
    class AnimationStateMachineSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationStateMachineSchema;
        static Load(InName: string): AnimationStateMachineSchema;
    }
    
    class AnimNode_TransitionResult extends AnimNode_Base {
        constructor(bCanEnterTransition: boolean);
        bCanEnterTransition: boolean;
    }
    
    class AnimGraphNode_TransitionResult extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_TransitionResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TransitionResult;
        static Load(InName: string): AnimGraphNode_TransitionResult;
    }
    
    class AnimationTransitionGraph extends AnimationGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyResultNode: AnimGraphNode_TransitionResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationTransitionGraph;
        static Load(InName: string): AnimationTransitionGraph;
    }
    
    class AnimationTransitionSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationTransitionSchema;
        static Load(InName: string): AnimationTransitionSchema;
    }
    
    class AnimBlueprintPostCompileValidation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintPostCompileValidation;
        static Load(InName: string): AnimBlueprintPostCompileValidation;
    }
    
    class AnimationGroupReference {
        constructor(GroupName: string, GroupRole: number);
        GroupName: string;
        GroupRole: number;
    }
    
    class AnimGraphNode_AssetPlayerBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SyncGroup: AnimationGroupReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AssetPlayerBase;
        static Load(InName: string): AnimGraphNode_AssetPlayerBase;
    }
    
    class AnimGraphNode_BlendSpaceBase extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpaceBase;
        static Load(InName: string): AnimGraphNode_BlendSpaceBase;
    }
    
    class AnimNode_AssetPlayerBase extends AnimNode_Base {
        constructor(GroupIndex: number, GroupRole: number, bIgnoreForRelevancyTest: boolean, BlendWeight: number, InternalTimeAccumulator: number);
        GroupIndex: number;
        GroupRole: number;
        bIgnoreForRelevancyTest: boolean;
        BlendWeight: number;
        InternalTimeAccumulator: number;
    }
    
    class InterpolationParameter {
        constructor(InterpolationTime: number, InterpolationType: number);
        InterpolationTime: number;
        InterpolationType: number;
    }
    
    class PerBoneInterpolation {
        constructor(BoneReference: BoneReference, InterpolationSpeedPerSec: number);
        BoneReference: BoneReference;
        InterpolationSpeedPerSec: number;
    }
    
    class BlendSample {
        constructor(Animation: AnimSequence, SampleValue: Vector, RateScale: number, bSnapToGrid: boolean, bIsValid: boolean);
        Animation: AnimSequence;
        SampleValue: Vector;
        RateScale: number;
        bSnapToGrid: boolean;
        bIsValid: boolean;
    }
    
    class EditorElement {
        constructor(Indices: FixSizeArray<number>, Weights: FixSizeArray<number>);
        Indices: FixSizeArray<number>;
        Weights: FixSizeArray<number>;
    }
    
    class BlendParameter {
        constructor(DisplayName: string, Min: number, Max: number, GridNum: number);
        DisplayName: string;
        Min: number;
        Max: number;
        GridNum: number;
    }
    
    class BlendSpaceBase extends AnimationAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRotationBlendInMeshSpace: boolean;
        PreviewBasePose: AnimSequence;
        AnimLength: number;
        InterpolationParam: FixSizeArray<InterpolationParameter>;
        TargetWeightInterpolationSpeedPerSec: number;
        NotifyTriggerMode: number;
        PerBoneBlend: TArray<PerBoneInterpolation>;
        SampleIndexWithMarkers: number;
        SampleData: TArray<BlendSample>;
        GridSamples: TArray<EditorElement>;
        BlendParameters: FixSizeArray<BlendParameter>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceBase;
        static Load(InName: string): BlendSpaceBase;
    }
    
    class AnimNode_BlendSpacePlayer extends AnimNode_AssetPlayerBase {
        constructor(X: number, Y: number, Z: number, PlayRate: number, bLoop: boolean, bResetPlayTimeWhenBlendSpaceChanges: boolean, StartPosition: number, BlendSpace: BlendSpaceBase, PreviousBlendSpace: BlendSpaceBase);
        X: number;
        Y: number;
        Z: number;
        PlayRate: number;
        bLoop: boolean;
        bResetPlayTimeWhenBlendSpaceChanges: boolean;
        StartPosition: number;
        BlendSpace: BlendSpaceBase;
        PreviousBlendSpace: BlendSpaceBase;
    }
    
    class AnimNode_AimOffsetLookAt extends AnimNode_BlendSpacePlayer {
        constructor(BasePose: PoseLink, LODThreshold: number, SourceSocketName: string, PivotSocketName: string, LookAtLocation: Vector, SocketAxis: Vector, Alpha: number);
        BasePose: PoseLink;
        LODThreshold: number;
        SourceSocketName: string;
        PivotSocketName: string;
        LookAtLocation: Vector;
        SocketAxis: Vector;
        Alpha: number;
    }
    
    class AnimGraphNode_AimOffsetLookAt extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_AimOffsetLookAt;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AimOffsetLookAt;
        static Load(InName: string): AnimGraphNode_AimOffsetLookAt;
    }
    
    class AnimGraphNode_SkeletalControlBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SkeletalControlBase;
        static Load(InName: string): AnimGraphNode_SkeletalControlBase;
    }
    
    class ComponentSpacePoseLink extends PoseLinkBase {
        constructor();
    }
    
    enum EAnimAlphaInputType { Float, Bool, Curve, EAnimAlphaInputType_MAX}
    class InputScaleBias {
        constructor(Scale: number, Bias: number);
        Scale: number;
        Bias: number;
    }
    
    class InputAlphaBoolBlend {
        constructor(BlendInTime: number, BlendOutTime: number, BlendOption: EAlphaBlendOption, bInitialized: boolean, CustomCurve: CurveFloat, AlphaBlend: AlphaBlend);
        BlendInTime: number;
        BlendOutTime: number;
        BlendOption: EAlphaBlendOption;
        bInitialized: boolean;
        CustomCurve: CurveFloat;
        AlphaBlend: AlphaBlend;
    }
    
    class InputRange {
        constructor(Min: number, Max: number);
        Min: number;
        Max: number;
    }
    
    class InputScaleBiasClamp {
        constructor(bMapRange: boolean, bClampResult: boolean, bInterpResult: boolean, InRange: InputRange, OutRange: InputRange, Scale: number, Bias: number, ClampMin: number, ClampMax: number, InterpSpeedIncreasing: number, InterpSpeedDecreasing: number);
        bMapRange: boolean;
        bClampResult: boolean;
        bInterpResult: boolean;
        InRange: InputRange;
        OutRange: InputRange;
        Scale: number;
        Bias: number;
        ClampMin: number;
        ClampMax: number;
        InterpSpeedIncreasing: number;
        InterpSpeedDecreasing: number;
    }
    
    class AnimNode_SkeletalControlBase extends AnimNode_Base {
        constructor(ComponentPose: ComponentSpacePoseLink, LODThreshold: number, ActualAlpha: number, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean, Alpha: number, AlphaScaleBias: InputScaleBias, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp);
        ComponentPose: ComponentSpacePoseLink;
        LODThreshold: number;
        ActualAlpha: number;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
    }
    
    enum AnimPhysLinearConstraintType { Free, Limited, AnimPhysLinearConstraintType_MAX}
    enum AnimPhysAngularConstraintType { Angular, Cone, AnimPhysAngularConstraintType_MAX}
    enum AnimPhysTwistAxis { AxisX, AxisY, AxisZ, AnimPhysTwistAxis_MAX}
    class AnimPhysConstraintSetup {
        constructor(LinearXLimitType: AnimPhysLinearConstraintType, LinearYLimitType: AnimPhysLinearConstraintType, LinearZLimitType: AnimPhysLinearConstraintType, LinearAxesMin: Vector, LinearAxesMax: Vector, AngularConstraintType: AnimPhysAngularConstraintType, TwistAxis: AnimPhysTwistAxis, AngularTargetAxis: AnimPhysTwistAxis, ConeAngle: number, AngularXAngle: number, AngularYAngle: number, AngularZAngle: number, AngularLimitsMin: Vector, AngularLimitsMax: Vector, AngularTarget: Vector);
        LinearXLimitType: AnimPhysLinearConstraintType;
        LinearYLimitType: AnimPhysLinearConstraintType;
        LinearZLimitType: AnimPhysLinearConstraintType;
        LinearAxesMin: Vector;
        LinearAxesMax: Vector;
        AngularConstraintType: AnimPhysAngularConstraintType;
        TwistAxis: AnimPhysTwistAxis;
        AngularTargetAxis: AnimPhysTwistAxis;
        ConeAngle: number;
        AngularXAngle: number;
        AngularYAngle: number;
        AngularZAngle: number;
        AngularLimitsMin: Vector;
        AngularLimitsMax: Vector;
        AngularTarget: Vector;
    }
    
    enum ESphericalLimitType { Inner, Outer, ESphericalLimitType_MAX}
    class AnimPhysSphericalLimit {
        constructor(DrivingBone: BoneReference, SphereLocalOffset: Vector, LimitRadius: number, LimitType: ESphericalLimitType);
        DrivingBone: BoneReference;
        SphereLocalOffset: Vector;
        LimitRadius: number;
        LimitType: ESphericalLimitType;
    }
    
    class AnimPhysPlanarLimit {
        constructor(DrivingBone: BoneReference, PlaneTransform: Transform);
        DrivingBone: BoneReference;
        PlaneTransform: Transform;
    }
    
    enum AnimPhysCollisionType { CoM, CustomSphere, InnerSphere, OuterSphere, AnimPhysCollisionType_MAX}
    enum AnimPhysSimSpaceType { Component, Actor, World, RootRelative, BoneRelative, AnimPhysSimSpaceType_MAX}
    enum ERotationComponent { EulerX, EulerY, EulerZ, QuaternionAngle, SwingAngle, TwistAngle, ERotationComponent_MAX}
    enum EEasingFuncType { Linear, Sinusoidal, Cubic, QuadraticInOut, CubicInOut, HermiteCubic, QuarticInOut, QuinticInOut, CircularIn, CircularOut, CircularInOut, ExpIn, ExpOut, ExpInOut, CustomCurve, EEasingFuncType_MAX}
    class RotationRetargetingInfo {
        constructor(bEnabled: boolean, Source: Transform, Target: Transform, RotationComponent: ERotationComponent, TwistAxis: Vector, bUseAbsoluteAngle: boolean, SourceMinimum: number, SourceMaximum: number, TargetMinimum: number, TargetMaximum: number, EasingType: EEasingFuncType, CustomCurve: RuntimeFloatCurve, bFlipEasing: boolean, EasingWeight: number, bClamp: boolean);
        bEnabled: boolean;
        Source: Transform;
        Target: Transform;
        RotationComponent: ERotationComponent;
        TwistAxis: Vector;
        bUseAbsoluteAngle: boolean;
        SourceMinimum: number;
        SourceMaximum: number;
        TargetMinimum: number;
        TargetMaximum: number;
        EasingType: EEasingFuncType;
        CustomCurve: RuntimeFloatCurve;
        bFlipEasing: boolean;
        EasingWeight: number;
        bClamp: boolean;
    }
    
    class AnimNode_AnimDynamics extends AnimNode_SkeletalControlBase {
        constructor(LinearDampingOverride: number, AngularDampingOverride: number, RelativeSpaceBone: BoneReference, BoundBone: BoneReference, ChainEnd: BoneReference, BoxExtents: Vector, LocalJointOffset: Vector, GravityScale: number, GravityOverride: Vector, LinearSpringConstant: number, AngularSpringConstant: number, WindScale: number, ComponentLinearAccScale: Vector, ComponentLinearVelScale: Vector, ComponentAppliedLinearAccClamp: Vector, AngularBiasOverride: number, NumSolverIterationsPreUpdate: number, NumSolverIterationsPostUpdate: number, ConstraintSetup: AnimPhysConstraintSetup, SphericalLimits: TArray<AnimPhysSphericalLimit>, SphereCollisionRadius: number, ExternalForce: Vector, PlanarLimits: TArray<AnimPhysPlanarLimit>, CollisionType: AnimPhysCollisionType, SimulationSpace: AnimPhysSimSpaceType, bUseSphericalLimits: boolean, bUsePlanarLimit: boolean, bDoUpdate: boolean, bDoEval: boolean, bOverrideLinearDamping: boolean, bOverrideAngularBias: boolean, bOverrideAngularDamping: boolean, bEnableWind: boolean, bUseGravityOverride: boolean, bLinearSpring: boolean, bAngularSpring: boolean, bChain: boolean, RetargetingSettings: RotationRetargetingInfo);
        LinearDampingOverride: number;
        AngularDampingOverride: number;
        RelativeSpaceBone: BoneReference;
        BoundBone: BoneReference;
        ChainEnd: BoneReference;
        BoxExtents: Vector;
        LocalJointOffset: Vector;
        GravityScale: number;
        GravityOverride: Vector;
        LinearSpringConstant: number;
        AngularSpringConstant: number;
        WindScale: number;
        ComponentLinearAccScale: Vector;
        ComponentLinearVelScale: Vector;
        ComponentAppliedLinearAccClamp: Vector;
        AngularBiasOverride: number;
        NumSolverIterationsPreUpdate: number;
        NumSolverIterationsPostUpdate: number;
        ConstraintSetup: AnimPhysConstraintSetup;
        SphericalLimits: TArray<AnimPhysSphericalLimit>;
        SphereCollisionRadius: number;
        ExternalForce: Vector;
        PlanarLimits: TArray<AnimPhysPlanarLimit>;
        CollisionType: AnimPhysCollisionType;
        SimulationSpace: AnimPhysSimSpaceType;
        bUseSphericalLimits: boolean;
        bUsePlanarLimit: boolean;
        bDoUpdate: boolean;
        bDoEval: boolean;
        bOverrideLinearDamping: boolean;
        bOverrideAngularBias: boolean;
        bOverrideAngularDamping: boolean;
        bEnableWind: boolean;
        bUseGravityOverride: boolean;
        bLinearSpring: boolean;
        bAngularSpring: boolean;
        bChain: boolean;
        RetargetingSettings: RotationRetargetingInfo;
    }
    
    class AnimGraphNode_AnimDynamics extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_AnimDynamics;
        bPreviewLive: boolean;
        bShowLinearLimits: boolean;
        bShowAngularLimits: boolean;
        bShowPlanarLimit: boolean;
        bShowSphericalLimit: boolean;
        bShowCollisionSpheres: boolean;
        LastPreviewComponent: SkeletalMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_AnimDynamics;
        static Load(InName: string): AnimGraphNode_AnimDynamics;
    }
    
    class AnimNode_ApplyAdditive extends AnimNode_Base {
        constructor(Base: PoseLink, Additive: PoseLink, Alpha: number, AlphaScaleBias: InputScaleBias, LODThreshold: number, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean);
        Base: PoseLink;
        Additive: PoseLink;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        LODThreshold: number;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
    }
    
    class AnimGraphNode_ApplyAdditive extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ApplyAdditive;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyAdditive;
        static Load(InName: string): AnimGraphNode_ApplyAdditive;
    }
    
    class AngularRangeLimit {
        constructor(LimitMin: Vector, LimitMax: Vector, Bone: BoneReference);
        LimitMin: Vector;
        LimitMax: Vector;
        Bone: BoneReference;
    }
    
    class AnimNode_ApplyLimits extends AnimNode_SkeletalControlBase {
        constructor(AngularRangeLimits: TArray<AngularRangeLimit>, AngularOffsets: TArray<Vector>);
        AngularRangeLimits: TArray<AngularRangeLimit>;
        AngularOffsets: TArray<Vector>;
    }
    
    class AnimGraphNode_ApplyLimits extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ApplyLimits;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyLimits;
        static Load(InName: string): AnimGraphNode_ApplyLimits;
    }
    
    class AnimNode_ApplyMeshSpaceAdditive extends AnimNode_Base {
        constructor(Base: PoseLink, Additive: PoseLink, Alpha: number, AlphaScaleBias: InputScaleBias, LODThreshold: number);
        Base: PoseLink;
        Additive: PoseLink;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        LODThreshold: number;
    }
    
    class AnimGraphNode_ApplyMeshSpaceAdditive extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ApplyMeshSpaceAdditive;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ApplyMeshSpaceAdditive;
        static Load(InName: string): AnimGraphNode_ApplyMeshSpaceAdditive;
    }
    
    class BlendBoneByChannelEntry {
        constructor(SourceBone: BoneReference, TargetBone: BoneReference, bBlendTranslation: boolean, bBlendRotation: boolean, bBlendScale: boolean);
        SourceBone: BoneReference;
        TargetBone: BoneReference;
        bBlendTranslation: boolean;
        bBlendRotation: boolean;
        bBlendScale: boolean;
    }
    
    class AnimNode_BlendBoneByChannel extends AnimNode_Base {
        constructor(A: PoseLink, B: PoseLink, BoneDefinitions: TArray<BlendBoneByChannelEntry>, Alpha: number, AlphaScaleBias: InputScaleBias, TransformsSpace: number);
        A: PoseLink;
        B: PoseLink;
        BoneDefinitions: TArray<BlendBoneByChannelEntry>;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        TransformsSpace: number;
    }
    
    class AnimGraphNode_BlendBoneByChannel extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendNode: AnimNode_BlendBoneByChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendBoneByChannel;
        static Load(InName: string): AnimGraphNode_BlendBoneByChannel;
    }
    
    class AnimGraphNode_BlendListBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListBase;
        static Load(InName: string): AnimGraphNode_BlendListBase;
    }
    
    enum EBlendListTransitionType { StandardBlend, Inertialization, EBlendListTransitionType_MAX}
    class AnimNode_BlendListBase extends AnimNode_Base {
        constructor(BlendPose: TArray<PoseLink>, BlendTime: TArray<number>, TransitionType: EBlendListTransitionType, BlendType: EAlphaBlendOption, bResetChildOnActivation: boolean, CustomBlendCurve: CurveFloat, BlendProfile: BlendProfile);
        BlendPose: TArray<PoseLink>;
        BlendTime: TArray<number>;
        TransitionType: EBlendListTransitionType;
        BlendType: EAlphaBlendOption;
        bResetChildOnActivation: boolean;
        CustomBlendCurve: CurveFloat;
        BlendProfile: BlendProfile;
    }
    
    class AnimNode_BlendListByBool extends AnimNode_BlendListBase {
        constructor(bActiveValue: boolean);
        bActiveValue: boolean;
    }
    
    class AnimGraphNode_BlendListByBool extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_BlendListByBool;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByBool;
        static Load(InName: string): AnimGraphNode_BlendListByBool;
    }
    
    class AnimNode_BlendListByEnum extends AnimNode_BlendListBase {
        constructor(EnumToPoseIndex: TArray<number>, ActiveEnumValue: number);
        EnumToPoseIndex: TArray<number>;
        ActiveEnumValue: number;
    }
    
    class AnimGraphNode_BlendListByEnum extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_BlendListByEnum;
        BoundEnum: Enum;
        VisibleEnumEntries: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByEnum;
        static Load(InName: string): AnimGraphNode_BlendListByEnum;
    }
    
    class AnimNode_BlendListByInt extends AnimNode_BlendListBase {
        constructor(ActiveChildIndex: number);
        ActiveChildIndex: number;
    }
    
    class AnimGraphNode_BlendListByInt extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_BlendListByInt;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendListByInt;
        static Load(InName: string): AnimGraphNode_BlendListByInt;
    }
    
    class AnimNode_BlendSpaceEvaluator extends AnimNode_BlendSpacePlayer {
        constructor(NormalizedTime: number);
        NormalizedTime: number;
    }
    
    class AnimGraphNode_BlendSpaceEvaluator extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_BlendSpaceEvaluator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpaceEvaluator;
        static Load(InName: string): AnimGraphNode_BlendSpaceEvaluator;
    }
    
    class AnimGraphNode_BlendSpacePlayer extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_BlendSpacePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BlendSpacePlayer;
        static Load(InName: string): AnimGraphNode_BlendSpacePlayer;
    }
    
    enum EDrivenDestinationMode { Bone, MorphTarget, MaterialParameter, EDrivenDestinationMode_MAX}
    enum EDrivenBoneModificationMode { AddToInput, ReplaceComponent, AddToRefPose, EDrivenBoneModificationMode_MAX}
    class AnimNode_BoneDrivenController extends AnimNode_SkeletalControlBase {
        constructor(SourceBone: BoneReference, DrivingCurve: CurveFloat, Multiplier: number, RangeMin: number, RangeMax: number, RemappedMin: number, RemappedMax: number, ParameterName: string, TargetBone: BoneReference, TargetComponent: number, DestinationMode: EDrivenDestinationMode, ModificationMode: EDrivenBoneModificationMode, SourceComponent: number, bUseRange: boolean, bAffectTargetTranslationX: boolean, bAffectTargetTranslationY: boolean, bAffectTargetTranslationZ: boolean, bAffectTargetRotationX: boolean, bAffectTargetRotationY: boolean, bAffectTargetRotationZ: boolean, bAffectTargetScaleX: boolean, bAffectTargetScaleY: boolean, bAffectTargetScaleZ: boolean);
        SourceBone: BoneReference;
        DrivingCurve: CurveFloat;
        Multiplier: number;
        RangeMin: number;
        RangeMax: number;
        RemappedMin: number;
        RemappedMax: number;
        ParameterName: string;
        TargetBone: BoneReference;
        TargetComponent: number;
        DestinationMode: EDrivenDestinationMode;
        ModificationMode: EDrivenBoneModificationMode;
        SourceComponent: number;
        bUseRange: boolean;
        bAffectTargetTranslationX: boolean;
        bAffectTargetTranslationY: boolean;
        bAffectTargetTranslationZ: boolean;
        bAffectTargetRotationX: boolean;
        bAffectTargetRotationY: boolean;
        bAffectTargetRotationZ: boolean;
        bAffectTargetScaleX: boolean;
        bAffectTargetScaleY: boolean;
        bAffectTargetScaleZ: boolean;
    }
    
    class AnimGraphNode_BoneDrivenController extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_BoneDrivenController;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_BoneDrivenController;
        static Load(InName: string): AnimGraphNode_BoneDrivenController;
    }
    
    class SocketReference {
        constructor(SocketName: string);
        SocketName: string;
    }
    
    class BoneSocketTarget {
        constructor(bUseSocket: boolean, BoneReference: BoneReference, SocketReference: SocketReference);
        bUseSocket: boolean;
        BoneReference: BoneReference;
        SocketReference: SocketReference;
    }
    
    class AnimNode_CCDIK extends AnimNode_SkeletalControlBase {
        constructor(EffectorLocation: Vector, EffectorLocationSpace: number, EffectorTarget: BoneSocketTarget, TipBone: BoneReference, RootBone: BoneReference, Precision: number, MaxIterations: number, bStartFromTail: boolean, bEnableRotationLimit: boolean, RotationLimitPerJoints: TArray<number>);
        EffectorLocation: Vector;
        EffectorLocationSpace: number;
        EffectorTarget: BoneSocketTarget;
        TipBone: BoneReference;
        RootBone: BoneReference;
        Precision: number;
        MaxIterations: number;
        bStartFromTail: boolean;
        bEnableRotationLimit: boolean;
        RotationLimitPerJoints: TArray<number>;
    }
    
    class AnimGraphNode_CCDIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_CCDIK;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CCDIK;
        static Load(InName: string): AnimGraphNode_CCDIK;
    }
    
    class AnimNode_ConvertComponentToLocalSpace extends AnimNode_Base {
        constructor(ComponentPose: ComponentSpacePoseLink);
        ComponentPose: ComponentSpacePoseLink;
    }
    
    class AnimGraphNode_ComponentToLocalSpace extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ConvertComponentToLocalSpace;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ComponentToLocalSpace;
        static Load(InName: string): AnimGraphNode_ComponentToLocalSpace;
    }
    
    enum EConstraintOffsetOption { None, Offset_RefPose, EConstraintOffsetOption_MAX}
    enum ETransformConstraintType { Translation, Rotation, Scale, Parent, ETransformConstraintType_MAX}
    class FilterOptionPerAxis {
        constructor(bX: boolean, bY: boolean, bZ: boolean);
        bX: boolean;
        bY: boolean;
        bZ: boolean;
    }
    
    class Constraint {
        constructor(TargetBone: BoneReference, OffsetOption: EConstraintOffsetOption, TransformType: ETransformConstraintType, PerAxis: FilterOptionPerAxis);
        TargetBone: BoneReference;
        OffsetOption: EConstraintOffsetOption;
        TransformType: ETransformConstraintType;
        PerAxis: FilterOptionPerAxis;
    }
    
    class AnimNode_Constraint extends AnimNode_SkeletalControlBase {
        constructor(BoneToModify: BoneReference, ConstraintSetup: TArray<Constraint>, ConstraintWeights: TArray<number>);
        BoneToModify: BoneReference;
        ConstraintSetup: TArray<Constraint>;
        ConstraintWeights: TArray<number>;
    }
    
    class AnimGraphNode_Constraint extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_Constraint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Constraint;
        static Load(InName: string): AnimGraphNode_Constraint;
    }
    
    class AnimNode_CopyBone extends AnimNode_SkeletalControlBase {
        constructor(SourceBone: BoneReference, TargetBone: BoneReference, bCopyTranslation: boolean, bCopyRotation: boolean, bCopyScale: boolean, ControlSpace: number);
        SourceBone: BoneReference;
        TargetBone: BoneReference;
        bCopyTranslation: boolean;
        bCopyRotation: boolean;
        bCopyScale: boolean;
        ControlSpace: number;
    }
    
    class AnimGraphNode_CopyBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_CopyBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyBone;
        static Load(InName: string): AnimGraphNode_CopyBone;
    }
    
    enum CopyBoneDeltaMode { Accumulate, Copy, CopyBoneDeltaMode_MAX}
    class AnimNode_CopyBoneDelta extends AnimNode_SkeletalControlBase {
        constructor(SourceBone: BoneReference, TargetBone: BoneReference, bCopyTranslation: boolean, bCopyRotation: boolean, bCopyScale: boolean, CopyMode: CopyBoneDeltaMode, TranslationMultiplier: number, RotationMultiplier: number, ScaleMultiplier: number);
        SourceBone: BoneReference;
        TargetBone: BoneReference;
        bCopyTranslation: boolean;
        bCopyRotation: boolean;
        bCopyScale: boolean;
        CopyMode: CopyBoneDeltaMode;
        TranslationMultiplier: number;
        RotationMultiplier: number;
        ScaleMultiplier: number;
    }
    
    class AnimGraphNode_CopyBoneDelta extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_CopyBoneDelta;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyBoneDelta;
        static Load(InName: string): AnimGraphNode_CopyBoneDelta;
    }
    
    class AnimNode_CopyPoseFromMesh extends AnimNode_Base {
        constructor(SourceMeshComponent: TWeakObjectPtr<SkeletalMeshComponent>, bUseAttachedParent: boolean, bCopyCurves: boolean);
        SourceMeshComponent: TWeakObjectPtr<SkeletalMeshComponent>;
        bUseAttachedParent: boolean;
        bCopyCurves: boolean;
    }
    
    class AnimGraphNode_CopyPoseFromMesh extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_CopyPoseFromMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CopyPoseFromMesh;
        static Load(InName: string): AnimGraphNode_CopyPoseFromMesh;
    }
    
    class NamedCurveValue {
        constructor(Name: string, Value: number);
        Name: string;
        Value: number;
    }
    
    class CurveSourceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetCurveValue(CurveName: string): number;
        GetCurves(OutValues: $Ref<TArray<NamedCurveValue>>): void;
        GetBindingName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveSourceInterface;
        static Load(InName: string): CurveSourceInterface;
    }
    
    class AnimNode_CurveSource extends AnimNode_Base {
        constructor(SourcePose: PoseLink, SourceBinding: string, Alpha: number, CurveSource: CurveSourceInterface);
        SourcePose: PoseLink;
        SourceBinding: string;
        Alpha: number;
        CurveSource: CurveSourceInterface;
    }
    
    class AnimGraphNode_CurveSource extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_CurveSource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CurveSource;
        static Load(InName: string): AnimGraphNode_CurveSource;
    }
    
    class AnimGraphNode_CustomProperty extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KnownExposableProperties: TArray<string>;
        ExposedPropertyNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_CustomProperty;
        static Load(InName: string): AnimGraphNode_CustomProperty;
    }
    
    class AnimNode_Fabrik extends AnimNode_SkeletalControlBase {
        constructor(EffectorTransform: Transform, EffectorTarget: BoneSocketTarget, TipBone: BoneReference, RootBone: BoneReference, Precision: number, MaxIterations: number, EffectorTransformSpace: number, EffectorRotationSource: number, bEnableDebugDraw: boolean, EffectorTransformBone: BoneReference);
        EffectorTransform: Transform;
        EffectorTarget: BoneSocketTarget;
        TipBone: BoneReference;
        RootBone: BoneReference;
        Precision: number;
        MaxIterations: number;
        EffectorTransformSpace: number;
        EffectorRotationSource: number;
        bEnableDebugDraw: boolean;
        EffectorTransformBone: BoneReference;
    }
    
    class AnimGraphNode_Fabrik extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_Fabrik;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Fabrik;
        static Load(InName: string): AnimGraphNode_Fabrik;
    }
    
    class AnimNode_HandIKRetargeting extends AnimNode_SkeletalControlBase {
        constructor(RightHandFK: BoneReference, LeftHandFK: BoneReference, RightHandIK: BoneReference, LeftHandIK: BoneReference, IKBonesToMove: TArray<BoneReference>, HandFKWeight: number);
        RightHandFK: BoneReference;
        LeftHandFK: BoneReference;
        RightHandIK: BoneReference;
        LeftHandIK: BoneReference;
        IKBonesToMove: TArray<BoneReference>;
        HandFKWeight: number;
    }
    
    class AnimGraphNode_HandIKRetargeting extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_HandIKRetargeting;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_HandIKRetargeting;
        static Load(InName: string): AnimGraphNode_HandIKRetargeting;
    }
    
    class AnimNode_RefPose extends AnimNode_Base {
        constructor(RefPoseType: number);
        RefPoseType: number;
    }
    
    class AnimGraphNode_RefPoseBase extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RefPose;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RefPoseBase;
        static Load(InName: string): AnimGraphNode_RefPoseBase;
    }
    
    class AnimGraphNode_IdentityPose extends AnimGraphNode_RefPoseBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_IdentityPose;
        static Load(InName: string): AnimGraphNode_IdentityPose;
    }
    
    class AnimNode_Inertialization extends AnimNode_Base {
        constructor(Source: PoseLink);
        Source: PoseLink;
    }
    
    class AnimGraphNode_Inertialization extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_Inertialization;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Inertialization;
        static Load(InName: string): AnimGraphNode_Inertialization;
    }
    
    class BranchFilter {
        constructor(BoneName: string, BlendDepth: number);
        BoneName: string;
        BlendDepth: number;
    }
    
    class InputBlendPose {
        constructor(BranchFilters: TArray<BranchFilter>);
        BranchFilters: TArray<BranchFilter>;
    }
    
    class PerBoneBlendWeight {
        constructor(SourceIndex: number, BlendWeight: number);
        SourceIndex: number;
        BlendWeight: number;
    }
    
    class AnimNode_LayeredBoneBlend extends AnimNode_Base {
        constructor(BasePose: PoseLink, BlendPoses: TArray<PoseLink>, LayerSetup: TArray<InputBlendPose>, BlendWeights: TArray<number>, bMeshSpaceRotationBlend: boolean, bMeshSpaceScaleBlend: boolean, CurveBlendOption: number, bBlendRootMotionBasedOnRootBone: boolean, LODThreshold: number, PerBoneBlendWeights: TArray<PerBoneBlendWeight>, SkeletonGuid: Guid, VirtualBoneGuid: Guid);
        BasePose: PoseLink;
        BlendPoses: TArray<PoseLink>;
        LayerSetup: TArray<InputBlendPose>;
        BlendWeights: TArray<number>;
        bMeshSpaceRotationBlend: boolean;
        bMeshSpaceScaleBlend: boolean;
        CurveBlendOption: number;
        bBlendRootMotionBasedOnRootBone: boolean;
        LODThreshold: number;
        PerBoneBlendWeights: TArray<PerBoneBlendWeight>;
        SkeletonGuid: Guid;
        VirtualBoneGuid: Guid;
    }
    
    class AnimGraphNode_LayeredBoneBlend extends AnimGraphNode_BlendListBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_LayeredBoneBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LayeredBoneBlend;
        static Load(InName: string): AnimGraphNode_LayeredBoneBlend;
    }
    
    class AnimLegIKDefinition {
        constructor(IKFootBone: BoneReference, FKFootBone: BoneReference, NumBonesInLimb: number, MinRotationAngle: number, FootBoneForwardAxis: number, HingeRotationAxis: number, bEnableRotationLimit: boolean, bEnableKneeTwistCorrection: boolean);
        IKFootBone: BoneReference;
        FKFootBone: BoneReference;
        NumBonesInLimb: number;
        MinRotationAngle: number;
        FootBoneForwardAxis: number;
        HingeRotationAxis: number;
        bEnableRotationLimit: boolean;
        bEnableKneeTwistCorrection: boolean;
    }
    
    class AnimNode_LegIK extends AnimNode_SkeletalControlBase {
        constructor(ReachPrecision: number, MaxIterations: number, LegsDefinition: TArray<AnimLegIKDefinition>);
        ReachPrecision: number;
        MaxIterations: number;
        LegsDefinition: TArray<AnimLegIKDefinition>;
    }
    
    class AnimGraphNode_LegIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_LegIK;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LegIK;
        static Load(InName: string): AnimGraphNode_LegIK;
    }
    
    class AnimGraphNode_LinkedAnimGraphBase extends AnimGraphNode_CustomProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimGraphBase;
        static Load(InName: string): AnimGraphNode_LinkedAnimGraphBase;
    }
    
    class AnimNode_CustomProperty extends AnimNode_Base {
        constructor(SourcePropertyNames: TArray<string>, DestPropertyNames: TArray<string>, TargetInstance: Object, SourceProperties: TArray<Property>, DestProperties: TArray<Property>);
        SourcePropertyNames: TArray<string>;
        DestPropertyNames: TArray<string>;
        TargetInstance: Object;
        SourceProperties: TArray<Property>;
        DestProperties: TArray<Property>;
    }
    
    class AnimNode_LinkedAnimGraph extends AnimNode_CustomProperty {
        constructor(InputPoses: TArray<PoseLink>, InputPoseNames: TArray<string>, InstanceClass: Class, Tag: string);
        InputPoses: TArray<PoseLink>;
        InputPoseNames: TArray<string>;
        InstanceClass: Class;
        Tag: string;
    }
    
    class AnimGraphNode_LinkedAnimGraph extends AnimGraphNode_LinkedAnimGraphBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_LinkedAnimGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimGraph;
        static Load(InName: string): AnimGraphNode_LinkedAnimGraph;
    }
    
    class AnimNode_LinkedAnimLayer extends AnimNode_LinkedAnimGraph {
        constructor(Interface: Class, Layer: string);
        Interface: Class;
        Layer: string;
    }
    
    class AnimGraphNode_LinkedAnimLayer extends AnimGraphNode_LinkedAnimGraphBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_LinkedAnimLayer;
        InterfaceGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedAnimLayer;
        static Load(InName: string): AnimGraphNode_LinkedAnimLayer;
    }
    
    class AnimNode_LinkedInputPose extends AnimNode_Base {
        constructor(Name: string, Graph: string, InputPose: PoseLink);
        Name: string;
        Graph: string;
        InputPose: PoseLink;
    }
    
    class AnimBlueprintFunctionPinInfo {
        constructor(Name: string, Type: EdGraphPinType);
        Name: string;
        Type: EdGraphPinType;
    }
    
    class AnimGraphNode_LinkedInputPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_LinkedInputPose;
        Inputs: TArray<AnimBlueprintFunctionPinInfo>;
        FunctionReference: MemberReference;
        InputPoseIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LinkedInputPose;
        static Load(InName: string): AnimGraphNode_LinkedInputPose;
    }
    
    class AnimGraphNode_LocalRefPose extends AnimGraphNode_RefPoseBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LocalRefPose;
        static Load(InName: string): AnimGraphNode_LocalRefPose;
    }
    
    class AnimNode_ConvertLocalToComponentSpace extends AnimNode_Base {
        constructor(LocalPose: PoseLink);
        LocalPose: PoseLink;
    }
    
    class AnimGraphNode_LocalToComponentSpace extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ConvertLocalToComponentSpace;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LocalToComponentSpace;
        static Load(InName: string): AnimGraphNode_LocalToComponentSpace;
    }
    
    class Axis {
        constructor(Axis: Vector, bInLocalSpace: boolean);
        Axis: Vector;
        bInLocalSpace: boolean;
    }
    
    class AnimNode_LookAt extends AnimNode_SkeletalControlBase {
        constructor(BoneToModify: BoneReference, LookAtTarget: BoneSocketTarget, LookAtLocation: Vector, LookAt_Axis: Axis, bUseLookUpAxis: boolean, InterpolationType: number, LookUp_Axis: Axis, LookAtClamp: number, InterpolationTime: number, InterpolationTriggerThreashold: number, LookAtBone: BoneReference, LookAtSocket: string, LookAtAxis: number, CustomLookAtAxis: Vector, LookUpAxis: number, CustomLookUpAxis: Vector);
        BoneToModify: BoneReference;
        LookAtTarget: BoneSocketTarget;
        LookAtLocation: Vector;
        LookAt_Axis: Axis;
        bUseLookUpAxis: boolean;
        InterpolationType: number;
        LookUp_Axis: Axis;
        LookAtClamp: number;
        InterpolationTime: number;
        InterpolationTriggerThreashold: number;
        LookAtBone: BoneReference;
        LookAtSocket: string;
        LookAtAxis: number;
        CustomLookAtAxis: Vector;
        LookUpAxis: number;
        CustomLookUpAxis: Vector;
    }
    
    class AnimGraphNode_LookAt extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_LookAt;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_LookAt;
        static Load(InName: string): AnimGraphNode_LookAt;
    }
    
    class AnimNode_MakeDynamicAdditive extends AnimNode_Base {
        constructor(Base: PoseLink, Additive: PoseLink, bMeshSpaceAdditive: boolean);
        Base: PoseLink;
        Additive: PoseLink;
        bMeshSpaceAdditive: boolean;
    }
    
    class AnimGraphNode_MakeDynamicAdditive extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_MakeDynamicAdditive;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MakeDynamicAdditive;
        static Load(InName: string): AnimGraphNode_MakeDynamicAdditive;
    }
    
    class AnimNode_MeshSpaceRefPose extends AnimNode_Base {
        constructor();
    }
    
    class AnimGraphNode_MeshRefPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_MeshSpaceRefPose;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MeshRefPose;
        static Load(InName: string): AnimGraphNode_MeshRefPose;
    }
    
    class AnimNode_ModifyBone extends AnimNode_SkeletalControlBase {
        constructor(BoneToModify: BoneReference, Translation: Vector, Rotation: Rotator, Scale: Vector, TranslationMode: number, RotationMode: number, ScaleMode: number, TranslationSpace: number, RotationSpace: number, ScaleSpace: number);
        BoneToModify: BoneReference;
        Translation: Vector;
        Rotation: Rotator;
        Scale: Vector;
        TranslationMode: number;
        RotationMode: number;
        ScaleMode: number;
        TranslationSpace: number;
        RotationSpace: number;
        ScaleSpace: number;
    }
    
    class AnimGraphNode_ModifyBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ModifyBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ModifyBone;
        static Load(InName: string): AnimGraphNode_ModifyBone;
    }
    
    enum EModifyCurveApplyMode { Add, Scale, Blend, WeightedMovingAverage, RemapCurve, EModifyCurveApplyMode_MAX}
    class AnimNode_ModifyCurve extends AnimNode_Base {
        constructor(SourcePose: PoseLink, CurveValues: TArray<number>, CurveNames: TArray<string>, Alpha: number, ApplyMode: EModifyCurveApplyMode);
        SourcePose: PoseLink;
        CurveValues: TArray<number>;
        CurveNames: TArray<string>;
        Alpha: number;
        ApplyMode: EModifyCurveApplyMode;
    }
    
    class AnimGraphNode_ModifyCurve extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ModifyCurve;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ModifyCurve;
        static Load(InName: string): AnimGraphNode_ModifyCurve;
    }
    
    class AnimNode_MultiWayBlend extends AnimNode_Base {
        constructor(Poses: TArray<PoseLink>, DesiredAlphas: TArray<number>, AlphaScaleBias: InputScaleBias, bAdditiveNode: boolean, bNormalizeAlpha: boolean);
        Poses: TArray<PoseLink>;
        DesiredAlphas: TArray<number>;
        AlphaScaleBias: InputScaleBias;
        bAdditiveNode: boolean;
        bNormalizeAlpha: boolean;
    }
    
    class AnimGraphNode_MultiWayBlend extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_MultiWayBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_MultiWayBlend;
        static Load(InName: string): AnimGraphNode_MultiWayBlend;
    }
    
    class AnimNode_ObserveBone extends AnimNode_SkeletalControlBase {
        constructor(BoneToObserve: BoneReference, DisplaySpace: number, bRelativeToRefPose: boolean, Translation: Vector, Rotation: Rotator, Scale: Vector);
        BoneToObserve: BoneReference;
        DisplaySpace: number;
        bRelativeToRefPose: boolean;
        Translation: Vector;
        Rotation: Rotator;
        Scale: Vector;
    }
    
    class AnimGraphNode_ObserveBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ObserveBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ObserveBone;
        static Load(InName: string): AnimGraphNode_ObserveBone;
    }
    
    class AnimGraphNode_PoseHandler extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseHandler;
        static Load(InName: string): AnimGraphNode_PoseHandler;
    }
    
    class AnimNode_PoseHandler extends AnimNode_AssetPlayerBase {
        constructor(PoseAsset: PoseAsset);
        PoseAsset: PoseAsset;
    }
    
    class AnimNode_PoseBlendNode extends AnimNode_PoseHandler {
        constructor(SourcePose: PoseLink, BlendOption: EAlphaBlendOption, CustomCurve: CurveFloat);
        SourcePose: PoseLink;
        BlendOption: EAlphaBlendOption;
        CustomCurve: CurveFloat;
    }
    
    class AnimGraphNode_PoseBlendNode extends AnimGraphNode_PoseHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_PoseBlendNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseBlendNode;
        static Load(InName: string): AnimGraphNode_PoseBlendNode;
    }
    
    class AnimNode_PoseByName extends AnimNode_PoseHandler {
        constructor(PoseName: string, PoseWeight: number);
        PoseName: string;
        PoseWeight: number;
    }
    
    class AnimGraphNode_PoseByName extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_PoseByName;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseByName;
        static Load(InName: string): AnimGraphNode_PoseByName;
    }
    
    class PoseDriverTransform {
        constructor(TargetTranslation: Vector, TargetRotation: Rotator);
        TargetTranslation: Vector;
        TargetRotation: Rotator;
    }
    
    enum ERBFDistanceMethod { Euclidean, Quaternion, SwingAngle, DefaultMethod, ERBFDistanceMethod_MAX}
    enum ERBFFunctionType { Gaussian, Exponential, Linear, Cubic, Quintic, DefaultFunction, ERBFFunctionType_MAX}
    class PoseDriverTarget {
        constructor(BoneTransforms: TArray<PoseDriverTransform>, TargetRotation: Rotator, TargetScale: number, DistanceMethod: ERBFDistanceMethod, FunctionType: ERBFFunctionType, bApplyCustomCurve: boolean, CustomCurve: RichCurve, DrivenName: string, bIsHidden: boolean);
        BoneTransforms: TArray<PoseDriverTransform>;
        TargetRotation: Rotator;
        TargetScale: number;
        DistanceMethod: ERBFDistanceMethod;
        FunctionType: ERBFFunctionType;
        bApplyCustomCurve: boolean;
        CustomCurve: RichCurve;
        DrivenName: string;
        bIsHidden: boolean;
    }
    
    enum ERBFNormalizeMethod { OnlyNormalizeAboveOne, AlwaysNormalize, NormalizeWithinMedian, ERBFNormalizeMethod_MAX}
    class RBFParams {
        constructor(TargetDimensions: number, Radius: number, Function: ERBFFunctionType, DistanceMethod: ERBFDistanceMethod, TwistAxis: number, WeightThreshold: number, NormalizeMethod: ERBFNormalizeMethod, MedianReference: Vector, MedianMin: number, MedianMax: number);
        TargetDimensions: number;
        Radius: number;
        Function: ERBFFunctionType;
        DistanceMethod: ERBFDistanceMethod;
        TwistAxis: number;
        WeightThreshold: number;
        NormalizeMethod: ERBFNormalizeMethod;
        MedianReference: Vector;
        MedianMin: number;
        MedianMax: number;
    }
    
    enum EPoseDriverType { SwingAndTwist, SwingOnly, Translation, EPoseDriverType_MAX}
    enum EPoseDriverSource { Rotation, Translation, EPoseDriverSource_MAX}
    enum EPoseDriverOutput { DrivePoses, DriveCurves, EPoseDriverOutput_MAX}
    class AnimNode_PoseDriver extends AnimNode_PoseHandler {
        constructor(SourcePose: PoseLink, SourceBones: TArray<BoneReference>, OnlyDriveBones: TArray<BoneReference>, PoseTargets: TArray<PoseDriverTarget>, EvalSpaceBone: BoneReference, RBFParams: RBFParams, SourceBone: BoneReference, TwistAxis: number, Type: EPoseDriverType, RadialScaling: number, DriveSource: EPoseDriverSource, DriveOutput: EPoseDriverOutput, bOnlyDriveSelectedBones: boolean);
        SourcePose: PoseLink;
        SourceBones: TArray<BoneReference>;
        OnlyDriveBones: TArray<BoneReference>;
        PoseTargets: TArray<PoseDriverTarget>;
        EvalSpaceBone: BoneReference;
        RBFParams: RBFParams;
        SourceBone: BoneReference;
        TwistAxis: number;
        Type: EPoseDriverType;
        RadialScaling: number;
        DriveSource: EPoseDriverSource;
        DriveOutput: EPoseDriverOutput;
        bOnlyDriveSelectedBones: boolean;
    }
    
    class AnimGraphNode_PoseDriver extends AnimGraphNode_PoseHandler {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_PoseDriver;
        AxisLength: number;
        ConeSubdivision: number;
        bDrawDebugCones: boolean;
        LastPreviewComponent: SkeletalMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseDriver;
        static Load(InName: string): AnimGraphNode_PoseDriver;
    }
    
    enum ESnapshotSourceMode { NamedSnapshot, SnapshotPin, ESnapshotSourceMode_MAX}
    class AnimNode_PoseSnapshot extends AnimNode_Base {
        constructor(SnapshotName: string, Snapshot: PoseSnapshot, Mode: ESnapshotSourceMode);
        SnapshotName: string;
        Snapshot: PoseSnapshot;
        Mode: ESnapshotSourceMode;
    }
    
    class AnimGraphNode_PoseSnapshot extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_PoseSnapshot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_PoseSnapshot;
        static Load(InName: string): AnimGraphNode_PoseSnapshot;
    }
    
    class RandomPlayerSequenceEntry {
        constructor(Sequence: AnimSequence, ChanceToPlay: number, MinLoopCount: number, MaxLoopCount: number, MinPlayRate: number, MaxPlayRate: number, BlendIn: AlphaBlend);
        Sequence: AnimSequence;
        ChanceToPlay: number;
        MinLoopCount: number;
        MaxLoopCount: number;
        MinPlayRate: number;
        MaxPlayRate: number;
        BlendIn: AlphaBlend;
    }
    
    class AnimNode_RandomPlayer extends AnimNode_Base {
        constructor(Entries: TArray<RandomPlayerSequenceEntry>, bShuffleMode: boolean);
        Entries: TArray<RandomPlayerSequenceEntry>;
        bShuffleMode: boolean;
    }
    
    class AnimGraphNode_RandomPlayer extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RandomPlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RandomPlayer;
        static Load(InName: string): AnimGraphNode_RandomPlayer;
    }
    
    class AnimNode_ResetRoot extends AnimNode_SkeletalControlBase {
        constructor();
    }
    
    class AnimGraphNode_ResetRoot extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ResetRoot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ResetRoot;
        static Load(InName: string): AnimGraphNode_ResetRoot;
    }
    
    enum ESimulationSpace { ComponentSpace, WorldSpace, BaseBoneSpace, ESimulationSpace_MAX}
    class AnimNode_RigidBody extends AnimNode_SkeletalControlBase {
        constructor(OverridePhysicsAsset: PhysicsAsset, OverrideWorldGravity: Vector, ExternalForce: Vector, ComponentLinearAccScale: Vector, ComponentLinearVelScale: Vector, ComponentAppliedLinearAccClamp: Vector, CachedBoundsScale: number, BaseBoneRef: BoneReference, OverlapChannel: number, SimulationSpace: ESimulationSpace, bForceDisableCollisionBetweenConstraintBodies: boolean, bEnableWorldGeometry: boolean, bOverrideWorldGravity: boolean, bTransferBoneVelocities: boolean, bFreezeIncomingPoseOnStart: boolean, bClampLinearTranslationLimitToRefPose: boolean, bComponentSpaceSimulation: boolean);
        OverridePhysicsAsset: PhysicsAsset;
        OverrideWorldGravity: Vector;
        ExternalForce: Vector;
        ComponentLinearAccScale: Vector;
        ComponentLinearVelScale: Vector;
        ComponentAppliedLinearAccClamp: Vector;
        CachedBoundsScale: number;
        BaseBoneRef: BoneReference;
        OverlapChannel: number;
        SimulationSpace: ESimulationSpace;
        bForceDisableCollisionBetweenConstraintBodies: boolean;
        bEnableWorldGeometry: boolean;
        bOverrideWorldGravity: boolean;
        bTransferBoneVelocities: boolean;
        bFreezeIncomingPoseOnStart: boolean;
        bClampLinearTranslationLimitToRefPose: boolean;
        bComponentSpaceSimulation: boolean;
    }
    
    class AnimGraphNode_RigidBody extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RigidBody;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RigidBody;
        static Load(InName: string): AnimGraphNode_RigidBody;
    }
    
    class AnimNode_RigidBody_Chaos extends AnimNode_SkeletalControlBase {
        constructor(OverridePhysicsAsset: PhysicsAsset, OverrideWorldGravity: Vector, ExternalForce: Vector, ComponentLinearAccScale: Vector, ComponentLinearVelScale: Vector, ComponentAppliedLinearAccClamp: Vector, CachedBoundsScale: number, BaseBoneRef: BoneReference, OverlapChannel: number, SimulationSpace: ESimulationSpace, bForceDisableCollisionBetweenConstraintBodies: boolean, bEnableWorldGeometry: boolean, bOverrideWorldGravity: boolean, bTransferBoneVelocities: boolean, bFreezeIncomingPoseOnStart: boolean, bClampLinearTranslationLimitToRefPose: boolean, bComponentSpaceSimulation: boolean);
        OverridePhysicsAsset: PhysicsAsset;
        OverrideWorldGravity: Vector;
        ExternalForce: Vector;
        ComponentLinearAccScale: Vector;
        ComponentLinearVelScale: Vector;
        ComponentAppliedLinearAccClamp: Vector;
        CachedBoundsScale: number;
        BaseBoneRef: BoneReference;
        OverlapChannel: number;
        SimulationSpace: ESimulationSpace;
        bForceDisableCollisionBetweenConstraintBodies: boolean;
        bEnableWorldGeometry: boolean;
        bOverrideWorldGravity: boolean;
        bTransferBoneVelocities: boolean;
        bFreezeIncomingPoseOnStart: boolean;
        bClampLinearTranslationLimitToRefPose: boolean;
        bComponentSpaceSimulation: boolean;
    }
    
    class AnimGraphNode_RigidBody_Chaos extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RigidBody_Chaos;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RigidBody_Chaos;
        static Load(InName: string): AnimGraphNode_RigidBody_Chaos;
    }
    
    class AnimGraphNode_Root extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_Root;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Root;
        static Load(InName: string): AnimGraphNode_Root;
    }
    
    class AnimNode_RotateRootBone extends AnimNode_Base {
        constructor(BasePose: PoseLink, Pitch: number, Yaw: number, PitchScaleBiasClamp: InputScaleBiasClamp, YawScaleBiasClamp: InputScaleBiasClamp, MeshToComponent: Rotator);
        BasePose: PoseLink;
        Pitch: number;
        Yaw: number;
        PitchScaleBiasClamp: InputScaleBiasClamp;
        YawScaleBiasClamp: InputScaleBiasClamp;
        MeshToComponent: Rotator;
    }
    
    class AnimGraphNode_RotateRootBone extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RotateRootBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotateRootBone;
        static Load(InName: string): AnimGraphNode_RotateRootBone;
    }
    
    class AnimNode_RotationMultiplier extends AnimNode_SkeletalControlBase {
        constructor(TargetBone: BoneReference, SourceBone: BoneReference, Multiplier: number, RotationAxisToRefer: number, bIsAdditive: boolean);
        TargetBone: BoneReference;
        SourceBone: BoneReference;
        Multiplier: number;
        RotationAxisToRefer: number;
        bIsAdditive: boolean;
    }
    
    class AnimGraphNode_RotationMultiplier extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RotationMultiplier;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotationMultiplier;
        static Load(InName: string): AnimGraphNode_RotationMultiplier;
    }
    
    class AnimNode_RotationOffsetBlendSpace extends AnimNode_BlendSpacePlayer {
        constructor(BasePose: PoseLink, LODThreshold: number, Alpha: number, AlphaScaleBias: InputScaleBias, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean);
        BasePose: PoseLink;
        LODThreshold: number;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
    }
    
    class AnimGraphNode_RotationOffsetBlendSpace extends AnimGraphNode_BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_RotationOffsetBlendSpace;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_RotationOffsetBlendSpace;
        static Load(InName: string): AnimGraphNode_RotationOffsetBlendSpace;
    }
    
    class AnimNode_SaveCachedPose extends AnimNode_Base {
        constructor(Pose: PoseLink, CachePoseName: string);
        Pose: PoseLink;
        CachePoseName: string;
    }
    
    class AnimGraphNode_SaveCachedPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SaveCachedPose;
        CacheName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SaveCachedPose;
        static Load(InName: string): AnimGraphNode_SaveCachedPose;
    }
    
    enum EScaleChainInitialLength { FixedDefaultLengthValue, Distance, ChainLength, EScaleChainInitialLength_MAX}
    class AnimNode_ScaleChainLength extends AnimNode_Base {
        constructor(InputPose: PoseLink, DefaultChainLength: number, ChainStartBone: BoneReference, ChainEndBone: BoneReference, TargetLocation: Vector, Alpha: number, AlphaScaleBias: InputScaleBias, ChainInitialLength: EScaleChainInitialLength);
        InputPose: PoseLink;
        DefaultChainLength: number;
        ChainStartBone: BoneReference;
        ChainEndBone: BoneReference;
        TargetLocation: Vector;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        ChainInitialLength: EScaleChainInitialLength;
    }
    
    class AnimGraphNode_ScaleChainLength extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_ScaleChainLength;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_ScaleChainLength;
        static Load(InName: string): AnimGraphNode_ScaleChainLength;
    }
    
    class AnimNode_SequenceEvaluator extends AnimNode_AssetPlayerBase {
        constructor(Sequence: AnimSequenceBase, ExplicitTime: number, bShouldLoop: boolean, bTeleportToExplicitTime: boolean, ReinitializationBehavior: number, StartPosition: number);
        Sequence: AnimSequenceBase;
        ExplicitTime: number;
        bShouldLoop: boolean;
        bTeleportToExplicitTime: boolean;
        ReinitializationBehavior: number;
        StartPosition: number;
    }
    
    class AnimGraphNode_SequenceEvaluator extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SequenceEvaluator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SequenceEvaluator;
        static Load(InName: string): AnimGraphNode_SequenceEvaluator;
    }
    
    class AnimNode_SequencePlayer extends AnimNode_AssetPlayerBase {
        constructor(Sequence: AnimSequenceBase, PlayRateBasis: number, PlayRate: number, PlayRateScaleBiasClamp: InputScaleBiasClamp, StartPosition: number, bLoopAnimation: boolean);
        Sequence: AnimSequenceBase;
        PlayRateBasis: number;
        PlayRate: number;
        PlayRateScaleBiasClamp: InputScaleBiasClamp;
        StartPosition: number;
        bLoopAnimation: boolean;
    }
    
    class AnimGraphNode_SequencePlayer extends AnimGraphNode_AssetPlayerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SequencePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SequencePlayer;
        static Load(InName: string): AnimGraphNode_SequencePlayer;
    }
    
    class AnimNode_Slot extends AnimNode_Base {
        constructor(Source: PoseLink, SlotName: string, bAlwaysUpdateSourcePose: boolean);
        Source: PoseLink;
        SlotName: string;
        bAlwaysUpdateSourcePose: boolean;
    }
    
    class AnimGraphNode_Slot extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_Slot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Slot;
        static Load(InName: string): AnimGraphNode_Slot;
    }
    
    enum ESplineBoneAxis { None, X, Y, Z, ESplineBoneAxis_MAX}
    class AnimNode_SplineIK extends AnimNode_SkeletalControlBase {
        constructor(StartBone: BoneReference, EndBone: BoneReference, BoneAxis: ESplineBoneAxis, bAutoCalculateSpline: boolean, PointCount: number, ControlPoints: TArray<Transform>, Roll: number, TwistStart: number, TwistEnd: number, TwistBlend: AlphaBlend, Stretch: number, Offset: number);
        StartBone: BoneReference;
        EndBone: BoneReference;
        BoneAxis: ESplineBoneAxis;
        bAutoCalculateSpline: boolean;
        PointCount: number;
        ControlPoints: TArray<Transform>;
        Roll: number;
        TwistStart: number;
        TwistEnd: number;
        TwistBlend: AlphaBlend;
        Stretch: number;
        Offset: number;
    }
    
    class AnimGraphNode_SplineIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SplineIK;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SplineIK;
        static Load(InName: string): AnimGraphNode_SplineIK;
    }
    
    class AnimNode_SpringBone extends AnimNode_SkeletalControlBase {
        constructor(SpringBone: BoneReference, MaxDisplacement: number, SpringStiffness: number, SpringDamping: number, ErrorResetThresh: number, bNoZSpring: boolean, bLimitDisplacement: boolean, bTranslateX: boolean, bTranslateY: boolean, bTranslateZ: boolean, bRotateX: boolean, bRotateY: boolean, bRotateZ: boolean);
        SpringBone: BoneReference;
        MaxDisplacement: number;
        SpringStiffness: number;
        SpringDamping: number;
        ErrorResetThresh: number;
        bNoZSpring: boolean;
        bLimitDisplacement: boolean;
        bTranslateX: boolean;
        bTranslateY: boolean;
        bTranslateZ: boolean;
        bRotateX: boolean;
        bRotateY: boolean;
        bRotateZ: boolean;
    }
    
    class AnimGraphNode_SpringBone extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SpringBone;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SpringBone;
        static Load(InName: string): AnimGraphNode_SpringBone;
    }
    
    class AnimNode_StateMachine extends AnimNode_Base {
        constructor(StateMachineIndexInClass: number, MaxTransitionsPerFrame: number, bSkipFirstUpdateTransition: boolean, bReinitializeOnBecomingRelevant: boolean);
        StateMachineIndexInClass: number;
        MaxTransitionsPerFrame: number;
        bSkipFirstUpdateTransition: boolean;
        bReinitializeOnBecomingRelevant: boolean;
    }
    
    class AnimGraphNode_StateMachine extends AnimGraphNode_StateMachineBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_StateMachine;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_StateMachine;
        static Load(InName: string): AnimGraphNode_StateMachine;
    }
    
    class RotationLimit {
        constructor(LimitMin: Vector, LimitMax: Vector);
        LimitMin: Vector;
        LimitMax: Vector;
    }
    
    class AnimNode_Trail extends AnimNode_SkeletalControlBase {
        constructor(TrailBone: BoneReference, ChainLength: number, ChainBoneAxis: number, bInvertChainBoneAxis: boolean, bLimitStretch: boolean, bLimitRotation: boolean, bUsePlanarLimit: boolean, bActorSpaceFakeVel: boolean, bReorientParentToChild: boolean, bEnableDebug: boolean, bShowBaseMotion: boolean, bShowTrailLocation: boolean, bShowLimit: boolean, DebugLifeTime: number, TrailRelaxation: number, MaxDeltaTime: number, RelaxationSpeedScale: number, TrailRelaxationSpeed: RuntimeFloatCurve, RelaxationSpeedScaleInputProcessor: InputScaleBiasClamp, RotationLimits: TArray<RotationLimit>, RotationOffsets: TArray<Vector>, PlanarLimits: TArray<AnimPhysPlanarLimit>, StretchLimit: number, FakeVelocity: Vector, BaseJoint: BoneReference, TrailBoneRotationBlendAlpha: number, LastBoneRotationAnimAlphaBlend: number);
        TrailBone: BoneReference;
        ChainLength: number;
        ChainBoneAxis: number;
        bInvertChainBoneAxis: boolean;
        bLimitStretch: boolean;
        bLimitRotation: boolean;
        bUsePlanarLimit: boolean;
        bActorSpaceFakeVel: boolean;
        bReorientParentToChild: boolean;
        bEnableDebug: boolean;
        bShowBaseMotion: boolean;
        bShowTrailLocation: boolean;
        bShowLimit: boolean;
        DebugLifeTime: number;
        TrailRelaxation: number;
        MaxDeltaTime: number;
        RelaxationSpeedScale: number;
        TrailRelaxationSpeed: RuntimeFloatCurve;
        RelaxationSpeedScaleInputProcessor: InputScaleBiasClamp;
        RotationLimits: TArray<RotationLimit>;
        RotationOffsets: TArray<Vector>;
        PlanarLimits: TArray<AnimPhysPlanarLimit>;
        StretchLimit: number;
        FakeVelocity: Vector;
        BaseJoint: BoneReference;
        TrailBoneRotationBlendAlpha: number;
        LastBoneRotationAnimAlphaBlend: number;
    }
    
    class AnimGraphNode_Trail extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_Trail;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_Trail;
        static Load(InName: string): AnimGraphNode_Trail;
    }
    
    class AnimNode_TransitionPoseEvaluator extends AnimNode_Base {
        constructor(FramesToCachePose: number, DataSource: number, EvaluatorMode: number);
        FramesToCachePose: number;
        DataSource: number;
        EvaluatorMode: number;
    }
    
    class AnimGraphNode_TransitionPoseEvaluator extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_TransitionPoseEvaluator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TransitionPoseEvaluator;
        static Load(InName: string): AnimGraphNode_TransitionPoseEvaluator;
    }
    
    class ReferenceBoneFrame {
        constructor(Bone: BoneReference, Axis: Axis);
        Bone: BoneReference;
        Axis: Axis;
    }
    
    class AnimCurveParam {
        constructor(Name: string);
        Name: string;
    }
    
    class AnimNode_TwistCorrectiveNode extends AnimNode_SkeletalControlBase {
        constructor(BaseFrame: ReferenceBoneFrame, TwistFrame: ReferenceBoneFrame, TwistPlaneNormalAxis: Axis, RangeMax: number, RemappedMin: number, RemappedMax: number, Curve: AnimCurveParam);
        BaseFrame: ReferenceBoneFrame;
        TwistFrame: ReferenceBoneFrame;
        TwistPlaneNormalAxis: Axis;
        RangeMax: number;
        RemappedMin: number;
        RemappedMax: number;
        Curve: AnimCurveParam;
    }
    
    class AnimGraphNode_TwistCorrectiveNode extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_TwistCorrectiveNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwistCorrectiveNode;
        static Load(InName: string): AnimGraphNode_TwistCorrectiveNode;
    }
    
    class AnimNode_TwoBoneIK extends AnimNode_SkeletalControlBase {
        constructor(IKBone: BoneReference, StartStretchRatio: number, MaxStretchScale: number, StretchLimits: Vector2D, bNoTwist: boolean, JointTargetSpaceBoneName: string, EffectorSpaceBoneName: string, EffectorLocation: Vector, EffectorTarget: BoneSocketTarget, JointTargetLocation: Vector, JointTarget: BoneSocketTarget, TwistAxis: Axis, EffectorLocationSpace: number, JointTargetLocationSpace: number, bAllowStretching: boolean, bTakeRotationFromEffectorSpace: boolean, bMaintainEffectorRelRot: boolean, bAllowTwist: boolean);
        IKBone: BoneReference;
        StartStretchRatio: number;
        MaxStretchScale: number;
        StretchLimits: Vector2D;
        bNoTwist: boolean;
        JointTargetSpaceBoneName: string;
        EffectorSpaceBoneName: string;
        EffectorLocation: Vector;
        EffectorTarget: BoneSocketTarget;
        JointTargetLocation: Vector;
        JointTarget: BoneSocketTarget;
        TwistAxis: Axis;
        EffectorLocationSpace: number;
        JointTargetLocationSpace: number;
        bAllowStretching: boolean;
        bTakeRotationFromEffectorSpace: boolean;
        bMaintainEffectorRelRot: boolean;
        bAllowTwist: boolean;
    }
    
    class AnimGraphNode_TwoBoneIK extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_TwoBoneIK;
        bEnableDebugDraw: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwoBoneIK;
        static Load(InName: string): AnimGraphNode_TwoBoneIK;
    }
    
    class AnimNode_TwoWayBlend extends AnimNode_Base {
        constructor(A: PoseLink, B: PoseLink, AlphaInputType: EAnimAlphaInputType, bAlphaBoolEnabled: boolean, bResetChildOnActivation: boolean, Alpha: number, AlphaScaleBias: InputScaleBias, AlphaBoolBlend: InputAlphaBoolBlend, AlphaCurveName: string, AlphaScaleBiasClamp: InputScaleBiasClamp);
        A: PoseLink;
        B: PoseLink;
        AlphaInputType: EAnimAlphaInputType;
        bAlphaBoolEnabled: boolean;
        bResetChildOnActivation: boolean;
        Alpha: number;
        AlphaScaleBias: InputScaleBias;
        AlphaBoolBlend: InputAlphaBoolBlend;
        AlphaCurveName: string;
        AlphaScaleBiasClamp: InputScaleBiasClamp;
    }
    
    class AnimGraphNode_TwoWayBlend extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendNode: AnimNode_TwoWayBlend;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_TwoWayBlend;
        static Load(InName: string): AnimGraphNode_TwoWayBlend;
    }
    
    class AnimNode_UseCachedPose extends AnimNode_Base {
        constructor(LinkToCachingNode: PoseLink, CachePoseName: string);
        LinkToCachingNode: PoseLink;
        CachePoseName: string;
    }
    
    class AnimGraphNode_UseCachedPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_UseCachedPose;
        SaveCachedPoseNode: TWeakObjectPtr<AnimGraphNode_SaveCachedPose>;
        NameOfCache: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_UseCachedPose;
        static Load(InName: string): AnimGraphNode_UseCachedPose;
    }
    
    class AnimCustomInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCustomInstance;
        static Load(InName: string): AnimCustomInstance;
    }
    
    class AnimPreviewAttacheInstance extends AnimCustomInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimPreviewAttacheInstance;
        static Load(InName: string): AnimPreviewAttacheInstance;
    }
    
    class AnimSingleNodeInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentAsset: AnimationAsset;
        PostEvaluateAnimEvent: $Delegate<() => void>;
        StopAnim(): void;
        SetReverse(bInReverse: boolean): void;
        SetPreviewCurveOverride(PoseName: string, Value: number, bRemoveIfZero: boolean): void;
        SetPositionWithPreviousTime(InPosition: number, InPreviousTime: number, bFireNotifies: boolean): void;
        SetPosition(InPosition: number, bFireNotifies: boolean): void;
        SetPlayRate(InPlayRate: number): void;
        SetPlaying(bIsPlaying: boolean): void;
        SetLooping(bIsLooping: boolean): void;
        SetBlendSpaceInput(InBlendInput: Vector): void;
        SetAnimationAsset(NewAsset: AnimationAsset, bIsLooping: boolean, InPlayRate: number): void;
        PlayAnim(bIsLooping: boolean, InPlayRate: number, InStartPosition: number): void;
        GetLength(): number;
        GetAnimationAsset(): AnimationAsset;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSingleNodeInstance;
        static Load(InName: string): AnimSingleNodeInstance;
    }
    
    class AnimPreviewInstance extends AnimSingleNodeInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MontagePreviewType: number;
        MontagePreviewStartSectionIdx: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimPreviewInstance;
        static Load(InName: string): AnimPreviewInstance;
    }
    
    class AnimStateNodeBase extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateNodeBase;
        static Load(InName: string): AnimStateNodeBase;
    }
    
    class AnimStateConduitNode extends AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: EdGraph;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateConduitNode;
        static Load(InName: string): AnimStateConduitNode;
    }
    
    class AnimStateNode extends AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: EdGraph;
        StateType: number;
        StateEntered: AnimNotifyEvent;
        StateLeft: AnimNotifyEvent;
        StateFullyBlended: AnimNotifyEvent;
        bAlwaysResetOnEntry: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateNode;
        static Load(InName: string): AnimStateNode;
    }
    
    class AnimStateTransitionNode extends AnimStateNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: EdGraph;
        CustomTransitionGraph: EdGraph;
        PriorityOrder: number;
        CrossfadeDuration: number;
        CrossfadeMode: number;
        BlendMode: EAlphaBlendOption;
        CustomBlendCurve: CurveFloat;
        BlendProfile: BlendProfile;
        bAutomaticRuleBasedOnSequencePlayerInState: boolean;
        LogicType: number;
        TransitionStart: AnimNotifyEvent;
        TransitionEnd: AnimNotifyEvent;
        TransitionInterrupt: AnimNotifyEvent;
        Bidirectional: boolean;
        bSharedRules: boolean;
        bSharedCrossfade: boolean;
        SharedRulesName: string;
        SharedRulesGuid: Guid;
        SharedColor: LinearColor;
        SharedCrossfadeName: string;
        SharedCrossfadeGuid: Guid;
        SharedCrossfadeIdx: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateTransitionNode;
        static Load(InName: string): AnimStateTransitionNode;
    }
    
    class K2Node_AnimGetter extends K2Node_CallFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceNode: AnimGraphNode_Base;
        SourceStateNode: AnimStateNodeBase;
        GetterClass: Class;
        SourceAnimBlueprint: AnimBlueprint;
        CachedTitle: string;
        Contexts: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AnimGetter;
        static Load(InName: string): K2Node_AnimGetter;
    }
    
    class K2Node_PlayMontage extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PlayMontage;
        static Load(InName: string): K2Node_PlayMontage;
    }
    
    class K2Node_TransitionRuleGetter extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetterType: number;
        AssociatedAnimAssetPlayerNode: AnimGraphNode_Base;
        AssociatedStateNode: AnimStateNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_TransitionRuleGetter;
        static Load(InName: string): K2Node_TransitionRuleGetter;
    }
    
    class Texture2DDynamic extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DDynamic;
        static Load(InName: string): Texture2DDynamic;
    }
    
    class AsyncTaskDownloadImage extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(Texture: Texture2DDynamic) => void>;
        OnFail: $MulticastDelegate<(Texture: Texture2DDynamic) => void>;
        static DownloadImage(URL: string): AsyncTaskDownloadImage;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncTaskDownloadImage;
        static Load(InName: string): AsyncTaskDownloadImage;
    }
    
    class ContentWidget extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetContent(Content: Widget): PanelSlot;
        GetContentSlot(): PanelSlot;
        GetContent(): Widget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentWidget;
        static Load(InName: string): ContentWidget;
    }
    
    class BackgroundBlur extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        bApplyAlphaToBlur: boolean;
        BlurStrength: number;
        bOverrideAutoRadiusCalculation: boolean;
        BlurRadius: number;
        LowQualityFallbackBrush: SlateBrush;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetLowQualityFallbackBrush(InBrush: SlateBrush): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        SetBlurStrength(InStrength: number): void;
        SetBlurRadius(InBlurRadius: number): void;
        SetApplyAlphaToBlur(bInApplyAlphaToBlur: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BackgroundBlur;
        static Load(InName: string): BackgroundBlur;
    }
    
    class BackgroundBlurSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BackgroundBlurSlot;
        static Load(InName: string): BackgroundBlurSlot;
    }
    
    class BoolBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoolBinding;
        static Load(InName: string): BoolBinding;
    }
    
    class SlateBrushAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Brush: SlateBrush;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBrushAsset;
        static Load(InName: string): SlateBrushAsset;
    }
    
    class Border extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HorizontalAlignment: number;
        VerticalAlignment: number;
        bShowEffectWhenDisabled: boolean;
        ContentColorAndOpacity: LinearColor;
        ContentColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        Padding: Margin;
        Background: SlateBrush;
        BackgroundDelegate: $Delegate<() => SlateBrush>;
        BrushColor: LinearColor;
        BrushColorDelegate: $Delegate<() => LinearColor>;
        DesiredSizeScale: Vector2D;
        bFlipForRightToLeftFlowDirection: boolean;
        OnMouseButtonDownEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        OnMouseButtonUpEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        OnMouseMoveEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        OnMouseDoubleClickEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        Brush: SlateBrushAsset;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        SetDesiredSizeScale(InScale: Vector2D): void;
        SetContentColorAndOpacity(InContentColorAndOpacity: LinearColor): void;
        SetBrushFromTexture(Texture: Texture2D): void;
        SetBrushFromMaterial(Material: MaterialInterface): void;
        SetBrushFromAsset(Asset: SlateBrushAsset): void;
        SetBrushColor(InBrushColor: LinearColor): void;
        SetBrush(InBrush: SlateBrush): void;
        GetDynamicMaterial(): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Border;
        static Load(InName: string): Border;
    }
    
    class BorderSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BorderSlot;
        static Load(InName: string): BorderSlot;
    }
    
    class BrushBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): SlateBrush;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushBinding;
        static Load(InName: string): BrushBinding;
    }
    
    class Button extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Style: SlateWidgetStyleAsset;
        WidgetStyle: ButtonStyle;
        ColorAndOpacity: LinearColor;
        BackgroundColor: LinearColor;
        ClickMethod: number;
        TouchMethod: number;
        PressMethod: number;
        IsFocusable: boolean;
        OnClicked: $MulticastDelegate<() => void>;
        OnPressed: $MulticastDelegate<() => void>;
        OnReleased: $MulticastDelegate<() => void>;
        OnHovered: $MulticastDelegate<() => void>;
        OnUnhovered: $MulticastDelegate<() => void>;
        SetTouchMethod(InTouchMethod: number): void;
        SetStyle(InStyle: ButtonStyle): void;
        SetPressMethod(InPressMethod: number): void;
        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
        SetClickMethod(InClickMethod: number): void;
        SetBackgroundColor(InBackgroundColor: LinearColor): void;
        IsPressed(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Button;
        static Load(InName: string): Button;
    }
    
    class ButtonSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ButtonSlot;
        static Load(InName: string): ButtonSlot;
    }
    
    class AnchorData {
        constructor(Offsets: Margin, Anchors: Anchors, Alignment: Vector2D);
        Offsets: Margin;
        Anchors: Anchors;
        Alignment: Vector2D;
    }
    
    class CanvasPanelSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayoutData: AnchorData;
        bAutoSize: boolean;
        ZOrder: number;
        SetZOrder(InZOrder: number): void;
        SetSize(InSize: Vector2D): void;
        SetPosition(InPosition: Vector2D): void;
        SetOffsets(InOffset: Margin): void;
        SetMinimum(InMinimumAnchors: Vector2D): void;
        SetMaximum(InMaximumAnchors: Vector2D): void;
        SetLayout(InLayoutData: AnchorData): void;
        SetAutoSize(InbAutoSize: boolean): void;
        SetAnchors(InAnchors: Anchors): void;
        SetAlignment(InAlignment: Vector2D): void;
        GetZOrder(): number;
        GetSize(): Vector2D;
        GetPosition(): Vector2D;
        GetOffsets(): Margin;
        GetLayout(): AnchorData;
        GetAutoSize(): boolean;
        GetAnchors(): Anchors;
        GetAlignment(): Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasPanelSlot;
        static Load(InName: string): CanvasPanelSlot;
    }
    
    class CanvasPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToCanvas(Content: Widget): CanvasPanelSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasPanel;
        static Load(InName: string): CanvasPanel;
    }
    
    class CheckBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CheckedState: ECheckBoxState;
        CheckedStateDelegate: $Delegate<() => ECheckBoxState>;
        WidgetStyle: CheckBoxStyle;
        Style: SlateWidgetStyleAsset;
        UncheckedImage: SlateBrushAsset;
        UncheckedHoveredImage: SlateBrushAsset;
        UncheckedPressedImage: SlateBrushAsset;
        CheckedImage: SlateBrushAsset;
        CheckedHoveredImage: SlateBrushAsset;
        CheckedPressedImage: SlateBrushAsset;
        UndeterminedImage: SlateBrushAsset;
        UndeterminedHoveredImage: SlateBrushAsset;
        UndeterminedPressedImage: SlateBrushAsset;
        HorizontalAlignment: number;
        Padding: Margin;
        BorderBackgroundColor: SlateColor;
        IsFocusable: boolean;
        OnCheckStateChanged: $MulticastDelegate<(bIsChecked: boolean) => void>;
        SetIsChecked(InIsChecked: boolean): void;
        SetCheckedState(InCheckedState: ECheckBoxState): void;
        IsPressed(): boolean;
        IsChecked(): boolean;
        GetCheckedState(): ECheckBoxState;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckBox;
        static Load(InName: string): CheckBox;
    }
    
    class CheckedStateBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): ECheckBoxState;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckedStateBinding;
        static Load(InName: string): CheckedStateBinding;
    }
    
    class CircularThrobber extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPieces: number;
        Period: number;
        Radius: number;
        PieceImage: SlateBrushAsset;
        Image: SlateBrush;
        bEnableRadius: boolean;
        SetRadius(InRadius: number): void;
        SetPeriod(InPeriod: number): void;
        SetNumberOfPieces(InNumberOfPieces: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CircularThrobber;
        static Load(InName: string): CircularThrobber;
    }
    
    class ColorBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetSlateValue(): SlateColor;
        GetLinearValue(): LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ColorBinding;
        static Load(InName: string): ColorBinding;
    }
    
    class ComboBox extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Items: TArray<Object>;
        OnGenerateWidgetEvent: $Delegate<(Item: Object) => Widget>;
        bIsFocusable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboBox;
        static Load(InName: string): ComboBox;
    }
    
    class TableRowStyle extends SlateWidgetStyle {
        constructor(SelectorFocusedBrush: SlateBrush, ActiveHoveredBrush: SlateBrush, ActiveBrush: SlateBrush, InactiveHoveredBrush: SlateBrush, InactiveBrush: SlateBrush, EvenRowBackgroundHoveredBrush: SlateBrush, EvenRowBackgroundBrush: SlateBrush, OddRowBackgroundHoveredBrush: SlateBrush, OddRowBackgroundBrush: SlateBrush, TextColor: SlateColor, SelectedTextColor: SlateColor, DropIndicator_Above: SlateBrush, DropIndicator_Onto: SlateBrush, DropIndicator_Below: SlateBrush, ActiveHighlightedBrush: SlateBrush, InactiveHighlightedBrush: SlateBrush);
        SelectorFocusedBrush: SlateBrush;
        ActiveHoveredBrush: SlateBrush;
        ActiveBrush: SlateBrush;
        InactiveHoveredBrush: SlateBrush;
        InactiveBrush: SlateBrush;
        EvenRowBackgroundHoveredBrush: SlateBrush;
        EvenRowBackgroundBrush: SlateBrush;
        OddRowBackgroundHoveredBrush: SlateBrush;
        OddRowBackgroundBrush: SlateBrush;
        TextColor: SlateColor;
        SelectedTextColor: SlateColor;
        DropIndicator_Above: SlateBrush;
        DropIndicator_Onto: SlateBrush;
        DropIndicator_Below: SlateBrush;
        ActiveHighlightedBrush: SlateBrush;
        InactiveHighlightedBrush: SlateBrush;
    }
    
    class ComboBoxString extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultOptions: TArray<string>;
        SelectedOption: string;
        WidgetStyle: ComboBoxStyle;
        ItemStyle: TableRowStyle;
        ContentPadding: Margin;
        MaxListHeight: number;
        HasDownArrow: boolean;
        EnableGamepadNavigationMode: boolean;
        Font: SlateFontInfo;
        ForegroundColor: SlateColor;
        bIsFocusable: boolean;
        OnGenerateWidgetEvent: $Delegate<(Item: string) => Widget>;
        OnSelectionChanged: $MulticastDelegate<(SelectedItem: string, SelectionType: number) => void>;
        OnOpening: $MulticastDelegate<() => void>;
        SetSelectedOption(Option: string): void;
        SetSelectedIndex(Index: number): void;
        RemoveOption(Option: string): boolean;
        RefreshOptions(): void;
        OnSelectionChangedEvent__DelegateSignature(SelectedItem: string, SelectionType: number): void;
        OnOpeningEvent__DelegateSignature(): void;
        IsOpen(): boolean;
        GetSelectedOption(): string;
        GetSelectedIndex(): number;
        GetOptionCount(): number;
        GetOptionAtIndex(Index: number): string;
        FindOptionIndex(Option: string): number;
        ClearSelection(): void;
        ClearOptions(): void;
        AddOption(Option: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComboBoxString;
        static Load(InName: string): ComboBoxString;
    }
    
    enum EDynamicBoxType { Horizontal, Vertical, Wrap, Overlay, EDynamicBoxType_MAX}
    class SlateChildSize {
        constructor(Value: number, SizeRule: number);
        Value: number;
        SizeRule: number;
    }
    
    class UserWidgetPool {
        constructor(ActiveWidgets: TArray<UserWidget>, InactiveWidgets: TArray<UserWidget>);
        ActiveWidgets: TArray<UserWidget>;
        InactiveWidgets: TArray<UserWidget>;
    }
    
    class DynamicEntryBoxBase extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryBoxType: EDynamicBoxType;
        EntrySpacing: Vector2D;
        SpacingPattern: TArray<Vector2D>;
        EntrySizeRule: SlateChildSize;
        EntryHorizontalAlignment: number;
        EntryVerticalAlignment: number;
        MaxElementSize: number;
        EntryWidgetPool: UserWidgetPool;
        SetEntrySpacing(InEntrySpacing: Vector2D): void;
        GetNumEntries(): number;
        GetAllEntries(): TArray<UserWidget>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicEntryBoxBase;
        static Load(InName: string): DynamicEntryBoxBase;
    }
    
    class DynamicEntryBox extends DynamicEntryBoxBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumDesignerPreviewEntries: number;
        EntryWidgetClass: Class;
        Reset(bDeleteWidgets: boolean): void;
        RemoveEntry(EntryWidget: UserWidget): void;
        BP_CreateEntryOfClass(EntryClass: Class): UserWidget;
        BP_CreateEntry(): UserWidget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicEntryBox;
        static Load(InName: string): DynamicEntryBox;
    }
    
    class VirtualKeyboardOptions {
        constructor(bEnableAutocorrect: boolean);
        bEnableAutocorrect: boolean;
    }
    
    enum EVirtualKeyboardDismissAction { TextChangeOnDismiss, TextCommitOnAccept, TextCommitOnDismiss, EVirtualKeyboardDismissAction_MAX}
    enum ETextShapingMethod { Auto, KerningOnly, FullShaping, ETextShapingMethod_MAX}
    enum ETextFlowDirection { Auto, LeftToRight, RightToLeft, ETextFlowDirection_MAX}
    class ShapedTextOptions {
        constructor(bOverride_TextShapingMethod: boolean, bOverride_TextFlowDirection: boolean, TextShapingMethod: ETextShapingMethod, TextFlowDirection: ETextFlowDirection);
        bOverride_TextShapingMethod: boolean;
        bOverride_TextFlowDirection: boolean;
        TextShapingMethod: ETextShapingMethod;
        TextFlowDirection: ETextFlowDirection;
    }
    
    class EditableText extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextDelegate: $Delegate<() => string>;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: EditableTextStyle;
        Style: SlateWidgetStyleAsset;
        BackgroundImageSelected: SlateBrushAsset;
        BackgroundImageComposing: SlateBrushAsset;
        CaretImage: SlateBrushAsset;
        Font: SlateFontInfo;
        ColorAndOpacity: SlateColor;
        IsReadOnly: boolean;
        IsPassword: boolean;
        MinimumDesiredWidth: number;
        IsCaretMovedWhenGainFocus: boolean;
        SelectAllTextWhenFocused: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        AllowContextMenu: boolean;
        KeyboardType: number;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Justification: number;
        ShapedTextOptions: ShapedTextOptions;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: number) => void>;
        SetText(InText: string): void;
        SetJustification(InJustification: number): void;
        SetIsReadOnly(InbIsReadyOnly: boolean): void;
        SetIsPassword(InbIsPassword: boolean): void;
        SetHintText(InHintText: string): void;
        OnEditableTextCommittedEvent__DelegateSignature(Text: string, CommitMethod: number): void;
        OnEditableTextChangedEvent__DelegateSignature(Text: string): void;
        GetText(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableText;
        static Load(InName: string): EditableText;
    }
    
    class EditableTextBox extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextDelegate: $Delegate<() => string>;
        WidgetStyle: EditableTextBoxStyle;
        Style: SlateWidgetStyleAsset;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        Font: SlateFontInfo;
        ForegroundColor: LinearColor;
        BackgroundColor: LinearColor;
        ReadOnlyForegroundColor: LinearColor;
        IsReadOnly: boolean;
        IsPassword: boolean;
        MinimumDesiredWidth: number;
        Padding: Margin;
        IsCaretMovedWhenGainFocus: boolean;
        SelectAllTextWhenFocused: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        AllowContextMenu: boolean;
        KeyboardType: number;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Justification: number;
        ShapedTextOptions: ShapedTextOptions;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: number) => void>;
        SetText(InText: string): void;
        SetJustification(InJustification: number): void;
        SetIsReadOnly(bReadOnly: boolean): void;
        SetIsPassword(bIsPassword: boolean): void;
        SetHintText(InText: string): void;
        SetError(InError: string): void;
        OnEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: number): void;
        OnEditableTextBoxChangedEvent__DelegateSignature(Text: string): void;
        HasError(): boolean;
        GetText(): string;
        ClearError(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableTextBox;
        static Load(InName: string): EditableTextBox;
    }
    
    class ExpandableAreaStyle extends SlateWidgetStyle {
        constructor(CollapsedImage: SlateBrush, ExpandedImage: SlateBrush, RolloutAnimationSeconds: number);
        CollapsedImage: SlateBrush;
        ExpandedImage: SlateBrush;
        RolloutAnimationSeconds: number;
    }
    
    class ExpandableArea extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Style: ExpandableAreaStyle;
        BorderBrush: SlateBrush;
        BorderColor: SlateColor;
        bIsExpanded: boolean;
        MaxHeight: number;
        HeaderPadding: Margin;
        AreaPadding: Margin;
        OnExpansionChanged: $MulticastDelegate<(Area: ExpandableArea, bIsExpanded: boolean) => void>;
        HeaderContent: Widget;
        BodyContent: Widget;
        SetIsExpanded_Animated(IsExpanded: boolean): void;
        SetIsExpanded(IsExpanded: boolean): void;
        GetIsExpanded(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExpandableArea;
        static Load(InName: string): ExpandableArea;
    }
    
    class FloatBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatBinding;
        static Load(InName: string): FloatBinding;
    }
    
    class GridSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        Row: number;
        RowSpan: number;
        Column: number;
        ColumnSpan: number;
        Layer: number;
        Nudge: Vector2D;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetRowSpan(InRowSpan: number): void;
        SetRow(InRow: number): void;
        SetPadding(InPadding: Margin): void;
        SetNudge(InNudge: Vector2D): void;
        SetLayer(InLayer: number): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        SetColumnSpan(InColumnSpan: number): void;
        SetColumn(InColumn: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridSlot;
        static Load(InName: string): GridSlot;
    }
    
    class GridPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColumnFill: TArray<number>;
        RowFill: TArray<number>;
        SetRowFill(ColumnIndex: number, Coefficient: number): void;
        SetColumnFill(ColumnIndex: number, Coefficient: number): void;
        AddChildToGrid(Content: Widget, InRow: number, InColumn: number): GridSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridPanel;
        static Load(InName: string): GridPanel;
    }
    
    class HorizontalBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        Size: SlateChildSize;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetSize(InSize: SlateChildSize): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HorizontalBoxSlot;
        static Load(InName: string): HorizontalBoxSlot;
    }
    
    class HorizontalBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToHorizontalBox(Content: Widget): HorizontalBoxSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HorizontalBox;
        static Load(InName: string): HorizontalBox;
    }
    
    class SlateTextureAtlasInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateTextureAtlasInterface;
        static Load(InName: string): SlateTextureAtlasInterface;
    }
    
    class Image extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Image: SlateBrushAsset;
        Brush: SlateBrush;
        BrushDelegate: $Delegate<() => SlateBrush>;
        ColorAndOpacity: LinearColor;
        ColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        bFlipForRightToLeftFlowDirection: boolean;
        OnMouseButtonDownEvent: $Delegate<(MyGeometry: Geometry, MouseEvent: PointerEvent) => EventReply>;
        SetOpacity(InOpacity: number): void;
        SetColorAndOpacity(InColorAndOpacity: LinearColor): void;
        SetBrushTintColor(TintColor: SlateColor): void;
        SetBrushSize(DesiredSize: Vector2D): void;
        SetBrushResourceObject(ResourceObject: Object): void;
        SetBrushFromTextureDynamic(Texture: Texture2DDynamic, bMatchSize: boolean): void;
        SetBrushFromTexture(Texture: Texture2D, bMatchSize: boolean): void;
        SetBrushFromSoftTexture(SoftTexture: TSoftObjectPtr<Texture2D>, bMatchSize: boolean): void;
        SetBrushFromSoftMaterial(SoftMaterial: TSoftObjectPtr<MaterialInterface>): void;
        SetBrushFromMaterial(Material: MaterialInterface): void;
        SetBrushFromAtlasInterface(AtlasRegion: SlateTextureAtlasInterface, bMatchSize: boolean): void;
        SetBrushFromAsset(Asset: SlateBrushAsset): void;
        SetBrush(InBrush: SlateBrush): void;
        GetDynamicMaterial(): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Image;
        static Load(InName: string): Image;
    }
    
    class InputKeySelector extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: ButtonStyle;
        TextStyle: TextBlockStyle;
        SelectedKey: InputChord;
        Font: SlateFontInfo;
        Margin: Margin;
        ColorAndOpacity: LinearColor;
        KeySelectionText: string;
        NoKeySpecifiedText: string;
        bAllowModifierKeys: boolean;
        bAllowGamepadKeys: boolean;
        EscapeKeys: TArray<Key>;
        OnKeySelected: $MulticastDelegate<(SelectedKey: InputChord) => void>;
        OnIsSelectingKeyChanged: $MulticastDelegate<() => void>;
        SetTextBlockVisibility(InVisibility: ESlateVisibility): void;
        SetSelectedKey(InSelectedKey: InputChord): void;
        SetNoKeySpecifiedText(InNoKeySpecifiedText: string): void;
        SetKeySelectionText(InKeySelectionText: string): void;
        SetEscapeKeys(InKeys: TArray<Key>): void;
        SetAllowModifierKeys(bInAllowModifierKeys: boolean): void;
        SetAllowGamepadKeys(bInAllowGamepadKeys: boolean): void;
        OnKeySelected__DelegateSignature(SelectedKey: InputChord): void;
        OnIsSelectingKeyChanged__DelegateSignature(): void;
        GetIsSelectingKey(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputKeySelector;
        static Load(InName: string): InputKeySelector;
    }
    
    class Int32Binding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Int32Binding;
        static Load(InName: string): Int32Binding;
    }
    
    class InvalidationBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanCache: boolean;
        CacheRelativeTransforms: boolean;
        SetCanCache(CanCache: boolean): void;
        InvalidateCache(): void;
        GetCanCache(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InvalidationBox;
        static Load(InName: string): InvalidationBox;
    }
    
    class UserListEntry extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BP_OnItemSelectionChanged(bIsSelected: boolean): void;
        BP_OnItemExpansionChanged(bIsExpanded: boolean): void;
        BP_OnEntryReleased(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserListEntry;
        static Load(InName: string): UserListEntry;
    }
    
    class ListViewBase extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryWidgetClass: Class;
        WheelScrollMultiplier: number;
        bEnableScrollAnimation: boolean;
        bEnableFixedLineOffset: boolean;
        FixedLineScrollOffset: number;
        BP_OnEntryGenerated: $MulticastDelegate<(Widget: UserWidget) => void>;
        BP_OnEntryReleased: $MulticastDelegate<(Widget: UserWidget) => void>;
        NumDesignerPreviewEntries: number;
        EntryWidgetPool: UserWidgetPool;
        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
        SetScrollOffset(InScrollOffset: number): void;
        SetScrollbarVisibility(InVisibility: ESlateVisibility): void;
        ScrollToTop(): void;
        ScrollToBottom(): void;
        RequestRefresh(): void;
        RegenerateAllEntries(): void;
        GetDisplayedEntryWidgets(): TArray<UserWidget>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListViewBase;
        static Load(InName: string): ListViewBase;
    }
    
    class UserListEntryLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static IsListItemSelected(UserListEntry: UserListEntry): boolean;
        static IsListItemExpanded(UserListEntry: UserListEntry): boolean;
        static GetOwningListView(UserListEntry: UserListEntry): ListViewBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserListEntryLibrary;
        static Load(InName: string): UserListEntryLibrary;
    }
    
    class UserObjectListEntry extends UserListEntry {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnListItemObjectSet(ListItemObject: Object): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserObjectListEntry;
        static Load(InName: string): UserObjectListEntry;
    }
    
    class UserObjectListEntryLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetListItemObject(UserObjectListEntry: UserObjectListEntry): Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserObjectListEntryLibrary;
        static Load(InName: string): UserObjectListEntryLibrary;
    }
    
    enum EConsumeMouseWheel { WhenScrollingPossible, Always, Never, EConsumeMouseWheel_MAX}
    class ListView extends ListViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Orientation: number;
        SelectionMode: number;
        ConsumeMouseWheel: EConsumeMouseWheel;
        bClearSelectionOnClick: boolean;
        bIsFocusable: boolean;
        EntrySpacing: number;
        bReturnFocusToSelection: boolean;
        ListItems: TArray<Object>;
        BP_OnEntryInitialized: $MulticastDelegate<(Item: Object, Widget: UserWidget) => void>;
        BP_OnItemClicked: $MulticastDelegate<(Item: Object) => void>;
        BP_OnItemDoubleClicked: $MulticastDelegate<(Item: Object) => void>;
        BP_OnItemIsHoveredChanged: $MulticastDelegate<(Item: Object, bIsHovered: boolean) => void>;
        BP_OnItemSelectionChanged: $MulticastDelegate<(Item: Object, bIsSelected: boolean) => void>;
        BP_OnItemScrolledIntoView: $MulticastDelegate<(Item: Object, Widget: UserWidget) => void>;
        SetSelectionMode(SelectionMode: number): void;
        SetSelectedIndex(Index: number): void;
        ScrollIndexIntoView(Index: number): void;
        RemoveItem(Item: Object): void;
        NavigateToIndex(Index: number): void;
        IsRefreshPending(): boolean;
        GetNumItems(): number;
        GetListItems(): TArray<Object>;
        GetItemAt(Index: number): Object;
        GetIndexForItem(Item: Object): number;
        ClearListItems(): void;
        BP_SetSelectedItem(Item: Object): void;
        BP_SetListItems(InListItems: TArray<Object>): void;
        BP_SetItemSelection(Item: Object, bSelected: boolean): void;
        BP_ScrollItemIntoView(Item: Object): void;
        BP_NavigateToItem(Item: Object): void;
        BP_IsItemVisible(Item: Object): boolean;
        BP_GetSelectedItems(Items: $Ref<TArray<Object>>): boolean;
        BP_GetSelectedItem(): Object;
        BP_GetNumItemsSelected(): number;
        BP_ClearSelection(): void;
        BP_CancelScrollIntoView(): void;
        AddItem(Item: Object): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListView;
        static Load(InName: string): ListView;
    }
    
    class ListViewDesignerPreviewItem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListViewDesignerPreviewItem;
        static Load(InName: string): ListViewDesignerPreviewItem;
    }
    
    class MenuAnchor extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MenuClass: Class;
        OnGetMenuContentEvent: $Delegate<() => Widget>;
        Placement: number;
        bFitInWindow: boolean;
        ShouldDeferPaintingAfterWindowContent: boolean;
        UseApplicationMenuStack: boolean;
        OnMenuOpenChanged: $MulticastDelegate<(bIsOpen: boolean) => void>;
        ToggleOpen(bFocusOnOpen: boolean): void;
        ShouldOpenDueToClick(): boolean;
        SetPlacement(InPlacement: number): void;
        Open(bFocusMenu: boolean): void;
        IsOpen(): boolean;
        HasOpenSubMenus(): boolean;
        GetMenuPosition(): Vector2D;
        FitInWindow(bFit: boolean): void;
        Close(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MenuAnchor;
        static Load(InName: string): MenuAnchor;
    }
    
    class MouseCursorBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MouseCursorBinding;
        static Load(InName: string): MouseCursorBinding;
    }
    
    class MovieScene2DTransformMask {
        constructor(Mask: number);
        Mask: number;
    }
    
    class MovieScene2DTransformSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformMask: MovieScene2DTransformMask;
        Translation: FixSizeArray<MovieSceneFloatChannel>;
        Rotation: MovieSceneFloatChannel;
        Scale: FixSizeArray<MovieSceneFloatChannel>;
        Shear: FixSizeArray<MovieSceneFloatChannel>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformSection;
        static Load(InName: string): MovieScene2DTransformSection;
    }
    
    class MovieSceneNameableTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneNameableTrack;
        static Load(InName: string): MovieSceneNameableTrack;
    }
    
    class MovieScenePropertyTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueTrackName: string;
        SectionToKey: MovieSceneSection;
        PropertyName: string;
        PropertyPath: string;
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePropertyTrack;
        static Load(InName: string): MovieScenePropertyTrack;
    }
    
    class MovieScene2DTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene2DTransformTrack;
        static Load(InName: string): MovieScene2DTransformTrack;
    }
    
    class MovieSceneMarginSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TopCurve: MovieSceneFloatChannel;
        LeftCurve: MovieSceneFloatChannel;
        RightCurve: MovieSceneFloatChannel;
        BottomCurve: MovieSceneFloatChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMarginSection;
        static Load(InName: string): MovieSceneMarginSection;
    }
    
    class MovieSceneMarginTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMarginTrack;
        static Load(InName: string): MovieSceneMarginTrack;
    }
    
    class MovieSceneMaterialTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMaterialTrack;
        static Load(InName: string): MovieSceneMaterialTrack;
    }
    
    class MovieSceneWidgetMaterialTrack extends MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrushPropertyNamePath: TArray<string>;
        TrackName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneWidgetMaterialTrack;
        static Load(InName: string): MovieSceneWidgetMaterialTrack;
    }
    
    enum ETextWrappingPolicy { DefaultWrapping, AllowPerCharacterWrapping, ETextWrappingPolicy_MAX}
    class TextLayoutWidget extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShapedTextOptions: ShapedTextOptions;
        Justification: number;
        WrappingPolicy: ETextWrappingPolicy;
        AutoWrapText: boolean;
        WrapTextAt: number;
        Margin: Margin;
        LineHeightPercentage: number;
        SetJustification(InJustification: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextLayoutWidget;
        static Load(InName: string): TextLayoutWidget;
    }
    
    class MultiLineEditableText extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: TextBlockStyle;
        bIsReadOnly: boolean;
        Font: SlateFontInfo;
        SelectAllTextWhenFocused: boolean;
        ClearTextSelectionOnFocusLoss: boolean;
        RevertTextOnEscape: boolean;
        ClearKeyboardFocusOnCommit: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: number) => void>;
        SetWidgetStyle(InWidgetStyle: TextBlockStyle): void;
        SetText(InText: string): void;
        SetIsReadOnly(bReadOnly: boolean): void;
        SetHintText(InHintText: string): void;
        OnMultiLineEditableTextCommittedEvent__DelegateSignature(Text: string, CommitMethod: number): void;
        OnMultiLineEditableTextChangedEvent__DelegateSignature(Text: string): void;
        GetText(): string;
        GetHintText(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiLineEditableText;
        static Load(InName: string): MultiLineEditableText;
    }
    
    class MultiLineEditableTextBox extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        HintText: string;
        HintTextDelegate: $Delegate<() => string>;
        WidgetStyle: EditableTextBoxStyle;
        TextStyle: TextBlockStyle;
        bIsReadOnly: boolean;
        AllowContextMenu: boolean;
        VirtualKeyboardOptions: VirtualKeyboardOptions;
        VirtualKeyboardDismissAction: EVirtualKeyboardDismissAction;
        Style: SlateWidgetStyleAsset;
        Font: SlateFontInfo;
        ForegroundColor: LinearColor;
        BackgroundColor: LinearColor;
        ReadOnlyForegroundColor: LinearColor;
        OnTextChanged: $MulticastDelegate<(Text: string) => void>;
        OnTextCommitted: $MulticastDelegate<(Text: string, CommitMethod: number) => void>;
        SetTextStyle(InTextStyle: TextBlockStyle): void;
        SetText(InText: string): void;
        SetIsReadOnly(bReadOnly: boolean): void;
        SetHintText(InHintText: string): void;
        SetError(InError: string): void;
        OnMultiLineEditableTextBoxCommittedEvent__DelegateSignature(Text: string, CommitMethod: number): void;
        OnMultiLineEditableTextBoxChangedEvent__DelegateSignature(Text: string): void;
        GetText(): string;
        GetHintText(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MultiLineEditableTextBox;
        static Load(InName: string): MultiLineEditableTextBox;
    }
    
    class NamedSlot extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NamedSlot;
        static Load(InName: string): NamedSlot;
    }
    
    class NamedSlotInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NamedSlotInterface;
        static Load(InName: string): NamedSlotInterface;
    }
    
    class NativeWidgetHost extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NativeWidgetHost;
        static Load(InName: string): NativeWidgetHost;
    }
    
    class OverlaySlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OverlaySlot;
        static Load(InName: string): OverlaySlot;
    }
    
    class Overlay extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToOverlay(Content: Widget): OverlaySlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Overlay;
        static Load(InName: string): Overlay;
    }
    
    class ProgressBar extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: ProgressBarStyle;
        Style: SlateWidgetStyleAsset;
        BackgroundImage: SlateBrushAsset;
        FillImage: SlateBrushAsset;
        MarqueeImage: SlateBrushAsset;
        Percent: number;
        BarFillType: number;
        bIsMarquee: boolean;
        BorderPadding: Vector2D;
        PercentDelegate: $Delegate<() => number>;
        FillColorAndOpacity: LinearColor;
        FillColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        SetPercent(InPercent: number): void;
        SetIsMarquee(InbIsMarquee: boolean): void;
        SetFillColorAndOpacity(InColor: LinearColor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProgressBar;
        static Load(InName: string): ProgressBar;
    }
    
    class RetainerBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderOnInvalidation: boolean;
        RenderOnPhase: boolean;
        Phase: number;
        PhaseCount: number;
        EffectMaterial: MaterialInterface;
        TextureParameter: string;
        SetTextureParameter(TextureParameter: string): void;
        SetRenderingPhase(RenderPhase: number, TotalPhases: number): void;
        SetEffectMaterial(EffectMaterial: MaterialInterface): void;
        RequestRender(): void;
        GetEffectMaterial(): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RetainerBox;
        static Load(InName: string): RetainerBox;
    }
    
    class RichTextBlockDecorator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichTextBlockDecorator;
        static Load(InName: string): RichTextBlockDecorator;
    }
    
    class RichTextBlock extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextStyleSet: DataTable;
        DecoratorClasses: TArray<Class>;
        bOverrideDefaultStyle: boolean;
        DefaultTextStyleOverride: TextBlockStyle;
        MinDesiredWidth: number;
        InstanceDecorators: TArray<RichTextBlockDecorator>;
        SetTextStyleSet(NewTextStyleSet: DataTable): void;
        SetText(InText: string): void;
        SetMinDesiredWidth(InMinDesiredWidth: number): void;
        SetDefaultTextStyle(InDefaultTextStyle: TextBlockStyle): void;
        SetDefaultStrikeBrush(InStrikeBrush: $Ref<SlateBrush>): void;
        SetDefaultShadowOffset(InShadowOffset: Vector2D): void;
        SetDefaultShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
        SetDefaultFont(InFontInfo: SlateFontInfo): void;
        SetDefaultColorAndOpacity(InColorAndOpacity: SlateColor): void;
        SetAutoWrapText(InAutoTextWrap: boolean): void;
        GetText(): string;
        GetDecoratorByClass(DecoratorClass: Class): RichTextBlockDecorator;
        ClearAllDefaultStyleOverrides(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichTextBlock;
        static Load(InName: string): RichTextBlock;
    }
    
    class RichTextBlockImageDecorator extends RichTextBlockDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImageSet: DataTable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RichTextBlockImageDecorator;
        static Load(InName: string): RichTextBlockImageDecorator;
    }
    
    class SafeZone extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PadLeft: boolean;
        PadRight: boolean;
        PadTop: boolean;
        PadBottom: boolean;
        SetSidesToPad(InPadLeft: boolean, InPadRight: boolean, InPadTop: boolean, InPadBottom: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SafeZone;
        static Load(InName: string): SafeZone;
    }
    
    class SafeZoneSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsTitleSafe: boolean;
        SafeAreaScale: Margin;
        HAlign: number;
        VAlign: number;
        Padding: Margin;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SafeZoneSlot;
        static Load(InName: string): SafeZoneSlot;
    }
    
    class ScaleBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Stretch: number;
        StretchDirection: number;
        UserSpecifiedScale: number;
        IgnoreInheritedScale: boolean;
        SetUserSpecifiedScale(InUserSpecifiedScale: number): void;
        SetStretchDirection(InStretchDirection: number): void;
        SetStretch(InStretch: number): void;
        SetIgnoreInheritedScale(bInIgnoreInheritedScale: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScaleBox;
        static Load(InName: string): ScaleBox;
    }
    
    class ScaleBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScaleBoxSlot;
        static Load(InName: string): ScaleBoxSlot;
    }
    
    class ScrollBar extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: ScrollBarStyle;
        Style: SlateWidgetStyleAsset;
        bAlwaysShowScrollbar: boolean;
        bAlwaysShowScrollbarTrack: boolean;
        Orientation: number;
        Thickness: Vector2D;
        Padding: Margin;
        SetState(InOffsetFraction: number, InThumbSizeFraction: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBar;
        static Load(InName: string): ScrollBar;
    }
    
    enum EDescendantScrollDestination { IntoView, TopOrLeft, Center, EDescendantScrollDestination_MAX}
    class ScrollBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetStyle: ScrollBoxStyle;
        WidgetBarStyle: ScrollBarStyle;
        Style: SlateWidgetStyleAsset;
        BarStyle: SlateWidgetStyleAsset;
        Orientation: number;
        ScrollBarVisibility: ESlateVisibility;
        ConsumeMouseWheel: EConsumeMouseWheel;
        ScrollbarThickness: Vector2D;
        ScrollbarPadding: Margin;
        AlwaysShowScrollbar: boolean;
        AlwaysShowScrollbarTrack: boolean;
        AllowOverscroll: boolean;
        bAnimateWheelScrolling: boolean;
        NavigationDestination: EDescendantScrollDestination;
        NavigationScrollPadding: number;
        bAllowRightClickDragScrolling: boolean;
        WheelScrollMultiplier: number;
        OnUserScrolled: $MulticastDelegate<(CurrentOffset: number) => void>;
        SetWheelScrollMultiplier(NewWheelScrollMultiplier: number): void;
        SetScrollOffset(NewScrollOffset: number): void;
        SetScrollBarVisibility(NewScrollBarVisibility: ESlateVisibility): void;
        SetScrollbarThickness(NewScrollbarThickness: Vector2D): void;
        SetScrollbarPadding(NewScrollbarPadding: Margin): void;
        SetOrientation(NewOrientation: number): void;
        SetConsumeMouseWheel(NewConsumeMouseWheel: EConsumeMouseWheel): void;
        SetAnimateWheelScrolling(bShouldAnimateWheelScrolling: boolean): void;
        SetAlwaysShowScrollbar(NewAlwaysShowScrollbar: boolean): void;
        SetAllowOverscroll(NewAllowOverscroll: boolean): void;
        ScrollWidgetIntoView(WidgetToFind: Widget, AnimateScroll: boolean, ScrollDestination: EDescendantScrollDestination): void;
        ScrollToStart(): void;
        ScrollToEnd(): void;
        GetViewOffsetFraction(): number;
        GetScrollOffsetOfEnd(): number;
        GetScrollOffset(): number;
        EndInertialScrolling(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBox;
        static Load(InName: string): ScrollBox;
    }
    
    class ScrollBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScrollBoxSlot;
        static Load(InName: string): ScrollBoxSlot;
    }
    
    class SizeBox extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidthOverride: number;
        HeightOverride: number;
        MinDesiredWidth: number;
        MinDesiredHeight: number;
        MaxDesiredWidth: number;
        MaxDesiredHeight: number;
        MinAspectRatio: number;
        MaxAspectRatio: number;
        bOverride_WidthOverride: boolean;
        bOverride_HeightOverride: boolean;
        bOverride_MinDesiredWidth: boolean;
        bOverride_MinDesiredHeight: boolean;
        bOverride_MaxDesiredWidth: boolean;
        bOverride_MaxDesiredHeight: boolean;
        bOverride_MinAspectRatio: boolean;
        bOverride_MaxAspectRatio: boolean;
        SetWidthOverride(InWidthOverride: number): void;
        SetMinDesiredWidth(InMinDesiredWidth: number): void;
        SetMinDesiredHeight(InMinDesiredHeight: number): void;
        SetMinAspectRatio(InMinAspectRatio: number): void;
        SetMaxDesiredWidth(InMaxDesiredWidth: number): void;
        SetMaxDesiredHeight(InMaxDesiredHeight: number): void;
        SetMaxAspectRatio(InMaxAspectRatio: number): void;
        SetHeightOverride(InHeightOverride: number): void;
        ClearWidthOverride(): void;
        ClearMinDesiredWidth(): void;
        ClearMinDesiredHeight(): void;
        ClearMinAspectRatio(): void;
        ClearMaxDesiredWidth(): void;
        ClearMaxDesiredHeight(): void;
        ClearMaxAspectRatio(): void;
        ClearHeightOverride(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SizeBox;
        static Load(InName: string): SizeBox;
    }
    
    class SizeBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SizeBoxSlot;
        static Load(InName: string): SizeBoxSlot;
    }
    
    class SlateBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TransformVectorLocalToAbsolute(Geometry: Geometry, LocalVector: Vector2D): Vector2D;
        static TransformVectorAbsoluteToLocal(Geometry: Geometry, AbsoluteVector: Vector2D): Vector2D;
        static TransformScalarLocalToAbsolute(Geometry: Geometry, LocalScalar: number): number;
        static TransformScalarAbsoluteToLocal(Geometry: Geometry, AbsoluteScalar: number): number;
        static ScreenToWidgetLocal(WorldContextObject: Object, Geometry: Geometry, ScreenPosition: Vector2D, LocalCoordinate: $Ref<Vector2D>): void;
        static ScreenToWidgetAbsolute(WorldContextObject: Object, ScreenPosition: Vector2D, AbsoluteCoordinate: $Ref<Vector2D>): void;
        static ScreenToViewport(WorldContextObject: Object, ScreenPosition: Vector2D, ViewportPosition: $Ref<Vector2D>): void;
        static LocalToViewport(WorldContextObject: Object, Geometry: Geometry, LocalCoordinate: Vector2D, PixelPosition: $Ref<Vector2D>, ViewportPosition: $Ref<Vector2D>): void;
        static LocalToAbsolute(Geometry: Geometry, LocalCoordinate: Vector2D): Vector2D;
        static IsUnderLocation(Geometry: Geometry, AbsoluteCoordinate: Vector2D): boolean;
        static GetLocalTopLeft(Geometry: Geometry): Vector2D;
        static GetLocalSize(Geometry: Geometry): Vector2D;
        static GetAbsoluteSize(Geometry: Geometry): Vector2D;
        static EqualEqual_SlateBrush(A: SlateBrush, B: SlateBrush): boolean;
        static AbsoluteToViewport(WorldContextObject: Object, AbsoluteDesktopCoordinate: Vector2D, PixelPosition: $Ref<Vector2D>, ViewportPosition: $Ref<Vector2D>): void;
        static AbsoluteToLocal(Geometry: Geometry, AbsoluteCoordinate: Vector2D): Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBlueprintLibrary;
        static Load(InName: string): SlateBlueprintLibrary;
    }
    
    class SlateMeshVertex {
        constructor(Position: Vector2D, Color: Color, UV0: Vector2D, UV1: Vector2D, UV2: Vector2D, UV3: Vector2D, UV4: Vector2D, UV5: Vector2D);
        Position: Vector2D;
        Color: Color;
        UV0: Vector2D;
        UV1: Vector2D;
        UV2: Vector2D;
        UV3: Vector2D;
        UV4: Vector2D;
        UV5: Vector2D;
    }
    
    class SlateVectorArtData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshAsset: StaticMesh;
        SourceMaterial: MaterialInterface;
        VertexData: TArray<SlateMeshVertex>;
        IndexData: TArray<number>;
        Material: MaterialInterface;
        ExtentMin: Vector2D;
        ExtentMax: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateVectorArtData;
        static Load(InName: string): SlateVectorArtData;
    }
    
    class SliderStyle extends SlateWidgetStyle {
        constructor(NormalBarImage: SlateBrush, HoveredBarImage: SlateBrush, DisabledBarImage: SlateBrush, NormalThumbImage: SlateBrush, HoveredThumbImage: SlateBrush, DisabledThumbImage: SlateBrush, BarThickness: number);
        NormalBarImage: SlateBrush;
        HoveredBarImage: SlateBrush;
        DisabledBarImage: SlateBrush;
        NormalThumbImage: SlateBrush;
        HoveredThumbImage: SlateBrush;
        DisabledThumbImage: SlateBrush;
        BarThickness: number;
    }
    
    class Slider extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: number;
        ValueDelegate: $Delegate<() => number>;
        MinValue: number;
        MaxValue: number;
        WidgetStyle: SliderStyle;
        Orientation: number;
        SliderBarColor: LinearColor;
        SliderHandleColor: LinearColor;
        IndentHandle: boolean;
        Locked: boolean;
        MouseUsesStep: boolean;
        RequiresControllerLock: boolean;
        StepSize: number;
        IsFocusable: boolean;
        OnMouseCaptureBegin: $MulticastDelegate<() => void>;
        OnMouseCaptureEnd: $MulticastDelegate<() => void>;
        OnControllerCaptureBegin: $MulticastDelegate<() => void>;
        OnControllerCaptureEnd: $MulticastDelegate<() => void>;
        OnValueChanged: $MulticastDelegate<(Value: number) => void>;
        SetValue(InValue: number): void;
        SetStepSize(InValue: number): void;
        SetSliderHandleColor(InValue: LinearColor): void;
        SetSliderBarColor(InValue: LinearColor): void;
        SetMinValue(InValue: number): void;
        SetMaxValue(InValue: number): void;
        SetLocked(InValue: boolean): void;
        SetIndentHandle(InValue: boolean): void;
        GetValue(): number;
        GetNormalizedValue(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Slider;
        static Load(InName: string): Slider;
    }
    
    class Spacer extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Size: Vector2D;
        SetSize(InSize: Vector2D): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Spacer;
        static Load(InName: string): Spacer;
    }
    
    class SpinBox extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: number;
        ValueDelegate: $Delegate<() => number>;
        WidgetStyle: SpinBoxStyle;
        Style: SlateWidgetStyleAsset;
        Delta: number;
        SliderExponent: number;
        Font: SlateFontInfo;
        Justification: number;
        MinDesiredWidth: number;
        ClearKeyboardFocusOnCommit: boolean;
        SelectAllTextOnCommit: boolean;
        ForegroundColor: SlateColor;
        OnValueChanged: $MulticastDelegate<(InValue: number) => void>;
        OnValueCommitted: $MulticastDelegate<(InValue: number, CommitMethod: number) => void>;
        OnBeginSliderMovement: $MulticastDelegate<() => void>;
        OnEndSliderMovement: $MulticastDelegate<(InValue: number) => void>;
        bOverride_MinValue: boolean;
        bOverride_MaxValue: boolean;
        bOverride_MinSliderValue: boolean;
        bOverride_MaxSliderValue: boolean;
        MinValue: number;
        MaxValue: number;
        MinSliderValue: number;
        MaxSliderValue: number;
        SetValue(NewValue: number): void;
        SetMinValue(NewValue: number): void;
        SetMinSliderValue(NewValue: number): void;
        SetMaxValue(NewValue: number): void;
        SetMaxSliderValue(NewValue: number): void;
        SetForegroundColor(InForegroundColor: SlateColor): void;
        OnSpinBoxValueCommittedEvent__DelegateSignature(InValue: number, CommitMethod: number): void;
        OnSpinBoxValueChangedEvent__DelegateSignature(InValue: number): void;
        OnSpinBoxBeginSliderMovement__DelegateSignature(): void;
        GetValue(): number;
        GetMinValue(): number;
        GetMinSliderValue(): number;
        GetMaxValue(): number;
        GetMaxSliderValue(): number;
        ClearMinValue(): void;
        ClearMinSliderValue(): void;
        ClearMaxValue(): void;
        ClearMaxSliderValue(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpinBox;
        static Load(InName: string): SpinBox;
    }
    
    class TextBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetTextValue(): string;
        GetStringValue(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBinding;
        static Load(InName: string): TextBinding;
    }
    
    class TextBlock extends TextLayoutWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        TextDelegate: $Delegate<() => string>;
        ColorAndOpacity: SlateColor;
        ColorAndOpacityDelegate: $Delegate<() => SlateColor>;
        Font: SlateFontInfo;
        StrikeBrush: SlateBrush;
        ShadowOffset: Vector2D;
        ShadowColorAndOpacity: LinearColor;
        ShadowColorAndOpacityDelegate: $Delegate<() => LinearColor>;
        MinDesiredWidth: number;
        bWrapWithInvalidationPanel: boolean;
        bAutoWrapText: boolean;
        bSimpleTextMode: boolean;
        SetText(InText: string): void;
        SetStrikeBrush(InStrikeBrush: SlateBrush): void;
        SetShadowOffset(InShadowOffset: Vector2D): void;
        SetShadowColorAndOpacity(InShadowColorAndOpacity: LinearColor): void;
        SetOpacity(InOpacity: number): void;
        SetMinDesiredWidth(InMinDesiredWidth: number): void;
        SetFont(InFontInfo: SlateFontInfo): void;
        SetColorAndOpacity(InColorAndOpacity: SlateColor): void;
        SetAutoWrapText(InAutoTextWrap: boolean): void;
        GetText(): string;
        GetDynamicOutlineMaterial(): MaterialInstanceDynamic;
        GetDynamicFontMaterial(): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBlock;
        static Load(InName: string): TextBlock;
    }
    
    class Throbber extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPieces: number;
        bAnimateHorizontally: boolean;
        bAnimateVertically: boolean;
        bAnimateOpacity: boolean;
        PieceImage: SlateBrushAsset;
        Image: SlateBrush;
        SetNumberOfPieces(InNumberOfPieces: number): void;
        SetAnimateVertically(bInAnimateVertically: boolean): void;
        SetAnimateOpacity(bInAnimateOpacity: boolean): void;
        SetAnimateHorizontally(bInAnimateHorizontally: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Throbber;
        static Load(InName: string): Throbber;
    }
    
    enum EListItemAlignment { EvenlyDistributed, EvenlySize, EvenlyWide, LeftAligned, RightAligned, CenterAligned, Fill, EListItemAlignment_MAX}
    class TileView extends ListView {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EntryHeight: number;
        EntryWidth: number;
        TileAlignment: EListItemAlignment;
        bWrapHorizontalNavigation: boolean;
        SetEntryWidth(NewWidth: number): void;
        SetEntryHeight(NewHeight: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileView;
        static Load(InName: string): TileView;
    }
    
    class TreeView extends ListView {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BP_OnGetItemChildren: $Delegate<(Item: Object, Children: $Ref<TArray<Object>>) => void>;
        BP_OnItemExpansionChanged: $MulticastDelegate<(Item: Object, bIsExpanded: boolean) => void>;
        SetItemExpansion(Item: Object, bExpandItem: boolean): void;
        ExpandAll(): void;
        CollapseAll(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TreeView;
        static Load(InName: string): TreeView;
    }
    
    class UniformGridSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HorizontalAlignment: number;
        VerticalAlignment: number;
        Row: number;
        Column: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetRow(InRow: number): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        SetColumn(InColumn: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformGridSlot;
        static Load(InName: string): UniformGridSlot;
    }
    
    class UniformGridPanel extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SlotPadding: Margin;
        MinDesiredSlotWidth: number;
        MinDesiredSlotHeight: number;
        SetSlotPadding(InSlotPadding: Margin): void;
        SetMinDesiredSlotWidth(InMinDesiredSlotWidth: number): void;
        SetMinDesiredSlotHeight(InMinDesiredSlotHeight: number): void;
        AddChildToUniformGrid(Content: Widget, InRow: number, InColumn: number): UniformGridSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformGridPanel;
        static Load(InName: string): UniformGridPanel;
    }
    
    class VerticalBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Size: SlateChildSize;
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetSize(InSize: SlateChildSize): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VerticalBoxSlot;
        static Load(InName: string): VerticalBoxSlot;
    }
    
    class VerticalBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddChildToVerticalBox(Content: Widget): VerticalBoxSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VerticalBox;
        static Load(InName: string): VerticalBox;
    }
    
    class Viewport extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BackgroundColor: LinearColor;
        Spawn(ActorClass: Class): Actor;
        SetViewRotation(Rotation: Rotator): void;
        SetViewLocation(Location: Vector): void;
        GetViewRotation(): Rotator;
        GetViewportWorld(): World;
        GetViewLocation(): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Viewport;
        static Load(InName: string): Viewport;
    }
    
    class VisibilityBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): ESlateVisibility;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisibilityBinding;
        static Load(InName: string): VisibilityBinding;
    }
    
    class BlueprintWidgetAnimationDelegateBinding {
        constructor(Action: EWidgetAnimationEvent, AnimationToBind: string, FunctionNameToBind: string, UserTag: string);
        Action: EWidgetAnimationEvent;
        AnimationToBind: string;
        FunctionNameToBind: string;
        UserTag: string;
    }
    
    class WidgetAnimationDelegateBinding extends DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetAnimationDelegateBindings: TArray<BlueprintWidgetAnimationDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetAnimationDelegateBinding;
        static Load(InName: string): WidgetAnimationDelegateBinding;
    }
    
    class WidgetAnimationPlayCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Finished: $MulticastDelegate<() => void>;
        static CreatePlayAnimationTimeRangeProxyObject(Result: $Ref<UMGSequencePlayer>, Widget: UserWidget, InAnimation: WidgetAnimation, StartAtTime: number, EndAtTime: number, NumLoopsToPlay: number, PlayMode: number, PlaybackSpeed: number): WidgetAnimationPlayCallbackProxy;
        static CreatePlayAnimationProxyObject(Result: $Ref<UMGSequencePlayer>, Widget: UserWidget, InAnimation: WidgetAnimation, StartAtTime: number, NumLoopsToPlay: number, PlayMode: number, PlaybackSpeed: number): WidgetAnimationPlayCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetAnimationPlayCallbackProxy;
        static Load(InName: string): WidgetAnimationPlayCallbackProxy;
    }
    
    class WidgetBinding extends PropertyBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetValue(): Widget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBinding;
        static Load(InName: string): WidgetBinding;
    }
    
    enum EBindingKind { Function, Property, EBindingKind_MAX}
    class DelegateRuntimeBinding {
        constructor(ObjectName: string, PropertyName: string, FunctionName: string, SourcePath: DynamicPropertyPath, Kind: EBindingKind);
        ObjectName: string;
        PropertyName: string;
        FunctionName: string;
        SourcePath: DynamicPropertyPath;
        Kind: EBindingKind;
    }
    
    class WidgetBlueprintGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetTree: WidgetTree;
        bCookSlowConstructionWidgetTree: boolean;
        bCanCallPreConstruct: boolean;
        bAllowTemplate: boolean;
        bAllowDynamicCreation: boolean;
        bValidTemplate: boolean;
        bTemplateInitialized: boolean;
        bCookedTemplate: boolean;
        bClassRequiresNativeTick: boolean;
        Bindings: TArray<DelegateRuntimeBinding>;
        Animations: TArray<WidgetAnimation>;
        NamedSlots: TArray<string>;
        TemplateAsset: TSoftObjectPtr<UserWidget>;
        Template: UserWidget;
        EditorTemplate: UserWidget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintGeneratedClass;
        static Load(InName: string): WidgetBlueprintGeneratedClass;
    }
    
    enum EWindowTitleBarMode { Overlay, VerticalBox, EWindowTitleBarMode_MAX}
    enum EMouseLockMode { DoNotLock, LockOnCapture, LockAlways, LockInFullscreen, EMouseLockMode_MAX}
    class NavigationEvent extends InputEvent {
        constructor();
    }
    
    class WidgetBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UnlockMouse(Reply: $Ref<EventReply>): EventReply;
        static Unhandled(): EventReply;
        static SetWindowTitleBarState(TitleBarContent: Widget, Mode: EWindowTitleBarMode, bTitleBarDragEnabled: boolean, bWindowButtonsVisible: boolean, bTitleBarVisible: boolean): void;
        static SetWindowTitleBarOnCloseClickedDelegate(Delegate: $Delegate<() => void>): void;
        static SetWindowTitleBarCloseButtonActive(bActive: boolean): void;
        static SetUserFocus(Reply: $Ref<EventReply>, FocusWidget: Widget, bInAllUsers: boolean): EventReply;
        static SetMousePosition(Reply: $Ref<EventReply>, NewMousePosition: Vector2D): EventReply;
        static SetInputMode_UIOnlyEx(PlayerController: PlayerController, InWidgetToFocus: Widget, InMouseLockMode: EMouseLockMode): void;
        static SetInputMode_UIOnly(Target: PlayerController, InWidgetToFocus: Widget, bLockMouseToViewport: boolean): void;
        static SetInputMode_GameOnly(PlayerController: PlayerController): void;
        static SetInputMode_GameAndUIEx(PlayerController: PlayerController, InWidgetToFocus: Widget, InMouseLockMode: EMouseLockMode, bHideCursorDuringCapture: boolean): void;
        static SetInputMode_GameAndUI(Target: PlayerController, InWidgetToFocus: Widget, bLockMouseToViewport: boolean, bHideCursorDuringCapture: boolean): void;
        static SetHardwareCursor(WorldContextObject: Object, CursorShape: number, CursorName: string, HotSpot: Vector2D): boolean;
        static SetFocusToGameViewport(): void;
        static SetColorVisionDeficiencyType(Type: EColorVisionDeficiency, Severity: number, CorrectDeficiency: boolean, ShowCorrectionWithDeficiency: boolean): void;
        static SetBrushResourceToTexture(Brush: $Ref<SlateBrush>, Texture: Texture2D): void;
        static SetBrushResourceToMaterial(Brush: $Ref<SlateBrush>, Material: MaterialInterface): void;
        static RestorePreviousWindowTitleBarState(): void;
        static ReleaseMouseCapture(Reply: $Ref<EventReply>): EventReply;
        static ReleaseJoystickCapture(Reply: $Ref<EventReply>, bInAllJoysticks: boolean): EventReply;
        OnGameWindowCloseButtonClickedDelegate__DelegateSignature(): void;
        static NoResourceBrush(): SlateBrush;
        static MakeBrushFromTexture(Texture: Texture2D, Width: number, Height: number): SlateBrush;
        static MakeBrushFromMaterial(Material: MaterialInterface, Width: number, Height: number): SlateBrush;
        static MakeBrushFromAsset(BrushAsset: SlateBrushAsset): SlateBrush;
        static LockMouse(Reply: $Ref<EventReply>, CapturingWidget: Widget): EventReply;
        static IsDragDropping(): boolean;
        static Handled(): EventReply;
        static GetSafeZonePadding(WorldContextObject: Object, SafePadding: $Ref<Vector4>, SafePaddingScale: $Ref<Vector2D>, SpillOverPadding: $Ref<Vector4>): void;
        static GetKeyEventFromAnalogInputEvent(Event: AnalogInputEvent): KeyEvent;
        static GetInputEventFromPointerEvent(Event: PointerEvent): InputEvent;
        static GetInputEventFromNavigationEvent(Event: NavigationEvent): InputEvent;
        static GetInputEventFromKeyEvent(Event: KeyEvent): InputEvent;
        static GetInputEventFromCharacterEvent(Event: CharacterEvent): InputEvent;
        static GetDynamicMaterial(Brush: $Ref<SlateBrush>): MaterialInstanceDynamic;
        static GetDragDroppingContent(): DragDropOperation;
        static GetBrushResourceAsTexture2D(Brush: SlateBrush): Texture2D;
        static GetBrushResourceAsMaterial(Brush: SlateBrush): MaterialInterface;
        static GetBrushResource(Brush: SlateBrush): Object;
        static GetAllWidgetsWithInterface(WorldContextObject: Object, FoundWidgets: $Ref<TArray<UserWidget>>, Interface: Class, TopLevelOnly: boolean): void;
        static GetAllWidgetsOfClass(WorldContextObject: Object, FoundWidgets: $Ref<TArray<UserWidget>>, WidgetClass: Class, TopLevelOnly: boolean): void;
        static EndDragDrop(Reply: $Ref<EventReply>): EventReply;
        static DrawTextFormatted(Context: $Ref<PaintContext>, Text: string, Position: Vector2D, Font: Font, FontSize: number, FontTypeFace: string, Tint: LinearColor): void;
        static DrawText(Context: $Ref<PaintContext>, InString: string, Position: Vector2D, Tint: LinearColor): void;
        static DrawLines(Context: $Ref<PaintContext>, Points: TArray<Vector2D>, Tint: LinearColor, bAntiAlias: boolean, Thickness: number): void;
        static DrawLine(Context: $Ref<PaintContext>, PositionA: Vector2D, PositionB: Vector2D, Tint: LinearColor, bAntiAlias: boolean, Thickness: number): void;
        static DrawBox(Context: $Ref<PaintContext>, Position: Vector2D, Size: Vector2D, Brush: SlateBrushAsset, Tint: LinearColor): void;
        static DismissAllMenus(): void;
        static DetectDragIfPressed(PointerEvent: PointerEvent, WidgetDetectingDrag: Widget, DragKey: Key): EventReply;
        static DetectDrag(Reply: $Ref<EventReply>, WidgetDetectingDrag: Widget, DragKey: Key): EventReply;
        static CreateDragDropOperation(OperationClass: Class): DragDropOperation;
        static Create(WorldContextObject: Object, WidgetType: Class, OwningPlayer: PlayerController): UserWidget;
        static ClearUserFocus(Reply: $Ref<EventReply>, bInAllUsers: boolean): EventReply;
        static CaptureMouse(Reply: $Ref<EventReply>, CapturingWidget: Widget): EventReply;
        static CaptureJoystick(Reply: $Ref<EventReply>, CapturingWidget: Widget, bInAllJoysticks: boolean): EventReply;
        static CancelDragDrop(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintLibrary;
        static Load(InName: string): WidgetBlueprintLibrary;
    }
    
    enum EWidgetInteractionSource { World, Mouse, CenterScreen, Custom, EWidgetInteractionSource_MAX}
    class WidgetInteractionComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnHoveredWidgetChanged: $MulticastDelegate<(WidgetComponent: WidgetComponent, PreviousWidgetComponent: WidgetComponent) => void>;
        VirtualUserIndex: number;
        PointerIndex: number;
        TraceChannel: number;
        InteractionDistance: number;
        InteractionSource: EWidgetInteractionSource;
        bEnableHitTesting: boolean;
        bShowDebug: boolean;
        DebugColor: LinearColor;
        CustomHitResult: HitResult;
        LocalHitLocation: Vector2D;
        LastLocalHitLocation: Vector2D;
        HoveredWidgetComponent: WidgetComponent;
        LastHitResult: HitResult;
        bIsHoveredWidgetInteractable: boolean;
        bIsHoveredWidgetFocusable: boolean;
        bIsHoveredWidgetHitTestVisible: boolean;
        ArrowComponent: ArrowComponent;
        SetFocus(FocusWidget: Widget): void;
        SetCustomHitResult(HitResult: HitResult): void;
        SendKeyChar(Characters: string, bRepeat: boolean): boolean;
        ScrollWheel(ScrollDelta: number): void;
        ReleasePointerKey(Key: Key): void;
        ReleaseKey(Key: Key): boolean;
        PressPointerKey(Key: Key): void;
        PressKey(Key: Key, bRepeat: boolean): boolean;
        PressAndReleaseKey(Key: Key): boolean;
        IsOverInteractableWidget(): boolean;
        IsOverHitTestVisibleWidget(): boolean;
        IsOverFocusableWidget(): boolean;
        GetLastHitResult(): HitResult;
        GetHoveredWidgetComponent(): WidgetComponent;
        Get2DHitLocation(): Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetInteractionComponent;
        static Load(InName: string): WidgetInteractionComponent;
    }
    
    class WrapBoxSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        bFillEmptySpace: boolean;
        FillSpanWhenLessThan: number;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        SetFillSpanWhenLessThan(InFillSpanWhenLessThan: number): void;
        SetFillEmptySpace(InbFillEmptySpace: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WrapBoxSlot;
        static Load(InName: string): WrapBoxSlot;
    }
    
    class WidgetSwitcherSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetSwitcherSlot;
        static Load(InName: string): WidgetSwitcherSlot;
    }
    
    class WidgetLayoutLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SlotAsWrapBoxSlot(Widget: Widget): WrapBoxSlot;
        static SlotAsWidgetSwitcherSlot(Widget: Widget): WidgetSwitcherSlot;
        static SlotAsVerticalBoxSlot(Widget: Widget): VerticalBoxSlot;
        static SlotAsUniformGridSlot(Widget: Widget): UniformGridSlot;
        static SlotAsSizeBoxSlot(Widget: Widget): SizeBoxSlot;
        static SlotAsScrollBoxSlot(Widget: Widget): ScrollBoxSlot;
        static SlotAsScaleBoxSlot(Widget: Widget): ScaleBoxSlot;
        static SlotAsSafeBoxSlot(Widget: Widget): SafeZoneSlot;
        static SlotAsOverlaySlot(Widget: Widget): OverlaySlot;
        static SlotAsHorizontalBoxSlot(Widget: Widget): HorizontalBoxSlot;
        static SlotAsGridSlot(Widget: Widget): GridSlot;
        static SlotAsCanvasSlot(Widget: Widget): CanvasPanelSlot;
        static SlotAsBorderSlot(Widget: Widget): BorderSlot;
        static RemoveAllWidgets(WorldContextObject: Object): void;
        static ProjectWorldLocationToWidgetPosition(PlayerController: PlayerController, WorldLocation: Vector, ScreenPosition: $Ref<Vector2D>): boolean;
        static GetViewportWidgetGeometry(WorldContextObject: Object): Geometry;
        static GetViewportSize(WorldContextObject: Object): Vector2D;
        static GetViewportScale(WorldContextObject: Object): number;
        static GetPlayerScreenWidgetGeometry(PlayerController: PlayerController): Geometry;
        static GetMousePositionScaledByDPI(Player: PlayerController, LocationX: $Ref<number>, LocationY: $Ref<number>): boolean;
        static GetMousePositionOnViewport(WorldContextObject: Object): Vector2D;
        static GetMousePositionOnPlatform(): Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetLayoutLibrary;
        static Load(InName: string): WidgetLayoutLibrary;
    }
    
    class WidgetSwitcher extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActiveWidgetIndex: number;
        SetActiveWidgetIndex(Index: number): void;
        SetActiveWidget(Widget: Widget): void;
        GetWidgetAtIndex(Index: number): Widget;
        GetNumWidgets(): number;
        GetActiveWidgetIndex(): number;
        GetActiveWidget(): Widget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetSwitcher;
        static Load(InName: string): WidgetSwitcher;
    }
    
    class WindowTitleBarArea extends ContentWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bWindowButtonsEnabled: boolean;
        bDoubleClickTogglesFullscreen: boolean;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindowTitleBarArea;
        static Load(InName: string): WindowTitleBarArea;
    }
    
    class WindowTitleBarAreaSlot extends PanelSlot {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Padding: Margin;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        SetVerticalAlignment(InVerticalAlignment: number): void;
        SetPadding(InPadding: Margin): void;
        SetHorizontalAlignment(InHorizontalAlignment: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindowTitleBarAreaSlot;
        static Load(InName: string): WindowTitleBarAreaSlot;
    }
    
    class WrapBox extends PanelWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerSlotPadding: Vector2D;
        WrapWidth: number;
        bExplicitWrapWidth: boolean;
        SetInnerSlotPadding(InPadding: Vector2D): void;
        AddChildToWrapBox(Content: Widget): WrapBoxSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WrapBox;
        static Load(InName: string): WrapBox;
    }
    
    class AnimationDataSourceRegistry extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataSources: TMap<string, Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationDataSourceRegistry;
        static Load(InName: string): AnimationDataSourceRegistry;
    }
    
    class AnimNotify_PlayMontageNotify extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayMontageNotify;
        static Load(InName: string): AnimNotify_PlayMontageNotify;
    }
    
    class AnimNotify_PlayMontageNotifyWindow extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayMontageNotifyWindow;
        static Load(InName: string): AnimNotify_PlayMontageNotifyWindow;
    }
    
    class AnimSequencerInstance extends AnimCustomInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequencerInstance;
        static Load(InName: string): AnimSequencerInstance;
    }
    
    class PositionHistory {
        constructor(Positions: TArray<Vector>, Range: number);
        Positions: TArray<Vector>;
        Range: number;
    }
    
    class KismetAnimationLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static K2_TwoBoneIK(RootPos: Vector, JointPos: Vector, EndPos: Vector, JointTarget: Vector, Effector: Vector, OutJointPos: $Ref<Vector>, OutEndPos: $Ref<Vector>, bAllowStretching: boolean, StartStretchRatio: number, MaxStretchScale: number): void;
        static K2_StartProfilingTimer(): void;
        static K2_MakePerlinNoiseVectorAndRemap(X: number, Y: number, Z: number, RangeOutMinX: number, RangeOutMaxX: number, RangeOutMinY: number, RangeOutMaxY: number, RangeOutMinZ: number, RangeOutMaxZ: number): Vector;
        static K2_MakePerlinNoiseAndRemap(Value: number, RangeOutMin: number, RangeOutMax: number): number;
        static K2_LookAt(CurrentTransform: Transform, TargetPosition: Vector, LookAtVector: Vector, bUseUpVector: boolean, UpVector: Vector, ClampConeInDegree: number): Transform;
        static K2_EndProfilingTimer(bLog: boolean, LogPrefix: string): number;
        static K2_DistanceBetweenTwoSocketsAndMapRange(Component: SkeletalMeshComponent, SocketOrBoneNameA: string, SocketSpaceA: number, SocketOrBoneNameB: string, SocketSpaceB: number, bRemapRange: boolean, InRangeMin: number, InRangeMax: number, OutRangeMin: number, OutRangeMax: number): number;
        static K2_DirectionBetweenSockets(Component: SkeletalMeshComponent, SocketOrBoneNameFrom: string, SocketOrBoneNameTo: string): Vector;
        static K2_CalculateVelocityFromSockets(DeltaSeconds: number, Component: SkeletalMeshComponent, SocketOrBoneName: string, ReferenceSocketOrBone: string, SocketSpace: number, OffsetInBoneSpace: Vector, History: $Ref<PositionHistory>, NumberOfSamples: number, VelocityMin: number, VelocityMax: number, EasingType: EEasingFuncType, CustomCurve: RuntimeFloatCurve): number;
        static K2_CalculateVelocityFromPositionHistory(DeltaSeconds: number, Position: Vector, History: $Ref<PositionHistory>, NumberOfSamples: number, VelocityMin: number, VelocityMax: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetAnimationLibrary;
        static Load(InName: string): KismetAnimationLibrary;
    }
    
    class BranchingPointNotifyPayload {
        constructor();
    }
    
    class PlayMontageCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnCompleted: $MulticastDelegate<(NotifyName: string) => void>;
        OnBlendOut: $MulticastDelegate<(NotifyName: string) => void>;
        OnInterrupted: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyBegin: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyEnd: $MulticastDelegate<(NotifyName: string) => void>;
        OnNotifyEndReceived(NotifyName: string, BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;
        OnNotifyBeginReceived(NotifyName: string, BranchingPointNotifyPayload: BranchingPointNotifyPayload): void;
        OnMontageEnded(Montage: AnimMontage, bInterrupted: boolean): void;
        OnMontageBlendingOut(Montage: AnimMontage, bInterrupted: boolean): void;
        static CreateProxyObjectForPlayMontage(InSkeletalMeshComponent: SkeletalMeshComponent, MontageToPlay: AnimMontage, PlayRate: number, StartingPosition: number, StartingSection: string): PlayMontageCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayMontageCallbackProxy;
        static Load(InName: string): PlayMontageCallbackProxy;
    }
    
    class MovieSceneTransformOrigin extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BP_GetTransformOrigin(): Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformOrigin;
        static Load(InName: string): MovieSceneTransformOrigin;
    }
    
    class MovieScene3DConstraintSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintId: Guid;
        ConstraintBindingID: MovieSceneObjectBindingID;
        SetConstraintBindingID(InConstraintBindingID: MovieSceneObjectBindingID): void;
        GetConstraintBindingID(): MovieSceneObjectBindingID;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DConstraintSection;
        static Load(InName: string): MovieScene3DConstraintSection;
    }
    
    class MovieScene3DAttachSection extends MovieScene3DConstraintSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AttachSocketName: string;
        AttachComponentName: string;
        bFullRevertOnDetach: boolean;
        ReAttachOnDetach: TSoftObjectPtr<Actor>;
        AttachmentLocationRule: EAttachmentRule;
        AttachmentRotationRule: EAttachmentRule;
        AttachmentScaleRule: EAttachmentRule;
        DetachmentLocationRule: EDetachmentRule;
        DetachmentRotationRule: EDetachmentRule;
        DetachmentScaleRule: EDetachmentRule;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DAttachSection;
        static Load(InName: string): MovieScene3DAttachSection;
    }
    
    class MovieScene3DConstraintTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintSections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DConstraintTrack;
        static Load(InName: string): MovieScene3DConstraintTrack;
    }
    
    class MovieScene3DAttachTrack extends MovieScene3DConstraintTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DAttachTrack;
        static Load(InName: string): MovieScene3DAttachTrack;
    }
    
    enum MovieScene3DPathSection_Axis { X, Y, Z, NEG_X, NEG_Y, NEG_Z, MovieScene3DPathSection_MAX}
    class MovieScene3DPathSection extends MovieScene3DConstraintSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimingCurve: MovieSceneFloatChannel;
        FrontAxisEnum: MovieScene3DPathSection_Axis;
        UpAxisEnum: MovieScene3DPathSection_Axis;
        bFollow: boolean;
        bReverse: boolean;
        bForceUpright: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DPathSection;
        static Load(InName: string): MovieScene3DPathSection;
    }
    
    class MovieScene3DPathTrack extends MovieScene3DConstraintTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DPathTrack;
        static Load(InName: string): MovieScene3DPathTrack;
    }
    
    class MovieScene3DTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformTrack;
        static Load(InName: string): MovieScene3DTransformTrack;
    }
    
    class MovieSceneActorReferenceKey {
        constructor(Object: MovieSceneObjectBindingID);
        Object: MovieSceneObjectBindingID;
    }
    
    class MovieSceneActorReferenceData extends MovieSceneChannel {
        constructor(KeyTimes: TArray<FrameNumber>, KeyValues: TArray<MovieSceneActorReferenceKey>);
        KeyTimes: TArray<FrameNumber>;
        KeyValues: TArray<MovieSceneActorReferenceKey>;
    }
    
    class IntegralKey {
        constructor(Time: number, Value: number);
        Time: number;
        Value: number;
    }
    
    class IntegralCurve extends IndexedCurve {
        constructor(Keys: TArray<IntegralKey>, DefaultValue: number, bUseDefaultValueBeforeFirstKey: boolean);
        Keys: TArray<IntegralKey>;
        DefaultValue: number;
        bUseDefaultValueBeforeFirstKey: boolean;
    }
    
    class MovieSceneActorReferenceSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorReferenceData: MovieSceneActorReferenceData;
        ActorGuidIndexCurve: IntegralCurve;
        ActorGuidStrings: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneActorReferenceSection;
        static Load(InName: string): MovieSceneActorReferenceSection;
    }
    
    class MovieSceneActorReferenceTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneActorReferenceTrack;
        static Load(InName: string): MovieSceneActorReferenceTrack;
    }
    
    class MovieSceneAudioSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sound: SoundBase;
        StartFrameOffset: FrameNumber;
        StartOffset: number;
        AudioStartTime: number;
        AudioDilationFactor: number;
        AudioVolume: number;
        SoundVolume: MovieSceneFloatChannel;
        PitchMultiplier: MovieSceneFloatChannel;
        bSuppressSubtitles: boolean;
        bOverrideAttenuation: boolean;
        AttenuationSettings: SoundAttenuation;
        OnQueueSubtitles: $Delegate<(Subtitles: TArray<SubtitleCue>, CueDuration: number) => void>;
        OnAudioFinished: $MulticastDelegate<() => void>;
        OnAudioPlaybackPercent: $MulticastDelegate<(PlayingSoundWave: SoundWave, PlaybackPercent: number) => void>;
        SetStartOffset(InStartOffset: FrameNumber): void;
        SetSound(InSound: SoundBase): void;
        GetStartOffset(): FrameNumber;
        GetSound(): SoundBase;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioSection;
        static Load(InName: string): MovieSceneAudioSection;
    }
    
    class MovieSceneAudioTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AudioSections: TArray<MovieSceneSection>;
        RowHeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneAudioTrack;
        static Load(InName: string): MovieSceneAudioTrack;
    }
    
    class MovieSceneBoolChannel extends MovieSceneChannel {
        constructor(Times: TArray<FrameNumber>, DefaultValue: boolean, bHasDefaultValue: boolean, Values: TArray<boolean>);
        Times: TArray<FrameNumber>;
        DefaultValue: boolean;
        bHasDefaultValue: boolean;
        Values: TArray<boolean>;
    }
    
    class MovieSceneBoolSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: boolean;
        BoolCurve: MovieSceneBoolChannel;
        bIsExternallyInverted: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBoolSection;
        static Load(InName: string): MovieSceneBoolSection;
    }
    
    class MovieSceneBoolTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBoolTrack;
        static Load(InName: string): MovieSceneBoolTrack;
    }
    
    class MovieSceneByteChannel extends MovieSceneChannel {
        constructor(Times: TArray<FrameNumber>, DefaultValue: number, bHasDefaultValue: boolean, Values: TArray<number>, Enum: Enum);
        Times: TArray<FrameNumber>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        Values: TArray<number>;
        Enum: Enum;
    }
    
    class MovieSceneByteSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ByteCurve: MovieSceneByteChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneByteSection;
        static Load(InName: string): MovieSceneByteSection;
    }
    
    class MovieSceneByteTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneByteTrack;
        static Load(InName: string): MovieSceneByteTrack;
    }
    
    class MovieSceneCameraAnimSectionData {
        constructor(CameraAnim: CameraAnim, PlayRate: number, PlayScale: number, BlendInTime: number, BlendOutTime: number, bLooping: boolean);
        CameraAnim: CameraAnim;
        PlayRate: number;
        PlayScale: number;
        BlendInTime: number;
        BlendOutTime: number;
        bLooping: boolean;
    }
    
    class MovieSceneCameraAnimSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimData: MovieSceneCameraAnimSectionData;
        CameraAnim: CameraAnim;
        PlayRate: number;
        PlayScale: number;
        BlendInTime: number;
        BlendOutTime: number;
        bLooping: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraAnimSection;
        static Load(InName: string): MovieSceneCameraAnimSection;
    }
    
    class MovieSceneCameraAnimTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraAnimSections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraAnimTrack;
        static Load(InName: string): MovieSceneCameraAnimTrack;
    }
    
    class MovieSceneCameraCutSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraGuid: Guid;
        CameraBindingID: MovieSceneObjectBindingID;
        ThumbnailReferenceOffset: number;
        SetCameraBindingID(InCameraBindingID: MovieSceneObjectBindingID): void;
        GetCameraBindingID(): MovieSceneObjectBindingID;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutSection;
        static Load(InName: string): MovieSceneCameraCutSection;
    }
    
    class MovieSceneCameraCutTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraCutTrack;
        static Load(InName: string): MovieSceneCameraCutTrack;
    }
    
    class MovieSceneCameraShakeSectionData {
        constructor(ShakeClass: Class, PlayScale: number, PlaySpace: number, UserDefinedPlaySpace: Rotator);
        ShakeClass: Class;
        PlayScale: number;
        PlaySpace: number;
        UserDefinedPlaySpace: Rotator;
    }
    
    class MovieSceneCameraShakeSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShakeData: MovieSceneCameraShakeSectionData;
        ShakeClass: Class;
        PlayScale: number;
        PlaySpace: number;
        UserDefinedPlaySpace: Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeSection;
        static Load(InName: string): MovieSceneCameraShakeSection;
    }
    
    class MovieSceneCameraShakeTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraShakeSections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCameraShakeTrack;
        static Load(InName: string): MovieSceneCameraShakeTrack;
    }
    
    class MovieSceneSectionParameters {
        constructor(StartFrameOffset: FrameNumber, TimeScale: number, HierarchicalBias: number, StartOffset: number, PrerollTime: number, PostrollTime: number);
        StartFrameOffset: FrameNumber;
        TimeScale: number;
        HierarchicalBias: number;
        StartOffset: number;
        PrerollTime: number;
        PostrollTime: number;
    }
    
    class MovieSceneSubSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parameters: MovieSceneSectionParameters;
        StartOffset: number;
        TimeScale: number;
        PrerollTime: number;
        SubSequence: MovieSceneSequence;
        ActorToRecord: TLazyObjectPtr<Actor>;
        TargetSequenceName: string;
        TargetPathToRecordTo: DirectoryPath;
        SetSequence(Sequence: MovieSceneSequence): void;
        GetSequence(): MovieSceneSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSubSection;
        static Load(InName: string): MovieSceneSubSection;
    }
    
    class MovieSceneCinematicShotSection extends MovieSceneSubSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShotDisplayName: string;
        DisplayName: string;
        ThumbnailReferenceOffset: number;
        SetShotDisplayName(InShotDisplayName: string): void;
        GetShotDisplayName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCinematicShotSection;
        static Load(InName: string): MovieSceneCinematicShotSection;
    }
    
    class MovieSceneSubTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSubTrack;
        static Load(InName: string): MovieSceneSubTrack;
    }
    
    class MovieSceneCinematicShotTrack extends MovieSceneSubTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneCinematicShotTrack;
        static Load(InName: string): MovieSceneCinematicShotTrack;
    }
    
    class MovieSceneColorSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RedCurve: MovieSceneFloatChannel;
        GreenCurve: MovieSceneFloatChannel;
        BlueCurve: MovieSceneFloatChannel;
        AlphaCurve: MovieSceneFloatChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneColorSection;
        static Load(InName: string): MovieSceneColorSection;
    }
    
    class MovieSceneColorTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsSlateColor: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneColorTrack;
        static Load(InName: string): MovieSceneColorTrack;
    }
    
    class MovieSceneEnumSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumCurve: MovieSceneByteChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEnumSection;
        static Load(InName: string): MovieSceneEnumSection;
    }
    
    class MovieSceneEnumTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Enum: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEnumTrack;
        static Load(InName: string): MovieSceneEnumTrack;
    }
    
    class MovieSceneEulerTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEulerTransformTrack;
        static Load(InName: string): MovieSceneEulerTransformTrack;
    }
    
    class MovieSceneEventPtrs {
        constructor(Function: Function, BoundObjectProperty: Property);
        Function: Function;
        BoundObjectProperty: Property;
    }
    
    class MovieSceneEventPayloadVariable {
        constructor(Value: string);
        Value: string;
    }
    
    class MovieSceneEvent {
        constructor(Ptrs: MovieSceneEventPtrs, PayloadVariables: TMap<string, MovieSceneEventPayloadVariable>, CompiledFunctionName: string, BoundObjectPinName: string, GraphGuid: Guid, NodeGuid: Guid, WeakCachedEndpoint: TWeakObjectPtr<Object>, FunctionEntry: TWeakObjectPtr<Object>);
        Ptrs: MovieSceneEventPtrs;
        PayloadVariables: TMap<string, MovieSceneEventPayloadVariable>;
        CompiledFunctionName: string;
        BoundObjectPinName: string;
        GraphGuid: Guid;
        NodeGuid: Guid;
        WeakCachedEndpoint: TWeakObjectPtr<Object>;
        FunctionEntry: TWeakObjectPtr<Object>;
    }
    
    class MovieSceneEventRepeaterSection extends MovieSceneEventSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: MovieSceneEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventRepeaterSection;
        static Load(InName: string): MovieSceneEventRepeaterSection;
    }
    
    class NameCurveKey {
        constructor(Time: number, Value: string);
        Time: number;
        Value: string;
    }
    
    class NameCurve extends IndexedCurve {
        constructor(Keys: TArray<NameCurveKey>);
        Keys: TArray<NameCurveKey>;
    }
    
    class MovieSceneEventParameters {
        constructor();
    }
    
    class EventPayload {
        constructor(EventName: string, Parameters: MovieSceneEventParameters);
        EventName: string;
        Parameters: MovieSceneEventParameters;
    }
    
    class MovieSceneEventSectionData extends MovieSceneChannel {
        constructor(Times: TArray<FrameNumber>, KeyValues: TArray<EventPayload>, KeyTimes: TArray<number>);
        Times: TArray<FrameNumber>;
        KeyValues: TArray<EventPayload>;
        KeyTimes: TArray<number>;
    }
    
    class MovieSceneEventSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Events: NameCurve;
        EventData: MovieSceneEventSectionData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventSection;
        static Load(InName: string): MovieSceneEventSection;
    }
    
    enum EFireEventsAtPosition { AtStartOfEvaluation, AtEndOfEvaluation, AfterSpawn, EFireEventsAtPosition_MAX}
    class MovieSceneEventTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        EventPosition: EFireEventsAtPosition;
        EventReceivers: TArray<MovieSceneObjectBindingID>;
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventTrack;
        static Load(InName: string): MovieSceneEventTrack;
    }
    
    class MovieSceneEventChannel extends MovieSceneChannel {
        constructor(KeyTimes: TArray<FrameNumber>, KeyValues: TArray<MovieSceneEvent>);
        KeyTimes: TArray<FrameNumber>;
        KeyValues: TArray<MovieSceneEvent>;
    }
    
    class MovieSceneEventTriggerSection extends MovieSceneEventSectionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventChannel: MovieSceneEventChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEventTriggerSection;
        static Load(InName: string): MovieSceneEventTriggerSection;
    }
    
    class MovieSceneFloatSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatCurve: MovieSceneFloatChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatSection;
        static Load(InName: string): MovieSceneFloatSection;
    }
    
    class MovieSceneFadeSection extends MovieSceneFloatSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FadeColor: LinearColor;
        bFadeAudio: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFadeSection;
        static Load(InName: string): MovieSceneFadeSection;
    }
    
    class MovieSceneFloatTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFloatTrack;
        static Load(InName: string): MovieSceneFloatTrack;
    }
    
    class MovieSceneFadeTrack extends MovieSceneFloatTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneFadeTrack;
        static Load(InName: string): MovieSceneFadeTrack;
    }
    
    class MovieSceneIntegerChannel extends MovieSceneChannel {
        constructor(Times: TArray<FrameNumber>, DefaultValue: number, bHasDefaultValue: boolean, Values: TArray<number>);
        Times: TArray<FrameNumber>;
        DefaultValue: number;
        bHasDefaultValue: boolean;
        Values: TArray<number>;
    }
    
    class MovieSceneIntegerSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntegerCurve: MovieSceneIntegerChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneIntegerSection;
        static Load(InName: string): MovieSceneIntegerSection;
    }
    
    class MovieSceneIntegerTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneIntegerTrack;
        static Load(InName: string): MovieSceneIntegerTrack;
    }
    
    enum ELevelVisibility { Visible, Hidden, ELevelVisibility_MAX}
    class MovieSceneLevelVisibilitySection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Visibility: ELevelVisibility;
        LevelNames: TArray<string>;
        SetVisibility(InVisibility: ELevelVisibility): void;
        SetLevelNames(InLevelNames: TArray<string>): void;
        GetVisibility(): ELevelVisibility;
        GetLevelNames(): TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilitySection;
        static Load(InName: string): MovieSceneLevelVisibilitySection;
    }
    
    class MovieSceneLevelVisibilityTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneLevelVisibilityTrack;
        static Load(InName: string): MovieSceneLevelVisibilityTrack;
    }
    
    class MovieSceneMaterialParameterCollectionTrack extends MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MPC: MaterialParameterCollection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMaterialParameterCollectionTrack;
        static Load(InName: string): MovieSceneMaterialParameterCollectionTrack;
    }
    
    class MovieSceneComponentMaterialTrack extends MovieSceneMaterialTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneComponentMaterialTrack;
        static Load(InName: string): MovieSceneComponentMaterialTrack;
    }
    
    class MovieSceneObjectPathChannelKeyValue {
        constructor(SoftPtr: TSoftObjectPtr<Object>, HardPtr: Object);
        SoftPtr: TSoftObjectPtr<Object>;
        HardPtr: Object;
    }
    
    class MovieSceneObjectPathChannel extends MovieSceneChannel {
        constructor(PropertyClass: Class, Times: TArray<FrameNumber>, Values: TArray<MovieSceneObjectPathChannelKeyValue>, DefaultValue: MovieSceneObjectPathChannelKeyValue);
        PropertyClass: Class;
        Times: TArray<FrameNumber>;
        Values: TArray<MovieSceneObjectPathChannelKeyValue>;
        DefaultValue: MovieSceneObjectPathChannelKeyValue;
    }
    
    class MovieSceneObjectPropertySection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectChannel: MovieSceneObjectPathChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneObjectPropertySection;
        static Load(InName: string): MovieSceneObjectPropertySection;
    }
    
    class MovieSceneObjectPropertyTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneObjectPropertyTrack;
        static Load(InName: string): MovieSceneObjectPropertyTrack;
    }
    
    class ScalarParameterNameAndCurve {
        constructor(ParameterName: string, ParameterCurve: MovieSceneFloatChannel);
        ParameterName: string;
        ParameterCurve: MovieSceneFloatChannel;
    }
    
    class VectorParameterNameAndCurves {
        constructor(ParameterName: string, XCurve: MovieSceneFloatChannel, YCurve: MovieSceneFloatChannel, ZCurve: MovieSceneFloatChannel);
        ParameterName: string;
        XCurve: MovieSceneFloatChannel;
        YCurve: MovieSceneFloatChannel;
        ZCurve: MovieSceneFloatChannel;
    }
    
    class ColorParameterNameAndCurves {
        constructor(ParameterName: string, RedCurve: MovieSceneFloatChannel, GreenCurve: MovieSceneFloatChannel, BlueCurve: MovieSceneFloatChannel, AlphaCurve: MovieSceneFloatChannel);
        ParameterName: string;
        RedCurve: MovieSceneFloatChannel;
        GreenCurve: MovieSceneFloatChannel;
        BlueCurve: MovieSceneFloatChannel;
        AlphaCurve: MovieSceneFloatChannel;
    }
    
    class TransformParameterNameAndCurves {
        constructor(ParameterName: string, Translation: FixSizeArray<MovieSceneFloatChannel>, Rotation: FixSizeArray<MovieSceneFloatChannel>, Scale: FixSizeArray<MovieSceneFloatChannel>);
        ParameterName: string;
        Translation: FixSizeArray<MovieSceneFloatChannel>;
        Rotation: FixSizeArray<MovieSceneFloatChannel>;
        Scale: FixSizeArray<MovieSceneFloatChannel>;
    }
    
    class MovieSceneParameterSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScalarParameterNamesAndCurves: TArray<ScalarParameterNameAndCurve>;
        VectorParameterNamesAndCurves: TArray<VectorParameterNameAndCurves>;
        ColorParameterNamesAndCurves: TArray<ColorParameterNameAndCurves>;
        TransformParameterNamesAndCurves: TArray<TransformParameterNameAndCurves>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParameterSection;
        static Load(InName: string): MovieSceneParameterSection;
    }
    
    class MovieSceneParticleParameterTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleParameterTrack;
        static Load(InName: string): MovieSceneParticleParameterTrack;
    }
    
    class MovieSceneParticleChannel extends MovieSceneByteChannel {
        constructor();
    }
    
    class MovieSceneParticleSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParticleKeys: MovieSceneParticleChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleSection;
        static Load(InName: string): MovieSceneParticleSection;
    }
    
    class MovieSceneParticleTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParticleSections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleTrack;
        static Load(InName: string): MovieSceneParticleTrack;
    }
    
    class MovieScenePrimitiveMaterialSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialChannel: MovieSceneObjectPathChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePrimitiveMaterialSection;
        static Load(InName: string): MovieScenePrimitiveMaterialSection;
    }
    
    class MovieScenePrimitiveMaterialTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScenePrimitiveMaterialTrack;
        static Load(InName: string): MovieScenePrimitiveMaterialTrack;
    }
    
    class MovieSceneSkeletalAnimationParams {
        constructor(Animation: AnimSequenceBase, FirstLoopStartFrameOffset: FrameNumber, StartFrameOffset: FrameNumber, EndFrameOffset: FrameNumber, PlayRate: number, bReverse: boolean, SlotName: string, Weight: MovieSceneFloatChannel, bSkipAnimNotifiers: boolean, bForceCustomMode: boolean, StartOffset: number, EndOffset: number);
        Animation: AnimSequenceBase;
        FirstLoopStartFrameOffset: FrameNumber;
        StartFrameOffset: FrameNumber;
        EndFrameOffset: FrameNumber;
        PlayRate: number;
        bReverse: boolean;
        SlotName: string;
        Weight: MovieSceneFloatChannel;
        bSkipAnimNotifiers: boolean;
        bForceCustomMode: boolean;
        StartOffset: number;
        EndOffset: number;
    }
    
    class MovieSceneSkeletalAnimationSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Params: MovieSceneSkeletalAnimationParams;
        AnimSequence: AnimSequence;
        Animation: AnimSequenceBase;
        StartOffset: number;
        EndOffset: number;
        PlayRate: number;
        bReverse: boolean;
        SlotName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSkeletalAnimationSection;
        static Load(InName: string): MovieSceneSkeletalAnimationSection;
    }
    
    class MovieSceneSkeletalAnimationTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationSections: TArray<MovieSceneSection>;
        bUseLegacySectionIndexBlend: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSkeletalAnimationTrack;
        static Load(InName: string): MovieSceneSkeletalAnimationTrack;
    }
    
    class MovieSceneSlomoSection extends MovieSceneFloatSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSlomoSection;
        static Load(InName: string): MovieSceneSlomoSection;
    }
    
    class MovieSceneSlomoTrack extends MovieSceneFloatTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSlomoTrack;
        static Load(InName: string): MovieSceneSlomoTrack;
    }
    
    class MovieSceneSpawnSection extends MovieSceneBoolSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnSection;
        static Load(InName: string): MovieSceneSpawnSection;
    }
    
    class MovieSceneSpawnTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sections: TArray<MovieSceneSection>;
        ObjectGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneSpawnTrack;
        static Load(InName: string): MovieSceneSpawnTrack;
    }
    
    class MovieSceneStringChannel extends MovieSceneChannel {
        constructor(Times: TArray<FrameNumber>, Values: TArray<string>, DefaultValue: string, bHasDefaultValue: boolean);
        Times: TArray<FrameNumber>;
        Values: TArray<string>;
        DefaultValue: string;
        bHasDefaultValue: boolean;
    }
    
    class MovieSceneStringSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StringCurve: MovieSceneStringChannel;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneStringSection;
        static Load(InName: string): MovieSceneStringSection;
    }
    
    class MovieSceneStringTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneStringTrack;
        static Load(InName: string): MovieSceneStringTrack;
    }
    
    class MovieSceneTransformTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneTransformTrack;
        static Load(InName: string): MovieSceneTransformTrack;
    }
    
    class MovieSceneVectorSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Curves: FixSizeArray<MovieSceneFloatChannel>;
        ChannelsUsed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVectorSection;
        static Load(InName: string): MovieSceneVectorSection;
    }
    
    class MovieSceneVectorTrack extends MovieScenePropertyTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumChannelsUsed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVectorTrack;
        static Load(InName: string): MovieSceneVectorTrack;
    }
    
    class MovieSceneVisibilityTrack extends MovieSceneBoolTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVisibilityTrack;
        static Load(InName: string): MovieSceneVisibilityTrack;
    }
    
    class EngineCustomTimeStep extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineCustomTimeStep;
        static Load(InName: string): EngineCustomTimeStep;
    }
    
    class FixedFrameRateCustomTimeStep extends EngineCustomTimeStep {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FixedFrameRate: FrameRate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FixedFrameRateCustomTimeStep;
        static Load(InName: string): FixedFrameRateCustomTimeStep;
    }
    
    class TimeManagementBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TransformTime(SourceTime: FrameTime, SourceRate: FrameRate, DestinationRate: FrameRate): FrameTime;
        static Subtract_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;
        static Subtract_FrameNumberFrameNumber(A: FrameNumber, B: FrameNumber): FrameNumber;
        static SnapFrameTimeToRate(SourceTime: FrameTime, SourceRate: FrameRate, SnapToRate: FrameRate): FrameTime;
        static Multiply_SecondsFrameRate(TimeInSeconds: number, FrameRate: FrameRate): FrameTime;
        static Multiply_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;
        static IsValid_MultipleOf(InFrameRate: FrameRate, OtherFramerate: FrameRate): boolean;
        static IsValid_Framerate(InFrameRate: FrameRate): boolean;
        static GetTimecodeFrameRate(): FrameRate;
        static GetTimecode(): Timecode;
        static Divide_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;
        static Conv_TimecodeToString(InTimecode: Timecode, bForceSignDisplay: boolean): string;
        static Conv_QualifiedFrameTimeToSeconds(InFrameTime: QualifiedFrameTime): number;
        static Conv_FrameRateToSeconds(InFrameRate: FrameRate): number;
        static Conv_FrameNumberToInteger(InFrameNumber: FrameNumber): number;
        static Add_FrameNumberInteger(A: FrameNumber, B: number): FrameNumber;
        static Add_FrameNumberFrameNumber(A: FrameNumber, B: FrameNumber): FrameNumber;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimeManagementBlueprintLibrary;
        static Load(InName: string): TimeManagementBlueprintLibrary;
    }
    
    class TimeSynchronizationSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseForSynchronization: boolean;
        FrameOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimeSynchronizationSource;
        static Load(InName: string): TimeSynchronizationSource;
    }
    
    class MovieSceneBindingOwnerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBindingOwnerInterface;
        static Load(InName: string): MovieSceneBindingOwnerInterface;
    }
    
    enum EMovieSceneBuiltInEasing { Linear, SinIn, SinOut, SinInOut, QuadIn, QuadOut, QuadInOut, CubicIn, CubicOut, CubicInOut, QuartIn, QuartOut, QuartInOut, QuintIn, QuintOut, QuintInOut, ExpoIn, ExpoOut, ExpoInOut, CircIn, CircOut, CircInOut, EMovieSceneBuiltInEasing_MAX}
    class MovieSceneBuiltInEasingFunction extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Type: EMovieSceneBuiltInEasing;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneBuiltInEasingFunction;
        static Load(InName: string): MovieSceneBuiltInEasingFunction;
    }
    
    class MovieSceneEasingExternalCurve extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Curve: CurveFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneEasingExternalCurve;
        static Load(InName: string): MovieSceneEasingExternalCurve;
    }
    
    class MovieSceneKeyProxy extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneKeyProxy;
        static Load(InName: string): MovieSceneKeyProxy;
    }
    
    class TestMovieSceneTrack extends MovieSceneTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHighPassFilter: boolean;
        SectionArray: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestMovieSceneTrack;
        static Load(InName: string): TestMovieSceneTrack;
    }
    
    class TestMovieSceneSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSection;
        static Load(InName: string): TestMovieSceneSection;
    }
    
    class TestMovieSceneSequence extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovieScene: MovieScene;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestMovieSceneSequence;
        static Load(InName: string): TestMovieSceneSequence;
    }
    
    class DefaultLevelSequenceInstanceData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TransformOriginActor: Actor;
        TransformOrigin: Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultLevelSequenceInstanceData;
        static Load(InName: string): DefaultLevelSequenceInstanceData;
    }
    
    class LevelSequenceMetaData extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceMetaData;
        static Load(InName: string): LevelSequenceMetaData;
    }
    
    class LevelSequenceDirector extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Player: LevelSequencePlayer;
        OnCreated(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceDirector;
        static Load(InName: string): LevelSequenceDirector;
    }
    
    class LegacyLevelSequenceDirectorBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LegacyLevelSequenceDirectorBlueprint;
        static Load(InName: string): LegacyLevelSequenceDirectorBlueprint;
    }
    
    class ActorFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayName: string;
        MenuPriority: number;
        NewActorClassName: string;
        NewActorClass: Class;
        bShowInEditorQuickMenu: boolean;
        bUseSurfaceOrientation: boolean;
        SpawnPositionOffset: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactory;
        static Load(InName: string): ActorFactory;
    }
    
    class ActorFactoryAmbientSound extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryAmbientSound;
        static Load(InName: string): ActorFactoryAmbientSound;
    }
    
    class ActorFactorySkeletalMesh extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySkeletalMesh;
        static Load(InName: string): ActorFactorySkeletalMesh;
    }
    
    class ActorFactoryAnimationAsset extends ActorFactorySkeletalMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryAnimationAsset;
        static Load(InName: string): ActorFactoryAnimationAsset;
    }
    
    class ActorFactoryAtmosphericFog extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryAtmosphericFog;
        static Load(InName: string): ActorFactoryAtmosphericFog;
    }
    
    class ActorFactoryStaticMesh extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryStaticMesh;
        static Load(InName: string): ActorFactoryStaticMesh;
    }
    
    class ActorFactoryBasicShape extends ActorFactoryStaticMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBasicShape;
        static Load(InName: string): ActorFactoryBasicShape;
    }
    
    class ActorFactoryBlueprint extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBlueprint;
        static Load(InName: string): ActorFactoryBlueprint;
    }
    
    class ActorFactoryBoxReflectionCapture extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBoxReflectionCapture;
        static Load(InName: string): ActorFactoryBoxReflectionCapture;
    }
    
    class ActorFactoryVolume extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryVolume;
        static Load(InName: string): ActorFactoryVolume;
    }
    
    class ActorFactoryBoxVolume extends ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryBoxVolume;
        static Load(InName: string): ActorFactoryBoxVolume;
    }
    
    class ActorFactoryCameraActor extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryCameraActor;
        static Load(InName: string): ActorFactoryCameraActor;
    }
    
    class ActorFactoryCharacter extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryCharacter;
        static Load(InName: string): ActorFactoryCharacter;
    }
    
    class ActorFactoryClass extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryClass;
        static Load(InName: string): ActorFactoryClass;
    }
    
    class ActorFactoryCylinderVolume extends ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryCylinderVolume;
        static Load(InName: string): ActorFactoryCylinderVolume;
    }
    
    class ActorFactoryDeferredDecal extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryDeferredDecal;
        static Load(InName: string): ActorFactoryDeferredDecal;
    }
    
    class ActorFactoryDirectionalLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryDirectionalLight;
        static Load(InName: string): ActorFactoryDirectionalLight;
    }
    
    class ActorFactoryEmitter extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryEmitter;
        static Load(InName: string): ActorFactoryEmitter;
    }
    
    class ActorFactoryEmptyActor extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bVisualizeActor: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryEmptyActor;
        static Load(InName: string): ActorFactoryEmptyActor;
    }
    
    class ActorFactoryExponentialHeightFog extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryExponentialHeightFog;
        static Load(InName: string): ActorFactoryExponentialHeightFog;
    }
    
    class ActorFactoryInteractiveFoliage extends ActorFactoryStaticMesh {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryInteractiveFoliage;
        static Load(InName: string): ActorFactoryInteractiveFoliage;
    }
    
    class ActorFactoryMatineeActor extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryMatineeActor;
        static Load(InName: string): ActorFactoryMatineeActor;
    }
    
    class ActorFactoryMovieScene extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryMovieScene;
        static Load(InName: string): ActorFactoryMovieScene;
    }
    
    class ActorFactoryNote extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryNote;
        static Load(InName: string): ActorFactoryNote;
    }
    
    class ActorFactoryPawn extends ActorFactoryEmptyActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPawn;
        static Load(InName: string): ActorFactoryPawn;
    }
    
    class ActorFactoryPhysicsAsset extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPhysicsAsset;
        static Load(InName: string): ActorFactoryPhysicsAsset;
    }
    
    class ActorFactoryPlanarReflection extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlanarReflection;
        static Load(InName: string): ActorFactoryPlanarReflection;
    }
    
    class ActorFactoryPlaneReflectionCapture extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlaneReflectionCapture;
        static Load(InName: string): ActorFactoryPlaneReflectionCapture;
    }
    
    class ActorFactoryPlayerStart extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPlayerStart;
        static Load(InName: string): ActorFactoryPlayerStart;
    }
    
    class ActorFactoryPointLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryPointLight;
        static Load(InName: string): ActorFactoryPointLight;
    }
    
    class ActorFactoryRectLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryRectLight;
        static Load(InName: string): ActorFactoryRectLight;
    }
    
    class ActorFactoryRuntimeVirtualTextureVolume extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryRuntimeVirtualTextureVolume;
        static Load(InName: string): ActorFactoryRuntimeVirtualTextureVolume;
    }
    
    class ActorFactorySkyAtmosphere extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySkyAtmosphere;
        static Load(InName: string): ActorFactorySkyAtmosphere;
    }
    
    class ActorFactorySkyLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySkyLight;
        static Load(InName: string): ActorFactorySkyLight;
    }
    
    class ActorFactorySphereReflectionCapture extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySphereReflectionCapture;
        static Load(InName: string): ActorFactorySphereReflectionCapture;
    }
    
    class ActorFactorySphereVolume extends ActorFactoryVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySphereVolume;
        static Load(InName: string): ActorFactorySphereVolume;
    }
    
    class ActorFactorySpotLight extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactorySpotLight;
        static Load(InName: string): ActorFactorySpotLight;
    }
    
    class ActorFactoryTargetPoint extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTargetPoint;
        static Load(InName: string): ActorFactoryTargetPoint;
    }
    
    class ActorFactoryTextRender extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTextRender;
        static Load(InName: string): ActorFactoryTextRender;
    }
    
    class ActorFactoryTriggerBox extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerBox;
        static Load(InName: string): ActorFactoryTriggerBox;
    }
    
    class ActorFactoryTriggerCapsule extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerCapsule;
        static Load(InName: string): ActorFactoryTriggerCapsule;
    }
    
    class ActorFactoryTriggerSphere extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryTriggerSphere;
        static Load(InName: string): ActorFactoryTriggerSphere;
    }
    
    class ActorFactoryVectorFieldVolume extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryVectorFieldVolume;
        static Load(InName: string): ActorFactoryVectorFieldVolume;
    }
    
    class ActorGroupingUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UnlockSelectedGroups(): void;
        UngroupSelected(): void;
        UngroupActors(ActorsToUngroup: TArray<Actor>): void;
        static SetGroupingActive(bInGroupingActive: boolean): void;
        RemoveSelectedFromGroup(): void;
        LockSelectedGroups(): void;
        static IsGroupingActive(): boolean;
        GroupSelected(): void;
        GroupActors(ActorsToGroup: TArray<Actor>): void;
        static Get(): ActorGroupingUtils;
        AddSelectedToGroup(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorGroupingUtils;
        static Load(InName: string): ActorGroupingUtils;
    }
    
    class AutomatedAssetImportData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupName: string;
        Filenames: TArray<string>;
        DestinationPath: string;
        FactoryName: string;
        bReplaceExisting: boolean;
        bSkipReadOnly: boolean;
        Factory: Factory;
        LevelToLoad: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomatedAssetImportData;
        static Load(InName: string): AutomatedAssetImportData;
    }
    
    class AssetImportTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Filename: string;
        DestinationPath: string;
        DestinationName: string;
        bReplaceExisting: boolean;
        bAutomated: boolean;
        bSave: boolean;
        Factory: Factory;
        Options: Object;
        ImportedObjectPaths: TArray<string>;
        Result: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetImportTask;
        static Load(InName: string): AssetImportTask;
    }
    
    class Factory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCreateNew: boolean;
        SupportedClass: Class;
        ContextClass: Class;
        Formats: TArray<string>;
        bEditAfterNew: boolean;
        bEditorImport: boolean;
        bText: boolean;
        ImportPriority: number;
        AutomatedImportData: AutomatedAssetImportData;
        AssetImportTask: AssetImportTask;
        OverwriteYesOrNoToAllState: number;
        ScriptFactoryCreateFile(InTask: AssetImportTask): boolean;
        ScriptFactoryCanImport(Filename: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Factory;
        static Load(InName: string): Factory;
    }
    
    class BlendSpaceFactory1D extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceFactory1D;
        static Load(InName: string): BlendSpaceFactory1D;
    }
    
    class AimOffsetBlendSpaceFactory1D extends BlendSpaceFactory1D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpaceFactory1D;
        static Load(InName: string): AimOffsetBlendSpaceFactory1D;
    }
    
    class BlendSpaceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceFactoryNew;
        static Load(InName: string): BlendSpaceFactoryNew;
    }
    
    class AimOffsetBlendSpaceFactoryNew extends BlendSpaceFactoryNew {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpaceFactoryNew;
        static Load(InName: string): AimOffsetBlendSpaceFactoryNew;
    }
    
    class AnalyticsPrivacySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSendUsageData: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnalyticsPrivacySettings;
        static Load(InName: string): AnalyticsPrivacySettings;
    }
    
    class AnimationBlueprintEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHideUnrelatedNodes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationBlueprintEditorOptions;
        static Load(InName: string): AnimationBlueprintEditorOptions;
    }
    
    class CompressionHolder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Compression: AnimCompress;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompressionHolder;
        static Load(InName: string): CompressionHolder;
    }
    
    class AnimBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintType: number;
        ParentClass: Class;
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintFactory;
        static Load(InName: string): AnimBlueprintFactory;
    }
    
    class AnimLayerInterfaceFactory extends AnimBlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimLayerInterfaceFactory;
        static Load(InName: string): AnimLayerInterfaceFactory;
    }
    
    class ThumbnailRenderer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ThumbnailRenderer;
        static Load(InName: string): ThumbnailRenderer;
    }
    
    class DefaultSizedThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSizeX: number;
        DefaultSizeY: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultSizedThumbnailRenderer;
        static Load(InName: string): DefaultSizedThumbnailRenderer;
    }
    
    class AnimBlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimBlueprintThumbnailRenderer;
        static Load(InName: string): AnimBlueprintThumbnailRenderer;
    }
    
    class AnimCompositeFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        SourceAnimation: AnimSequence;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompositeFactory;
        static Load(InName: string): AnimCompositeFactory;
    }
    
    class AnimCurveCompressionSettingsFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionSettingsFactory;
        static Load(InName: string): AnimCurveCompressionSettingsFactory;
    }
    
    class AnimMontageFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        SourceAnimation: AnimSequence;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimMontageFactory;
        static Load(InName: string): AnimMontageFactory;
    }
    
    class ExporterFBX extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExporterFBX;
        static Load(InName: string): ExporterFBX;
    }
    
    class AnimSequenceExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceExporterFBX;
        static Load(InName: string): AnimSequenceExporterFBX;
    }
    
    class AnimSequenceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceFactory;
        static Load(InName: string): AnimSequenceFactory;
    }
    
    class AnimSequenceThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSequenceThumbnailRenderer;
        static Load(InName: string): AnimSequenceThumbnailRenderer;
    }
    
    class AnimStreamableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeleton: Skeleton;
        SourceAnimation: AnimSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStreamableFactory;
        static Load(InName: string): AnimStreamableFactory;
    }
    
    class AssetEditorSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OpenEditorForAssets(Assets: TArray<Object>): boolean;
        CloseAllEditorsForAsset(Asset: Object): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetEditorSubsystem;
        static Load(InName: string): AssetEditorSubsystem;
    }
    
    class AssetEditorToolkitMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetEditorToolkitMenuContext;
        static Load(InName: string): AssetEditorToolkitMenuContext;
    }
    
    class Commandlet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpDescription: string;
        HelpUsage: string;
        HelpWebLink: string;
        HelpParamNames: TArray<string>;
        HelpParamDescriptions: TArray<string>;
        IsServer: boolean;
        IsClient: boolean;
        IsEditor: boolean;
        LogToConsole: boolean;
        ShowErrorCount: boolean;
        ShowProgress: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Commandlet;
        static Load(InName: string): Commandlet;
    }
    
    class AssetRegUtilCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetRegUtilCommandlet;
        static Load(InName: string): AssetRegUtilCommandlet;
    }
    
    class AudioMixerCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioMixerCommandlet;
        static Load(InName: string): AudioMixerCommandlet;
    }
    
    class AudioTestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioTestCommandlet;
        static Load(InName: string): AudioTestCommandlet;
    }
    
    class AutoReimportManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutoReimportManager;
        static Load(InName: string): AutoReimportManager;
    }
    
    class BaseWidgetBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetTree: WidgetTree;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BaseWidgetBlueprint;
        static Load(InName: string): BaseWidgetBlueprint;
    }
    
    class BlendSpaceThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpaceThumbnailRenderer;
        static Load(InName: string): BlendSpaceThumbnailRenderer;
    }
    
    class BlueprintEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHideUnrelatedNodes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEditorOptions;
        static Load(InName: string): BlueprintEditorOptions;
    }
    
    class BlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFactory;
        static Load(InName: string): BlueprintFactory;
    }
    
    class BlueprintFunctionLibraryFactory extends BlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintFunctionLibraryFactory;
        static Load(InName: string): BlueprintFunctionLibraryFactory;
    }
    
    class BlueprintInterfaceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintInterfaceFactory;
        static Load(InName: string): BlueprintInterfaceFactory;
    }
    
    class BlueprintMacroFactory extends BlueprintFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintMacroFactory;
        static Load(InName: string): BlueprintMacroFactory;
    }
    
    class BlueprintThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintThumbnailRenderer;
        static Load(InName: string): BlueprintThumbnailRenderer;
    }
    
    class CameraAnimFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraAnimFactory;
        static Load(InName: string): CameraAnimFactory;
    }
    
    class CanvasRenderTarget2DFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasRenderTarget2DFactoryNew;
        static Load(InName: string): CanvasRenderTarget2DFactoryNew;
    }
    
    class CascadeOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowModuleDump: boolean;
        BackgroundColor: Color;
        bUseSubMenus: boolean;
        bUseSpaceBarReset: boolean;
        bUseSpaceBarResetInLevel: boolean;
        Empty_Background: Color;
        Emitter_Background: Color;
        Emitter_Unselected: Color;
        Emitter_Selected: Color;
        ModuleColor_General_Unselected: Color;
        ModuleColor_General_Selected: Color;
        ModuleColor_TypeData_Unselected: Color;
        ModuleColor_TypeData_Selected: Color;
        ModuleColor_Beam_Unselected: Color;
        ModuleColor_Beam_Selected: Color;
        ModuleColor_Trail_Unselected: Color;
        ModuleColor_Trail_Selected: Color;
        ModuleColor_Spawn_Unselected: Color;
        ModuleColor_Spawn_Selected: Color;
        ModuleColor_Light_Unselected: Color;
        ModuleColor_Light_Selected: Color;
        ModuleColor_SubUV_Unselected: Color;
        ModuleColor_SubUV_Selected: Color;
        ModuleColor_Required_Unselected: Color;
        ModuleColor_Required_Selected: Color;
        ModuleColor_Event_Unselected: Color;
        ModuleColor_Event_Selected: Color;
        bShowGrid: boolean;
        GridColor_Hi: Color;
        GridColor_Low: Color;
        GridPerspectiveSize: number;
        bShowParticleCounts: boolean;
        bShowParticleEvents: boolean;
        bShowParticleTimes: boolean;
        bShowParticleDistance: boolean;
        bShowParticleMemory: boolean;
        ParticleMemoryUpdateTime: number;
        bShowFloor: boolean;
        FloorMesh: string;
        FloorPosition: Vector;
        FloorRotation: Rotator;
        FloorScale: number;
        FloorScale3D: Vector;
        ShowPPFlags: number;
        bUseSlimCascadeDraw: boolean;
        SlimCascadeDrawHeight: number;
        bCenterCascadeModuleText: boolean;
        Cascade_MouseMoveThreshold: number;
        MotionModeRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CascadeOptions;
        static Load(InName: string): CascadeOptions;
    }
    
    class ChaosPhysicalMaterialFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosPhysicalMaterialFactory;
        static Load(InName: string): ChaosPhysicalMaterialFactory;
    }
    
    class ChunkDependency {
        constructor(ChunkID: number, ParentChunkID: number);
        ChunkID: number;
        ParentChunkID: number;
    }
    
    class ChunkDependencyInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DependencyArray: TArray<ChunkDependency>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChunkDependencyInfo;
        static Load(InName: string): ChunkDependencyInfo;
    }
    
    class ClassThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassThumbnailRenderer;
        static Load(InName: string): ClassThumbnailRenderer;
    }
    
    enum EClassViewerDeveloperType { CVDT_None, CVDT_CurrentUser, CVDT_All, CVDT_Max, CVDT_MAX}
    class ClassViewerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayInternalClasses: boolean;
        DeveloperFolderType: EClassViewerDeveloperType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClassViewerSettings;
        static Load(InName: string): ClassViewerSettings;
    }
    
    class CompileAllBlueprintsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompileAllBlueprintsCommandlet;
        static Load(InName: string): CompileAllBlueprintsCommandlet;
    }
    
    class CompositeCurveTableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeCurveTableFactory;
        static Load(InName: string): CompositeCurveTableFactory;
    }
    
    class DataTableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Struct: ScriptStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataTableFactory;
        static Load(InName: string): DataTableFactory;
    }
    
    class CompositeDataTableFactory extends DataTableFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeDataTableFactory;
        static Load(InName: string): CompositeDataTableFactory;
    }
    
    class CompressAnimationsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompressAnimationsCommandlet;
        static Load(InName: string): CompressAnimationsCommandlet;
    }
    
    class EditorBrushBuilder extends BrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorBrushBuilder;
        static Load(InName: string): EditorBrushBuilder;
    }
    
    class ConeBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Z: number;
        CapZ: number;
        OuterRadius: number;
        InnerRadius: number;
        Sides: number;
        GroupName: string;
        AlignToSide: boolean;
        Hollow: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConeBuilder;
        static Load(InName: string): ConeBuilder;
    }
    
    class ContentBrowserSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumObjectsToLoadBeforeWarning: number;
        bOpenSourcesPanelByDefault: boolean;
        RealTimeThumbnails: boolean;
        DisplayFolders: boolean;
        DisplayEmptyFolders: boolean;
        FilterRecursively: boolean;
        NumObjectsInRecentList: number;
        bShowFullCollectionNameInToolTip: boolean;
        DisplayEngineFolder: boolean;
        DisplayDevelopersFolder: boolean;
        DisplayL10NFolder: boolean;
        DisplayPluginFolders: boolean;
        DisplayFavorites: boolean;
        DisplayCppFolders: boolean;
        IncludeClassNames: boolean;
        IncludeAssetPaths: boolean;
        IncludeCollectionNames: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContentBrowserSettings;
        static Load(InName: string): ContentBrowserSettings;
    }
    
    class CookCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FullGCAssetClassNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookCommandlet;
        static Load(InName: string): CookCommandlet;
    }
    
    class DeveloperSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DeveloperSettings;
        static Load(InName: string): DeveloperSettings;
    }
    
    enum ECookProgressDisplayMode { Nothing, RemainingPackages, PackageNames, NamesAndRemainingPackages, Max, ECookProgressDisplayMode_MAX}
    enum EBlueprintComponentDataCookingMethod { Disabled, AllBlueprints, EnabledBlueprintsOnly, EBlueprintComponentDataCookingMethod_MAX}
    class CookerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableCookOnTheSide: boolean;
        bEnableBuildDDCInBackground: boolean;
        bIterativeCookingForLaunchOn: boolean;
        bIterativeCookingForFileCookContent: boolean;
        bCookOnTheFlyForLaunchOn: boolean;
        CookProgressDisplayMode: ECookProgressDisplayMode;
        bIgnoreIniSettingsOutOfDateForIteration: boolean;
        bIgnoreScriptPackagesOutOfDateForIteration: boolean;
        bCompileBlueprintsInDevelopmentMode: boolean;
        BlueprintComponentDataCookingMethod: EBlueprintComponentDataCookingMethod;
        ClassesExcludedOnDedicatedServer: TArray<string>;
        ModulesExcludedOnDedicatedServer: TArray<string>;
        ClassesExcludedOnDedicatedClient: TArray<string>;
        ModulesExcludedOnDedicatedClient: TArray<string>;
        VersionedIntRValues: TArray<string>;
        DefaultPVRTCQuality: number;
        DefaultASTCQualityBySpeed: number;
        DefaultASTCQualityBySize: number;
        bAllowCookedDataInEditorBuilds: boolean;
        bCookBlueprintComponentTemplateData: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookerSettings;
        static Load(InName: string): CookerSettings;
    }
    
    class CookOnTheFlyServer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CookOnTheFlyServer;
        static Load(InName: string): CookOnTheFlyServer;
    }
    
    class CrashReporterSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UploadSymbolsPath: string;
        DownstreamStorage: string;
        RemoteStorage: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrashReporterSettings;
        static Load(InName: string): CrashReporterSettings;
    }
    
    class CrashReportsPrivacySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSendUnattendedBugReports: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrashReportsPrivacySettings;
        static Load(InName: string): CrashReportsPrivacySettings;
    }
    
    enum ECSVImportType { ECSV_DataTable, ECSV_CurveTable, ECSV_CurveFloat, ECSV_CurveVector, ECSV_CurveLinearColor, ECSV_MAX}
    class CSVImportSettings {
        constructor(ImportRowStruct: ScriptStruct, ImportType: ECSVImportType, ImportCurveInterpMode: number);
        ImportRowStruct: ScriptStruct;
        ImportType: ECSVImportType;
        ImportCurveInterpMode: number;
    }
    
    class CSVImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutomatedImportSettings: CSVImportSettings;
        TempImportDataTable: DataTable;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CSVImportFactory;
        static Load(InName: string): CSVImportFactory;
    }
    
    class CubeBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: number;
        Y: number;
        Z: number;
        WallThickness: number;
        GroupName: string;
        Hollow: boolean;
        Tessellated: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CubeBuilder;
        static Load(InName: string): CubeBuilder;
    }
    
    class CurvedStairBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerRadius: number;
        StepHeight: number;
        StepWidth: number;
        AngleOfCurve: number;
        NumSteps: number;
        AddToFirstStep: number;
        GroupName: string;
        CounterClockwise: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurvedStairBuilder;
        static Load(InName: string): CurvedStairBuilder;
    }
    
    class CurveEdOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinViewRange: number;
        MaxViewRange: number;
        BackgroundColor: LinearColor;
        LabelColor: LinearColor;
        SelectedLabelColor: LinearColor;
        GridColor: LinearColor;
        GridTextColor: LinearColor;
        LabelBlockBkgColor: LinearColor;
        SelectedKeyColor: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEdOptions;
        static Load(InName: string): CurveEdOptions;
    }
    
    class CurveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveFactory;
        static Load(InName: string): CurveFactory;
    }
    
    class CurveFloatFactory extends CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveFloatFactory;
        static Load(InName: string): CurveFloatFactory;
    }
    
    class CurveLinearColorFactory extends CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorFactory;
        static Load(InName: string): CurveLinearColorFactory;
    }
    
    class CurveVectorFactory extends CurveFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveVectorFactory;
        static Load(InName: string): CurveVectorFactory;
    }
    
    class CurveImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveImportFactory;
        static Load(InName: string): CurveImportFactory;
    }
    
    class CurveLinearColorAtlasFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorAtlasFactory;
        static Load(InName: string): CurveLinearColorAtlasFactory;
    }
    
    class CurveLinearColorThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveLinearColorThumbnailRenderer;
        static Load(InName: string): CurveLinearColorThumbnailRenderer;
    }
    
    class CylinderBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Z: number;
        OuterRadius: number;
        InnerRadius: number;
        Sides: number;
        GroupName: string;
        AlignToSide: boolean;
        Hollow: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CylinderBuilder;
        static Load(InName: string): CylinderBuilder;
    }
    
    class DataAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataAssetClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataAssetFactory;
        static Load(InName: string): DataAssetFactory;
    }
    
    class DDCCleanupCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DDCCleanupCommandlet;
        static Load(InName: string): DDCCleanupCommandlet;
    }
    
    class DebugSkelMeshComponent extends SkeletalMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRenderRawSkeleton: boolean;
        bDrawMesh: boolean;
        bShowBoneNames: boolean;
        bDrawBoneInfluences: boolean;
        bDrawMorphTargetVerts: boolean;
        bDrawNormals: boolean;
        bDrawTangents: boolean;
        bDrawBinormals: boolean;
        bDrawSockets: boolean;
        bSkeletonSocketsVisible: boolean;
        bMeshSocketsVisible: boolean;
        bDisplayRawAnimation: boolean;
        bDisplayNonRetargetedPose: boolean;
        bDisplayAdditiveBasePose: boolean;
        bDisplayBakedAnimation: boolean;
        bDisplaySourceAnimation: boolean;
        bDisplayBound: boolean;
        bDisplayVertexColors: boolean;
        bPreviewRootMotion: boolean;
        bShowClothData: boolean;
        MinClothPropertyView: number;
        MaxClothPropertyView: number;
        ClothMeshOpacity: number;
        bClothFlipNormal: boolean;
        bClothCullBackface: boolean;
        BonesOfInterest: TArray<number>;
        MorphTargetOfInterests: TArray<MorphTarget>;
        SkelMaterials: TArray<MaterialInterface>;
        PreviewInstance: AnimPreviewInstance;
        SavedAnimScriptInstance: AnimInstance;
        bIsUsingInGameBounds: boolean;
        bIsUsingPreSkinnedBounds: boolean;
        bPerformSingleClothingTick: boolean;
        bPauseClothingSimulationWithAnim: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugSkelMeshComponent;
        static Load(InName: string): DebugSkelMeshComponent;
    }
    
    class DEditorParameterValue extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bOverride: boolean;
        ParameterInfo: MaterialParameterInfo;
        ExpressionId: Guid;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorParameterValue;
        static Load(InName: string): DEditorParameterValue;
    }
    
    class DFontParameters {
        constructor(FontValue: Font, FontPage: number);
        FontValue: Font;
        FontPage: number;
    }
    
    class DEditorFontParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: DFontParameters;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorFontParameterValue;
        static Load(InName: string): DEditorFontParameterValue;
    }
    
    class DEditorMaterialLayersParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: MaterialLayersFunctions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorMaterialLayersParameterValue;
        static Load(InName: string): DEditorMaterialLayersParameterValue;
    }
    
    class DEditorRuntimeVirtualTextureParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: RuntimeVirtualTexture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorRuntimeVirtualTextureParameterValue;
        static Load(InName: string): DEditorRuntimeVirtualTextureParameterValue;
    }
    
    class ScalarParameterAtlasData {
        constructor(bIsUsedAsAtlasPosition: boolean, Curve: TSoftObjectPtr<CurveLinearColor>, Atlas: TSoftObjectPtr<CurveLinearColorAtlas>);
        bIsUsedAsAtlasPosition: boolean;
        Curve: TSoftObjectPtr<CurveLinearColor>;
        Atlas: TSoftObjectPtr<CurveLinearColorAtlas>;
    }
    
    class DEditorScalarParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: number;
        AtlasData: ScalarParameterAtlasData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorScalarParameterValue;
        static Load(InName: string): DEditorScalarParameterValue;
    }
    
    class DComponentMaskParameter {
        constructor(R: boolean, G: boolean, B: boolean, A: boolean);
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;
    }
    
    class DEditorStaticComponentMaskParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: DComponentMaskParameter;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorStaticComponentMaskParameterValue;
        static Load(InName: string): DEditorStaticComponentMaskParameterValue;
    }
    
    class DEditorStaticSwitchParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorStaticSwitchParameterValue;
        static Load(InName: string): DEditorStaticSwitchParameterValue;
    }
    
    class ParameterChannelNames {
        constructor(R: string, G: string, B: string, A: string);
        R: string;
        G: string;
        B: string;
        A: string;
    }
    
    class DEditorTextureParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: Texture;
        ChannelNames: ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorTextureParameterValue;
        static Load(InName: string): DEditorTextureParameterValue;
    }
    
    class DEditorVectorParameterValue extends DEditorParameterValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterValue: LinearColor;
        bIsUsedAsChannelMask: boolean;
        ChannelNames: ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DEditorVectorParameterValue;
        static Load(InName: string): DEditorVectorParameterValue;
    }
    
    class DerivedDataCacheCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DerivedDataCacheCommandlet;
        static Load(InName: string): DerivedDataCacheCommandlet;
    }
    
    class DiffAssetRegistriesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetRegistrySearchPath: TArray<string>;
        P4Repository: string;
        P4EngineBasePath: string;
        P4EngineAssetPath: string;
        P4GameBasePath: string;
        P4GameAssetPath: string;
        RegexBranchCL: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffAssetRegistriesCommandlet;
        static Load(InName: string): DiffAssetRegistriesCommandlet;
    }
    
    class DiffAssetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffAssetsCommandlet;
        static Load(InName: string): DiffAssetsCommandlet;
    }
    
    class DiffFilesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffFilesCommandlet;
        static Load(InName: string): DiffFilesCommandlet;
    }
    
    class DiffPackagesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Packages: FixSizeArray<Package>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DiffPackagesCommandlet;
        static Load(InName: string): DiffPackagesCommandlet;
    }
    
    class DumpBlueprintsInfoCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DumpBlueprintsInfoCommandlet;
        static Load(InName: string): DumpBlueprintsInfoCommandlet;
    }
    
    class DumpHiddenCategoriesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DumpHiddenCategoriesCommandlet;
        static Load(InName: string): DumpHiddenCategoriesCommandlet;
    }
    
    class EdGraphNode_Comment extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CommentColor: LinearColor;
        FontSize: number;
        bCommentBubbleVisible_InDetailsPanel: boolean;
        bColorCommentBubble: boolean;
        MoveMode: number;
        CommentDepth: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Comment;
        static Load(InName: string): EdGraphNode_Comment;
    }
    
    class EditorActorFolders extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorActorFolders;
        static Load(InName: string): EditorActorFolders;
    }
    
    class EditorAnimBaseObj extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimBaseObj;
        static Load(InName: string): EditorAnimBaseObj;
    }
    
    class EditorAnimCompositeSegment extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimSegment: AnimSegment;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimCompositeSegment;
        static Load(InName: string): EditorAnimCompositeSegment;
    }
    
    class EditorAnimCurveBoneLinks extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveName: SmartName;
        ConnectedBones: TArray<BoneReference>;
        MaxLOD: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimCurveBoneLinks;
        static Load(InName: string): EditorAnimCurveBoneLinks;
    }
    
    class EditorAnimSegment extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimSegment: AnimSegment;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorAnimSegment;
        static Load(InName: string): EditorAnimSegment;
    }
    
    class EditorCompositeSection extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompositeSection: CompositeSection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorCompositeSection;
        static Load(InName: string): EditorCompositeSection;
    }
    
    class GameUserSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseVSync: boolean;
        bUseDynamicResolution: boolean;
        ResolutionSizeX: number;
        ResolutionSizeY: number;
        LastUserConfirmedResolutionSizeX: number;
        LastUserConfirmedResolutionSizeY: number;
        WindowPosX: number;
        WindowPosY: number;
        FullscreenMode: number;
        LastConfirmedFullscreenMode: number;
        PreferredFullscreenMode: number;
        Version: number;
        AudioQualityLevel: number;
        LastConfirmedAudioQualityLevel: number;
        FrameRateLimit: number;
        DesiredScreenWidth: number;
        bUseDesiredScreenHeight: boolean;
        DesiredScreenHeight: number;
        LastUserConfirmedDesiredScreenWidth: number;
        LastUserConfirmedDesiredScreenHeight: number;
        LastRecommendedScreenWidth: number;
        LastRecommendedScreenHeight: number;
        LastCPUBenchmarkResult: number;
        LastGPUBenchmarkResult: number;
        LastCPUBenchmarkSteps: TArray<number>;
        LastGPUBenchmarkSteps: TArray<number>;
        LastGPUBenchmarkMultiplier: number;
        bUseHDRDisplayOutput: boolean;
        HDRDisplayOutputNits: number;
        OnGameUserSettingsUINeedsUpdate: $MulticastDelegate<() => void>;
        ValidateSettings(): void;
        SupportsHDRDisplayOutput(): boolean;
        SetVSyncEnabled(bEnable: boolean): void;
        SetVisualEffectQuality(Value: number): void;
        SetViewDistanceQuality(Value: number): void;
        SetToDefaults(): void;
        SetTextureQuality(Value: number): void;
        SetShadowQuality(Value: number): void;
        SetShadingQuality(Value: number): void;
        SetScreenResolution(Resolution: IntPoint): void;
        SetResolutionScaleValueEx(NewScaleValue: number): void;
        SetResolutionScaleValue(NewScaleValue: number): void;
        SetResolutionScaleNormalized(NewScaleNormalized: number): void;
        SetPostProcessingQuality(Value: number): void;
        SetOverallScalabilityLevel(Value: number): void;
        SetFullscreenMode(InFullscreenMode: number): void;
        SetFrameRateLimit(NewLimit: number): void;
        SetFoliageQuality(Value: number): void;
        SetDynamicResolutionEnabled(bEnable: boolean): void;
        SetBenchmarkFallbackValues(): void;
        SetAudioQualityLevel(QualityLevel: number): void;
        SetAntiAliasingQuality(Value: number): void;
        SaveSettings(): void;
        RunHardwareBenchmark(WorkScale: number, CPUMultiplier: number, GPUMultiplier: number): void;
        RevertVideoMode(): void;
        ResetToCurrentSettings(): void;
        LoadSettings(bForceReload: boolean): void;
        IsVSyncEnabled(): boolean;
        IsVSyncDirty(): boolean;
        IsScreenResolutionDirty(): boolean;
        IsHDREnabled(): boolean;
        IsFullscreenModeDirty(): boolean;
        IsDynamicResolutionEnabled(): boolean;
        IsDynamicResolutionDirty(): boolean;
        IsDirty(): boolean;
        GetVisualEffectQuality(): number;
        GetViewDistanceQuality(): number;
        GetTextureQuality(): number;
        static GetSyncInterval(): number;
        GetShadowQuality(): number;
        GetShadingQuality(): number;
        GetScreenResolution(): IntPoint;
        GetResolutionScaleNormalized(): number;
        GetResolutionScaleInformationEx(CurrentScaleNormalized: $Ref<number>, CurrentScaleValue: $Ref<number>, MinScaleValue: $Ref<number>, MaxScaleValue: $Ref<number>): void;
        GetResolutionScaleInformation(CurrentScaleNormalized: $Ref<number>, CurrentScaleValue: $Ref<number>, MinScaleValue: $Ref<number>, MaxScaleValue: $Ref<number>): void;
        GetRecommendedResolutionScale(): number;
        GetPreferredFullscreenMode(): number;
        GetPostProcessingQuality(): number;
        GetOverallScalabilityLevel(): number;
        GetLastConfirmedScreenResolution(): IntPoint;
        GetLastConfirmedFullscreenMode(): number;
        static GetGameUserSettings(): GameUserSettings;
        GetFullscreenMode(): number;
        GetFrameRateLimit(): number;
        GetFoliageQuality(): number;
        GetDesktopResolution(): IntPoint;
        static GetDefaultWindowPosition(): IntPoint;
        static GetDefaultWindowMode(): number;
        GetDefaultResolutionScale(): number;
        static GetDefaultResolution(): IntPoint;
        GetCurrentHDRDisplayNits(): number;
        GetAudioQualityLevel(): number;
        GetAntiAliasingQuality(): number;
        EnableHDRDisplayOutput(bEnable: boolean, DisplayNits: number): void;
        ConfirmVideoMode(): void;
        ApplySettings(bCheckForCommandLineOverrides: boolean): void;
        ApplyResolutionSettings(bCheckForCommandLineOverrides: boolean): void;
        ApplyNonResolutionSettings(): void;
        ApplyHardwareBenchmarkResults(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameUserSettings;
        static Load(InName: string): GameUserSettings;
    }
    
    class AssetManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectReferenceList: TArray<Object>;
        bIsGlobalAsyncScanEnvironment: boolean;
        bShouldGuessTypeAndName: boolean;
        bShouldUseSynchronousLoad: boolean;
        bIsLoadingFromPakFiles: boolean;
        bShouldAcquireMissingChunksOnLoad: boolean;
        bOnlyCookProductionAssets: boolean;
        bIsBulkScanning: boolean;
        bIsPrimaryAssetDirectoryCurrent: boolean;
        bIsManagementDatabaseCurrent: boolean;
        bUpdateManagementDatabaseAfterScan: boolean;
        bIncludeOnlyOnDiskAssets: boolean;
        NumberOfSpawnedNotifications: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetManager;
        static Load(InName: string): AssetManager;
    }
    
    class StatColorMapEntry {
        constructor(In: number, Out: Color);
        In: number;
        Out: Color;
    }
    
    class StatColorMapping {
        constructor(StatName: string, ColorMap: TArray<StatColorMapEntry>, DisableBlend: boolean);
        StatName: string;
        ColorMap: TArray<StatColorMapEntry>;
        DisableBlend: boolean;
    }
    
    class GameNameRedirect {
        constructor(OldGameName: string, NewGameName: string);
        OldGameName: string;
        NewGameName: string;
    }
    
    class ClassRedirect {
        constructor(ObjectName: string, OldClassName: string, NewClassName: string, OldSubobjName: string, NewSubobjName: string, NewClassClass: string, NewClassPackage: string, InstanceOnly: boolean);
        ObjectName: string;
        OldClassName: string;
        NewClassName: string;
        OldSubobjName: string;
        NewSubobjName: string;
        NewClassClass: string;
        NewClassPackage: string;
        InstanceOnly: boolean;
    }
    
    class PluginRedirect {
        constructor(OldPluginName: string, NewPluginName: string);
        OldPluginName: string;
        NewPluginName: string;
    }
    
    class StructRedirect {
        constructor(OldStructName: string, NewStructName: string);
        OldStructName: string;
        NewStructName: string;
    }
    
    enum ETimecodeProviderSynchronizationState { Closed, Error, Synchronized, Synchronizing, ETimecodeProviderSynchronizationState_MAX}
    class TimecodeProvider extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameDelay: number;
        GetTimecode(): Timecode;
        GetSynchronizationState(): ETimecodeProviderSynchronizationState;
        GetFrameRate(): FrameRate;
        GetDelayedTimecode(): Timecode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimecodeProvider;
        static Load(InName: string): TimecodeProvider;
    }
    
    enum ETransitionType { None, Paused, Loading, Saving, Connecting, Precaching, WaitingToConnect, MAX}
    class DropNoteInfo {
        constructor(Location: Vector, Rotation: Rotator, Comment: string);
        Location: Vector;
        Rotation: Rotator;
        Comment: string;
    }
    
    class NetDriverDefinition {
        constructor(DefName: string, DriverClassName: string, DriverClassNameFallback: string);
        DefName: string;
        DriverClassName: string;
        DriverClassNameFallback: string;
    }
    
    class Engine extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TinyFont: Font;
        TinyFontName: SoftObjectPath;
        SmallFont: Font;
        SmallFontName: SoftObjectPath;
        MediumFont: Font;
        MediumFontName: SoftObjectPath;
        LargeFont: Font;
        LargeFontName: SoftObjectPath;
        SubtitleFont: Font;
        SubtitleFontName: SoftObjectPath;
        AdditionalFonts: TArray<Font>;
        AdditionalFontNames: TArray<string>;
        ConsoleClass: Class;
        ConsoleClassName: SoftClassPath;
        GameViewportClientClass: Class;
        GameViewportClientClassName: SoftClassPath;
        LocalPlayerClass: Class;
        LocalPlayerClassName: SoftClassPath;
        WorldSettingsClass: Class;
        WorldSettingsClassName: SoftClassPath;
        NavigationSystemClassName: SoftClassPath;
        NavigationSystemClass: Class;
        NavigationSystemConfigClassName: SoftClassPath;
        NavigationSystemConfigClass: Class;
        AvoidanceManagerClassName: SoftClassPath;
        AvoidanceManagerClass: Class;
        PhysicsCollisionHandlerClass: Class;
        PhysicsCollisionHandlerClassName: SoftClassPath;
        GameUserSettingsClassName: SoftClassPath;
        GameUserSettingsClass: Class;
        AIControllerClassName: SoftClassPath;
        GameUserSettings: GameUserSettings;
        LevelScriptActorClass: Class;
        LevelScriptActorClassName: SoftClassPath;
        DefaultBlueprintBaseClassName: SoftClassPath;
        GameSingletonClassName: SoftClassPath;
        GameSingleton: Object;
        AssetManagerClassName: SoftClassPath;
        AssetManager: AssetManager;
        DefaultTexture: Texture2D;
        DefaultTextureName: SoftObjectPath;
        DefaultDiffuseTexture: Texture;
        DefaultDiffuseTextureName: SoftObjectPath;
        DefaultBSPVertexTexture: Texture2D;
        DefaultBSPVertexTextureName: SoftObjectPath;
        HighFrequencyNoiseTexture: Texture2D;
        HighFrequencyNoiseTextureName: SoftObjectPath;
        DefaultBokehTexture: Texture2D;
        DefaultBokehTextureName: SoftObjectPath;
        DefaultBloomKernelTexture: Texture2D;
        DefaultBloomKernelTextureName: SoftObjectPath;
        WireframeMaterial: Material;
        WireframeMaterialName: string;
        HairDefaultMaterial: Material;
        HairDefaultMaterialName: string;
        HairDebugMaterial: Material;
        HairDebugMaterialName: string;
        GeomMaterial: Material;
        GeomMaterialName: SoftObjectPath;
        DebugMeshMaterial: Material;
        DebugMeshMaterialName: SoftObjectPath;
        EmissiveMeshMaterial: Material;
        EmissiveMeshMaterialName: SoftObjectPath;
        LevelColorationLitMaterial: Material;
        LevelColorationLitMaterialName: string;
        LevelColorationUnlitMaterial: Material;
        LevelColorationUnlitMaterialName: string;
        LightingTexelDensityMaterial: Material;
        LightingTexelDensityName: string;
        ShadedLevelColorationLitMaterial: Material;
        ShadedLevelColorationLitMaterialName: string;
        ShadedLevelColorationUnlitMaterial: Material;
        ShadedLevelColorationUnlitMaterialName: string;
        RemoveSurfaceMaterial: Material;
        RemoveSurfaceMaterialName: SoftObjectPath;
        VertexColorMaterial: Material;
        VertexColorMaterialName: string;
        VertexColorViewModeMaterial_ColorOnly: Material;
        VertexColorViewModeMaterialName_ColorOnly: string;
        VertexColorViewModeMaterial_AlphaAsColor: Material;
        VertexColorViewModeMaterialName_AlphaAsColor: string;
        VertexColorViewModeMaterial_RedOnly: Material;
        VertexColorViewModeMaterialName_RedOnly: string;
        VertexColorViewModeMaterial_GreenOnly: Material;
        VertexColorViewModeMaterialName_GreenOnly: string;
        VertexColorViewModeMaterial_BlueOnly: Material;
        VertexColorViewModeMaterialName_BlueOnly: string;
        BoneWeightMaterial: Material;
        BoneWeightMaterialName: SoftObjectPath;
        ClothPaintMaterial: Material;
        ClothPaintMaterialWireframe: Material;
        ClothPaintMaterialInstance: MaterialInstanceDynamic;
        ClothPaintMaterialWireframeInstance: MaterialInstanceDynamic;
        ClothPaintMaterialName: SoftObjectPath;
        ClothPaintMaterialWireframeName: SoftObjectPath;
        DebugEditorMaterial: Material;
        DebugEditorMaterialName: SoftObjectPath;
        ConstraintLimitMaterial: Material;
        ConstraintLimitMaterialX: MaterialInstanceDynamic;
        ConstraintLimitMaterialXAxis: MaterialInstanceDynamic;
        ConstraintLimitMaterialY: MaterialInstanceDynamic;
        ConstraintLimitMaterialYAxis: MaterialInstanceDynamic;
        ConstraintLimitMaterialZ: MaterialInstanceDynamic;
        ConstraintLimitMaterialZAxis: MaterialInstanceDynamic;
        ConstraintLimitMaterialPrismatic: MaterialInstanceDynamic;
        InvalidLightmapSettingsMaterial: Material;
        InvalidLightmapSettingsMaterialName: SoftObjectPath;
        PreviewShadowsIndicatorMaterial: Material;
        PreviewShadowsIndicatorMaterialName: SoftObjectPath;
        ArrowMaterial: Material;
        ArrowMaterialYellow: MaterialInstanceDynamic;
        ArrowMaterialName: SoftObjectPath;
        LightingOnlyBrightness: LinearColor;
        ShaderComplexityColors: TArray<LinearColor>;
        QuadComplexityColors: TArray<LinearColor>;
        LightComplexityColors: TArray<LinearColor>;
        StationaryLightOverlapColors: TArray<LinearColor>;
        LODColorationColors: TArray<LinearColor>;
        HLODColorationColors: TArray<LinearColor>;
        StreamingAccuracyColors: TArray<LinearColor>;
        MaxPixelShaderAdditiveComplexityCount: number;
        MaxES2PixelShaderAdditiveComplexityCount: number;
        MaxES3PixelShaderAdditiveComplexityCount: number;
        MinLightMapDensity: number;
        IdealLightMapDensity: number;
        MaxLightMapDensity: number;
        bRenderLightMapDensityGrayscale: boolean;
        RenderLightMapDensityGrayscaleScale: number;
        RenderLightMapDensityColorScale: number;
        LightMapDensityVertexMappedColor: LinearColor;
        LightMapDensitySelectedColor: LinearColor;
        StatColorMappings: TArray<StatColorMapping>;
        EditorBrushMaterial: Material;
        EditorBrushMaterialName: SoftObjectPath;
        DefaultPhysMaterial: PhysicalMaterial;
        DefaultPhysMaterialName: SoftObjectPath;
        ActiveGameNameRedirects: TArray<GameNameRedirect>;
        ActiveClassRedirects: TArray<ClassRedirect>;
        ActivePluginRedirects: TArray<PluginRedirect>;
        ActiveStructRedirects: TArray<StructRedirect>;
        PreIntegratedSkinBRDFTexture: Texture2D;
        PreIntegratedSkinBRDFTextureName: SoftObjectPath;
        BlueNoiseTexture: Texture2D;
        BlueNoiseTextureName: SoftObjectPath;
        MiniFontTexture: Texture2D;
        MiniFontTextureName: SoftObjectPath;
        WeightMapPlaceholderTexture: Texture;
        WeightMapPlaceholderTextureName: SoftObjectPath;
        LightMapDensityTexture: Texture2D;
        LightMapDensityTextureName: SoftObjectPath;
        GameViewport: GameViewportClient;
        DeferredCommands: TArray<string>;
        TickCycles: number;
        GameCycles: number;
        ClientCycles: number;
        NearClipPlane: number;
        bHardwareSurveyEnabled: boolean;
        bSubtitlesEnabled: boolean;
        bSubtitlesForcedOff: boolean;
        MaximumLoopIterationCount: number;
        bCanBlueprintsTickByDefault: boolean;
        bOptimizeAnimBlueprintMemberVariableAccess: boolean;
        bAllowMultiThreadedAnimationUpdate: boolean;
        bEnableEditorPSysRealtimeLOD: boolean;
        bSmoothFrameRate: boolean;
        bUseFixedFrameRate: boolean;
        FixedFrameRate: number;
        SmoothedFrameRateRange: FloatRange;
        DefaultCustomTimeStep: EngineCustomTimeStep;
        CurrentCustomTimeStep: EngineCustomTimeStep;
        CustomTimeStepClassName: SoftClassPath;
        DefaultTimecodeProvider: TimecodeProvider;
        CustomTimecodeProvider: TimecodeProvider;
        DefaultTimecodeProviderClassName: SoftClassPath;
        TimecodeProviderClassName: SoftClassPath;
        DefaultTimecodeFrameRate: FrameRate;
        bCheckForMultiplePawnsSpawnedInAFrame: boolean;
        NumPawnsAllowedToBeSpawnedInAFrame: number;
        bShouldGenerateLowQualityLightmaps: boolean;
        C_WorldBox: Color;
        C_BrushWire: Color;
        C_AddWire: Color;
        C_SubtractWire: Color;
        C_SemiSolidWire: Color;
        C_NonSolidWire: Color;
        C_WireBackground: Color;
        C_ScaleBoxHi: Color;
        C_VolumeCollision: Color;
        C_BSPCollision: Color;
        C_OrthoBackground: Color;
        C_Volume: Color;
        C_BrushShape: Color;
        StreamingDistanceFactor: number;
        GameScreenshotSaveDirectory: DirectoryPath;
        TransitionType: ETransitionType;
        TransitionDescription: string;
        TransitionGameMode: string;
        MeshLODRange: number;
        bAllowMatureLanguage: boolean;
        CameraRotationThreshold: number;
        CameraTranslationThreshold: number;
        PrimitiveProbablyVisibleTime: number;
        MaxOcclusionPixelsFraction: number;
        bPauseOnLossOfFocus: boolean;
        MaxParticleResize: number;
        MaxParticleResizeWarn: number;
        PendingDroppedNotes: TArray<DropNoteInfo>;
        NetClientTicksPerSecond: number;
        DisplayGamma: number;
        MinDesiredFrameRate: number;
        DefaultSelectedMaterialColor: LinearColor;
        SelectedMaterialColor: LinearColor;
        SelectionOutlineColor: LinearColor;
        SubduedSelectionOutlineColor: LinearColor;
        SelectedMaterialColorOverride: LinearColor;
        bIsOverridingSelectedColor: boolean;
        bEnableOnScreenDebugMessages: boolean;
        bEnableOnScreenDebugMessagesDisplay: boolean;
        bSuppressMapWarnings: boolean;
        bDisableAILogging: boolean;
        bEnableVisualLogRecordingOnStart: number;
        ScreenSaverInhibitorSemaphore: number;
        bLockReadOnlyLevels: boolean;
        ParticleEventManagerClassPath: string;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        SelectionHighlightIntensityBillboards: number;
        NetDriverDefinitions: TArray<NetDriverDefinition>;
        ServerActors: TArray<string>;
        RuntimeServerActors: TArray<string>;
        NetErrorLogInterval: number;
        bStartedLoadMapMovie: boolean;
        NextWorldContextHandle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Engine;
        static Load(InName: string): Engine;
    }
    
    class Transactor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Transactor;
        static Load(InName: string): Transactor;
    }
    
    class EditorWorldExtensionCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorWorldExtensionCollection;
        static Load(InName: string): EditorWorldExtensionCollection;
    }
    
    class EditorWorldExtensionManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorWorldExtensionCollection: TArray<EditorWorldExtensionCollection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorWorldExtensionManager;
        static Load(InName: string): EditorWorldExtensionManager;
    }
    
    class EditorEngine extends Engine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TempModel: Model;
        ConversionTempModel: Model;
        Trans: Transactor;
        Bad: Texture2D;
        EditorFont: Font;
        PreviewSoundCue: SoundCue;
        PreviewAudioComponent: AudioComponent;
        EditorCube: StaticMesh;
        EditorSphere: StaticMesh;
        EditorPlane: StaticMesh;
        EditorCylinder: StaticMesh;
        bFastRebuild: boolean;
        IsImportingT3D: boolean;
        ClickFlags: number;
        ParentContext: Package;
        UnsnappedClickLocation: Vector;
        ClickLocation: Vector;
        ClickPlane: Plane;
        MouseMovement: Vector;
        DetailMode: number;
        UseSizingBox: boolean;
        UseAxisIndicator: boolean;
        GodMode: boolean;
        GameCommandLine: string;
        bShowBrushMarkerPolys: boolean;
        bEnableSocketSnapping: boolean;
        bEnableLODLocking: boolean;
        HeightMapExportClassName: string;
        ActorFactories: TArray<ActorFactory>;
        UserOpenedFile: string;
        InEditorGameURLOptions: string;
        PlayWorld: World;
        PlayWorldLocation: Vector;
        PlayWorldRotation: Rotator;
        bIsPlayWorldQueued: boolean;
        bIsToggleBetweenPIEandSIEQueued: boolean;
        bIsSimulateInEditorQueued: boolean;
        bAllowMultiplePIEWorlds: boolean;
        bRequestEndPlayMapQueued: boolean;
        bHasPlayWorldPlacement: boolean;
        bUseMobilePreviewForPlayWorld: boolean;
        bUseVRPreviewForPlayWorld: boolean;
        bIsSimulatingInEditor: boolean;
        bSquelchTransactionNotification: boolean;
        bNotifyUndoRedoSelectionChange: boolean;
        PlayFromHerePlayerStartClass: Class;
        EditorWorld: World;
        ActorsThatWereSelected: TArray<TWeakObjectPtr<Actor>>;
        PlayWorldDestination: number;
        CurrentPlayWorldDestination: number;
        bMobilePreviewPortrait: boolean;
        BuildPlayDevice: number;
        PlayInEditorViewportIndex: number;
        UserEditedPlayWorldURL: string;
        ScratchRenderTarget2048: TextureRenderTarget2D;
        ScratchRenderTarget1024: TextureRenderTarget2D;
        ScratchRenderTarget512: TextureRenderTarget2D;
        ScratchRenderTarget256: TextureRenderTarget2D;
        PreviewMeshComp: StaticMeshComponent;
        PreviewMeshIndex: number;
        bShowPreviewMesh: boolean;
        bCustomCameraAlignEmitter: boolean;
        CustomCameraAlignEmitterDistance: number;
        bDrawSocketsInGMode: boolean;
        bDrawParticleHelpers: boolean;
        BrushBuilders: TArray<BrushBuilder>;
        EditorWorldExtensionsManager: EditorWorldExtensionManager;
        ActorGroupingUtilsClassName: SoftClassPath;
        ActorGroupingUtils: ActorGroupingUtils;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorEngine;
        static Load(InName: string): EditorEngine;
    }
    
    class EditorExperimentalSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHDREditor: boolean;
        HDREditorNITLevel: number;
        bProceduralFoliage: boolean;
        bEnableLocalizationDashboard: boolean;
        bEnableTranslationPicker: boolean;
        bEnableFavoriteSystem: boolean;
        ConsoleForGamepadLabels: number;
        bToolbarCustomization: boolean;
        bBreakOnExceptions: boolean;
        bEnableFindAndReplaceReferences: boolean;
        BaseClassesToAllowRecompilingDuringPlayInEditor: TArray<TSoftObjectPtr<Class>>;
        ResolvedBaseClassesToAllowRecompilingDuringPlayInEditor: TArray<Class>;
        bDrawMidpointArrowsInBlueprints: boolean;
        bContextMenuChunkAssignments: boolean;
        bDisableCookInEditor: boolean;
        bSharedCookedBuilds: boolean;
        MultiProcessCooking: number;
        bEQSEditor: boolean;
        bAllowLateJoinInPIE: boolean;
        bAllowVulkanPreview: boolean;
        bEnableMultithreadedLightmapEncoding: boolean;
        bEnableMultithreadedShadowmapEncoding: boolean;
        bUseOpenCLForConvexHullDecomp: boolean;
        bAllowPotentiallyUnsafePropertyEditing: boolean;
        bFacialAnimationImporter: boolean;
        bMobilePIEPreviewDeviceLaunch: boolean;
        bTextAssetFormatSupport: boolean;
        bExampleLayersAndBlends: boolean;
        bEnableLongPathsSupport: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorExperimentalSettings;
        static Load(InName: string): EditorExperimentalSettings;
    }
    
    enum ELevelVisibilityDirtyMode { ModifyOnChange, DontModify, ELevelVisibilityDirtyMode_MAX}
    class EditorLevelUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetLevelVisibility(Level: Level, bShouldBeVisible: boolean, bForceLayersVisible: boolean, ModifyMode: ELevelVisibilityDirtyMode): void;
        static SetLevelsVisibility(Levels: TArray<Level>, bShouldBeVisible: TArray<boolean>, bForceLayersVisible: boolean, ModifyMode: ELevelVisibilityDirtyMode): void;
        static MoveSelectedActorsToLevel(DestLevel: LevelStreaming, bWarnAboutReferences: boolean): number;
        static MoveActorsToLevel(ActorsToMove: TArray<Actor>, DestStreamingLevel: LevelStreaming, bWarnAboutReferences: boolean): number;
        static MakeLevelCurrent(InStreamingLevel: LevelStreaming): void;
        static CreateNewStreamingLevel(LevelStreamingClass: Class, NewLevelPath: string, bMoveSelectedActorsIntoNewLevel: boolean): LevelStreaming;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorLevelUtils;
        static Load(InName: string): EditorLevelUtils;
    }
    
    class AutoReimportWildcard {
        constructor(Wildcard: string, bInclude: boolean);
        Wildcard: string;
        bInclude: boolean;
    }
    
    class AutoReimportDirectoryConfig {
        constructor(SourceDirectory: string, MountPoint: string, Wildcards: TArray<AutoReimportWildcard>);
        SourceDirectory: string;
        MountPoint: string;
        Wildcards: TArray<AutoReimportWildcard>;
    }
    
    class EditorLoadingSavingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoadLevelAtStartup: number;
        bForceCompilationAtStartup: boolean;
        bRestoreOpenAssetTabsOnRestart: boolean;
        bEnableSourceControlCompatabilityCheck: boolean;
        bMonitorContentDirectories: boolean;
        AutoReimportDirectories: TArray<string>;
        AutoReimportDirectorySettings: TArray<AutoReimportDirectoryConfig>;
        AutoReimportThreshold: number;
        bAutoCreateAssets: boolean;
        bAutoDeleteAssets: boolean;
        bDetectChangesOnStartup: boolean;
        bPromptBeforeAutoImporting: boolean;
        bDeleteSourceFilesWithAssets: boolean;
        bAutoReimportTextures: boolean;
        bAutoReimportCSV: boolean;
        bDirtyMigratedBlueprints: boolean;
        bAutoSaveEnable: boolean;
        bAutoSaveMaps: boolean;
        bAutoSaveContent: boolean;
        AutoSaveTimeMinutes: number;
        AutoSaveInteractionDelayInSeconds: number;
        AutoSaveWarningInSeconds: number;
        bAutomaticallyCheckoutOnAssetModification: boolean;
        bPromptForCheckoutOnAssetModification: boolean;
        bSCCAutoAddNewFiles: boolean;
        bSCCUseGlobalSettings: boolean;
        TextDiffToolPath: FilePath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorLoadingSavingSettings;
        static Load(InName: string): EditorLoadingSavingSettings;
    }
    
    class EditorMiscSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorMiscSettings;
        static Load(InName: string): EditorMiscSettings;
    }
    
    class EditorNotifyObject extends EditorAnimBaseObj {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: AnimNotifyEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorNotifyObject;
        static Load(InName: string): EditorNotifyObject;
    }
    
    class EditorParentPlayerListObj extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Overrides: TArray<AnimParentNodeAssetOverride>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorParentPlayerListObj;
        static Load(InName: string): EditorParentPlayerListObj;
    }
    
    class EditorPerformanceSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowFrameRateAndMemory: boolean;
        bThrottleCPUWhenNotForeground: boolean;
        bMonitorEditorPerformance: boolean;
        bOverrideDPIBasedEditorViewportScaling: boolean;
        bEnableSharedDDCPerformanceNotifications: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorPerformanceSettings;
        static Load(InName: string): EditorPerformanceSettings;
    }
    
    class EditorPerProjectUserSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisplayUIExtensionPoints: boolean;
        bDisplayDocumentationLink: boolean;
        bDisplayActionListItemRefIds: boolean;
        bAlwaysGatherBehaviorTreeDebuggerData: boolean;
        bDisplayBlackboardKeysInAlphabeticalOrder: boolean;
        bDisplayEngineVersionInBadge: boolean;
        bUseSimplygonSwarm: boolean;
        SimplygonServerIP: string;
        bEnableSwarmDebugging: boolean;
        SimplygonSwarmDelay: number;
        SwarmNumOfConcurrentJobs: number;
        SwarmMaxUploadChunkSizeInMB: number;
        SwarmIntermediateFolder: string;
        bAutomaticallyHotReloadNewClasses: boolean;
        bShowCompilerLogOnCompileError: boolean;
        bKeepFbxNamespace: boolean;
        bShowImportDialogAtReimport: boolean;
        DataSourceFolder: DirectoryPath;
        bKeepAttachHierarchy: boolean;
        bAnimationReimportWarnings: boolean;
        bUseCurvesForDistributions: boolean;
        PropertyMatrix_NumberOfPasteOperationsBeforeWarning: number;
        bSCSEditorShowGrid: boolean;
        bSCSEditorShowFloor: boolean;
        bGetAttentionOnUATCompletion: boolean;
        SCSViewportCameraSpeed: number;
        bAutoloadCheckedOutPackages: boolean;
        bSuppressFullyLoadPrompt: boolean;
        bAllowSelectTranslucent: boolean;
        BlueprintFavorites: BlueprintPaletteFavorites;
        AssetViewerProfileIndex: number;
        AssetViewerProfileName: string;
        MaterialQualityLevel: number;
        PreviewFeatureLevel: number;
        PreviewShaderFormatName: string;
        bPreviewFeatureLevelActive: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorPerProjectUserSettings;
        static Load(InName: string): EditorPerProjectUserSettings;
    }
    
    enum EUnit { Micrometers, Millimeters, Centimeters, Meters, Kilometers, Inches, Feet, Yards, Miles, Lightyears, Degrees, Radians, MetersPerSecond, KilometersPerHour, MilesPerHour, Celsius, Farenheit, Kelvin, Micrograms, Milligrams, Grams, Kilograms, MetricTons, Ounces, Pounds, Stones, Newtons, PoundsForce, KilogramsForce, Hertz, Kilohertz, Megahertz, Gigahertz, RevolutionsPerMinute, Bytes, Kilobytes, Megabytes, Gigabytes, Terabytes, Lumens, Milliseconds, Seconds, Minutes, Hours, Days, Months, Years, Multiplier, Percentage, Unspecified, EUnit_MAX}
    enum EUnitDisplay { None, Metric, Imperial, Invalid, EUnitDisplay_MAX}
    enum EDefaultLocationUnit { Micrometers, Millimeters, Centimeters, Meters, Kilometers, Inches, Feet, Yards, Miles, Invalid, EDefaultLocationUnit_MAX}
    class EditorProjectAppearanceSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisplayUnits: boolean;
        bDisplayUnitsOnComponentTransforms: boolean;
        DistanceUnits: TArray<EUnit>;
        MassUnits: TArray<EUnit>;
        TimeUnits: TArray<EUnit>;
        AngleUnits: EUnit;
        SpeedUnits: EUnit;
        TemperatureUnits: EUnit;
        ForceUnits: EUnit;
        UnitDisplay: EUnitDisplay;
        DefaultInputUnits: EDefaultLocationUnit;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorProjectAppearanceSettings;
        static Load(InName: string): EditorProjectAppearanceSettings;
    }
    
    enum ELevelEditor2DAxis { X, Y, Z, ELevelEditor2DAxis_MAX}
    class Mode2DLayer {
        constructor(Name: string, Depth: number);
        Name: string;
        Depth: number;
    }
    
    class LevelEditor2DSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnable2DWidget: boolean;
        bEnableSnapLayers: boolean;
        SnapAxis: ELevelEditor2DAxis;
        SnapLayers: TArray<Mode2DLayer>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditor2DSettings;
        static Load(InName: string): LevelEditor2DSettings;
    }
    
    class BlueprintEditorProjectSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bForceAllDependenciesToRecompile: boolean;
        bValidateUnloadedSoftActorReferences: boolean;
        DisabledCompilerMessagesExceptEditor: TArray<string>;
        DisabledCompilerMessages: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintEditorProjectSettings;
        static Load(InName: string): BlueprintEditorProjectSettings;
    }
    
    class EditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLoadTheMostRecentlyLoadedProjectAtStartup: boolean;
        bEditorAnalyticsEnabled: boolean;
        LocalDerivedDataCache: DirectoryPath;
        SharedDerivedDataCache: DirectoryPath;
        RecentlyOpenedProjectFiles: TArray<string>;
        CreatedProjectPaths: TArray<string>;
        bCopyStarterContentPreference: boolean;
        CompletedSurveys: TArray<Guid>;
        InProgressSurveys: TArray<Guid>;
        AutoScalabilityWorkScaleAmount: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSettings;
        static Load(InName: string): EditorSettings;
    }
    
    class EditorSkeletonNotifyObj extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Name: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSkeletonNotifyObj;
        static Load(InName: string): EditorSkeletonNotifyObj;
    }
    
    class EditorSubsystemBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetEditorSubsystem(Class: Class): EditorSubsystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorSubsystemBlueprintLibrary;
        static Load(InName: string): EditorSubsystemBlueprintLibrary;
    }
    
    class EnumFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnumFactory;
        static Load(InName: string): EnumFactory;
    }
    
    class GatherTextCommandletBase extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextCommandletBase;
        static Load(InName: string): GatherTextCommandletBase;
    }
    
    class ExportDialogueScriptCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExportDialogueScriptCommandlet;
        static Load(InName: string): ExportDialogueScriptCommandlet;
    }
    
    class ExportPakDependenciesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExportPakDependenciesCommandlet;
        static Load(InName: string): ExportPakDependenciesCommandlet;
    }
    
    class ExportTextContainer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExportText: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExportTextContainer;
        static Load(InName: string): ExportTextContainer;
    }
    
    class FbxSceneImportData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFbxFile: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportData;
        static Load(InName: string): FbxSceneImportData;
    }
    
    class FbxAssetImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportTranslation: Vector;
        ImportRotation: Rotator;
        ImportUniformScale: number;
        bConvertScene: boolean;
        bForceFrontXAxis: boolean;
        bConvertSceneUnit: boolean;
        bImportAsScene: boolean;
        FbxSceneImportDataReference: FbxSceneImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxAssetImportData;
        static Load(InName: string): FbxAssetImportData;
    }
    
    class Int32Interval {
        constructor(Min: number, Max: number);
        Min: number;
        Max: number;
    }
    
    class FbxAnimSequenceImportData extends FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bImportMeshesInBoneHierarchy: boolean;
        AnimationLength: number;
        StartFrame: number;
        EndFrame: number;
        FrameImportRange: Int32Interval;
        bUseDefaultSampleRate: boolean;
        CustomSampleRate: number;
        SourceAnimationName: string;
        bImportCustomAttribute: boolean;
        bDeleteExistingCustomAttributeCurves: boolean;
        bImportBoneTracks: boolean;
        bSetMaterialDriveParameterOnCustomAttribute: boolean;
        MaterialCurveSuffixes: TArray<string>;
        bRemoveRedundantKeys: boolean;
        bDeleteExistingMorphTargetCurves: boolean;
        bDoNotImportCurveWithZero: boolean;
        bPreserveLocalTransform: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxAnimSequenceImportData;
        static Load(InName: string): FbxAnimSequenceImportData;
    }
    
    class FbxTestPlanExpectedResult {
        constructor(ExpectedPresetsType: number, ExpectedPresetsDataInteger: TArray<number>, ExpectedPresetsDataFloat: TArray<number>, ExpectedPresetsDataDouble: TArray<number>, ExpectedPresetsDataString: TArray<string>);
        ExpectedPresetsType: number;
        ExpectedPresetsDataInteger: TArray<number>;
        ExpectedPresetsDataFloat: TArray<number>;
        ExpectedPresetsDataDouble: TArray<number>;
        ExpectedPresetsDataString: TArray<string>;
    }
    
    class ImportMeshLodSectionsData {
        constructor(SectionOriginalMaterialName: TArray<string>);
        SectionOriginalMaterialName: TArray<string>;
    }
    
    class FbxMeshImportData extends FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bTransformVertexToAbsolute: boolean;
        bBakePivotInVertex: boolean;
        bImportMeshLODs: boolean;
        NormalImportMethod: number;
        NormalGenerationMethod: number;
        bComputeWeightedNormals: boolean;
        bReorderMaterialToFbxOrder: boolean;
        ImportMaterialOriginalNameData: TArray<string>;
        ImportMeshLodData: TArray<ImportMeshLodSectionsData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxMeshImportData;
        static Load(InName: string): FbxMeshImportData;
    }
    
    class FbxStaticMeshImportData extends FbxMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshLODGroup: string;
        VertexColorImportOption: number;
        VertexOverrideColor: Color;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bGenerateLightmapUVs: boolean;
        bOneConvexHullPerUCX: boolean;
        bAutoGenerateCollision: boolean;
        bCombineMeshes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxStaticMeshImportData;
        static Load(InName: string): FbxStaticMeshImportData;
    }
    
    class FbxSkeletalMeshImportData extends FbxMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportContentType: number;
        LastImportContentType: number;
        VertexColorImportOption: number;
        VertexOverrideColor: Color;
        bUpdateSkeletonReferencePose: boolean;
        bUseT0AsRefPose: boolean;
        bPreserveSmoothingGroups: boolean;
        bImportMeshesInBoneHierarchy: boolean;
        bImportMorphTargets: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSkeletalMeshImportData;
        static Load(InName: string): FbxSkeletalMeshImportData;
    }
    
    enum EMaterialSearchLocation { Local, UnderParent, UnderRoot, AllAssets, EMaterialSearchLocation_MAX}
    class FbxTextureImportData extends FbxAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInvertNormalMaps: boolean;
        MaterialSearchLocation: EMaterialSearchLocation;
        BaseMaterialName: SoftObjectPath;
        BaseColorName: string;
        BaseDiffuseTextureName: string;
        BaseNormalTextureName: string;
        BaseEmissiveColorName: string;
        BaseEmmisiveTextureName: string;
        BaseSpecularTextureName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxTextureImportData;
        static Load(InName: string): FbxTextureImportData;
    }
    
    class FbxImportUI extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsObjImport: boolean;
        OriginalImportType: number;
        MeshTypeToImport: number;
        bOverrideFullName: boolean;
        bImportAsSkeletal: boolean;
        bImportMesh: boolean;
        Skeleton: Skeleton;
        bCreatePhysicsAsset: boolean;
        PhysicsAsset: PhysicsAsset;
        bAutoComputeLodDistances: boolean;
        LodDistance0: number;
        LodDistance1: number;
        LodDistance2: number;
        LodDistance3: number;
        LodDistance4: number;
        LodDistance5: number;
        LodDistance6: number;
        LodDistance7: number;
        MinimumLodNumber: number;
        LodNumber: number;
        bImportAnimations: boolean;
        OverrideAnimationName: string;
        bImportRigidMesh: boolean;
        bImportMaterials: boolean;
        bImportTextures: boolean;
        StaticMeshImportData: FbxStaticMeshImportData;
        SkeletalMeshImportData: FbxSkeletalMeshImportData;
        AnimSequenceImportData: FbxAnimSequenceImportData;
        TextureImportData: FbxTextureImportData;
        bAutomatedImportShouldDetectType: boolean;
        FileVersion: string;
        FileCreator: string;
        FileCreatorApplication: string;
        FileUnits: string;
        FileAxisDirection: string;
        FileSampleRate: string;
        AnimStartFrame: string;
        AnimEndFrame: string;
        ResetToDefault(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxImportUI;
        static Load(InName: string): FbxImportUI;
    }
    
    class FbxTestPlan extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestPlanName: string;
        Action: number;
        LodIndex: number;
        bDeleteFolderAssets: boolean;
        ExpectedResult: TArray<FbxTestPlanExpectedResult>;
        ImportUI: FbxImportUI;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxTestPlan;
        static Load(InName: string): FbxTestPlan;
    }
    
    enum EFbxExportCompatibility { FBX_2011, FBX_2012, FBX_2013, FBX_2014, FBX_2016, FBX_2018, FBX_MAX}
    class FbxExportOption extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FbxExportCompatibility: EFbxExportCompatibility;
        bASCII: boolean;
        bForceFrontXAxis: boolean;
        VertexColor: boolean;
        LevelOfDetail: boolean;
        Collision: boolean;
        bExportMorphTargets: boolean;
        bExportPreviewMesh: boolean;
        MapSkeletalMotionToRoot: boolean;
        bExportLocalTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxExportOption;
        static Load(InName: string): FbxExportOption;
    }
    
    class FbxFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportUI: FbxImportUI;
        OriginalImportUI: FbxImportUI;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxFactory;
        static Load(InName: string): FbxFactory;
    }
    
    class SceneImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneImportFactory;
        static Load(InName: string): SceneImportFactory;
    }
    
    class FbxSceneImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCreateContentFolderHierarchy: boolean;
        bImportAsDynamic: boolean;
        HierarchyType: number;
        bForceFrontXAxis: boolean;
        ImportTranslation: Vector;
        ImportRotation: Rotator;
        ImportUniformScale: number;
        bTransformVertexToAbsolute: boolean;
        bBakePivotInVertex: boolean;
        bImportStaticMeshLODs: boolean;
        bImportSkeletalMeshLODs: boolean;
        bInvertNormalMaps: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptions;
        static Load(InName: string): FbxSceneImportOptions;
    }
    
    class FbxSceneImportOptionsStaticMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshLODGroup: string;
        bAutoGenerateCollision: boolean;
        VertexColorImportOption: number;
        VertexOverrideColor: Color;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bBuildReversedIndexBuffer: boolean;
        bGenerateLightmapUVs: boolean;
        bOneConvexHullPerUCX: boolean;
        NormalImportMethod: number;
        NormalGenerationMethod: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptionsStaticMesh;
        static Load(InName: string): FbxSceneImportOptionsStaticMesh;
    }
    
    class FbxSceneImportOptionsSkeletalMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUpdateSkeletonReferencePose: boolean;
        bCreatePhysicsAsset: boolean;
        bUseT0AsRefPose: boolean;
        bPreserveSmoothingGroups: boolean;
        bImportMeshesInBoneHierarchy: boolean;
        bImportMorphTargets: boolean;
        ThresholdPosition: number;
        ThresholdTangentNormal: number;
        ThresholdUV: number;
        bImportAnimations: boolean;
        AnimationLength: number;
        FrameImportRange: Int32Interval;
        bUseDefaultSampleRate: boolean;
        CustomSampleRate: number;
        bImportCustomAttribute: boolean;
        bDeleteExistingCustomAttributeCurves: boolean;
        bPreserveLocalTransform: boolean;
        bDeleteExistingMorphTargetCurves: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportOptionsSkeletalMesh;
        static Load(InName: string): FbxSceneImportOptionsSkeletalMesh;
    }
    
    class FbxSceneImportFactory extends SceneImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneImportOptions: FbxSceneImportOptions;
        SceneImportOptionsStaticMesh: FbxSceneImportOptionsStaticMesh;
        SceneImportOptionsSkeletalMesh: FbxSceneImportOptionsSkeletalMesh;
        StaticMeshImportData: FbxStaticMeshImportData;
        SkeletalMeshImportData: FbxSkeletalMeshImportData;
        AnimSequenceImportData: FbxAnimSequenceImportData;
        TextureImportData: FbxTextureImportData;
        ReimportData: FbxSceneImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FbxSceneImportFactory;
        static Load(InName: string): FbxSceneImportFactory;
    }
    
    class EditorLoadingAndSavingUtils extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UnloadPackages(PackagesToUnload: TArray<Package>, bOutAnyPackagesUnloaded: $Ref<boolean>, OutErrorMessage: $Ref<string>): void;
        static SavePackagesWithDialog(PackagesToSave: TArray<Package>, bOnlyDirty: boolean): boolean;
        static SavePackages(PackagesToSave: TArray<Package>, bOnlyDirty: boolean): boolean;
        static SaveMap(World: World, AssetPath: string): boolean;
        static SaveDirtyPackagesWithDialog(bSaveMapPackages: boolean, bSaveContentPackages: boolean): boolean;
        static SaveDirtyPackages(bSaveMapPackages: boolean, bSaveContentPackages: boolean): boolean;
        static SaveCurrentLevel(): boolean;
        static NewMapFromTemplate(PathToTemplateLevel: string, bSaveExistingMap: boolean): World;
        static NewBlankMap(bSaveExistingMap: boolean): World;
        static LoadMapWithDialog(): World;
        static LoadMap(Filename: string): World;
        static ImportScene(Filename: string): void;
        static GetDirtyMapPackages(OutDirtyPackages: $Ref<TArray<Package>>): void;
        static GetDirtyContentPackages(OutDirtyPackages: $Ref<TArray<Package>>): void;
        static ExportScene(bExportSelectedActorsOnly: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorLoadingAndSavingUtils;
        static Load(InName: string): EditorLoadingAndSavingUtils;
    }
    
    class FileServerCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileServerCommandlet;
        static Load(InName: string): FileServerCommandlet;
    }
    
    class FixConflictingLocalizationKeysCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FixConflictingLocalizationKeysCommandlet;
        static Load(InName: string): FixConflictingLocalizationKeysCommandlet;
    }
    
    class ResavePackagesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ResavePackagesCommandlet;
        static Load(InName: string): ResavePackagesCommandlet;
    }
    
    class FixupNeedsLoadForEditorGameCommandlet extends ResavePackagesCommandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FixupNeedsLoadForEditorGameCommandlet;
        static Load(InName: string): FixupNeedsLoadForEditorGameCommandlet;
    }
    
    class FontFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFactory;
        static Load(InName: string): FontFactory;
    }
    
    class FontFileImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFileImportFactory;
        static Load(InName: string): FontFileImportFactory;
    }
    
    class TextureThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureThumbnailRenderer;
        static Load(InName: string): TextureThumbnailRenderer;
    }
    
    class FontThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontThumbnailRenderer;
        static Load(InName: string): FontThumbnailRenderer;
    }
    
    class ForceFeedbackAttenuationFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackAttenuationFactory;
        static Load(InName: string): ForceFeedbackAttenuationFactory;
    }
    
    class ForceFeedbackEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackEffectFactory;
        static Load(InName: string): ForceFeedbackEffectFactory;
    }
    
    class GatherTextCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextCommandlet;
        static Load(InName: string): GatherTextCommandlet;
    }
    
    class GatherTextFromAssetsCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextFromAssetsCommandlet;
        static Load(InName: string): GatherTextFromAssetsCommandlet;
    }
    
    class GatherTextFromMetaDataCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextFromMetaDataCommandlet;
        static Load(InName: string): GatherTextFromMetaDataCommandlet;
    }
    
    class GatherTextFromSourceCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GatherTextFromSourceCommandlet;
        static Load(InName: string): GatherTextFromSourceCommandlet;
    }
    
    class GenerateAssetManifestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateAssetManifestCommandlet;
        static Load(InName: string): GenerateAssetManifestCommandlet;
    }
    
    class GenerateBlueprintAPICommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateBlueprintAPICommandlet;
        static Load(InName: string): GenerateBlueprintAPICommandlet;
    }
    
    class GenerateDistillFileSetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateDistillFileSetsCommandlet;
        static Load(InName: string): GenerateDistillFileSetsCommandlet;
    }
    
    class GenerateGatherArchiveCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateGatherArchiveCommandlet;
        static Load(InName: string): GenerateGatherArchiveCommandlet;
    }
    
    class GenerateGatherManifestCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateGatherManifestCommandlet;
        static Load(InName: string): GenerateGatherManifestCommandlet;
    }
    
    class GenerateTextLocalizationReportCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateTextLocalizationReportCommandlet;
        static Load(InName: string): GenerateTextLocalizationReportCommandlet;
    }
    
    class GenerateTextLocalizationResourceCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenerateTextLocalizationResourceCommandlet;
        static Load(InName: string): GenerateTextLocalizationResourceCommandlet;
    }
    
    class GroupActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLocked: boolean;
        GroupActors: TArray<Actor>;
        SubGroups: TArray<GroupActor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GroupActor;
        static Load(InName: string): GroupActor;
    }
    
    class HapticFeedbackEffectBufferFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectBufferFactory;
        static Load(InName: string): HapticFeedbackEffectBufferFactory;
    }
    
    class HapticFeedbackEffectCurveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectCurveFactory;
        static Load(InName: string): HapticFeedbackEffectCurveFactory;
    }
    
    class HapticFeedbackEffectSoundWaveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffectSoundWaveFactory;
        static Load(InName: string): HapticFeedbackEffectSoundWaveFactory;
    }
    
    class HierarchicalLODSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bForceSettingsInAllMaps: boolean;
        DefaultSetup: TSoftObjectPtr<Class>;
        DirectoriesForHLODCommandlet: TArray<DirectoryPath>;
        MapsToBuild: TArray<FilePath>;
        bInvalidateHLODClusters: boolean;
        bDeleteHLODAssets: boolean;
        BaseMaterial: TSoftObjectPtr<MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalLODSettings;
        static Load(InName: string): HierarchicalLODSettings;
    }
    
    class HierarchicalLODVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIncludeOverlappingActors: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalLODVolume;
        static Load(InName: string): HierarchicalLODVolume;
    }
    
    class ImportAssetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GlobalImportData: AutomatedAssetImportData;
        ImportDataList: TArray<AutomatedAssetImportData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportAssetsCommandlet;
        static Load(InName: string): ImportAssetsCommandlet;
    }
    
    class ImportDialogueScriptCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportDialogueScriptCommandlet;
        static Load(InName: string): ImportDialogueScriptCommandlet;
    }
    
    class ImportLocalizedDialogueCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportLocalizedDialogueCommandlet;
        static Load(InName: string): ImportLocalizedDialogueCommandlet;
    }
    
    class ImportSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnAssetPreImport_BP: $MulticastDelegate<(InFactory: Factory, InClass: Class, InParent: Object, Name: string, Type: string) => void>;
        OnAssetPostImport_BP: $MulticastDelegate<(InFactory: Factory, InCreatedObject: Object) => void>;
        OnAssetReimport_BP: $MulticastDelegate<(InCreatedObject: Object) => void>;
        OnAssetPostLODImport_BP: $MulticastDelegate<(InObject: Object, InLODIndex: number) => void>;
        OnAssetReimport_Dyn__DelegateSignature(InCreatedObject: Object): void;
        OnAssetPreImport_Dyn__DelegateSignature(InFactory: Factory, InClass: Class, InParent: Object, Name: string, Type: string): void;
        OnAssetPostLODImport_Dyn__DelegateSignature(InObject: Object, InLODIndex: number): void;
        OnAssetPostImport_Dyn__DelegateSignature(InFactory: Factory, InCreatedObject: Object): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportSubsystem;
        static Load(InName: string): ImportSubsystem;
    }
    
    class InternationalizationConditioningCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationConditioningCommandlet;
        static Load(InName: string): InternationalizationConditioningCommandlet;
    }
    
    class InternationalizationExportCommandlet extends GatherTextCommandletBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationExportCommandlet;
        static Load(InName: string): InternationalizationExportCommandlet;
    }
    
    class InterpDataFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpDataFactoryNew;
        static Load(InName: string): InterpDataFactoryNew;
    }
    
    class LayersSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateAllViewVisibility(LayerThatChanged: string): void;
        UpdateAllActorsVisibility(bNotifySelectionChange: boolean, bRedrawViewports: boolean): boolean;
        UpdateActorVisibility(Actor: Actor, bOutSelectionChanged: $Ref<boolean>, bOutActorModified: $Ref<boolean>, bNotifySelectionChange: boolean, bRedrawViewports: boolean): boolean;
        UpdateActorAllViewsVisibility(Actor: Actor): void;
        TryGetLayer(LayerName: string, OutLayer: $Ref<Layer>): boolean;
        ToggleLayerVisibility(LayerName: string): void;
        ToggleLayersVisibility(LayerNames: TArray<string>): void;
        SetLayerVisibility(LayerName: string, bIsVisible: boolean): void;
        SetLayersVisibility(LayerNames: TArray<string>, bIsVisible: boolean): void;
        SelectActorsInLayers(LayerNames: TArray<string>, bSelect: boolean, bNotify: boolean, bSelectEvenIfHidden: boolean): boolean;
        SelectActorsInLayer(LayerName: string, bSelect: boolean, bNotify: boolean, bSelectEvenIfHidden: boolean): boolean;
        RenameLayer(OriginalLayerName: string, NewLayerName: string): boolean;
        RemoveSelectedActorsFromLayers(LayerNames: TArray<string>): boolean;
        RemoveSelectedActorsFromLayer(LayerName: string): boolean;
        RemoveLevelLayerInformation(Level: Level): void;
        RemoveActorsFromLayers(Actors: TArray<Actor>, LayerNames: TArray<string>, bUpdateStats: boolean): boolean;
        RemoveActorsFromLayer(Actors: TArray<Actor>, LayerName: string, bUpdateStats: boolean): boolean;
        RemoveActorFromLayers(Actor: Actor, LayerNames: TArray<string>, bUpdateStats: boolean): boolean;
        RemoveActorFromLayer(Actor: Actor, LayerToRemove: string, bUpdateStats: boolean): boolean;
        MakeAllLayersVisible(): void;
        IsLayer(LayerName: string): boolean;
        IsActorValidForLayer(Actor: Actor): boolean;
        InitializeNewActorLayers(Actor: Actor): boolean;
        GetWorld(): World;
        GetSelectedActors(): TArray<Actor>;
        GetLayer(LayerName: string): Layer;
        GetActorsFromLayers(LayerNames: TArray<string>): TArray<Actor>;
        GetActorsFromLayer(LayerName: string): TArray<Actor>;
        EditorRefreshLayerBrowser(): void;
        EditorMapChange(): void;
        DisassociateActorFromLayers(Actor: Actor): boolean;
        DeleteLayers(LayersToDelete: TArray<string>): void;
        DeleteLayer(LayerToDelete: string): void;
        CreateLayer(LayerName: string): Layer;
        AppendActorsFromLayers(LayerNames: TArray<string>, InOutActors: $Ref<TArray<Actor>>): void;
        AppendActorsFromLayer(LayerName: string, InOutActors: $Ref<TArray<Actor>>): void;
        AddSelectedActorsToLayers(LayerNames: TArray<string>): boolean;
        AddSelectedActorsToLayer(LayerName: string): boolean;
        AddLevelLayerInformation(Level: Level): void;
        AddAllLayersTo(OutLayers: $Ref<TArray<Layer>>): void;
        AddAllLayerNamesTo(OutLayerNames: $Ref<TArray<string>>): void;
        AddActorToLayers(Actor: Actor, LayerNames: TArray<string>): boolean;
        AddActorToLayer(Actor: Actor, LayerName: string): boolean;
        AddActorsToLayers(Actors: TArray<Actor>, LayerNames: TArray<string>): boolean;
        AddActorsToLayer(Actors: TArray<Actor>, LayerName: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LayersSubsystem;
        static Load(InName: string): LayersSubsystem;
    }
    
    class LevelEditorMiscSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoApplyLightingEnable: boolean;
        bBSPAutoUpdate: boolean;
        bAutoMoveBSPPivotOffset: boolean;
        bNavigationAutoUpdate: boolean;
        bReplaceRespectsScale: boolean;
        bAllowBackgroundAudio: boolean;
        bCreateNewAudioDeviceForPlayInEditor: boolean;
        bEnableRealTimeAudio: boolean;
        EditorVolumeLevel: number;
        bEnableEditorSounds: boolean;
        DefaultLevelStreamingClass: Class;
        bPromptWhenAddingToLevelBeforeCheckout: boolean;
        bPromptWhenAddingToLevelOutsideBounds: boolean;
        PercentageThresholdForPrompt: number;
        MinimumBoundsForCheckingSize: Vector;
        EditorScreenshotSaveDirectory: DirectoryPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorMiscSettings;
        static Load(InName: string): LevelEditorMiscSettings;
    }
    
    enum NetworkEmulationTarget { Server, Client, Any, NetworkEmulationTarget_MAX}
    class NetworkEmulationPacketSettings {
        constructor(MinLatency: number, MaxLatency: number, PacketLossPercentage: number);
        MinLatency: number;
        MaxLatency: number;
        PacketLossPercentage: number;
    }
    
    class LevelEditorPlayNetworkEmulationSettings {
        constructor(bIsNetworkEmulationEnabled: boolean, EmulationTarget: NetworkEmulationTarget, CurrentProfile: string, OutPackets: NetworkEmulationPacketSettings, InPackets: NetworkEmulationPacketSettings);
        bIsNetworkEmulationEnabled: boolean;
        EmulationTarget: NetworkEmulationTarget;
        CurrentProfile: string;
        OutPackets: NetworkEmulationPacketSettings;
        InPackets: NetworkEmulationPacketSettings;
    }
    
    class PlayScreenResolution {
        constructor(Description: string, Width: number, Height: number, AspectRatio: string, bCanSwapAspectRatio: boolean, ProfileName: string);
        Description: string;
        Width: number;
        Height: number;
        AspectRatio: string;
        bCanSwapAspectRatio: boolean;
        ProfileName: string;
    }
    
    class LevelEditorPlaySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayFromHerePlayerStartClassName: string;
        GameGetsMouseControl: boolean;
        UseMouseForTouch: boolean;
        ShowMouseControlLabel: boolean;
        MouseControlLabelPosition: number;
        ViewportGetsHMDControl: boolean;
        ShouldMinimizeEditorOnVRPIE: boolean;
        AutoRecompileBlueprints: boolean;
        EnableGameSound: boolean;
        EnablePIEEnterAndExitSounds: boolean;
        PlayInEditorSoundQualityLevel: number;
        bOnlyLoadVisibleLevelsInPIE: boolean;
        bPreferToStreamLevelsInPIE: boolean;
        NewWindowWidth: number;
        NewWindowHeight: number;
        NewWindowPosition: IntPoint;
        CenterNewWindow: boolean;
        PIEAlwaysOnTop: boolean;
        DisableStandaloneSound: boolean;
        AdditionalLaunchParameters: string;
        AdditionalLaunchParametersForMobile: string;
        BuildGameBeforeLaunch: number;
        LaunchConfiguration: number;
        bAutoCompileBlueprintsOnLaunch: boolean;
        PlayNetMode: number;
        RunUnderOneProcess: boolean;
        PlayNetDedicated: boolean;
        PlayNumberOfClients: number;
        ServerPort: number;
        ClientWindowWidth: number;
        AutoConnectToServer: boolean;
        RouteGamepadToSecondWindow: boolean;
        CreateAudioDeviceForEveryPlayer: boolean;
        ClientWindowHeight: number;
        ServerMapNameOverride: string;
        AdditionalServerGameOptions: string;
        AdditionalLaunchOptions: string;
        NetworkEmulationSettings: LevelEditorPlayNetworkEmulationSettings;
        MultipleInstanceLastHeight: number;
        MultipleInstanceLastWidth: number;
        MultipleInstancePositions: TArray<IntPoint>;
        LastExecutedLaunchDevice: string;
        LastExecutedLaunchName: string;
        LastExecutedLaunchModeType: number;
        LastExecutedPlayModeLocation: number;
        LastExecutedPlayModeType: number;
        LastExecutedPIEPreviewDevice: string;
        LaptopScreenResolutions: TArray<PlayScreenResolution>;
        MonitorScreenResolutions: TArray<PlayScreenResolution>;
        PhoneScreenResolutions: TArray<PlayScreenResolution>;
        TabletScreenResolutions: TArray<PlayScreenResolution>;
        TelevisionScreenResolutions: TArray<PlayScreenResolution>;
        DeviceToEmulate: string;
        PIESafeZoneOverride: Margin;
        CustomUnsafeZoneStarts: TArray<Vector2D>;
        CustomUnsafeZoneDimensions: TArray<Vector2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorPlaySettings;
        static Load(InName: string): LevelEditorPlaySettings;
    }
    
    enum ELandscapeFoliageEditorControlType { IgnoreCtrl, RequireCtrl, RequireNoCtrl, ELandscapeFoliageEditorControlType_MAX}
    enum EScrollGestureDirection { UseSystemSetting, Standard, Natural, EScrollGestureDirection_MAX}
    class SnapToSurfaceSettings {
        constructor(bEnabled: boolean, SnapOffsetExtent: number, bSnapRotation: boolean);
        bEnabled: boolean;
        SnapOffsetExtent: number;
        bSnapRotation: boolean;
    }
    
    class ExposureSettings {
        constructor(FixedEV100: number, bFixed: boolean);
        FixedEV100: number;
        bFixed: boolean;
    }
    
    class LevelEditorViewportInstanceSettings {
        constructor(ViewportType: number, PerspViewModeIndex: number, OrthoViewModeIndex: number, EditorShowFlagsString: string, GameShowFlagsString: string, BufferVisualizationMode: string, RayTracingDebugVisualizationMode: string, ExposureSettings: ExposureSettings, FOVAngle: number, FarViewPlane: number, bIsRealtime: boolean, bShowFPS: boolean, bShowOnScreenStats: boolean, EnabledStats: TArray<string>, bShowFullToolbar: boolean);
        ViewportType: number;
        PerspViewModeIndex: number;
        OrthoViewModeIndex: number;
        EditorShowFlagsString: string;
        GameShowFlagsString: string;
        BufferVisualizationMode: string;
        RayTracingDebugVisualizationMode: string;
        ExposureSettings: ExposureSettings;
        FOVAngle: number;
        FarViewPlane: number;
        bIsRealtime: boolean;
        bShowFPS: boolean;
        bShowOnScreenStats: boolean;
        EnabledStats: TArray<string>;
        bShowFullToolbar: boolean;
    }
    
    class LevelEditorViewportInstanceSettingsKeyValuePair {
        constructor(ConfigName: string, ConfigSettings: LevelEditorViewportInstanceSettings);
        ConfigName: string;
        ConfigSettings: LevelEditorViewportInstanceSettings;
    }
    
    class LevelEditorViewportSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FlightCameraControlType: number;
        LandscapeEditorControlType: ELandscapeFoliageEditorControlType;
        FoliageEditorControlType: ELandscapeFoliageEditorControlType;
        bPanMovesCanvas: boolean;
        bCenterZoomAroundCursor: boolean;
        bAllowTranslateRotateZWidget: boolean;
        bAllowArcballRotate: boolean;
        bAllowScreenRotate: boolean;
        bClickBSPSelectsBrush: boolean;
        CameraSpeed: number;
        CameraSpeedScalar: number;
        MouseScrollCameraSpeed: number;
        MouseSensitivty: number;
        bInvertMouseLookYAxis: boolean;
        bInvertOrbitYAxis: boolean;
        bInvertMiddleMousePan: boolean;
        bInvertRightMouseDollyYAxis: boolean;
        bUseAbsoluteTranslation: boolean;
        bLevelStreamingVolumePrevis: boolean;
        bUseUE3OrbitControls: boolean;
        ScrollGestureDirectionFor3DViewports: EScrollGestureDirection;
        ScrollGestureDirectionForOrthoViewports: EScrollGestureDirection;
        bLevelEditorJoystickControls: boolean;
        bUseDistanceScaledCameraSpeed: boolean;
        bOrbitCameraAroundSelection: boolean;
        bUsePowerOf2SnapSize: boolean;
        DecimalGridSizes: TArray<number>;
        DecimalGridIntervals: TArray<number>;
        Pow2GridSizes: TArray<number>;
        Pow2GridIntervals: TArray<number>;
        CommonRotGridSizes: TArray<number>;
        DivisionsOf360RotGridSizes: TArray<number>;
        ScalingGridSizes: TArray<number>;
        GridEnabled: boolean;
        RotGridEnabled: boolean;
        SnapScaleEnabled: boolean;
        SnapToSurface: SnapToSurfaceSettings;
        bUsePercentageBasedScaling: boolean;
        bEnableLayerSnap: boolean;
        ActiveSnapLayerIndex: number;
        bEnableActorSnap: boolean;
        ActorSnapScale: number;
        ActorSnapDistance: number;
        bSnapVertices: boolean;
        SnapDistance: number;
        CurrentPosGridSize: number;
        CurrentRotGridSize: number;
        CurrentScalingGridSize: number;
        PreserveNonUniformScale: boolean;
        CurrentRotGridMode: number;
        AspectRatioAxisConstraint: number;
        bEnableViewportHoverFeedback: boolean;
        bHighlightWithBrackets: boolean;
        bUseLinkedOrthographicViewports: boolean;
        bStrictBoxSelection: boolean;
        bTransparentBoxSelection: boolean;
        bUseSelectionOutline: boolean;
        SelectionHighlightIntensity: number;
        BSPSelectionHighlightIntensity: number;
        bEnableViewportCameraToUpdateFromPIV: boolean;
        bPreviewSelectedCameras: boolean;
        CameraPreviewSize: number;
        BackgroundDropDistance: number;
        PreviewMeshes: TArray<SoftObjectPath>;
        BillboardScale: number;
        TransformWidgetSizeAdjustment: number;
        bSaveEngineStats: boolean;
        MeasuringToolUnits: number;
        PerInstanceSettings: TArray<LevelEditorViewportInstanceSettingsKeyValuePair>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorViewportSettings;
        static Load(InName: string): LevelEditorViewportSettings;
    }
    
    class LevelExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterFBX;
        static Load(InName: string): LevelExporterFBX;
    }
    
    class LevelExporterLOD extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterLOD;
        static Load(InName: string): LevelExporterLOD;
    }
    
    class LevelExporterOBJ extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterOBJ;
        static Load(InName: string): LevelExporterOBJ;
    }
    
    class LevelExporterSTL extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterSTL;
        static Load(InName: string): LevelExporterSTL;
    }
    
    class LevelExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelExporterT3D;
        static Load(InName: string): LevelExporterT3D;
    }
    
    class LevelFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelFactory;
        static Load(InName: string): LevelFactory;
    }
    
    class LevelThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelThumbnailRenderer;
        static Load(InName: string): LevelThumbnailRenderer;
    }
    
    class LightmassDebugOptions {
        constructor(bDebugMode: boolean, bStatsEnabled: boolean, bGatherBSPSurfacesAcrossComponents: boolean, CoplanarTolerance: number, bUseImmediateImport: boolean, bImmediateProcessMappings: boolean, bSortMappings: boolean, bDumpBinaryFiles: boolean, bDebugMaterials: boolean, bPadMappings: boolean, bDebugPaddings: boolean, bOnlyCalcDebugTexelMappings: boolean, bUseRandomColors: boolean, bColorBordersGreen: boolean, bColorByExecutionTime: boolean, ExecutionTimeDivisor: number);
        bDebugMode: boolean;
        bStatsEnabled: boolean;
        bGatherBSPSurfacesAcrossComponents: boolean;
        CoplanarTolerance: number;
        bUseImmediateImport: boolean;
        bImmediateProcessMappings: boolean;
        bSortMappings: boolean;
        bDumpBinaryFiles: boolean;
        bDebugMaterials: boolean;
        bPadMappings: boolean;
        bDebugPaddings: boolean;
        bOnlyCalcDebugTexelMappings: boolean;
        bUseRandomColors: boolean;
        bColorBordersGreen: boolean;
        bColorByExecutionTime: boolean;
        ExecutionTimeDivisor: number;
    }
    
    class SwarmDebugOptions {
        constructor(bDistributionEnabled: boolean, bForceContentExport: boolean, bInitialized: boolean);
        bDistributionEnabled: boolean;
        bForceContentExport: boolean;
        bInitialized: boolean;
    }
    
    class LightmassOptionsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugSettings: LightmassDebugOptions;
        SwarmSettings: SwarmDebugOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassOptionsObject;
        static Load(InName: string): LightmassOptionsObject;
    }
    
    class LinearStairBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StepLength: number;
        StepHeight: number;
        StepWidth: number;
        NumSteps: number;
        AddToFirstStep: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LinearStairBuilder;
        static Load(InName: string): LinearStairBuilder;
    }
    
    class ListMaterialsUsedWithMeshEmittersCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListMaterialsUsedWithMeshEmittersCommandlet;
        static Load(InName: string): ListMaterialsUsedWithMeshEmittersCommandlet;
    }
    
    class ListStaticMeshesImportedFromSpeedTreesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ListStaticMeshesImportedFromSpeedTreesCommandlet;
        static Load(InName: string): ListStaticMeshesImportedFromSpeedTreesCommandlet;
    }
    
    class LoadPackageCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LoadPackageCommandlet;
        static Load(InName: string): LoadPackageCommandlet;
    }
    
    class EditorParameterGroup {
        constructor(GroupName: string, GroupAssociation: number, Parameters: TArray<DEditorParameterValue>, GroupSortPriority: number);
        GroupName: string;
        GroupAssociation: number;
        Parameters: TArray<DEditorParameterValue>;
        GroupSortPriority: number;
    }
    
    class MaterialFunctionInstance extends MaterialFunctionInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: MaterialFunctionInterface;
        Base: MaterialFunctionInterface;
        ScalarParameterValues: TArray<ScalarParameterValue>;
        VectorParameterValues: TArray<VectorParameterValue>;
        TextureParameterValues: TArray<TextureParameterValue>;
        FontParameterValues: TArray<FontParameterValue>;
        StaticSwitchParameterValues: TArray<StaticSwitchParameter>;
        StaticComponentMaskParameterValues: TArray<StaticComponentMaskParameter>;
        RuntimeVirtualTextureParameterValues: TArray<RuntimeVirtualTextureParameterValue>;
        PreviewMaterial: MaterialInstanceConstant;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInstance;
        static Load(InName: string): MaterialFunctionInstance;
    }
    
    class LightmassParameterValue {
        constructor(bOverride: boolean);
        bOverride: boolean;
    }
    
    class LightmassBooleanParameterValue extends LightmassParameterValue {
        constructor(ParameterValue: boolean);
        ParameterValue: boolean;
    }
    
    class LightmassScalarParameterValue extends LightmassParameterValue {
        constructor(ParameterValue: number);
        ParameterValue: number;
    }
    
    class LightmassParameterizedMaterialSettings {
        constructor(CastShadowAsMasked: LightmassBooleanParameterValue, EmissiveBoost: LightmassScalarParameterValue, DiffuseBoost: LightmassScalarParameterValue, ExportResolutionScale: LightmassScalarParameterValue);
        CastShadowAsMasked: LightmassBooleanParameterValue;
        EmissiveBoost: LightmassScalarParameterValue;
        DiffuseBoost: LightmassScalarParameterValue;
        ExportResolutionScale: LightmassScalarParameterValue;
    }
    
    class MaterialEditorInstanceConstant extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysMaterial: PhysicalMaterial;
        Parent: MaterialInterface;
        ParameterGroups: TArray<EditorParameterGroup>;
        RefractionDepthBias: number;
        SubsurfaceProfile: SubsurfaceProfile;
        bOverrideSubsurfaceProfile: boolean;
        bOverrideBaseProperties: boolean;
        bIsFunctionPreviewMaterial: boolean;
        bIsFunctionInstanceDirty: boolean;
        BasePropertyOverrides: MaterialInstanceBasePropertyOverrides;
        SourceInstance: MaterialInstanceConstant;
        SourceFunction: MaterialFunctionInstance;
        VisibleExpressions: TArray<MaterialParameterInfo>;
        LightmassSettings: LightmassParameterizedMaterialSettings;
        bUseOldStyleMICEditorGroups: boolean;
        StoredLayerPreviews: TArray<MaterialInstanceConstant>;
        StoredBlendPreviews: TArray<MaterialInstanceConstant>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorInstanceConstant;
        static Load(InName: string): MaterialEditorInstanceConstant;
    }
    
    class MaterialEditorMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorMeshComponent;
        static Load(InName: string): MaterialEditorMeshComponent;
    }
    
    class MaterialEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowGrid: boolean;
        bHideUnusedConnectors: boolean;
        bRealtimeMaterialViewport: boolean;
        bRealtimeExpressionViewport: boolean;
        bLivePreviewUpdate: boolean;
        bHideUnrelatedNodes: boolean;
        bAlwaysRefreshAllPreviews: boolean;
        bUseUnsortedMenus: boolean;
        FavoriteExpressions: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorOptions;
        static Load(InName: string): MaterialEditorOptions;
    }
    
    class MaterialEditorPreviewParameters extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterGroups: TArray<EditorParameterGroup>;
        PreviewMaterial: Material;
        OriginalFunction: MaterialFunction;
        OriginalMaterial: Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialEditorPreviewParameters;
        static Load(InName: string): MaterialEditorPreviewParameters;
    }
    
    class MaterialFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFactoryNew;
        static Load(InName: string): MaterialFactoryNew;
    }
    
    class MaterialFunctionFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionFactoryNew;
        static Load(InName: string): MaterialFunctionFactoryNew;
    }
    
    class MaterialFunctionInstanceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialParent: MaterialFunctionInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionInstanceFactory;
        static Load(InName: string): MaterialFunctionInstanceFactory;
    }
    
    class MaterialFunctionMaterialLayerInstanceFactory extends MaterialFunctionInstanceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerInstanceFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerInstanceFactory;
    }
    
    class MaterialFunctionMaterialLayerBlendInstanceFactory extends MaterialFunctionInstanceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendInstanceFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerBlendInstanceFactory;
    }
    
    class MaterialFunctionMaterialLayerBlendFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerBlendFactory;
    }
    
    class MaterialFunctionMaterialLayerFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerFactory;
        static Load(InName: string): MaterialFunctionMaterialLayerFactory;
    }
    
    class MaterialFunctionThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionThumbnailRenderer;
        static Load(InName: string): MaterialFunctionThumbnailRenderer;
    }
    
    class MaterialGraphNode_Base extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Base;
        static Load(InName: string): MaterialGraphNode_Base;
    }
    
    class MaterialGraphNode_Root extends MaterialGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Root;
        static Load(InName: string): MaterialGraphNode_Root;
    }
    
    class MaterialGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Material: Material;
        MaterialFunction: MaterialFunction;
        RootNode: MaterialGraphNode_Root;
        OriginalMaterialFullName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraph;
        static Load(InName: string): MaterialGraph;
    }
    
    class MaterialGraphNode extends MaterialGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialExpression: MaterialExpression;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode;
        static Load(InName: string): MaterialGraphNode;
    }
    
    class MaterialGraphNode_Comment extends EdGraphNode_Comment {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialExpressionComment: MaterialExpressionComment;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Comment;
        static Load(InName: string): MaterialGraphNode_Comment;
    }
    
    class MaterialGraphNode_Knot extends MaterialGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphNode_Knot;
        static Load(InName: string): MaterialGraphNode_Knot;
    }
    
    class MaterialGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialGraphSchema;
        static Load(InName: string): MaterialGraphSchema;
    }
    
    class MaterialImportHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FindExistingMaterialFromSearchLocation(MaterialFullName: string, BasePackagePath: string, SearchLocation: EMaterialSearchLocation, OutError: $Ref<string>): MaterialInterface;
        static FindExistingMaterial(BasePath: string, MaterialFullName: string, bRecursivePaths: boolean, OutError: $Ref<string>): MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialImportHelpers;
        static Load(InName: string): MaterialImportHelpers;
    }
    
    class MaterialInstanceConstantFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialParent: MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceConstantFactoryNew;
        static Load(InName: string): MaterialInstanceConstantFactoryNew;
    }
    
    class MaterialInstanceThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceThumbnailRenderer;
        static Load(InName: string): MaterialInstanceThumbnailRenderer;
    }
    
    class MaterialParameterCollectionFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialParameterCollectionFactoryNew;
        static Load(InName: string): MaterialParameterCollectionFactoryNew;
    }
    
    class MaterialStatsOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPlatformUsed: FixSizeArray<number>;
        bMaterialQualityUsed: FixSizeArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialStatsOptions;
        static Load(InName: string): MaterialStatsOptions;
    }
    
    class MergeShaderPipelineCachesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MergeShaderPipelineCachesCommandlet;
        static Load(InName: string): MergeShaderPipelineCachesCommandlet;
    }
    
    class ModelExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ModelExporterT3D;
        static Load(InName: string): ModelExporterT3D;
    }
    
    class ModelFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ModelFactory;
        static Load(InName: string): ModelFactory;
    }
    
    class NativeCodeGenCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NativeCodeGenCommandlet;
        static Load(InName: string): NativeCodeGenCommandlet;
    }
    
    class ObjectExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectExporterT3D;
        static Load(InName: string): ObjectExporterT3D;
    }
    
    class ObjectLibraryFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectLibraryFactory;
        static Load(InName: string): ObjectLibraryFactory;
    }
    
    class PackageFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageFactory;
        static Load(InName: string): PackageFactory;
    }
    
    class PackageTools extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SanitizePackageName(InPackageName: string): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageTools;
        static Load(InName: string): PackageTools;
    }
    
    class PackFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackFactory;
        static Load(InName: string): PackFactory;
    }
    
    class ParticleSystemAuditCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HighSpawnRateOrBurstThreshold: number;
        FarLODDistanceTheshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemAuditCommandlet;
        static Load(InName: string): ParticleSystemAuditCommandlet;
    }
    
    class ParticleSystemFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemFactoryNew;
        static Load(InName: string): ParticleSystemFactoryNew;
    }
    
    class ParticleSystemThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NoImage: Texture2D;
        OutOfDate: Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSystemThumbnailRenderer;
        static Load(InName: string): ParticleSystemThumbnailRenderer;
    }
    
    enum EAnimationViewportCameraFollowMode { None, Bounds, Bone, EAnimationViewportCameraFollowMode_MAX}
    class ViewportConfigOptions {
        constructor(ViewModeIndex: number, ViewFOV: number, CameraFollowMode: EAnimationViewportCameraFollowMode, CameraFollowBoneName: string);
        ViewModeIndex: number;
        ViewFOV: number;
        CameraFollowMode: EAnimationViewportCameraFollowMode;
        CameraFollowBoneName: string;
    }
    
    class AssetEditorOptions {
        constructor(Context: string, ViewportConfigs: FixSizeArray<ViewportConfigOptions>);
        Context: string;
        ViewportConfigs: FixSizeArray<ViewportConfigOptions>;
    }
    
    class PersonaOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoAlignFloorToMesh: boolean;
        bShowGrid: boolean;
        bHighlightOrigin: boolean;
        bMuteAudio: boolean;
        bUseAudioAttenuation: boolean;
        ShowMeshStats: number;
        DefaultLocalAxesSelection: number;
        DefaultBoneDrawSelection: number;
        SectionTimingNodeColor: LinearColor;
        NotifyTimingNodeColor: LinearColor;
        BranchingPointTimingNodeColor: LinearColor;
        bUseInlineSocketEditor: boolean;
        bFlattenSkeletonHierarchyWhenFiltering: boolean;
        bHideParentsWhenFiltering: boolean;
        bAllowPreviewMeshCollectionsToSelectFromDifferentSkeletons: boolean;
        bAllowPreviewMeshCollectionsToUseCustomAnimBP: boolean;
        bAllowMeshSectionSelection: boolean;
        NumFolderFiltersInAssetBrowser: number;
        AssetEditorOptions: TArray<AssetEditorOptions>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaOptions;
        static Load(InName: string): PersonaOptions;
    }
    
    class PhysicalMaterialFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicalMaterialClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalMaterialFactoryNew;
        static Load(InName: string): PhysicalMaterialFactoryNew;
    }
    
    enum EPhysicsAssetEditorRenderMode { Solid, Wireframe, None, EPhysicsAssetEditorRenderMode_MAX}
    enum EPhysicsAssetEditorConstraintViewMode { None, AllPositions, AllLimits, EPhysicsAssetEditorConstraintViewMode_MAX}
    class PhysicsAssetEditorOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicsBlend: number;
        bUpdateJointsFromAnimation: boolean;
        PhysicsUpdateMode: number;
        PokePauseTime: number;
        PokeBlendTime: number;
        GravScale: number;
        GravityOverrideZ: number;
        bUseGravityOverride: boolean;
        MaxFPS: number;
        HandleLinearDamping: number;
        HandleLinearStiffness: number;
        HandleAngularDamping: number;
        HandleAngularStiffness: number;
        InterpolationSpeed: number;
        PokeStrength: number;
        bShowConstraintsAsPoints: boolean;
        bRenderOnlySelectedConstraints: boolean;
        ConstraintDrawSize: number;
        MeshViewMode: EPhysicsAssetEditorRenderMode;
        CollisionViewMode: EPhysicsAssetEditorRenderMode;
        ConstraintViewMode: EPhysicsAssetEditorConstraintViewMode;
        SimulationMeshViewMode: EPhysicsAssetEditorRenderMode;
        SimulationCollisionViewMode: EPhysicsAssetEditorRenderMode;
        SimulationConstraintViewMode: EPhysicsAssetEditorConstraintViewMode;
        CollisionOpacity: number;
        bSolidRenderingForSelectedOnly: boolean;
        bResetClothWhenSimulating: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetEditorOptions;
        static Load(InName: string): PhysicsAssetEditorOptions;
    }
    
    class PhysicsAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetFactory;
        static Load(InName: string): PhysicsAssetFactory;
    }
    
    class PhysAssetCreateParams {
        constructor(MinBoneSize: number, MinWeldSize: number, GeomType: number, VertWeight: number, bAutoOrientToBone: boolean, bCreateConstraints: boolean, bWalkPastSmall: boolean, bBodyForAll: boolean, bDisableCollisionsByDefault: boolean, AngularConstraintMode: number, HullCount: number, MaxHullVerts: number);
        MinBoneSize: number;
        MinWeldSize: number;
        GeomType: number;
        VertWeight: number;
        bAutoOrientToBone: boolean;
        bCreateConstraints: boolean;
        bWalkPastSmall: boolean;
        bBodyForAll: boolean;
        bDisableCollisionsByDefault: boolean;
        AngularConstraintMode: number;
        HullCount: number;
        MaxHullVerts: number;
    }
    
    class PhysicsAssetGenerationSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreateParams: PhysAssetCreateParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetGenerationSettings;
        static Load(InName: string): PhysicsAssetGenerationSettings;
    }
    
    class PhysicsAssetThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsAssetThumbnailRenderer;
        static Load(InName: string): PhysicsAssetThumbnailRenderer;
    }
    
    class PkgInfoCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PkgInfoCommandlet;
        static Load(InName: string): PkgInfoCommandlet;
    }
    
    class PolysExporterOBJ extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PolysExporterOBJ;
        static Load(InName: string): PolysExporterOBJ;
    }
    
    class PolysExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PolysExporterT3D;
        static Load(InName: string): PolysExporterT3D;
    }
    
    class PolysFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PolysFactory;
        static Load(InName: string): PolysFactory;
    }
    
    class PopulateDialogueWaveFromCharacterSheetCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PopulateDialogueWaveFromCharacterSheetCommandlet;
        static Load(InName: string): PopulateDialogueWaveFromCharacterSheetCommandlet;
    }
    
    class PoseAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceAnimation: AnimSequence;
        PoseNames: TArray<string>;
        TargetSkeleton: Skeleton;
        PreviewSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseAssetFactory;
        static Load(InName: string): PoseAssetFactory;
    }
    
    class PreviewMaterial extends Material {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewMaterial;
        static Load(InName: string): PreviewMaterial;
    }
    
    class PreviewMeshCollectionFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentSkeleton: TWeakObjectPtr<Skeleton>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewMeshCollectionFactory;
        static Load(InName: string): PreviewMeshCollectionFactory;
    }
    
    enum EProjectPackagingBuild { Always, Never, IfProjectHasCode, IfEditorWasBuiltLocally, EProjectPackagingBuild_MAX}
    enum EProjectPackagingBlueprintNativizationMethod { Disabled, Inclusive, Exclusive, EProjectPackagingBlueprintNativizationMethod_MAX}
    enum EProjectPackagingInternationalizationPresets { English, EFIGS, EFIGSCJK, CJK, All, EProjectPackagingInternationalizationPresets_MAX}
    class ProjectPackagingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Build: EProjectPackagingBuild;
        BuildConfiguration: number;
        BuildTarget: string;
        StagingDirectory: DirectoryPath;
        FullRebuild: boolean;
        ForDistribution: boolean;
        IncludeDebugFiles: boolean;
        BlueprintNativizationMethod: EProjectPackagingBlueprintNativizationMethod;
        NativizeBlueprintAssets: TArray<FilePath>;
        bIncludeNativizedAssetsInProjectGeneration: boolean;
        bExcludeMonolithicEngineHeadersInNativizedCode: boolean;
        UsePakFile: boolean;
        bGenerateChunks: boolean;
        bGenerateNoChunks: boolean;
        bChunkHardReferencesOnly: boolean;
        bForceOneChunkPerFile: boolean;
        MaxChunkSize: bigint;
        bBuildHttpChunkInstallData: boolean;
        HttpChunkInstallDataDirectory: DirectoryPath;
        PakFileCompressionFormats: string;
        PakFileAdditionalCompressionOptions: string;
        HttpChunkInstallDataVersion: string;
        IncludePrerequisites: boolean;
        IncludeAppLocalPrerequisites: boolean;
        bShareMaterialShaderCode: boolean;
        bSharedMaterialNativeLibraries: boolean;
        ApplocalPrerequisitesDirectory: DirectoryPath;
        IncludeCrashReporter: boolean;
        InternationalizationPreset: EProjectPackagingInternationalizationPresets;
        CulturesToStage: TArray<string>;
        bCookAll: boolean;
        bCookMapsOnly: boolean;
        bCompressed: boolean;
        bEncryptIniFiles: boolean;
        bEncryptPakIndex: boolean;
        GenerateEarlyDownloaderPakFile: boolean;
        bSkipEditorContent: boolean;
        bSkipMovies: boolean;
        UFSMovies: TArray<string>;
        NonUFSMovies: TArray<string>;
        CompressedChunkWildcard: TArray<string>;
        IniKeyBlacklist: TArray<string>;
        IniSectionBlacklist: TArray<string>;
        EarlyDownloaderPakFileFiles: TArray<string>;
        MapsToCook: TArray<FilePath>;
        DirectoriesToAlwaysCook: TArray<DirectoryPath>;
        DirectoriesToNeverCook: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsUFS: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsNonUFS: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsUFSServer: TArray<DirectoryPath>;
        DirectoriesToAlwaysStageAsNonUFSServer: TArray<DirectoryPath>;
        bNativizeBlueprintAssets: boolean;
        bNativizeOnlySelectedBlueprints: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProjectPackagingSettings;
        static Load(InName: string): ProjectPackagingSettings;
    }
    
    enum EditColor { Red, Orange, Yellow, Green, Blue, Indigo, Violet, Pink, Magenta, Cyan, EditColor_MAX}
    class PropertyEditorTestSubStruct {
        constructor(FirstProperty: number, SecondProperty: number, CustomizedStructInsideUncustomizedStruct: LinearColor, CustomizedStructInsideUncustomizedStruct2: SoftObjectPath);
        FirstProperty: number;
        SecondProperty: number;
        CustomizedStructInsideUncustomizedStruct: LinearColor;
        CustomizedStructInsideUncustomizedStruct2: SoftObjectPath;
    }
    
    class PropertyEditorTestBasicStruct {
        constructor(IntPropertyInsideAStruct: number, FloatPropertyInsideAStruct: number, ObjectPropertyInsideAStruct: Object, InnerStruct: PropertyEditorTestSubStruct);
        IntPropertyInsideAStruct: number;
        FloatPropertyInsideAStruct: number;
        ObjectPropertyInsideAStruct: Object;
        InnerStruct: PropertyEditorTestSubStruct;
    }
    
    class PropertyEditTestTextStruct {
        constructor(NormalProperty: string);
        NormalProperty: string;
    }
    
    class AnimClassInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimClassInterface;
        static Load(InName: string): AnimClassInterface;
    }
    
    class DateTime {
        constructor();
    }
    
    class PropertyEditorTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Int8Property: number;
        Int16Property: number;
        Int32Property: number;
        Int64Property: bigint;
        ByteProperty: number;
        UnsignedInt16Property: number;
        UnsignedInt32Property: number;
        UnsignedInt64Property: bigint;
        FloatProperty: number;
        DoubleProperty: number;
        NameProperty: string;
        BoolProperty: boolean;
        StringProperty: string;
        TextProperty: string;
        IntPointProperty: IntPoint;
        Vector3Property: Vector;
        Vector2Property: Vector2D;
        Vector4Property: Vector4;
        RotatorProperty: Rotator;
        ObjectProperty: Object;
        ClassProperty: Class;
        ClassPropertyWithAllowed: Class;
        ClassPropertyWithDisallowed: Class;
        SubclassOfTexture: Class;
        SubclassOfWithAllowed: Class;
        SubclassOfWithDisallowed: Class;
        LinearColorProperty: LinearColor;
        ColorProperty: Color;
        EnumByteProperty: number;
        EnumProperty: EditColor;
        MatrixProperty: Matrix;
        TransformProperty: Transform;
        IntProperty32Array: TArray<number>;
        BytePropertyArray: TArray<number>;
        FloatPropertyArray: TArray<number>;
        NamePropertyArray: TArray<string>;
        BoolPropertyArray: TArray<boolean>;
        StringPropertyArray: TArray<string>;
        TextPropertyArray: TArray<string>;
        Vector3PropertyArray: TArray<Vector>;
        Vector2PropertyArray: TArray<Vector2D>;
        Vector4PropertyArray: TArray<Vector4>;
        RotatorPropertyArray: TArray<Rotator>;
        ObjectPropertyArray: TArray<Object>;
        ActorPropertyArray: TArray<Actor>;
        LinearColorPropertyArray: TArray<LinearColor>;
        ColorPropertyArray: TArray<Color>;
        EnumPropertyArray: TArray<number>;
        StructPropertyArray: TArray<PropertyEditorTestBasicStruct>;
        FixedArrayOfInts: TArray<number>;
        StaticArrayOfInts: FixSizeArray<number>;
        StaticArrayOfIntsWithEnumLabels: FixSizeArray<number>;
        FloatPropertyWithClampedRange: number;
        IntPropertyWithClampedRange: number;
        IntThatCannotBeChanged: number;
        StringThatCannotBeChanged: string;
        ObjectThatCannotBeChanged: PrimitiveComponent;
        StringPasswordProperty: string;
        TextPasswordProperty: string;
        ThisIsBrokenIfItsVisibleInADetailsView: PropertyEditorTestBasicStruct;
        StructWithMultipleInstances1: PropertyEditorTestBasicStruct;
        bEditConditionStructWithMultipleInstances2: boolean;
        StructWithMultipleInstances2: PropertyEditorTestBasicStruct;
        RichCurve: RichCurve;
        AssetReferenceCustomStruct: SoftObjectPath;
        AssetReferenceCustomStructWithThumbnail: SoftObjectPath;
        ExactlyPointLightActorReference: SoftObjectPath;
        LightActorReference: SoftObjectPath;
        ExactPointOrSpotLightActorReference: SoftObjectPath;
        LightOrStaticMeshActorReference: SoftObjectPath;
        NotLightActorReference: SoftObjectPath;
        MaterialOrTextureAssetReference: SoftObjectPath;
        bEditCondition: boolean;
        SimplePropertyWithEditCondition: number;
        bEditConditionAssetReferenceCustomStructWithEditCondition: boolean;
        AssetReferenceCustomStructWithEditCondition: SoftObjectPath;
        ArrayOfStructs: TArray<PropertyEditorTestBasicStruct>;
        Struct: PropertyEditTestTextStruct;
        EditInlineNewStaticMeshComponent: StaticMeshComponent;
        ArrayOfEditInlineNewSMCs: TArray<StaticMeshComponent>;
        TextureProp: Texture;
        StaticMeshProp: StaticMesh;
        AnyMaterialInterface: MaterialInterface;
        OnlyActorsAllowed: Actor;
        Int32Set: TSet<number>;
        FloatSet: TSet<number>;
        StringSet: TSet<string>;
        ObjectSet: TSet<Object>;
        ActorSet: TSet<Actor>;
        EditColorSet: TSet<EditColor>;
        NameSet: TSet<string>;
        Int32ToStringMap: TMap<number, string>;
        StringToColorMap: TMap<string, LinearColor>;
        Int32ToStructMap: TMap<number, PropertyEditorTestBasicStruct>;
        StringToFloatMap: TMap<string, number>;
        StringToObjectMap: TMap<string, Object>;
        StringToActorMap: TMap<string, Actor>;
        ObjectToInt32Map: TMap<Object, number>;
        ObjectToColorMap: TMap<Object, LinearColor>;
        IntToEnumMap: TMap<number, number>;
        NameToNameMap: TMap<string, string>;
        IntToCustomMap: TMap<number, PropertyEditorTestBasicStruct>;
        IntToSubStructMap: TMap<number, PropertyEditorTestSubStruct>;
        LinearColorSet: TSet<LinearColor>;
        VectorSet: TSet<Vector>;
        LinearColorToStringMap: TMap<LinearColor, string>;
        VectorToFloatMap: TMap<Vector, number>;
        LinearColorToVectorMap: TMap<LinearColor, Vector>;
        BlendableInterface: BlendableInterface;
        AnimClassInterface: AnimClassInterface;
        LightPropagationVolumeBlendable: BlendableInterface;
        TextureOrBlendableInterface: Object;
        bSubcategory: boolean;
        bSubcategoryAdvanced: boolean;
        bSubcategoryFooSimple: boolean;
        bSubcategoryFooAdvanced: boolean;
        bSubcategoryBarSimple: boolean;
        bSubcategoryBarAdvanced: boolean;
        bSubcategoryLast: boolean;
        bEnablesNext: boolean;
        bEnabledByPrevious: boolean;
        EnumEditCondition: EditColor;
        bEnabledWhenBlue: boolean;
        bEnabledWhenPink: boolean;
        EnumAsByteEditCondition: number;
        bEnabledWhenEnumIs2: boolean;
        bEnabledWhenEnumIs4: boolean;
        IntegerEditCondition: number;
        bEnabledWhenIntGreaterOrEqual5: boolean;
        bEnabledWhenIntLessOrEqual10: boolean;
        FloatEditCondition: number;
        bEnabledWhenFloatGreaterThan5: boolean;
        bEnabledWhenFloatLessThan10: boolean;
        bEditConditionForArrays: boolean;
        ArrayWithEditCondition: TArray<Texture2D>;
        ArrayOfStructsWithEditCondition: TArray<PropertyEditorTestBasicStruct>;
        InlineProperty: number;
        PropertyThatHides: number;
        bVisibleWhenStatic: boolean;
        VisibleWhenStationary: number;
        DateTime: DateTime;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyEditorTestObject;
        static Load(InName: string): PropertyEditorTestObject;
    }
    
    class ReimportCurveFactory extends CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportCurveFactory;
        static Load(InName: string): ReimportCurveFactory;
    }
    
    class ReimportCurveTableFactory extends CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportCurveTableFactory;
        static Load(InName: string): ReimportCurveTableFactory;
    }
    
    class ReimportDataTableFactory extends CSVImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportDataTableFactory;
        static Load(InName: string): ReimportDataTableFactory;
    }
    
    class ReimportFbxAnimSequenceFactory extends FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxAnimSequenceFactory;
        static Load(InName: string): ReimportFbxAnimSequenceFactory;
    }
    
    class ReimportFbxSceneFactory extends FbxSceneImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxSceneFactory;
        static Load(InName: string): ReimportFbxSceneFactory;
    }
    
    class ReimportFbxSkeletalMeshFactory extends FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxSkeletalMeshFactory;
        static Load(InName: string): ReimportFbxSkeletalMeshFactory;
    }
    
    class ReimportFbxStaticMeshFactory extends FbxFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportFbxStaticMeshFactory;
        static Load(InName: string): ReimportFbxStaticMeshFactory;
    }
    
    class TextureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NoCompression: boolean;
        NoAlpha: boolean;
        bDeferCompression: boolean;
        CompressionSettings: number;
        bCreateMaterial: boolean;
        bRGBToBaseColor: boolean;
        bRGBToEmissive: boolean;
        bAlphaToRoughness: boolean;
        bAlphaToEmissive: boolean;
        bAlphaToOpacity: boolean;
        bAlphaToOpacityMask: boolean;
        bTwoSided: boolean;
        Blending: number;
        ShadingModel: number;
        MipGenSettings: number;
        LODGroup: number;
        bDitherMipMapAlpha: boolean;
        AlphaCoverageThresholds: Vector4;
        bPreserveBorder: boolean;
        bFlipNormalMapGreenChannel: boolean;
        bUsingExistingSettings: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureFactory;
        static Load(InName: string): TextureFactory;
    }
    
    class ReimportTextureFactory extends TextureFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        pOriginalTex: Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportTextureFactory;
        static Load(InName: string): ReimportTextureFactory;
    }
    
    class VectorFieldStaticFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldStaticFactory;
        static Load(InName: string): VectorFieldStaticFactory;
    }
    
    class ReimportVectorFieldStaticFactory extends VectorFieldStaticFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportVectorFieldStaticFactory;
        static Load(InName: string): ReimportVectorFieldStaticFactory;
    }
    
    class RenderTargetExporterHDR extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RenderTargetExporterHDR;
        static Load(InName: string): RenderTargetExporterHDR;
    }
    
    class ReplaceActorCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplaceActorCommandlet;
        static Load(InName: string): ReplaceActorCommandlet;
    }
    
    class ReplaceAssetsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplaceAssetsCommandlet;
        static Load(InName: string): ReplaceAssetsCommandlet;
    }
    
    class SceneThumbnailInfo extends ThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OrbitPitch: number;
        OrbitYaw: number;
        OrbitZoom: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneThumbnailInfo;
        static Load(InName: string): SceneThumbnailInfo;
    }
    
    class SceneThumbnailInfoWithPrimitive extends SceneThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimitiveType: number;
        PreviewMesh: SoftObjectPath;
        bUserModifiedShape: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneThumbnailInfoWithPrimitive;
        static Load(InName: string): SceneThumbnailInfoWithPrimitive;
    }
    
    class SequenceExporterT3D extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceExporterT3D;
        static Load(InName: string): SequenceExporterT3D;
    }
    
    class ShaderCodeLibraryToolsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShaderCodeLibraryToolsCommandlet;
        static Load(InName: string): ShaderCodeLibraryToolsCommandlet;
    }
    
    class ShaderPipelineCacheToolsCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShaderPipelineCacheToolsCommandlet;
        static Load(InName: string): ShaderPipelineCacheToolsCommandlet;
    }
    
    class SheetBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: number;
        Y: number;
        XSegments: number;
        YSegments: number;
        Axis: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SheetBuilder;
        static Load(InName: string): SheetBuilder;
    }
    
    class SkeletalMeshEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimPreviewFloorColor: Color;
        AnimPreviewSkyColor: Color;
        AnimPreviewSkyBrightness: number;
        AnimPreviewLightBrightness: number;
        AnimPreviewLightingDirection: Rotator;
        AnimPreviewDirectionalColor: Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshEditorSettings;
        static Load(InName: string): SkeletalMeshEditorSettings;
    }
    
    class SkeletalMeshExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshExporterFBX;
        static Load(InName: string): SkeletalMeshExporterFBX;
    }
    
    class SkeletalMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshThumbnailRenderer;
        static Load(InName: string): SkeletalMeshThumbnailRenderer;
    }
    
    class SkeletonFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetSkeletalMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletonFactory;
        static Load(InName: string): SkeletonFactory;
    }
    
    class SlateBrushAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBrushAssetFactory;
        static Load(InName: string): SlateBrushAssetFactory;
    }
    
    class SlateBrushThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateBrushThumbnailRenderer;
        static Load(InName: string): SlateBrushThumbnailRenderer;
    }
    
    class SlateWidgetStyleAssetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StyleType: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateWidgetStyleAssetFactory;
        static Load(InName: string): SlateWidgetStyleAssetFactory;
    }
    
    class SoundExporterOGG extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundExporterOGG;
        static Load(InName: string): SoundExporterOGG;
    }
    
    class SoundExporterWAV extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundExporterWAV;
        static Load(InName: string): SoundExporterWAV;
    }
    
    class SoundSurroundExporterWAV extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSurroundExporterWAV;
        static Load(InName: string): SoundSurroundExporterWAV;
    }
    
    class SoundWaveThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundWaveThumbnailRenderer;
        static Load(InName: string): SoundWaveThumbnailRenderer;
    }
    
    class SpiralStairBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerRadius: number;
        StepWidth: number;
        StepHeight: number;
        StepThickness: number;
        NumStepsPer360: number;
        NumSteps: number;
        GroupName: string;
        SlopedCeiling: boolean;
        SlopedFloor: boolean;
        CounterClockwise: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpiralStairBuilder;
        static Load(InName: string): SpiralStairBuilder;
    }
    
    class StabilizeLocalizationKeysCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StabilizeLocalizationKeysCommandlet;
        static Load(InName: string): StabilizeLocalizationKeysCommandlet;
    }
    
    class StaticMeshExporterFBX extends ExporterFBX {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshExporterFBX;
        static Load(InName: string): StaticMeshExporterFBX;
    }
    
    class StaticMeshExporterOBJ extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshExporterOBJ;
        static Load(InName: string): StaticMeshExporterOBJ;
    }
    
    class StaticMeshThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshThumbnailRenderer;
        static Load(InName: string): StaticMeshThumbnailRenderer;
    }
    
    class StringTableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StringTableFactory;
        static Load(InName: string): StringTableFactory;
    }
    
    class StructureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructureFactory;
        static Load(InName: string): StructureFactory;
    }
    
    enum EStructViewerDeveloperType { SVDT_None, SVDT_CurrentUser, SVDT_All, SVDT_Max, SVDT_MAX}
    class StructViewerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayInternalStructs: boolean;
        DeveloperFolderType: EStructViewerDeveloperType;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructViewerSettings;
        static Load(InName: string): StructViewerSettings;
    }
    
    class SubsurfaceProfileFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfileFactory;
        static Load(InName: string): SubsurfaceProfileFactory;
    }
    
    class SubsurfaceProfileRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsurfaceProfileRenderer;
        static Load(InName: string): SubsurfaceProfileRenderer;
    }
    
    class SubUVAnimationFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubUVAnimationFactory;
        static Load(InName: string): SubUVAnimationFactory;
    }
    
    class SwapSoundForDialogueInCuesCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SwapSoundForDialogueInCuesCommandlet;
        static Load(InName: string): SwapSoundForDialogueInCuesCommandlet;
    }
    
    class TemplateMapMetadata extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TemplateMapMetadata;
        static Load(InName: string): TemplateMapMetadata;
    }
    
    class TetrahedronBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Radius: number;
        SphereExtrapolation: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TetrahedronBuilder;
        static Load(InName: string): TetrahedronBuilder;
    }
    
    class TexAligner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefTexAlign: number;
        TAxis: number;
        UTile: number;
        VTile: number;
        Desc: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAligner;
        static Load(InName: string): TexAligner;
    }
    
    class TexAlignerBox extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerBox;
        static Load(InName: string): TexAlignerBox;
    }
    
    class TexAlignerDefault extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerDefault;
        static Load(InName: string): TexAlignerDefault;
    }
    
    class TexAlignerFit extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerFit;
        static Load(InName: string): TexAlignerFit;
    }
    
    class TexAlignerPlanar extends TexAligner {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TexAlignerPlanar;
        static Load(InName: string): TexAlignerPlanar;
    }
    
    class TextAssetCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextAssetCommandlet;
        static Load(InName: string): TextAssetCommandlet;
    }
    
    class TextBufferExporterTXT extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextBufferExporterTXT;
        static Load(InName: string): TextBufferExporterTXT;
    }
    
    class Texture2DArrayFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTextures: TArray<Texture2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DArrayFactory;
        static Load(InName: string): Texture2DArrayFactory;
    }
    
    class Texture2DArrayThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DArrayThumbnailRenderer;
        static Load(InName: string): Texture2DArrayThumbnailRenderer;
    }
    
    class Texture2DFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DFactoryNew;
        static Load(InName: string): Texture2DFactoryNew;
    }
    
    class TextureCubeExporterHDR extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureCubeExporterHDR;
        static Load(InName: string): TextureCubeExporterHDR;
    }
    
    class TextureCubeThumbnailRenderer extends TextureThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureCubeThumbnailRenderer;
        static Load(InName: string): TextureCubeThumbnailRenderer;
    }
    
    class TextureExporterBMP extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterBMP;
        static Load(InName: string): TextureExporterBMP;
    }
    
    class TextureExporterHDR extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterHDR;
        static Load(InName: string): TextureExporterHDR;
    }
    
    class TextureExporterPCX extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterPCX;
        static Load(InName: string): TextureExporterPCX;
    }
    
    class TextureExporterTGA extends Exporter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureExporterTGA;
        static Load(InName: string): TextureExporterTGA;
    }
    
    class TextureImportSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AutoVTSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureImportSettings;
        static Load(InName: string): TextureImportSettings;
    }
    
    class TextureRenderTargetCubeFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetCubeFactoryNew;
        static Load(InName: string): TextureRenderTargetCubeFactoryNew;
    }
    
    class TextureRenderTargetFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        Format: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetFactoryNew;
        static Load(InName: string): TextureRenderTargetFactoryNew;
    }
    
    class SkeletalMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShouldDoAnimNotifies: boolean;
        bWakeOnLevelStart: boolean;
        SkeletalMeshComponent: SkeletalMeshComponent;
        ReplicatedMesh: SkeletalMesh;
        ReplicatedPhysAsset: PhysicsAsset;
        ReplicatedMaterial0: MaterialInterface;
        ReplicatedMaterial1: MaterialInterface;
        OnRep_ReplicatedPhysAsset(): void;
        OnRep_ReplicatedMesh(): void;
        OnRep_ReplicatedMaterial1(): void;
        OnRep_ReplicatedMaterial0(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshActor;
        static Load(InName: string): SkeletalMeshActor;
    }
    
    class AnimationThumbnailSkeletalMeshActor extends SkeletalMeshActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationThumbnailSkeletalMeshActor;
        static Load(InName: string): AnimationThumbnailSkeletalMeshActor;
    }
    
    class ThumbnailRenderingInfo {
        constructor(ClassNeedingThumbnailName: string, ClassNeedingThumbnail: Class, RendererClassName: string, Renderer: ThumbnailRenderer);
        ClassNeedingThumbnailName: string;
        ClassNeedingThumbnail: Class;
        RendererClassName: string;
        Renderer: ThumbnailRenderer;
    }
    
    class ThumbnailManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderableThumbnailTypes: TArray<ThumbnailRenderingInfo>;
        NotSupported: ThumbnailRenderingInfo;
        EditorCube: StaticMesh;
        EditorSphere: StaticMesh;
        EditorCylinder: StaticMesh;
        EditorPlane: StaticMesh;
        EditorSkySphere: StaticMesh;
        FloorPlaneMaterial: Material;
        AmbientCubemap: TextureCube;
        CheckerboardTexture: Texture2D;
        ThumbnailManagerClassName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ThumbnailManager;
        static Load(InName: string): ThumbnailManager;
    }
    
    class TouchInterfaceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TouchInterfaceFactory;
        static Load(InName: string): TouchInterfaceFactory;
    }
    
    class TransBuffer extends Transactor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TransBuffer;
        static Load(InName: string): TransBuffer;
    }
    
    class FontImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Data: FontImportOptionsData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontImportOptions;
        static Load(InName: string): FontImportOptions;
    }
    
    class TrueTypeFontFactory extends TextureFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportOptions: FontImportOptions;
        bPropertiesConfigured: boolean;
        bFontSelected: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TrueTypeFontFactory;
        static Load(InName: string): TrueTypeFontFactory;
    }
    
    class EdMode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StandardVertexColorMaterial: MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdMode;
        static Load(InName: string): EdMode;
    }
    
    class EditorCommandCategory {
        constructor(Parent: string, Name: string);
        Parent: string;
        Name: string;
    }
    
    class EditorCommand {
        constructor(Parent: string, CommandName: string, ExecCommand: string, Description: string);
        Parent: string;
        CommandName: string;
        ExecCommand: string;
        Description: string;
    }
    
    class EditorKeyBinding {
        constructor(bCtrlDown: boolean, bAltDown: boolean, bShiftDown: boolean, Key: Key, CommandName: string);
        bCtrlDown: boolean;
        bAltDown: boolean;
        bShiftDown: boolean;
        Key: Key;
        CommandName: string;
    }
    
    class UnrealEdKeyBindings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyBindings: TArray<EditorKeyBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdKeyBindings;
        static Load(InName: string): UnrealEdKeyBindings;
    }
    
    class ClassPickerDefaults {
        constructor(ClassName: string, AssetClass: string);
        ClassName: string;
        AssetClass: string;
    }
    
    class UnrealEdOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorCategories: TArray<EditorCommandCategory>;
        EditorCommands: TArray<EditorCommand>;
        EditorKeyBindings: UnrealEdKeyBindings;
        bExpandClassPickerClassList: boolean;
        NewAssetDefaultClasses: TArray<ClassPickerDefaults>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdOptions;
        static Load(InName: string): UnrealEdOptions;
    }
    
    class TemplateMapInfo {
        constructor(ThumbnailTexture: Texture2D, Map: string);
        ThumbnailTexture: Texture2D;
        Map: string;
    }
    
    class UnrealEdEngine extends EditorEngine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditorOptionsInst: UnrealEdOptions;
        AutoReimportManager: AutoReimportManager;
        MaterialCopyPasteBuffer: Material;
        MatineeCopyPasteBuffer: TArray<Object>;
        SoundCueCopyPasteBuffer: SoundCue;
        AnimationCompressionAlgorithms: TArray<AnimCompress>;
        PackagesToBeFullyLoadedAtStartup: TArray<string>;
        CurrentLODParentActor: Actor;
        bNeedWarningForPkgEngineVer: boolean;
        bNeedWarningForWritePermission: boolean;
        SortedSpriteCategories: TArray<string>;
        TemplateMapInfos: TArray<TemplateMapInfo>;
        CookServer: CookOnTheFlyServer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdEngine;
        static Load(InName: string): UnrealEdEngine;
    }
    
    class UnrealEdTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealEdTypes;
        static Load(InName: string): UnrealEdTypes;
    }
    
    class UnrealPakCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnrealPakCommandlet;
        static Load(InName: string): UnrealPakCommandlet;
    }
    
    class UpdateGameProjectCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UpdateGameProjectCommandlet;
        static Load(InName: string): UpdateGameProjectCommandlet;
    }
    
    class StructVariableDescription {
        constructor(VarName: string, VarGuid: Guid, FriendlyName: string, DefaultValue: string, Category: string, SubCategory: string, SubCategoryObject: TSoftObjectPtr<Object>, PinValueType: EdGraphTerminalType, ContainerType: EPinContainerType, bIsArray: boolean, bIsSet: boolean, bIsMap: boolean, bInvalidMember: boolean, bDontEditOnInstance: boolean, bEnableSaveGame: boolean, bEnableMultiLineText: boolean, bEnable3dWidget: boolean, CurrentDefaultValue: string, ToolTip: string);
        VarName: string;
        VarGuid: Guid;
        FriendlyName: string;
        DefaultValue: string;
        Category: string;
        SubCategory: string;
        SubCategoryObject: TSoftObjectPtr<Object>;
        PinValueType: EdGraphTerminalType;
        ContainerType: EPinContainerType;
        bIsArray: boolean;
        bIsSet: boolean;
        bIsMap: boolean;
        bInvalidMember: boolean;
        bDontEditOnInstance: boolean;
        bEnableSaveGame: boolean;
        bEnableMultiLineText: boolean;
        bEnable3dWidget: boolean;
        CurrentDefaultValue: string;
        ToolTip: string;
    }
    
    class UserDefinedStructEditorData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueNameId: number;
        VariablesDescriptions: TArray<StructVariableDescription>;
        ToolTip: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedStructEditorData;
        static Load(InName: string): UserDefinedStructEditorData;
    }
    
    class VolumeTextureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialTexture: Texture2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumeTextureFactory;
        static Load(InName: string): VolumeTextureFactory;
    }
    
    class VolumeTextureThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialInstance: MaterialInstanceConstant;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumeTextureThumbnailRenderer;
        static Load(InName: string): VolumeTextureThumbnailRenderer;
    }
    
    class VolumetricBuilder extends EditorBrushBuilder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Z: number;
        Radius: number;
        NumSheets: number;
        GroupName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumetricBuilder;
        static Load(InName: string): VolumetricBuilder;
    }
    
    class WorldFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldFactory;
        static Load(InName: string): WorldFactory;
    }
    
    class WorldThumbnailInfo extends SceneThumbnailInfo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraMode: number;
        OrthoDirection: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldThumbnailInfo;
        static Load(InName: string): WorldThumbnailInfo;
    }
    
    class WorldThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GlobalOrbitPitchOffset: number;
        GlobalOrbitYawOffset: number;
        bUseUnlitScene: boolean;
        bAllowWorldThumbnails: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldThumbnailRenderer;
        static Load(InName: string): WorldThumbnailRenderer;
    }
    
    class WrangleContentCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WrangleContentCommandlet;
        static Load(InName: string): WrangleContentCommandlet;
    }
    
    class InstancedStaticMeshInstanceData {
        constructor(Transform: Matrix);
        Transform: Matrix;
    }
    
    class InstancedStaticMeshMappingInfo {
        constructor();
    }
    
    class InstancedStaticMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PerInstanceSMData: TArray<InstancedStaticMeshInstanceData>;
        InstancingRandomSeed: number;
        InstanceStartCullDistance: number;
        InstanceEndCullDistance: number;
        InstanceReorderTable: TArray<number>;
        NumPendingLightmaps: number;
        CachedMappings: TArray<InstancedStaticMeshMappingInfo>;
        UpdateInstanceTransform(InstanceIndex: number, NewInstanceTransform: Transform, bWorldSpace: boolean, bMarkRenderStateDirty: boolean, bTeleport: boolean): boolean;
        SetCullDistances(StartCullDistance: number, EndCullDistance: number): void;
        RemoveInstance(InstanceIndex: number): boolean;
        GetInstanceTransform(InstanceIndex: number, OutInstanceTransform: $Ref<Transform>, bWorldSpace: boolean): boolean;
        GetInstancesOverlappingSphere(Center: Vector, Radius: number, bSphereInWorldSpace: boolean): TArray<number>;
        GetInstancesOverlappingBox(Box: Box, bBoxInWorldSpace: boolean): TArray<number>;
        GetInstanceCount(): number;
        ClearInstances(): void;
        BatchUpdateInstancesTransforms(StartInstanceIndex: number, NewInstancesTransforms: TArray<Transform>, bWorldSpace: boolean, bMarkRenderStateDirty: boolean, bTeleport: boolean): boolean;
        BatchUpdateInstancesTransform(StartInstanceIndex: number, NumInstances: number, NewInstancesTransform: Transform, bWorldSpace: boolean, bMarkRenderStateDirty: boolean, bTeleport: boolean): boolean;
        AddInstanceWorldSpace(WorldTransform: Transform): number;
        AddInstance(InstanceTransform: Transform): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InstancedStaticMeshComponent;
        static Load(InName: string): InstancedStaticMeshComponent;
    }
    
    class HierarchicalInstancedStaticMeshComponent extends InstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SortedInstances: TArray<number>;
        NumBuiltInstances: number;
        BuiltInstanceBounds: Box;
        UnbuiltInstanceBounds: Box;
        UnbuiltInstanceBoundsList: TArray<Box>;
        bEnableDensityScaling: boolean;
        OcclusionLayerNumNodes: number;
        CacheMeshExtendedBounds: BoxSphereBounds;
        bDisableCollision: boolean;
        InstanceCountToRender: number;
        RemoveInstances(InstancesToRemove: TArray<number>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalInstancedStaticMeshComponent;
        static Load(InName: string): HierarchicalInstancedStaticMeshComponent;
    }
    
    class FoliageInstancedStaticMeshComponent extends HierarchicalInstancedStaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnInstanceTakePointDamage: $MulticastDelegate<(InstanceIndex: number, Damage: number, InstigatedBy: Controller, HitLocation: Vector, ShotFromDirection: Vector, DamageType: DamageType, DamageCauser: Actor) => void>;
        OnInstanceTakeRadialDamage: $MulticastDelegate<(Instances: TArray<number>, Damages: TArray<number>, InstigatedBy: Controller, Origin: Vector, MaxRadius: number, DamageType: DamageType, DamageCauser: Actor) => void>;
        FoliageHiddenEditorViews: bigint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageInstancedStaticMeshComponent;
        static Load(InName: string): FoliageInstancedStaticMeshComponent;
    }
    
    class FoliageStatistics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static FoliageOverlappingSphereCount(WorldContextObject: Object, StaticMesh: StaticMesh, CenterPosition: Vector, Radius: number): number;
        static FoliageOverlappingBoxCount(WorldContextObject: Object, StaticMesh: StaticMesh, Box: Box): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageStatistics;
        static Load(InName: string): FoliageStatistics;
    }
    
    enum EFoliageScaling { Uniform, Free, LockXY, LockXZ, LockYZ, EFoliageScaling_MAX}
    class FloatInterval {
        constructor(Min: number, Max: number);
        Min: number;
        Max: number;
    }
    
    class FoliageVertexColorChannelMask {
        constructor(UseMask: boolean, MaskThreshold: number, InvertMask: boolean);
        UseMask: boolean;
        MaskThreshold: number;
        InvertMask: boolean;
    }
    
    class FoliageType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UpdateGuid: Guid;
        Density: number;
        DensityAdjustmentFactor: number;
        Radius: number;
        bSingleInstanceModeOverrideRadius: boolean;
        SingleInstanceModeRadius: number;
        Scaling: EFoliageScaling;
        ScaleX: FloatInterval;
        ScaleY: FloatInterval;
        ScaleZ: FloatInterval;
        VertexColorMaskByChannel: FixSizeArray<FoliageVertexColorChannelMask>;
        VertexColorMask: number;
        VertexColorMaskThreshold: number;
        VertexColorMaskInvert: boolean;
        ZOffset: FloatInterval;
        AlignToNormal: boolean;
        AlignMaxAngle: number;
        RandomYaw: boolean;
        RandomPitchAngle: number;
        GroundSlopeAngle: FloatInterval;
        Height: FloatInterval;
        LandscapeLayers: TArray<string>;
        MinimumLayerWeight: number;
        ExclusionLandscapeLayers: TArray<string>;
        MinimumExclusionLayerWeight: number;
        LandscapeLayer: string;
        CollisionWithWorld: boolean;
        CollisionScale: Vector;
        MeshBounds: BoxSphereBounds;
        LowBoundOriginRadius: Vector;
        Mobility: number;
        CullDistance: Int32Interval;
        bEnableStaticLighting: boolean;
        CastShadow: boolean;
        bAffectDynamicIndirectLighting: boolean;
        bAffectDistanceFieldLighting: boolean;
        bCastDynamicShadow: boolean;
        bCastStaticShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bReceivesDecals: boolean;
        bOverrideLightMapRes: boolean;
        OverriddenLightMapRes: number;
        LightmapType: ELightmapType;
        bUseAsOccluder: boolean;
        BodyInstance: BodyInstance;
        CustomNavigableGeometry: number;
        LightingChannels: LightingChannels;
        bRenderCustomDepth: boolean;
        CustomDepthStencilValue: number;
        TranslucencySortPriority: number;
        HiddenEditorViews: bigint;
        IsSelected: boolean;
        CollisionRadius: number;
        ShadeRadius: number;
        NumSteps: number;
        InitialSeedDensity: number;
        AverageSpreadDistance: number;
        SpreadVariance: number;
        SeedsPerStep: number;
        DistributionSeed: number;
        MaxInitialSeedOffset: number;
        bCanGrowInShade: boolean;
        bSpawnsInShade: boolean;
        MaxInitialAge: number;
        MaxAge: number;
        OverlapPriority: number;
        ProceduralScale: FloatInterval;
        ScaleCurve: RuntimeFloatCurve;
        ChangeCount: number;
        ReapplyDensity: boolean;
        ReapplyRadius: boolean;
        ReapplyAlignToNormal: boolean;
        ReapplyRandomYaw: boolean;
        ReapplyScaling: boolean;
        ReapplyScaleX: boolean;
        ReapplyScaleY: boolean;
        ReapplyScaleZ: boolean;
        ReapplyRandomPitchAngle: boolean;
        ReapplyGroundSlope: boolean;
        ReapplyHeight: boolean;
        ReapplyLandscapeLayers: boolean;
        ReapplyZOffset: boolean;
        ReapplyCollisionWithWorld: boolean;
        ReapplyVertexColorMask: boolean;
        bEnableDensityScaling: boolean;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureCullMips: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        ScaleMinX: number;
        ScaleMinY: number;
        ScaleMinZ: number;
        ScaleMaxX: number;
        ScaleMaxY: number;
        ScaleMaxZ: number;
        HeightMin: number;
        HeightMax: number;
        ZOffsetMin: number;
        ZOffsetMax: number;
        StartCullDistance: number;
        EndCullDistance: number;
        UniformScale: boolean;
        LockScaleX: boolean;
        LockScaleY: boolean;
        LockScaleZ: boolean;
        GroundSlope: number;
        MinGroundSlope: number;
        MinScale: number;
        MaxScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType;
        static Load(InName: string): FoliageType;
    }
    
    class FoliageType_Actor extends FoliageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorClass: Class;
        bShouldAttachToBaseComponent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_Actor;
        static Load(InName: string): FoliageType_Actor;
    }
    
    class FoliageType_InstancedStaticMesh extends FoliageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: StaticMesh;
        OverrideMaterials: TArray<MaterialInterface>;
        ComponentClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_InstancedStaticMesh;
        static Load(InName: string): FoliageType_InstancedStaticMesh;
    }
    
    class InstancedFoliageActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InstancedFoliageActor;
        static Load(InName: string): InstancedFoliageActor;
    }
    
    enum ENavDataGatheringMode { Default, Instant, Lazy, ENavDataGatheringMode_MAX}
    class StaticMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshComponent: StaticMeshComponent;
        bStaticMeshReplicateMovement: boolean;
        NavigationGeometryGatheringMode: ENavDataGatheringMode;
        SetMobility(InMobility: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshActor;
        static Load(InName: string): StaticMeshActor;
    }
    
    class InteractiveFoliageActor extends StaticMeshActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CapsuleComponent: CapsuleComponent;
        TouchingActorEntryPosition: Vector;
        FoliageVelocity: Vector;
        FoliageForce: Vector;
        FoliagePosition: Vector;
        FoliageDamageImpulseScale: number;
        FoliageTouchImpulseScale: number;
        FoliageStiffness: number;
        FoliageStiffnessQuadratic: number;
        FoliageDamping: number;
        MaxDamageImpulse: number;
        MaxTouchImpulse: number;
        MaxForce: number;
        Mass: number;
        CapsuleTouched(OverlappedComp: PrimitiveComponent, Other: Actor, OtherComp: PrimitiveComponent, OtherBodyIndex: number, bFromSweep: boolean, OverlapInfo: HitResult): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveFoliageActor;
        static Load(InName: string): InteractiveFoliageActor;
    }
    
    class InteractiveFoliageComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InteractiveFoliageComponent;
        static Load(InName: string): InteractiveFoliageComponent;
    }
    
    class FoliageTypeObject {
        constructor(FoliageTypeObject: Object, TypeInstance: FoliageType, bIsAsset: boolean, Type: Class);
        FoliageTypeObject: Object;
        TypeInstance: FoliageType;
        bIsAsset: boolean;
        Type: Class;
    }
    
    class ProceduralFoliageSpawner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeed: number;
        TileSize: number;
        NumUniqueTiles: number;
        MinimumQuadTreeSize: number;
        FoliageTypes: TArray<FoliageTypeObject>;
        bNeedsSimulation: boolean;
        Simulate(NumSteps: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageSpawner;
        static Load(InName: string): ProceduralFoliageSpawner;
    }
    
    class ProceduralFoliageComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FoliageSpawner: ProceduralFoliageSpawner;
        TileOverlap: number;
        bAllowLandscape: boolean;
        bAllowBSP: boolean;
        bAllowStaticMesh: boolean;
        bAllowTranslucent: boolean;
        bAllowFoliage: boolean;
        bShowDebugTiles: boolean;
        SpawningVolume: Volume;
        ProceduralGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageComponent;
        static Load(InName: string): ProceduralFoliageComponent;
    }
    
    class ProceduralFoliageVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProceduralComponent: ProceduralFoliageComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageVolume;
        static Load(InName: string): ProceduralFoliageVolume;
    }
    
    class ProceduralFoliageBlockingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProceduralFoliageVolume: ProceduralFoliageVolume;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageBlockingVolume;
        static Load(InName: string): ProceduralFoliageBlockingVolume;
    }
    
    class ProceduralFoliageInstance {
        constructor(Location: Vector, Rotation: Quat, Normal: Vector, Age: number, Scale: number, Type: FoliageType);
        Location: Vector;
        Rotation: Quat;
        Normal: Vector;
        Age: number;
        Scale: number;
        Type: FoliageType;
    }
    
    class ProceduralFoliageTile extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FoliageSpawner: ProceduralFoliageSpawner;
        InstancesArray: TArray<ProceduralFoliageInstance>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageTile;
        static Load(InName: string): ProceduralFoliageTile;
    }
    
    class ImageWriteOptions {
        constructor(Format: EDesiredImageFormat, OnComplete: $Delegate<(bSuccess: boolean) => void>, CompressionQuality: number, bOverwriteFile: boolean, bAsync: boolean);
        Format: EDesiredImageFormat;
        OnComplete: $Delegate<(bSuccess: boolean) => void>;
        CompressionQuality: number;
        bOverwriteFile: boolean;
        bAsync: boolean;
    }
    
    class ImageWriteBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ExportToDisk(Texture: Texture, Filename: string, Options: ImageWriteOptions): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImageWriteBlueprintLibrary;
        static Load(InName: string): ImageWriteBlueprintLibrary;
    }
    
    class ControlPointMeshComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSelected: boolean;
        VirtualTextureMainPassMaxDrawDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ControlPointMeshComponent;
        static Load(InName: string): ControlPointMeshComponent;
    }
    
    class ControlPointMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ControlPointMeshComponent: ControlPointMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ControlPointMeshActor;
        static Load(InName: string): ControlPointMeshActor;
    }
    
    class LandscapeSplineSegmentConnection {
        constructor(ControlPoint: LandscapeSplineControlPoint, TangentLen: number, SocketName: string);
        ControlPoint: LandscapeSplineControlPoint;
        TangentLen: number;
        SocketName: string;
    }
    
    class LandscapeSplineMeshEntry {
        constructor(Mesh: StaticMesh, MaterialOverrides: TArray<MaterialInterface>, bCenterH: boolean, CenterAdjust: Vector2D, bScaleToWidth: boolean, Scale: Vector, Orientation: number, ForwardAxis: number, UpAxis: number);
        Mesh: StaticMesh;
        MaterialOverrides: TArray<MaterialInterface>;
        bCenterH: boolean;
        CenterAdjust: Vector2D;
        bScaleToWidth: boolean;
        Scale: Vector;
        Orientation: number;
        ForwardAxis: number;
        UpAxis: number;
    }
    
    class LandscapeSplineInterpPoint {
        constructor(Center: Vector, Left: Vector, Right: Vector, FalloffLeft: Vector, FalloffRight: Vector, LayerLeft: Vector, LayerRight: Vector, LayerFalloffLeft: Vector, LayerFalloffRight: Vector, StartEndFalloff: number);
        Center: Vector;
        Left: Vector;
        Right: Vector;
        FalloffLeft: Vector;
        FalloffRight: Vector;
        LayerLeft: Vector;
        LayerRight: Vector;
        LayerFalloffLeft: Vector;
        LayerFalloffRight: Vector;
        StartEndFalloff: number;
    }
    
    class LandscapeSplineSegment extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Connections: FixSizeArray<LandscapeSplineSegmentConnection>;
        LayerName: string;
        bRaiseTerrain: boolean;
        bLowerTerrain: boolean;
        SplineMeshes: TArray<LandscapeSplineMeshEntry>;
        bEnableCollision: boolean;
        CollisionProfileName: string;
        bCastShadow: boolean;
        RandomSeed: number;
        LDMaxDrawDistance: number;
        TranslucencySortPriority: number;
        bHiddenInGame: boolean;
        bPlaceSplineMeshesInStreamingLevels: boolean;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        BodyInstance: BodyInstance;
        bSelected: boolean;
        bNavDirty: boolean;
        SplineInfo: InterpCurveVector;
        Points: TArray<LandscapeSplineInterpPoint>;
        Bounds: Box;
        LocalMeshComponents: TArray<SplineMeshComponent>;
        ForeignWorlds: TArray<TSoftObjectPtr<World>>;
        ModificationKey: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSplineSegment;
        static Load(InName: string): LandscapeSplineSegment;
    }
    
    class LandscapeSplineConnection {
        constructor(Segment: LandscapeSplineSegment, End: boolean);
        Segment: LandscapeSplineSegment;
        End: boolean;
    }
    
    class LandscapeSplineControlPoint extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Location: Vector;
        Rotation: Rotator;
        Width: number;
        LayerWidthRatio: number;
        SideFalloff: number;
        LeftSideFalloffFactor: number;
        RightSideFalloffFactor: number;
        LeftSideLayerFalloffFactor: number;
        RightSideLayerFalloffFactor: number;
        EndFalloff: number;
        SegmentMeshOffset: number;
        LayerName: string;
        bRaiseTerrain: boolean;
        bLowerTerrain: boolean;
        Mesh: StaticMesh;
        MaterialOverrides: TArray<MaterialInterface>;
        MeshScale: Vector;
        bHiddenInGame: boolean;
        bEnableCollision: boolean;
        CollisionProfileName: string;
        bCastShadow: boolean;
        LDMaxDrawDistance: number;
        TranslucencySortPriority: number;
        bPlaceSplineMeshesInStreamingLevels: boolean;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureLodBias: number;
        VirtualTextureCullMips: number;
        VirtualTextureMainPassMaxDrawDistance: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        BodyInstance: BodyInstance;
        bSelected: boolean;
        bNavDirty: boolean;
        ConnectedSegments: TArray<LandscapeSplineConnection>;
        Points: TArray<LandscapeSplineInterpPoint>;
        Bounds: Box;
        LocalMeshComponent: ControlPointMeshComponent;
        ForeignWorld: TSoftObjectPtr<World>;
        ModificationKey: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSplineControlPoint;
        static Load(InName: string): LandscapeSplineControlPoint;
    }
    
    class ForeignControlPointData {
        constructor(ModificationKey: Guid, MeshComponent: ControlPointMeshComponent, Identifier: TLazyObjectPtr<LandscapeSplineControlPoint>);
        ModificationKey: Guid;
        MeshComponent: ControlPointMeshComponent;
        Identifier: TLazyObjectPtr<LandscapeSplineControlPoint>;
    }
    
    class ForeignSplineSegmentData {
        constructor(ModificationKey: Guid, MeshComponents: TArray<SplineMeshComponent>, Identifier: TLazyObjectPtr<LandscapeSplineSegment>);
        ModificationKey: Guid;
        MeshComponents: TArray<SplineMeshComponent>;
        Identifier: TLazyObjectPtr<LandscapeSplineSegment>;
    }
    
    class ForeignWorldSplineData {
        constructor(ForeignControlPointDataMap: TMap<TLazyObjectPtr<LandscapeSplineControlPoint>, ForeignControlPointData>, ForeignControlPointData: TArray<ForeignControlPointData>, ForeignSplineSegmentDataMap: TMap<TLazyObjectPtr<LandscapeSplineSegment>, ForeignSplineSegmentData>, ForeignSplineSegmentData: TArray<ForeignSplineSegmentData>);
        ForeignControlPointDataMap: TMap<TLazyObjectPtr<LandscapeSplineControlPoint>, ForeignControlPointData>;
        ForeignControlPointData: TArray<ForeignControlPointData>;
        ForeignSplineSegmentDataMap: TMap<TLazyObjectPtr<LandscapeSplineSegment>, ForeignSplineSegmentData>;
        ForeignSplineSegmentData: TArray<ForeignSplineSegmentData>;
    }
    
    class LandscapeSplinesComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineResolution: number;
        SplineColor: Color;
        ControlPointSprite: Texture2D;
        SplineEditorMesh: StaticMesh;
        bShowSplineEditorMesh: boolean;
        ControlPoints: TArray<LandscapeSplineControlPoint>;
        Segments: TArray<LandscapeSplineSegment>;
        ForeignWorldSplineDataMap: TMap<TSoftObjectPtr<World>, ForeignWorldSplineData>;
        CookedForeignMeshComponents: TArray<MeshComponent>;
        GetSplineMeshComponents(): TArray<SplineMeshComponent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSplinesComponent;
        static Load(InName: string): LandscapeSplinesComponent;
    }
    
    enum ELandscapeLayerDisplayMode { Default, Alphabetical, UserSpecific, ELandscapeLayerDisplayMode_MAX}
    class LandscapeProxyMaterialOverride {
        constructor(LODIndex: PerPlatformInt, Material: MaterialInterface);
        LODIndex: PerPlatformInt;
        Material: MaterialInterface;
    }
    
    class LandscapeComponentMaterialOverride {
        constructor(LODIndex: PerPlatformInt, Material: MaterialInterface);
        LODIndex: PerPlatformInt;
        Material: MaterialInterface;
    }
    
    enum ESplineModulationColorMask { Red, Green, Blue, Alpha, ESplineModulationColorMask_MAX}
    class LandscapeLayerInfoObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerName: string;
        PhysMaterial: PhysicalMaterial;
        Hardness: number;
        bNoWeightBlend: boolean;
        SplineFalloffModulationTexture: Texture2D;
        SplineFalloffModulationColorMask: ESplineModulationColorMask;
        SplineFalloffModulationTiling: number;
        SplineFalloffModulationBias: number;
        SplineFalloffModulationScale: number;
        IsReferencedFromLoadedData: boolean;
        LayerUsageDebugColor: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeLayerInfoObject;
        static Load(InName: string): LandscapeLayerInfoObject;
    }
    
    class LandscapeHeightfieldCollisionComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentLayerInfos: TArray<LandscapeLayerInfoObject>;
        SectionBaseX: number;
        SectionBaseY: number;
        CollisionSizeQuads: number;
        CollisionScale: number;
        SimpleCollisionSizeQuads: number;
        CollisionQuadFlags: TArray<number>;
        HeightfieldGuid: Guid;
        CachedLocalBox: Box;
        RenderComponent: TLazyObjectPtr<LandscapeComponent>;
        CookedPhysicalMaterials: TArray<PhysicalMaterial>;
        GetRenderComponent(): LandscapeComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeHeightfieldCollisionComponent;
        static Load(InName: string): LandscapeHeightfieldCollisionComponent;
    }
    
    class HeightmapData {
        constructor(Texture: Texture2D);
        Texture: Texture2D;
    }
    
    class WeightmapLayerAllocationInfo {
        constructor(LayerInfo: LandscapeLayerInfoObject, WeightmapTextureIndex: number, WeightmapTextureChannel: number);
        LayerInfo: LandscapeLayerInfoObject;
        WeightmapTextureIndex: number;
        WeightmapTextureChannel: number;
    }
    
    class LandscapeWeightmapUsage extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChannelUsage: FixSizeArray<LandscapeComponent>;
        LayerGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeWeightmapUsage;
        static Load(InName: string): LandscapeWeightmapUsage;
    }
    
    class WeightmapData {
        constructor(Textures: TArray<Texture2D>, LayerAllocations: TArray<WeightmapLayerAllocationInfo>, TextureUsages: TArray<LandscapeWeightmapUsage>);
        Textures: TArray<Texture2D>;
        LayerAllocations: TArray<WeightmapLayerAllocationInfo>;
        TextureUsages: TArray<LandscapeWeightmapUsage>;
    }
    
    class LandscapeLayerComponentData {
        constructor(HeightmapData: HeightmapData, WeightmapData: WeightmapData);
        HeightmapData: HeightmapData;
        WeightmapData: WeightmapData;
    }
    
    class LandscapeEditToolRenderData {
        constructor(ToolMaterial: MaterialInterface, GizmoMaterial: MaterialInterface, SelectedType: number, DebugChannelR: number, DebugChannelG: number, DebugChannelB: number, DataTexture: Texture2D, LayerContributionTexture: Texture2D, DirtyTexture: Texture2D);
        ToolMaterial: MaterialInterface;
        GizmoMaterial: MaterialInterface;
        SelectedType: number;
        DebugChannelR: number;
        DebugChannelG: number;
        DebugChannelB: number;
        DataTexture: Texture2D;
        LayerContributionTexture: Texture2D;
        DirtyTexture: Texture2D;
    }
    
    class LandscapeComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SectionBaseX: number;
        SectionBaseY: number;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        NumSubsections: number;
        OverrideMaterial: MaterialInterface;
        OverrideHoleMaterial: MaterialInterface;
        OverrideMaterials: TArray<LandscapeComponentMaterialOverride>;
        MaterialInstance: MaterialInstanceConstant;
        MaterialInstances: TArray<MaterialInstanceConstant>;
        MaterialInstancesDynamic: TArray<MaterialInstanceDynamic>;
        LODIndexToMaterialIndex: TArray<number>;
        MaterialIndexToDisabledTessellationMaterial: TArray<number>;
        XYOffsetmapTexture: Texture2D;
        WeightmapScaleBias: Vector4;
        WeightmapSubsectionOffset: number;
        HeightmapScaleBias: Vector4;
        CachedLocalBox: Box;
        CollisionComponent: TLazyObjectPtr<LandscapeHeightfieldCollisionComponent>;
        LightingGuid: Guid;
        LayersData: TMap<Guid, LandscapeLayerComponentData>;
        WeightmapTexturesUsage: TArray<LandscapeWeightmapUsage>;
        LayerUpdateFlagPerMode: number;
        HeightmapTexture: Texture2D;
        WeightmapLayerAllocations: TArray<WeightmapLayerAllocationInfo>;
        WeightmapTextures: TArray<Texture2D>;
        MapBuildDataId: Guid;
        IrrelevantLights: TArray<Guid>;
        CollisionMipLevel: number;
        SimpleCollisionMipLevel: number;
        NegativeZBoundsExtension: number;
        PositiveZBoundsExtension: number;
        StaticLightingResolution: number;
        ForcedLOD: number;
        LODBias: number;
        StateId: Guid;
        BakedTextureMaterialGuid: Guid;
        GIBakedBaseColorTexture: Texture2D;
        LightingLODBias: number;
        LayerWhitelist: TArray<LandscapeLayerInfoObject>;
        EditToolRenderData: LandscapeEditToolRenderData;
        MobileDataSourceHash: Guid;
        MaterialPerLOD: TMap<MaterialInterface, number>;
        SplineHash: number;
        MobileBlendableLayerMask: number;
        MobileMaterialInterface: MaterialInterface;
        MobileMaterialInterfaces: TArray<MaterialInterface>;
        MobileWeightmapTextures: TArray<Texture2D>;
        MobileCombinationMaterialInstances: TArray<MaterialInstanceConstant>;
        MobileCombinationMaterialInstance: MaterialInstanceConstant;
        GetMaterialInstanceDynamic(InIndex: number): MaterialInstanceDynamic;
        EditorGetPaintLayerWeightByNameAtLocation(InLocation: Vector, InPaintLayerName: string): number;
        EditorGetPaintLayerWeightAtLocation(InLocation: Vector, PaintLayer: LandscapeLayerInfoObject): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeComponent;
        static Load(InName: string): LandscapeComponent;
    }
    
    class LandscapeEditorLayerSettings {
        constructor(LayerInfoObj: LandscapeLayerInfoObject, ReimportLayerFilePath: string);
        LayerInfoObj: LandscapeLayerInfoObject;
        ReimportLayerFilePath: string;
    }
    
    class LandscapeProxy extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineComponent: LandscapeSplinesComponent;
        LandscapeGuid: Guid;
        LandscapeSectionOffset: IntPoint;
        MaxLODLevel: number;
        LODDistanceFactor: number;
        LODFalloff: number;
        ComponentScreenSizeToUseSubSections: number;
        LOD0ScreenSize: number;
        LOD0DistributionSetting: number;
        LODDistributionSetting: number;
        TessellationComponentScreenSize: number;
        UseTessellationComponentScreenSizeFalloff: boolean;
        TessellationComponentScreenSizeFalloff: number;
        OccluderGeometryLOD: number;
        ExportLOD: number;
        TargetDisplayOrderList: TArray<string>;
        TargetDisplayOrder: ELandscapeLayerDisplayMode;
        StaticLightingLOD: number;
        DefaultPhysMaterial: PhysicalMaterial;
        StreamingDistanceMultiplier: number;
        LandscapeMaterial: MaterialInterface;
        LandscapeHoleMaterial: MaterialInterface;
        LandscapeMaterialsOverride: TArray<LandscapeProxyMaterialOverride>;
        PreEditLandscapeMaterial: MaterialInterface;
        PreEditLandscapeHoleMaterial: MaterialInterface;
        PreEditLandscapeMaterialsOverride: TArray<LandscapeProxyMaterialOverride>;
        bIsPerformingInteractiveActionOnLandscapeMaterialOverride: boolean;
        RuntimeVirtualTextures: TArray<RuntimeVirtualTexture>;
        VirtualTextureNumLods: number;
        VirtualTextureLodBias: number;
        VirtualTextureRenderPassType: ERuntimeVirtualTextureMainPassType;
        NegativeZBoundsExtension: number;
        PositiveZBoundsExtension: number;
        LandscapeComponents: TArray<LandscapeComponent>;
        CollisionComponents: TArray<LandscapeHeightfieldCollisionComponent>;
        FoliageComponents: TArray<HierarchicalInstancedStaticMeshComponent>;
        bHasLandscapeGrass: boolean;
        StaticLightingResolution: number;
        bCastStaticShadow: boolean;
        bCastShadowAsTwoSided: boolean;
        bCastFarShadow: boolean;
        bAffectDistanceFieldLighting: boolean;
        LightingChannels: LightingChannels;
        bUseMaterialPositionOffsetInStaticLighting: boolean;
        bRenderCustomDepth: boolean;
        CustomDepthStencilValue: number;
        LDMaxDrawDistance: number;
        bIsMovingToLevel: boolean;
        LightmassSettings: LightmassPrimitiveSettings;
        CollisionMipLevel: number;
        SimpleCollisionMipLevel: number;
        CollisionThickness: number;
        BodyInstance: BodyInstance;
        bGenerateOverlapEvents: boolean;
        bBakeMaterialPositionOffsetIntoCollision: boolean;
        EditorCachedLayerInfos: TArray<LandscapeLayerInfoObject>;
        ReimportHeightmapFilePath: string;
        EditorLayerSettings: TArray<LandscapeEditorLayerSettings>;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        NumSubsections: number;
        bUsedForNavigation: boolean;
        bUseDynamicMaterialInstance: boolean;
        NavigationGeometryGatheringMode: ENavDataGatheringMode;
        MaxPaintedLayersPerComponent: number;
        bUseLandscapeForCullingInvisibleHLODVertices: boolean;
        bHasLayersContent: boolean;
        WeightmapUsageMap: TMap<Texture2D, LandscapeWeightmapUsage>;
        SetLandscapeMaterialVectorParameterValue(ParameterName: string, Value: LinearColor): void;
        SetLandscapeMaterialTextureParameterValue(ParameterName: string, Value: Texture): void;
        SetLandscapeMaterialScalarParameterValue(ParameterName: string, Value: number): void;
        LandscapeImportWeightmapFromRenderTarget(InRenderTarget: TextureRenderTarget2D, InLayerName: string): boolean;
        LandscapeImportHeightmapFromRenderTarget(InRenderTarget: TextureRenderTarget2D, InImportHeightFromRGChannel: boolean): boolean;
        LandscapeExportWeightmapToRenderTarget(InRenderTarget: TextureRenderTarget2D, InLayerName: string): boolean;
        LandscapeExportHeightmapToRenderTarget(InRenderTarget: TextureRenderTarget2D, InExportHeightIntoRGChannel: boolean): boolean;
        EditorSetLandscapeMaterial(NewLandscapeMaterial: MaterialInterface): void;
        EditorApplySpline(InSplineComponent: SplineComponent, StartWidth: number, EndWidth: number, StartSideFalloff: number, EndSideFalloff: number, StartRoll: number, EndRoll: number, NumSubdivisions: number, bRaiseHeights: boolean, bLowerHeights: boolean, PaintLayer: LandscapeLayerInfoObject): void;
        ChangeUseTessellationComponentScreenSizeFalloff(InComponentScreenSizeToUseSubSections: boolean): void;
        ChangeTessellationComponentScreenSizeFalloff(InUseTessellationComponentScreenSizeFalloff: number): void;
        ChangeTessellationComponentScreenSize(InTessellationComponentScreenSize: number): void;
        ChangeLODDistanceFactor(InLODDistanceFactor: number): void;
        ChangeComponentScreenSizeToUseSubSections(InComponentScreenSizeToUseSubSections: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeProxy;
        static Load(InName: string): LandscapeProxy;
    }
    
    class LandscapeBlueprintBrushBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningLandscape: Landscape;
        AffectHeightmap: boolean;
        AffectWeightmap: boolean;
        AffectedWeightmapLayers: TArray<string>;
        bIsVisible: boolean;
        RequestLandscapeUpdate(): void;
        Render(InIsHeightmap: boolean, InCombinedResult: TextureRenderTarget2D, InWeightmapLayerName: string): TextureRenderTarget2D;
        Initialize(InLandscapeTransform: Transform, InLandscapeSize: IntPoint, InLandscapeRenderTargetSize: IntPoint): void;
        GetBlueprintRenderDependencies(OutStreamableAssets: $Ref<TArray<Texture2D>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeBlueprintBrushBase;
        static Load(InName: string): LandscapeBlueprintBrushBase;
    }
    
    class LandscapeLayerBrush {
        constructor(BlueprintBrush: LandscapeBlueprintBrushBase);
        BlueprintBrush: LandscapeBlueprintBrushBase;
    }
    
    class LandscapeLayer {
        constructor(Guid: Guid, Name: string, bVisible: boolean, bLocked: boolean, HeightmapAlpha: number, WeightmapAlpha: number, BlendMode: number, Brushes: TArray<LandscapeLayerBrush>, WeightmapLayerAllocationBlend: TMap<LandscapeLayerInfoObject, boolean>);
        Guid: Guid;
        Name: string;
        bVisible: boolean;
        bLocked: boolean;
        HeightmapAlpha: number;
        WeightmapAlpha: number;
        BlendMode: number;
        Brushes: TArray<LandscapeLayerBrush>;
        WeightmapLayerAllocationBlend: TMap<LandscapeLayerInfoObject, boolean>;
    }
    
    class Landscape extends LandscapeProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCanHaveLayersContent: boolean;
        LandscapeSplinesTargetLayerGuid: Guid;
        LandscapeLayers: TArray<LandscapeLayer>;
        HeightmapRTList: TArray<TextureRenderTarget2D>;
        WeightmapRTList: TArray<TextureRenderTarget2D>;
        LandscapeSplinesAffectedComponents: TSet<LandscapeComponent>;
        bLandscapeLayersAreInitialized: boolean;
        WasCompilingShaders: boolean;
        LayerContentUpdateModes: number;
        bSplineLayerUpdateRequested: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Landscape;
        static Load(InName: string): Landscape;
    }
    
    class LandscapeInfoLayerSettings {
        constructor(LayerInfoObj: LandscapeLayerInfoObject, LayerName: string, ThumbnailMIC: MaterialInstanceConstant, Owner: LandscapeProxy, DebugColorChannel: number, bValid: boolean);
        LayerInfoObj: LandscapeLayerInfoObject;
        LayerName: string;
        ThumbnailMIC: MaterialInstanceConstant;
        Owner: LandscapeProxy;
        DebugColorChannel: number;
        bValid: boolean;
    }
    
    class LandscapeStreamingProxy extends LandscapeProxy {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeActor: TLazyObjectPtr<Landscape>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeStreamingProxy;
        static Load(InName: string): LandscapeStreamingProxy;
    }
    
    class LandscapeInfo extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeActor: TLazyObjectPtr<Landscape>;
        LandscapeGuid: Guid;
        ComponentSizeQuads: number;
        SubsectionSizeQuads: number;
        ComponentNumSubsections: number;
        DrawScale: Vector;
        Layers: TArray<LandscapeInfoLayerSettings>;
        Proxies: TArray<LandscapeStreamingProxy>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeInfo;
        static Load(InName: string): LandscapeInfo;
    }
    
    class LandscapeGizmoActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Width: number;
        Height: number;
        LengthZ: number;
        MarginZ: number;
        MinRelativeZ: number;
        RelativeScaleZ: number;
        TargetLandscapeInfo: LandscapeInfo;
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoActor;
        static Load(InName: string): LandscapeGizmoActor;
    }
    
    class LandscapeGizmoActiveActor extends LandscapeGizmoActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DataType: number;
        GizmoTexture: Texture2D;
        TextureScale: Vector2D;
        SampledHeight: TArray<Vector>;
        SampledNormal: TArray<Vector>;
        SampleSizeX: number;
        SampleSizeY: number;
        CachedWidth: number;
        CachedHeight: number;
        CachedScaleXY: number;
        FrustumVerts: FixSizeArray<Vector>;
        GizmoMaterial: Material;
        GizmoDataMaterial: MaterialInstance;
        GizmoMeshMaterial: Material;
        LayerInfos: TArray<LandscapeLayerInfoObject>;
        bSnapToLandscapeGrid: boolean;
        UnsnappedRotation: Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoActiveActor;
        static Load(InName: string): LandscapeGizmoActiveActor;
    }
    
    class LandscapeGizmoRenderComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGizmoRenderComponent;
        static Load(InName: string): LandscapeGizmoRenderComponent;
    }
    
    enum EGrassScaling { Uniform, Free, LockXY, EGrassScaling_MAX}
    class GrassVariety {
        constructor(GrassMesh: StaticMesh, GrassDensity: PerPlatformFloat, bUseGrid: boolean, PlacementJitter: number, StartCullDistance: PerPlatformInt, EndCullDistance: PerPlatformInt, MinLOD: number, Scaling: EGrassScaling, ScaleX: FloatInterval, ScaleY: FloatInterval, ScaleZ: FloatInterval, RandomRotation: boolean, AlignToSurface: boolean, bUseLandscapeLightmap: boolean, LightingChannels: LightingChannels, bReceivesDecals: boolean, bCastDynamicShadow: boolean, bKeepInstanceBufferCPUCopy: boolean);
        GrassMesh: StaticMesh;
        GrassDensity: PerPlatformFloat;
        bUseGrid: boolean;
        PlacementJitter: number;
        StartCullDistance: PerPlatformInt;
        EndCullDistance: PerPlatformInt;
        MinLOD: number;
        Scaling: EGrassScaling;
        ScaleX: FloatInterval;
        ScaleY: FloatInterval;
        ScaleZ: FloatInterval;
        RandomRotation: boolean;
        AlignToSurface: boolean;
        bUseLandscapeLightmap: boolean;
        LightingChannels: LightingChannels;
        bReceivesDecals: boolean;
        bCastDynamicShadow: boolean;
        bKeepInstanceBufferCPUCopy: boolean;
    }
    
    class LandscapeGrassType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GrassVarieties: TArray<GrassVariety>;
        bEnableDensityScaling: boolean;
        GrassMesh: StaticMesh;
        GrassDensity: number;
        PlacementJitter: number;
        StartCullDistance: number;
        EndCullDistance: number;
        RandomRotation: boolean;
        AlignToSurface: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGrassType;
        static Load(InName: string): LandscapeGrassType;
    }
    
    class LandscapeInfoMap extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeInfoMap;
        static Load(InName: string): LandscapeInfoMap;
    }
    
    class LandscapeMaterialInstanceConstant extends MaterialInstanceConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsLayerThumbnail: boolean;
        bDisableTessellation: boolean;
        bMobile: boolean;
        bEditorToolUsage: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMaterialInstanceConstant;
        static Load(InName: string): LandscapeMaterialInstanceConstant;
    }
    
    class LandscapeMeshCollisionComponent extends LandscapeHeightfieldCollisionComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshGuid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMeshCollisionComponent;
        static Load(InName: string): LandscapeMeshCollisionComponent;
    }
    
    class LandscapeMeshProxyComponent extends StaticMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeGuid: Guid;
        ProxyComponentBases: TArray<IntPoint>;
        ProxyLOD: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMeshProxyComponent;
        static Load(InName: string): LandscapeMeshProxyComponent;
    }
    
    class LandscapeMeshProxyActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeMeshProxyComponent: LandscapeMeshProxyComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeMeshProxyActor;
        static Load(InName: string): LandscapeMeshProxyActor;
    }
    
    class LandscapeSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxNumberOfLayers: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeSettings;
        static Load(InName: string): LandscapeSettings;
    }
    
    class MaterialExpressionCustomOutput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCustomOutput;
        static Load(InName: string): MaterialExpressionCustomOutput;
    }
    
    class GrassInput {
        constructor(Name: string, GrassType: LandscapeGrassType, Input: ExpressionInput);
        Name: string;
        GrassType: LandscapeGrassType;
        Input: ExpressionInput;
    }
    
    class MaterialExpressionLandscapeGrassOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GrassTypes: TArray<GrassInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeGrassOutput;
        static Load(InName: string): MaterialExpressionLandscapeGrassOutput;
    }
    
    class LayerBlendInput {
        constructor(LayerName: string, BlendType: number, LayerInput: ExpressionInput, HeightInput: ExpressionInput, PreviewWeight: number, ConstLayerInput: Vector, ConstHeightInput: number);
        LayerName: string;
        BlendType: number;
        LayerInput: ExpressionInput;
        HeightInput: ExpressionInput;
        PreviewWeight: number;
        ConstLayerInput: Vector;
        ConstHeightInput: number;
    }
    
    class MaterialExpressionLandscapeLayerBlend extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Layers: TArray<LayerBlendInput>;
        ExpressionGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerBlend;
        static Load(InName: string): MaterialExpressionLandscapeLayerBlend;
    }
    
    class MaterialExpressionLandscapeLayerCoords extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MappingType: number;
        CustomUVType: number;
        MappingScale: number;
        MappingRotation: number;
        MappingPanU: number;
        MappingPanV: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerCoords;
        static Load(InName: string): MaterialExpressionLandscapeLayerCoords;
    }
    
    class MaterialExpressionLandscapeLayerSample extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        PreviewWeight: number;
        ExpressionGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerSample;
        static Load(InName: string): MaterialExpressionLandscapeLayerSample;
    }
    
    class MaterialExpressionLandscapeLayerSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerUsed: ExpressionInput;
        LayerNotUsed: ExpressionInput;
        ParameterName: string;
        PreviewUsed: boolean;
        ExpressionGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerSwitch;
        static Load(InName: string): MaterialExpressionLandscapeLayerSwitch;
    }
    
    class MaterialExpressionLandscapeLayerWeight extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Base: ExpressionInput;
        Layer: ExpressionInput;
        ParameterName: string;
        PreviewWeight: number;
        ConstBase: Vector;
        ExpressionGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeLayerWeight;
        static Load(InName: string): MaterialExpressionLandscapeLayerWeight;
    }
    
    class MaterialExpressionLandscapeVisibilityMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExpressionGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLandscapeVisibilityMask;
        static Load(InName: string): MaterialExpressionLandscapeVisibilityMask;
    }
    
    class ActorChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Actor: Actor;
        CreateSubObjects: TArray<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorChannel;
        static Load(InName: string): ActorChannel;
    }
    
    class BlendSpace extends BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisToScaleAnimation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpace;
        static Load(InName: string): BlendSpace;
    }
    
    class AimOffsetBlendSpace extends BlendSpace {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpace;
        static Load(InName: string): AimOffsetBlendSpace;
    }
    
    class BlendSpace1D extends BlendSpaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisplayEditorVertically: boolean;
        bScaleAnimation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlendSpace1D;
        static Load(InName: string): BlendSpace1D;
    }
    
    class AimOffsetBlendSpace1D extends BlendSpace1D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AimOffsetBlendSpace1D;
        static Load(InName: string): AimOffsetBlendSpace1D;
    }
    
    class AmbientSound extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AudioComponent: AudioComponent;
        Stop(): void;
        Play(StartTime: number): void;
        FadeOut(FadeOutDuration: number, FadeVolumeLevel: number): void;
        FadeIn(FadeInDuration: number, FadeVolumeLevel: number): void;
        AdjustVolume(AdjustVolumeDuration: number, AdjustVolumeLevel: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AmbientSound;
        static Load(InName: string): AmbientSound;
    }
    
    class AnimationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CompressCommandletVersion: number;
        KeyEndEffectorsMatchNameArray: TArray<string>;
        DefaultCompressionAlgorithm: Class;
        RotationCompressionFormat: number;
        TranslationCompressionFormat: number;
        MaxCurveError: number;
        AlternativeCompressionThreshold: number;
        ForceRecompression: boolean;
        bOnlyCheckForMissingSkeletalMeshes: boolean;
        bForceBelowThreshold: boolean;
        bFirstRecompressUsingCurrentOrDefault: boolean;
        bRaiseMaxErrorToExisting: boolean;
        bTryExhaustiveSearch: boolean;
        bEnableSegmenting: boolean;
        bEnablePerformanceLog: boolean;
        bStripAnimationDataOnDedicatedServer: boolean;
        bTickAnimationOnSkeletalMeshInit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSettings;
        static Load(InName: string): AnimationSettings;
    }
    
    class AnimBlueprintFunction {
        constructor(Name: string, Group: string, OutputPoseNodeIndex: number, InputPoseNames: TArray<string>, InputPoseNodeIndices: TArray<number>, OutputPoseNodeProperty: StructProperty, InputPoseNodeProperties: TArray<StructProperty>, InputProperties: TArray<Property>, bImplemented: boolean);
        Name: string;
        Group: string;
        OutputPoseNodeIndex: number;
        InputPoseNames: TArray<string>;
        InputPoseNodeIndices: TArray<number>;
        OutputPoseNodeProperty: StructProperty;
        InputPoseNodeProperties: TArray<StructProperty>;
        InputProperties: TArray<Property>;
        bImplemented: boolean;
    }
    
    class AnimClassData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BakedStateMachines: TArray<BakedAnimationStateMachine>;
        TargetSkeleton: Skeleton;
        AnimNotifies: TArray<AnimNotifyEvent>;
        OrderedSavedPoseIndicesMap: TMap<string, CachedPoseIndices>;
        AnimBlueprintFunctions: TArray<AnimBlueprintFunction>;
        AnimNodeProperties: TArray<StructProperty>;
        LinkedAnimGraphNodeProperties: TArray<StructProperty>;
        LinkedAnimLayerNodeProperties: TArray<StructProperty>;
        PreUpdateNodeProperties: TArray<StructProperty>;
        DynamicResetNodeProperties: TArray<StructProperty>;
        StateMachineNodeProperties: TArray<StructProperty>;
        InitializationNodeProperties: TArray<StructProperty>;
        GraphNameAssetPlayers: TMap<string, GraphAssetPlayerInformation>;
        SyncGroupNames: TArray<string>;
        EvaluateGraphExposedInputs: TArray<ExposedValueHandler>;
        GraphBlendOptions: TMap<string, AnimGraphBlendOptions>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimClassData;
        static Load(InName: string): AnimClassData;
    }
    
    class AnimComposite extends AnimCompositeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationTrack: AnimTrack;
        PreviewBasePose: AnimSequence;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimComposite;
        static Load(InName: string): AnimComposite;
    }
    
    class AnimCompress_Automatic extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxEndEffectorError: number;
        bRunCurrentDefaultCompressor: boolean;
        bAutoReplaceIfExistingErrorTooGreat: boolean;
        bRaiseMaxErrorToExisting: boolean;
        bTryExhaustiveSearch: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_Automatic;
        static Load(InName: string): AnimCompress_Automatic;
    }
    
    class AnimCompress_BitwiseCompressOnly extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_BitwiseCompressOnly;
        static Load(InName: string): AnimCompress_BitwiseCompressOnly;
    }
    
    class AnimCompress_LeastDestructive extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_LeastDestructive;
        static Load(InName: string): AnimCompress_LeastDestructive;
    }
    
    class AnimCompress_RemoveLinearKeys extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPosDiff: number;
        MaxAngleDiff: number;
        MaxScaleDiff: number;
        MaxEffectorDiff: number;
        MinEffectorDiff: number;
        EffectorDiffSocket: number;
        ParentKeyScale: number;
        bRetarget: boolean;
        bActuallyFilterLinearKeys: boolean;
        bOptimizeForForwardPlayback: boolean;
        bUseDecompression: boolean;
        bUseMultithreading: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveLinearKeys;
        static Load(InName: string): AnimCompress_RemoveLinearKeys;
    }
    
    class AnimCompress_PerTrackCompression extends AnimCompress_RemoveLinearKeys {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxZeroingThreshold: number;
        MaxPosDiffBitwise: number;
        MaxAngleDiffBitwise: number;
        MaxScaleDiffBitwise: number;
        AllowedRotationFormats: TArray<number>;
        AllowedTranslationFormats: TArray<number>;
        AllowedScaleFormats: TArray<number>;
        bResampleAnimation: boolean;
        ResampledFramerate: number;
        MinKeysForResampling: number;
        bUseAdaptiveError: boolean;
        bUseOverrideForEndEffectors: boolean;
        TrackHeightBias: number;
        ParentingDivisor: number;
        ParentingDivisorExponent: number;
        bUseAdaptiveError2: boolean;
        RotationErrorSourceRatio: number;
        TranslationErrorSourceRatio: number;
        ScaleErrorSourceRatio: number;
        MaxErrorPerTrackRatio: number;
        PerturbationProbeSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_PerTrackCompression;
        static Load(InName: string): AnimCompress_PerTrackCompression;
    }
    
    class AnimCompress_RemoveEverySecondKey extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinKeys: number;
        bStartAtSecondKey: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveEverySecondKey;
        static Load(InName: string): AnimCompress_RemoveEverySecondKey;
    }
    
    class AnimCompress_RemoveTrivialKeys extends AnimCompress {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPosDiff: number;
        MaxAngleDiff: number;
        MaxScaleDiff: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCompress_RemoveTrivialKeys;
        static Load(InName: string): AnimCompress_RemoveTrivialKeys;
    }
    
    class AnimCurveCompressionCodec_CompressedRichCurve extends AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxCurveError: number;
        UseAnimSequenceSampleRate: boolean;
        ErrorSampleRate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_CompressedRichCurve;
        static Load(InName: string): AnimCurveCompressionCodec_CompressedRichCurve;
    }
    
    class AnimCurveCompressionCodec_UniformIndexable extends AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_UniformIndexable;
        static Load(InName: string): AnimCurveCompressionCodec_UniformIndexable;
    }
    
    class AnimCurveCompressionCodec_UniformlySampled extends AnimCurveCompressionCodec {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UseAnimSequenceSampleRate: boolean;
        SampleRate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimCurveCompressionCodec_UniformlySampled;
        static Load(InName: string): AnimCurveCompressionCodec_UniformlySampled;
    }
    
    class AnimLayerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimLayerInterface;
        static Load(InName: string): AnimLayerInterface;
    }
    
    class AnimNotify_PauseClothingSimulation extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PauseClothingSimulation;
        static Load(InName: string): AnimNotify_PauseClothingSimulation;
    }
    
    class AnimNotify_PlayParticleEffect extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PSTemplate: ParticleSystem;
        LocationOffset: Vector;
        RotationOffset: Rotator;
        Scale: Vector;
        Attached: boolean;
        SocketName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlayParticleEffect;
        static Load(InName: string): AnimNotify_PlayParticleEffect;
    }
    
    class AnimNotify_PlaySound extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sound: SoundBase;
        VolumeMultiplier: number;
        PitchMultiplier: number;
        bFollow: boolean;
        AttachName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_PlaySound;
        static Load(InName: string): AnimNotify_PlaySound;
    }
    
    class AnimNotify_ResetClothingSimulation extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResetClothingSimulation;
        static Load(InName: string): AnimNotify_ResetClothingSimulation;
    }
    
    class AnimNotify_ResetDynamics extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResetDynamics;
        static Load(InName: string): AnimNotify_ResetDynamics;
    }
    
    class AnimNotify_ResumeClothingSimulation extends AnimNotify {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotify_ResumeClothingSimulation;
        static Load(InName: string): AnimNotify_ResumeClothingSimulation;
    }
    
    class AnimNotifyState_DisableRootMotion extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_DisableRootMotion;
        static Load(InName: string): AnimNotifyState_DisableRootMotion;
    }
    
    class AnimNotifyState_TimedParticleEffect extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PSTemplate: ParticleSystem;
        SocketName: string;
        LocationOffset: Vector;
        RotationOffset: Rotator;
        bDestroyAtEnd: boolean;
        PreviousPSTemplates: TArray<ParticleSystem>;
        PreviousSocketNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_TimedParticleEffect;
        static Load(InName: string): AnimNotifyState_TimedParticleEffect;
    }
    
    class AnimNotifyState_Trail extends AnimNotifyState {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PSTemplate: ParticleSystem;
        FirstSocketName: string;
        SecondSocketName: string;
        WidthScaleMode: number;
        WidthScaleCurve: string;
        bRecycleSpawnedSystems: boolean;
        bRenderGeometry: boolean;
        bRenderSpawnPoints: boolean;
        bRenderTangents: boolean;
        bRenderTessellation: boolean;
        OverridePSTemplate(MeshComp: SkeletalMeshComponent, Animation: AnimSequenceBase): ParticleSystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimNotifyState_Trail;
        static Load(InName: string): AnimNotifyState_Trail;
    }
    
    class AnimSetMeshLinkup {
        constructor(BoneToTrackTable: TArray<number>);
        BoneToTrackTable: TArray<number>;
    }
    
    class AnimSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAnimRotationOnly: boolean;
        TrackBoneNames: TArray<string>;
        Sequences: TArray<AnimSequence>;
        LinkupCache: TArray<AnimSetMeshLinkup>;
        BoneUseAnimTranslation: TArray<number>;
        ForceUseMeshTranslation: TArray<number>;
        UseTranslationBoneNames: TArray<string>;
        ForceMeshTranslationBoneNames: TArray<string>;
        PreviewSkelMeshName: string;
        BestRatioSkelMeshName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSet;
        static Load(InName: string): AnimSet;
    }
    
    class AnimStateMachineTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStateMachineTypes;
        static Load(InName: string): AnimStateMachineTypes;
    }
    
    class RawAnimSequenceTrack {
        constructor(PosKeys: TArray<Vector>, RotKeys: TArray<Quat>, ScaleKeys: TArray<Vector>);
        PosKeys: TArray<Vector>;
        RotKeys: TArray<Quat>;
        ScaleKeys: TArray<Vector>;
    }
    
    class AnimStreamable extends AnimSequenceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumFrames: number;
        Interpolation: EAnimInterpolationType;
        RetargetSource: string;
        SourceSequence: AnimSequence;
        CompressionScheme: AnimCompress;
        RawDataGuid: Guid;
        RawAnimationData: TArray<RawAnimSequenceTrack>;
        TrackToSkeletonMapTable: TArray<TrackToSkeletonMap>;
        AnimationTrackNames: TArray<string>;
        CurveCompressionSettings: AnimCurveCompressionSettings;
        bEnableRootMotion: boolean;
        RootMotionRootLock: number;
        bForceRootLock: boolean;
        bUseNormalizedRootMotionScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimStreamable;
        static Load(InName: string): AnimStreamable;
    }
    
    enum ETemperatureSeverityType { Unknown, Good, Bad, Serious, Critical, NumSeverities, ETemperatureSeverityType_MAX}
    class ApplicationLifecycleComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ApplicationWillDeactivateDelegate: $MulticastDelegate<() => void>;
        ApplicationHasReactivatedDelegate: $MulticastDelegate<() => void>;
        ApplicationWillEnterBackgroundDelegate: $MulticastDelegate<() => void>;
        ApplicationHasEnteredForegroundDelegate: $MulticastDelegate<() => void>;
        ApplicationWillTerminateDelegate: $MulticastDelegate<() => void>;
        ApplicationShouldUnloadResourcesDelegate: $MulticastDelegate<() => void>;
        ApplicationReceivedStartupArgumentsDelegate: $MulticastDelegate<(StartupArguments: TArray<string>) => void>;
        OnTemperatureChangeDelegate: $MulticastDelegate<(Severity: ETemperatureSeverityType) => void>;
        OnLowPowerModeDelegate: $MulticastDelegate<(bInLowPowerMode: boolean) => void>;
        OnTemperatureChangeDelegate__DelegateSignature(Severity: ETemperatureSeverityType): void;
        OnLowPowerModeDelegate__DelegateSignature(bInLowPowerMode: boolean): void;
        ApplicationStartupArgumentsDelegate__DelegateSignature(StartupArguments: TArray<string>): void;
        ApplicationLifetimeDelegate__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ApplicationLifecycleComponent;
        static Load(InName: string): ApplicationLifecycleComponent;
    }
    
    enum EPrimaryAssetCookRule { Unknown, NeverCook, DevelopmentCook, DevelopmentAlwaysCook, AlwaysCook, EPrimaryAssetCookRule_MAX}
    class PrimaryAssetRules {
        constructor(Priority: number, ChunkId: number, bApplyRecursively: boolean, CookRule: EPrimaryAssetCookRule);
        Priority: number;
        ChunkId: number;
        bApplyRecursively: boolean;
        CookRule: EPrimaryAssetCookRule;
    }
    
    class PrimaryAssetTypeInfo {
        constructor(PrimaryAssetType: string, AssetBaseClass: TSoftObjectPtr<Class>, AssetBaseClassLoaded: Class, bHasBlueprintClasses: boolean, bIsEditorOnly: boolean, Directories: TArray<DirectoryPath>, SpecificAssets: TArray<SoftObjectPath>, Rules: PrimaryAssetRules, AssetScanPaths: TArray<string>, bIsDynamicAsset: boolean, NumberOfAssets: number);
        PrimaryAssetType: string;
        AssetBaseClass: TSoftObjectPtr<Class>;
        AssetBaseClassLoaded: Class;
        bHasBlueprintClasses: boolean;
        bIsEditorOnly: boolean;
        Directories: TArray<DirectoryPath>;
        SpecificAssets: TArray<SoftObjectPath>;
        Rules: PrimaryAssetRules;
        AssetScanPaths: TArray<string>;
        bIsDynamicAsset: boolean;
        NumberOfAssets: number;
    }
    
    class PrimaryAssetType {
        constructor(Name: string);
        Name: string;
    }
    
    class PrimaryAssetId {
        constructor(PrimaryAssetType: PrimaryAssetType, PrimaryAssetName: string);
        PrimaryAssetType: PrimaryAssetType;
        PrimaryAssetName: string;
    }
    
    class PrimaryAssetRulesOverride {
        constructor(PrimaryAssetId: PrimaryAssetId, Rules: PrimaryAssetRules);
        PrimaryAssetId: PrimaryAssetId;
        Rules: PrimaryAssetRules;
    }
    
    class PrimaryAssetRulesCustomOverride {
        constructor(PrimaryAssetType: PrimaryAssetType, FilterDirectory: DirectoryPath, FilterString: string, Rules: PrimaryAssetRules);
        PrimaryAssetType: PrimaryAssetType;
        FilterDirectory: DirectoryPath;
        FilterString: string;
        Rules: PrimaryAssetRules;
    }
    
    class AssetManagerRedirect {
        constructor(Old: string, New: string);
        Old: string;
        New: string;
    }
    
    class AssetManagerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryAssetTypesToScan: TArray<PrimaryAssetTypeInfo>;
        DirectoriesToExclude: TArray<DirectoryPath>;
        PrimaryAssetRules: TArray<PrimaryAssetRulesOverride>;
        CustomPrimaryAssetRules: TArray<PrimaryAssetRulesCustomOverride>;
        bOnlyCookProductionAssets: boolean;
        bShouldManagerDetermineTypeAndName: boolean;
        bShouldGuessTypeAndNameInEditor: boolean;
        bShouldAcquireMissingChunksOnLoad: boolean;
        PrimaryAssetIdRedirects: TArray<AssetManagerRedirect>;
        PrimaryAssetTypeRedirects: TArray<AssetManagerRedirect>;
        AssetPathRedirects: TArray<AssetManagerRedirect>;
        MetaDataTagsForAssetRegistry: TSet<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetManagerSettings;
        static Load(InName: string): AssetManagerSettings;
    }
    
    class SaveGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SaveGame;
        static Load(InName: string): SaveGame;
    }
    
    class AsyncActionHandleSaveGame extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(SaveGame: SaveGame, bSuccess: boolean) => void>;
        SaveGameObject: SaveGame;
        static AsyncSaveGameToSlot(WorldContextObject: Object, SaveGameObject: SaveGame, SlotName: string, UserIndex: number): AsyncActionHandleSaveGame;
        static AsyncLoadGameFromSlot(WorldContextObject: Object, SlotName: string, UserIndex: number): AsyncActionHandleSaveGame;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionHandleSaveGame;
        static Load(InName: string): AsyncActionHandleSaveGame;
    }
    
    class AsyncActionLoadPrimaryAssetBase extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetBase;
        static Load(InName: string): AsyncActionLoadPrimaryAssetBase;
    }
    
    class AsyncActionLoadPrimaryAsset extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: Object) => void>;
        static AsyncLoadPrimaryAsset(WorldContextObject: Object, PrimaryAsset: PrimaryAssetId, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAsset;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAsset;
        static Load(InName: string): AsyncActionLoadPrimaryAsset;
    }
    
    class AsyncActionLoadPrimaryAssetClass extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: Class) => void>;
        static AsyncLoadPrimaryAssetClass(WorldContextObject: Object, PrimaryAsset: PrimaryAssetId, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAssetClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetClass;
        static Load(InName: string): AsyncActionLoadPrimaryAssetClass;
    }
    
    class AsyncActionLoadPrimaryAssetList extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: TArray<Object>) => void>;
        static AsyncLoadPrimaryAssetList(WorldContextObject: Object, PrimaryAssetList: TArray<PrimaryAssetId>, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAssetList;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetList;
        static Load(InName: string): AsyncActionLoadPrimaryAssetList;
    }
    
    class AsyncActionLoadPrimaryAssetClassList extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<(Loaded: TArray<Class>) => void>;
        static AsyncLoadPrimaryAssetClassList(WorldContextObject: Object, PrimaryAssetList: TArray<PrimaryAssetId>, LoadBundles: TArray<string>): AsyncActionLoadPrimaryAssetClassList;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionLoadPrimaryAssetClassList;
        static Load(InName: string): AsyncActionLoadPrimaryAssetClassList;
    }
    
    class AsyncActionChangePrimaryAssetBundles extends AsyncActionLoadPrimaryAssetBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Completed: $MulticastDelegate<() => void>;
        static AsyncChangeBundleStateForPrimaryAssetList(WorldContextObject: Object, PrimaryAssetList: TArray<PrimaryAssetId>, AddBundles: TArray<string>, RemoveBundles: TArray<string>): AsyncActionChangePrimaryAssetBundles;
        static AsyncChangeBundleStateForMatchingPrimaryAssets(WorldContextObject: Object, NewBundles: TArray<string>, OldBundles: TArray<string>): AsyncActionChangePrimaryAssetBundles;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AsyncActionChangePrimaryAssetBundles;
        static Load(InName: string): AsyncActionChangePrimaryAssetBundles;
    }
    
    class AtmospherePrecomputeParameters {
        constructor(DensityHeight: number, DecayHeight: number, MaxScatteringOrder: number, TransmittanceTexWidth: number, TransmittanceTexHeight: number, IrradianceTexWidth: number, IrradianceTexHeight: number, InscatterAltitudeSampleNum: number, InscatterMuNum: number, InscatterMuSNum: number, InscatterNuNum: number);
        DensityHeight: number;
        DecayHeight: number;
        MaxScatteringOrder: number;
        TransmittanceTexWidth: number;
        TransmittanceTexHeight: number;
        IrradianceTexWidth: number;
        IrradianceTexHeight: number;
        InscatterAltitudeSampleNum: number;
        InscatterMuNum: number;
        InscatterMuSNum: number;
        InscatterNuNum: number;
    }
    
    class AtmosphericFogComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SunMultiplier: number;
        FogMultiplier: number;
        DensityMultiplier: number;
        DensityOffset: number;
        DistanceScale: number;
        AltitudeScale: number;
        DistanceOffset: number;
        GroundOffset: number;
        StartDistance: number;
        SunDiscScale: number;
        DefaultBrightness: number;
        DefaultLightColor: Color;
        bDisableSunDisk: boolean;
        bAtmosphereAffectsSunIlluminance: boolean;
        bDisableGroundScattering: boolean;
        PrecomputeParams: AtmospherePrecomputeParameters;
        TransmittanceTexture: Texture2D;
        IrradianceTexture: Texture2D;
        StartPrecompute(): void;
        SetSunMultiplier(NewSunMultiplier: number): void;
        SetStartDistance(NewStartDistance: number): void;
        SetPrecomputeParams(DensityHeight: number, MaxScatteringOrder: number, InscatterAltitudeSampleNum: number): void;
        SetFogMultiplier(NewFogMultiplier: number): void;
        SetDistanceScale(NewDistanceScale: number): void;
        SetDistanceOffset(NewDistanceOffset: number): void;
        SetDensityOffset(NewDensityOffset: number): void;
        SetDensityMultiplier(NewDensityMultiplier: number): void;
        SetDefaultLightColor(NewLightColor: LinearColor): void;
        SetDefaultBrightness(NewBrightness: number): void;
        SetAltitudeScale(NewAltitudeScale: number): void;
        DisableSunDisk(NewSunDisk: boolean): void;
        DisableGroundScattering(NewGroundScattering: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AtmosphericFogComponent;
        static Load(InName: string): AtmosphericFogComponent;
    }
    
    class AtmosphericFog extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AtmosphericFogComponent: AtmosphericFogComponent;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AtmosphericFog;
        static Load(InName: string): AtmosphericFog;
    }
    
    enum EVoiceSampleRate { Low16000Hz, Normal24000Hz, EVoiceSampleRate_MAX}
    class AudioQualitySettings {
        constructor(DisplayName: string, MaxChannels: number);
        DisplayName: string;
        MaxChannels: number;
    }
    
    enum EPanningMethod { Linear, EqualPower, EPanningMethod_MAX}
    enum EMonoChannelUpmixMethod { Linear, EqualPower, FullVolume, EMonoChannelUpmixMethod_MAX}
    class AudioSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSoundClassName: SoftObjectPath;
        DefaultMediaSoundClassName: SoftObjectPath;
        DefaultSoundConcurrencyName: SoftObjectPath;
        DefaultBaseSoundMix: SoftObjectPath;
        VoiPSoundClass: SoftObjectPath;
        VoiPSampleRate: EVoiceSampleRate;
        VoipBufferingDelay: number;
        DefaultReverbSendLevel: number;
        bEnableLegacyReverb: boolean;
        MaximumConcurrentStreams: number;
        GlobalMinPitchScale: number;
        GlobalMaxPitchScale: number;
        QualityLevels: TArray<AudioQualitySettings>;
        bAllowPlayWhenSilent: boolean;
        bDisableMasterEQ: boolean;
        bAllowCenterChannel3DPanning: boolean;
        NumStoppingSources: number;
        PanningMethod: EPanningMethod;
        MonoChannelUpmixMethod: EMonoChannelUpmixMethod;
        DialogueFilenameFormat: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioSettings;
        static Load(InName: string): AudioSettings;
    }
    
    class AudioVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Priority: number;
        bEnabled: boolean;
        Settings: ReverbSettings;
        AmbientZoneSettings: InteriorSettings;
        SetReverbSettings(NewReverbSettings: ReverbSettings): void;
        SetPriority(NewPriority: number): void;
        SetInteriorSettings(NewInteriorSettings: InteriorSettings): void;
        SetEnabled(bNewEnabled: boolean): void;
        OnRep_bEnabled(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioVolume;
        static Load(InName: string): AudioVolume;
    }
    
    class EditorMapPerformanceTestDefinition {
        constructor(PerformanceTestmap: SoftObjectPath, TestTimer: number);
        PerformanceTestmap: SoftObjectPath;
        TestTimer: number;
    }
    
    class ImportFactorySettingValues {
        constructor(SettingName: string, Value: string);
        SettingName: string;
        Value: string;
    }
    
    class EditorImportWorkflowDefinition {
        constructor(ImportFilePath: FilePath, FactorySettings: TArray<ImportFactorySettingValues>);
        ImportFilePath: FilePath;
        FactorySettings: TArray<ImportFactorySettingValues>;
    }
    
    class BuildPromotionImportWorkflowSettings {
        constructor(Diffuse: EditorImportWorkflowDefinition, Normal: EditorImportWorkflowDefinition, StaticMesh: EditorImportWorkflowDefinition, ReimportStaticMesh: EditorImportWorkflowDefinition, BlendShapeMesh: EditorImportWorkflowDefinition, MorphMesh: EditorImportWorkflowDefinition, SkeletalMesh: EditorImportWorkflowDefinition, Animation: EditorImportWorkflowDefinition, Sound: EditorImportWorkflowDefinition, SurroundSound: EditorImportWorkflowDefinition, OtherAssetsToImport: TArray<EditorImportWorkflowDefinition>);
        Diffuse: EditorImportWorkflowDefinition;
        Normal: EditorImportWorkflowDefinition;
        StaticMesh: EditorImportWorkflowDefinition;
        ReimportStaticMesh: EditorImportWorkflowDefinition;
        BlendShapeMesh: EditorImportWorkflowDefinition;
        MorphMesh: EditorImportWorkflowDefinition;
        SkeletalMesh: EditorImportWorkflowDefinition;
        Animation: EditorImportWorkflowDefinition;
        Sound: EditorImportWorkflowDefinition;
        SurroundSound: EditorImportWorkflowDefinition;
        OtherAssetsToImport: TArray<EditorImportWorkflowDefinition>;
    }
    
    class BuildPromotionOpenAssetSettings {
        constructor(BlueprintAsset: FilePath, MaterialAsset: FilePath, ParticleSystemAsset: FilePath, SkeletalMeshAsset: FilePath, StaticMeshAsset: FilePath, TextureAsset: FilePath);
        BlueprintAsset: FilePath;
        MaterialAsset: FilePath;
        ParticleSystemAsset: FilePath;
        SkeletalMeshAsset: FilePath;
        StaticMeshAsset: FilePath;
        TextureAsset: FilePath;
    }
    
    class BuildPromotionNewProjectSettings {
        constructor(NewProjectFolderOverride: DirectoryPath, NewProjectNameOverride: string);
        NewProjectFolderOverride: DirectoryPath;
        NewProjectNameOverride: string;
    }
    
    class BuildPromotionTestSettings {
        constructor(DefaultStaticMeshAsset: FilePath, ImportWorkflow: BuildPromotionImportWorkflowSettings, OpenAssets: BuildPromotionOpenAssetSettings, NewProjectSettings: BuildPromotionNewProjectSettings, SourceControlMaterial: FilePath);
        DefaultStaticMeshAsset: FilePath;
        ImportWorkflow: BuildPromotionImportWorkflowSettings;
        OpenAssets: BuildPromotionOpenAssetSettings;
        NewProjectSettings: BuildPromotionNewProjectSettings;
        SourceControlMaterial: FilePath;
    }
    
    class MaterialEditorPromotionSettings {
        constructor(DefaultMaterialAsset: FilePath, DefaultDiffuseTexture: FilePath, DefaultNormalTexture: FilePath);
        DefaultMaterialAsset: FilePath;
        DefaultDiffuseTexture: FilePath;
        DefaultNormalTexture: FilePath;
    }
    
    class ParticleEditorPromotionSettings {
        constructor(DefaultParticleAsset: FilePath);
        DefaultParticleAsset: FilePath;
    }
    
    class BlueprintEditorPromotionSettings {
        constructor(FirstMeshPath: FilePath, SecondMeshPath: FilePath, DefaultParticleAsset: FilePath);
        FirstMeshPath: FilePath;
        SecondMeshPath: FilePath;
        DefaultParticleAsset: FilePath;
    }
    
    class ExternalToolDefinition {
        constructor(ToolName: string, ExecutablePath: FilePath, CommandLineOptions: string, WorkingDirectory: DirectoryPath, ScriptExtension: string, ScriptDirectory: DirectoryPath);
        ToolName: string;
        ExecutablePath: FilePath;
        CommandLineOptions: string;
        WorkingDirectory: DirectoryPath;
        ScriptExtension: string;
        ScriptDirectory: DirectoryPath;
    }
    
    class EditorImportExportTestDefinition {
        constructor(ImportFilePath: FilePath, ExportFileExtension: string, bSkipExport: boolean, FactorySettings: TArray<ImportFactorySettingValues>);
        ImportFilePath: FilePath;
        ExportFileExtension: string;
        bSkipExport: boolean;
        FactorySettings: TArray<ImportFactorySettingValues>;
    }
    
    class LaunchOnTestSettings {
        constructor(LaunchOnTestmap: FilePath, DeviceID: string);
        LaunchOnTestmap: FilePath;
        DeviceID: string;
    }
    
    class AutomationTestSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EngineTestModules: TArray<string>;
        EditorTestModules: TArray<string>;
        AutomationTestmap: SoftObjectPath;
        EditorPerformanceTestMaps: TArray<EditorMapPerformanceTestDefinition>;
        AssetsToOpen: TArray<SoftObjectPath>;
        BuildPromotionTest: BuildPromotionTestSettings;
        MaterialEditorPromotionTest: MaterialEditorPromotionSettings;
        ParticleEditorPromotionTest: ParticleEditorPromotionSettings;
        BlueprintEditorPromotionTest: BlueprintEditorPromotionSettings;
        TestLevelFolders: TArray<string>;
        ExternalTools: TArray<ExternalToolDefinition>;
        ImportExportTestDefinitions: TArray<EditorImportExportTestDefinition>;
        LaunchOnSettings: TArray<LaunchOnTestSettings>;
        DefaultScreenshotResolution: IntPoint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationTestSettings;
        static Load(InName: string): AutomationTestSettings;
    }
    
    class BandwidthTestItem {
        constructor(Kilobyte: TArray<number>);
        Kilobyte: TArray<number>;
    }
    
    class BandwidthTestGenerator {
        constructor(ReplicatedBuffers: TArray<BandwidthTestItem>);
        ReplicatedBuffers: TArray<BandwidthTestItem>;
    }
    
    class BandwidthTestActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BandwidthGenerator: BandwidthTestGenerator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BandwidthTestActor;
        static Load(InName: string): BandwidthTestActor;
    }
    
    class BlockingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlockingVolume;
        static Load(InName: string): BlockingVolume;
    }
    
    class BlueprintMapLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetMapPropertyByName(Object: Object, PropertyName: string, Value: TMap<number, number>): void;
        static Map_Values(TargetMap: TMap<number, number>, Values: $Ref<TArray<number>>): void;
        static Map_Remove(TargetMap: TMap<number, number>, Key: number): boolean;
        static Map_Length(TargetMap: TMap<number, number>): number;
        static Map_Keys(TargetMap: TMap<number, number>, Keys: $Ref<TArray<number>>): void;
        static Map_Find(TargetMap: TMap<number, number>, Key: number, Value: $Ref<number>): boolean;
        static Map_Contains(TargetMap: TMap<number, number>, Key: number): boolean;
        static Map_Clear(TargetMap: TMap<number, number>): void;
        static Map_Add(TargetMap: TMap<number, number>, Key: number, Value: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintMapLibrary;
        static Load(InName: string): BlueprintMapLibrary;
    }
    
    class BlueprintPathsLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static VideoCaptureDir(): string;
        static ValidatePath(InPath: string, bDidSucceed: $Ref<boolean>, OutReason: $Ref<string>): void;
        static Split(InPath: string, PathPart: $Ref<string>, FilenamePart: $Ref<string>, ExtensionPart: $Ref<string>): void;
        static SourceConfigDir(): string;
        static ShouldSaveToUserDir(): boolean;
        static ShaderWorkingDir(): string;
        static SetProjectFilePath(NewGameProjectFilePath: string): void;
        static SetExtension(InPath: string, InNewExtension: string): string;
        static ScreenShotDir(): string;
        static SandboxesDir(): string;
        static RootDir(): string;
        static RemoveDuplicateSlashes(InPath: string, OutPath: $Ref<string>): void;
        static ProjectUserDir(): string;
        static ProjectSavedDir(): string;
        static ProjectPluginsDir(): string;
        static ProjectPersistentDownloadDir(): string;
        static ProjectModsDir(): string;
        static ProjectLogDir(): string;
        static ProjectIntermediateDir(): string;
        static ProjectDir(): string;
        static ProjectContentDir(): string;
        static ProjectConfigDir(): string;
        static ProfilingDir(): string;
        static NormalizeFilename(InPath: string, OutPath: $Ref<string>): void;
        static NormalizeDirectoryName(InPath: string, OutPath: $Ref<string>): void;
        static MakeValidFileName(InString: string, InReplacementChar: string): string;
        static MakeStandardFilename(InPath: string, OutPath: $Ref<string>): void;
        static MakePlatformFilename(InPath: string, OutPath: $Ref<string>): void;
        static MakePathRelativeTo(InPath: string, InRelativeTo: string, OutPath: $Ref<string>): boolean;
        static LaunchDir(): string;
        static IsSamePath(PathA: string, PathB: string): boolean;
        static IsRestrictedPath(InPath: string): boolean;
        static IsRelative(InPath: string): boolean;
        static IsProjectFilePathSet(): boolean;
        static IsDrive(InPath: string): boolean;
        static HasProjectPersistentDownloadDir(): boolean;
        static GetToolTipLocalizationPaths(): TArray<string>;
        static GetRestrictedFolderNames(): TArray<string>;
        static GetRelativePathToRoot(): string;
        static GetPropertyNameLocalizationPaths(): TArray<string>;
        static GetProjectFilePath(): string;
        static GetPath(InPath: string): string;
        static GetInvalidFileSystemChars(): string;
        static GetGameLocalizationPaths(): TArray<string>;
        static GetExtension(InPath: string, bIncludeDot: boolean): string;
        static GetEngineLocalizationPaths(): TArray<string>;
        static GetEditorLocalizationPaths(): TArray<string>;
        static GetCleanFilename(InPath: string): string;
        static GetBaseFilename(InPath: string, bRemovePath: boolean): string;
        static GeneratedConfigDir(): string;
        static GameUserDeveloperDir(): string;
        static GameSourceDir(): string;
        static GameDevelopersDir(): string;
        static GameAgnosticSavedDir(): string;
        static FileExists(InPath: string): boolean;
        static FeaturePackDir(): string;
        static EnterprisePluginsDir(): string;
        static EnterpriseFeaturePackDir(): string;
        static EnterpriseDir(): string;
        static EngineVersionAgnosticUserDir(): string;
        static EngineUserDir(): string;
        static EngineSourceDir(): string;
        static EngineSavedDir(): string;
        static EnginePluginsDir(): string;
        static EngineIntermediateDir(): string;
        static EngineDir(): string;
        static EngineContentDir(): string;
        static EngineConfigDir(): string;
        static DirectoryExists(InPath: string): boolean;
        static DiffDir(): string;
        static CreateTempFilename(Path: string, Prefix: string, Extension: string): string;
        static ConvertToSandboxPath(InPath: string, InSandboxName: string): string;
        static ConvertRelativePathToFull(InPath: string, InBasePath: string): string;
        static ConvertFromSandboxPath(InPath: string, InSandboxName: string): string;
        static Combine(InPaths: TArray<string>): string;
        static CollapseRelativeDirectories(InPath: string, OutPath: $Ref<string>): boolean;
        static CloudDir(): string;
        static ChangeExtension(InPath: string, InNewExtension: string): string;
        static BugItDir(): string;
        static AutomationTransientDir(): string;
        static AutomationLogDir(): string;
        static AutomationDir(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintPathsLibrary;
        static Load(InName: string): BlueprintPathsLibrary;
    }
    
    class PlatformGameInstance extends GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ApplicationWillDeactivateDelegate: $MulticastDelegate<() => void>;
        ApplicationHasReactivatedDelegate: $MulticastDelegate<() => void>;
        ApplicationWillEnterBackgroundDelegate: $MulticastDelegate<() => void>;
        ApplicationHasEnteredForegroundDelegate: $MulticastDelegate<() => void>;
        ApplicationWillTerminateDelegate: $MulticastDelegate<() => void>;
        ApplicationShouldUnloadResourcesDelegate: $MulticastDelegate<() => void>;
        ApplicationReceivedStartupArgumentsDelegate: $MulticastDelegate<(StartupArguments: TArray<string>) => void>;
        ApplicationRegisteredForRemoteNotificationsDelegate: $MulticastDelegate<(inArray: TArray<number>) => void>;
        ApplicationRegisteredForUserNotificationsDelegate: $MulticastDelegate<(inInt: number) => void>;
        ApplicationFailedToRegisterForRemoteNotificationsDelegate: $MulticastDelegate<(inString: string) => void>;
        ApplicationReceivedRemoteNotificationDelegate: $MulticastDelegate<(inString: string, inAppState: number) => void>;
        ApplicationReceivedLocalNotificationDelegate: $MulticastDelegate<(inString: string, inInt: number, inAppState: number) => void>;
        ApplicationReceivedScreenOrientationChangedNotificationDelegate: $MulticastDelegate<(inScreenOrientation: number) => void>;
        PlatformStartupArgumentsDelegate__DelegateSignature(StartupArguments: TArray<string>): void;
        PlatformScreenOrientationChangedDelegate__DelegateSignature(inScreenOrientation: number): void;
        PlatformRegisteredForUserNotificationsDelegate__DelegateSignature(inInt: number): void;
        PlatformRegisteredForRemoteNotificationsDelegate__DelegateSignature(inArray: TArray<number>): void;
        PlatformReceivedRemoteNotificationDelegate__DelegateSignature(inString: string, inAppState: number): void;
        PlatformReceivedLocalNotificationDelegate__DelegateSignature(inString: string, inInt: number, inAppState: number): void;
        PlatformFailedToRegisterForRemoteNotificationsDelegate__DelegateSignature(inString: string): void;
        PlatformDelegate__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformGameInstance;
        static Load(InName: string): PlatformGameInstance;
    }
    
    class BlueprintPlatformLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ScheduleLocalNotificationFromNow(inSecondsFromNow: number, Title: string, Body: string, Action: string, ActivationEvent: string): number;
        static ScheduleLocalNotificationBadgeFromNow(inSecondsFromNow: number, ActivationEvent: string): void;
        static ScheduleLocalNotificationBadgeAtTime(FireDateTime: DateTime, LocalTime: boolean, ActivationEvent: string): number;
        static ScheduleLocalNotificationAtTime(FireDateTime: DateTime, LocalTime: boolean, Title: string, Body: string, Action: string, ActivationEvent: string): number;
        static GetLaunchNotification(NotificationLaunchedApp: $Ref<boolean>, ActivationEvent: $Ref<string>, FireDate: $Ref<number>): void;
        static GetDeviceOrientation(): number;
        static ClearAllLocalNotifications(): void;
        static CancelLocalNotificationById(NotificationId: number): void;
        static CancelLocalNotification(ActivationEvent: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintPlatformLibrary;
        static Load(InName: string): BlueprintPlatformLibrary;
    }
    
    class BlueprintSetLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetSetPropertyByName(Object: Object, PropertyName: string, Value: TSet<number>): void;
        static Set_Union(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>): void;
        static Set_ToArray(A: TSet<number>, Result: $Ref<TArray<number>>): void;
        static Set_RemoveItems(TargetSet: TSet<number>, Items: TArray<number>): void;
        static Set_Remove(TargetSet: TSet<number>, Item: number): boolean;
        static Set_Length(TargetSet: TSet<number>): number;
        static Set_Intersection(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>): void;
        static Set_Difference(A: TSet<number>, B: TSet<number>, Result: $Ref<TSet<number>>): void;
        static Set_Contains(TargetSet: TSet<number>, ItemToFind: number): boolean;
        static Set_Clear(TargetSet: TSet<number>): void;
        static Set_AddItems(TargetSet: TSet<number>, NewItems: TArray<number>): void;
        static Set_Add(TargetSet: TSet<number>, NewItem: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlueprintSetLibrary;
        static Load(InName: string): BlueprintSetLibrary;
    }
    
    class BoneMaskFilter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlendPoses: TArray<InputBlendPose>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoneMaskFilter;
        static Load(InName: string): BoneMaskFilter;
    }
    
    class BookMark2D extends BookmarkBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Zoom2D: number;
        Location: IntPoint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BookMark2D;
        static Load(InName: string): BookMark2D;
    }
    
    class BoxComponent extends ShapeComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoxExtent: Vector;
        LineThickness: number;
        SetBoxExtent(InBoxExtent: Vector, bUpdateOverlaps: boolean): void;
        GetUnscaledBoxExtent(): Vector;
        GetScaledBoxExtent(): Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxComponent;
        static Load(InName: string): BoxComponent;
    }
    
    enum EReflectionSourceType { CapturedScene, SpecifiedCubemap, EReflectionSourceType_MAX}
    class ReflectionCaptureComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureOffsetComponent: BillboardComponent;
        ReflectionSourceType: EReflectionSourceType;
        Cubemap: TextureCube;
        SourceCubemapAngle: number;
        Brightness: number;
        CaptureOffset: Vector;
        MapBuildDataId: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReflectionCaptureComponent;
        static Load(InName: string): ReflectionCaptureComponent;
    }
    
    class ReflectionCapture extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponent: ReflectionCaptureComponent;
        SpriteComponent: BillboardComponent;
        CaptureOffsetComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReflectionCapture;
        static Load(InName: string): ReflectionCapture;
    }
    
    class BoxReflectionCapture extends ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxReflectionCapture;
        static Load(InName: string): BoxReflectionCapture;
    }
    
    class BoxReflectionCaptureComponent extends ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoxTransitionDistance: number;
        PreviewInfluenceBox: BoxComponent;
        PreviewCaptureBox: BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxReflectionCaptureComponent;
        static Load(InName: string): BoxReflectionCaptureComponent;
    }
    
    class BrushShape extends Brush {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrushShape;
        static Load(InName: string): BrushShape;
    }
    
    class ButtonStyleAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ButtonStyle: ButtonStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ButtonStyleAsset;
        static Load(InName: string): ButtonStyleAsset;
    }
    
    class CameraBlockingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CameraBlockingVolume;
        static Load(InName: string): CameraBlockingVolume;
    }
    
    class CanvasRenderTarget2D extends TextureRenderTarget2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnCanvasRenderTargetUpdate: $MulticastDelegate<(Canvas: Canvas, Width: number, Height: number) => void>;
        World: TWeakObjectPtr<World>;
        bShouldClearRenderTargetOnReceiveUpdate: boolean;
        UpdateResource(): void;
        ReceiveUpdate(Canvas: Canvas, Width: number, Height: number): void;
        GetSize(Width: $Ref<number>, Height: $Ref<number>): void;
        static CreateCanvasRenderTarget2D(WorldContextObject: Object, CanvasRenderTarget2DClass: Class, Width: number, Height: number): CanvasRenderTarget2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CanvasRenderTarget2D;
        static Load(InName: string): CanvasRenderTarget2D;
    }
    
    class ChaosPhysicalMaterial extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Friction: number;
        Restitution: number;
        SleepingLinearVelocityThreshold: number;
        SleepingAngularVelocityThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosPhysicalMaterial;
        static Load(InName: string): ChaosPhysicalMaterial;
    }
    
    class CheckBoxStyleAsset extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CheckBoxStyle: CheckBoxStyle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CheckBoxStyleAsset;
        static Load(InName: string): CheckBoxStyleAsset;
    }
    
    class PlatformInterfaceData {
        constructor(DataName: string, Type: number, IntValue: number, FloatValue: number, StringValue: string, ObjectValue: Object);
        DataName: string;
        Type: number;
        IntValue: number;
        FloatValue: number;
        StringValue: string;
        ObjectValue: Object;
    }
    
    class PlatformInterfaceDelegateResult {
        constructor(bSuccessful: boolean, Data: PlatformInterfaceData);
        bSuccessful: boolean;
        Data: PlatformInterfaceData;
    }
    
    class DelegateArray {
        constructor(Delegates: TArray<$Delegate<(Result: PlatformInterfaceDelegateResult) => void>>);
        Delegates: TArray<$Delegate<(Result: PlatformInterfaceDelegateResult) => void>>;
    }
    
    class PlatformInterfaceBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllDelegates: TArray<DelegateArray>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformInterfaceBase;
        static Load(InName: string): PlatformInterfaceBase;
    }
    
    class CloudStorageBase extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LocalCloudFiles: TArray<string>;
        bSuppressDelegateCalls: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CloudStorageBase;
        static Load(InName: string): CloudStorageBase;
    }
    
    class CollisionResponseTemplate {
        constructor(Name: string, CollisionEnabled: number, bCanModify: boolean, ObjectTypeName: string, CustomResponses: TArray<ResponseChannel>, HelpMessage: string);
        Name: string;
        CollisionEnabled: number;
        bCanModify: boolean;
        ObjectTypeName: string;
        CustomResponses: TArray<ResponseChannel>;
        HelpMessage: string;
    }
    
    class CustomChannelSetup {
        constructor(Channel: number, DefaultResponse: number, bTraceType: boolean, bStaticObject: boolean, Name: string);
        Channel: number;
        DefaultResponse: number;
        bTraceType: boolean;
        bStaticObject: boolean;
        Name: string;
    }
    
    class CustomProfile {
        constructor(Name: string, CustomResponses: TArray<ResponseChannel>);
        Name: string;
        CustomResponses: TArray<ResponseChannel>;
    }
    
    class Redirector {
        constructor(OldName: string, NewName: string);
        OldName: string;
        NewName: string;
    }
    
    class CollisionProfile extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<CollisionResponseTemplate>;
        DefaultChannelResponses: TArray<CustomChannelSetup>;
        EditProfiles: TArray<CustomProfile>;
        ProfileRedirects: TArray<Redirector>;
        CollisionChannelRedirects: TArray<Redirector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CollisionProfile;
        static Load(InName: string): CollisionProfile;
    }
    
    class BlueprintComponentDelegateBinding {
        constructor(ComponentPropertyName: string, DelegatePropertyName: string, FunctionNameToBind: string);
        ComponentPropertyName: string;
        DelegatePropertyName: string;
        FunctionNameToBind: string;
    }
    
    class ComponentDelegateBinding extends DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ComponentDelegateBindings: TArray<BlueprintComponentDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ComponentDelegateBinding;
        static Load(InName: string): ComponentDelegateBinding;
    }
    
    class CompositeCurveTable extends CurveTable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentTables: TArray<CurveTable>;
        OldParentTables: TArray<CurveTable>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeCurveTable;
        static Load(InName: string): CompositeCurveTable;
    }
    
    class CompositeDataTable extends DataTable {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentTables: TArray<DataTable>;
        OldParentTables: TArray<DataTable>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CompositeDataTable;
        static Load(InName: string): CompositeDataTable;
    }
    
    class ControlChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ControlChannel;
        static Load(InName: string): ControlChannel;
    }
    
    class StreamingSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AsyncLoadingThreadEnabled: boolean;
        WarnIfTimeLimitExceeded: boolean;
        TimeLimitExceededMultiplier: number;
        TimeLimitExceededMinTime: number;
        MinBulkDataSizeForAsyncLoading: number;
        UseBackgroundLevelStreaming: boolean;
        AsyncLoadingUseFullTimeLimit: boolean;
        AsyncLoadingTimeLimit: number;
        PriorityAsyncLoadingExtraTime: number;
        LevelStreamingActorsUpdateTimeLimit: number;
        PriorityLevelStreamingActorsUpdateExtraTime: number;
        LevelStreamingComponentsRegistrationGranularity: number;
        LevelStreamingUnregisterComponentsTimeLimit: number;
        LevelStreamingComponentsUnregistrationGranularity: number;
        EventDrivenLoaderEnabled: boolean;
        FlushStreamingOnExit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamingSettings;
        static Load(InName: string): StreamingSettings;
    }
    
    class GarbageCollectionSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeBetweenPurgingPendingKillObjects: number;
        FlushStreamingOnGC: boolean;
        AllowParallelGC: boolean;
        IncrementalBeginDestroyEnabled: boolean;
        MultithreadedDestructionEnabled: boolean;
        CreateGCClusters: boolean;
        ActorClusteringEnabled: boolean;
        BlueprintClusteringEnabled: boolean;
        UseDisregardForGCOnDedicatedServers: boolean;
        MinGCClusterSize: number;
        NumRetriesBeforeForcingGC: number;
        MaxObjectsNotConsideredByGC: number;
        SizeOfPermanentObjectPool: number;
        MaxObjectsInGame: number;
        MaxObjectsInEditor: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GarbageCollectionSettings;
        static Load(InName: string): GarbageCollectionSettings;
    }
    
    class CullDistanceSizePair {
        constructor(Size: number, CullDistance: number);
        Size: number;
        CullDistance: number;
    }
    
    class CullDistanceVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CullDistances: TArray<CullDistanceSizePair>;
        bEnabled: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CullDistanceVolume;
        static Load(InName: string): CullDistanceVolume;
    }
    
    class CurveEdPresetCurve extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEdPresetCurve;
        static Load(InName: string): CurveEdPresetCurve;
    }
    
    class AssetBundleEntry {
        constructor(BundleScope: PrimaryAssetId, BundleName: string, BundleAssets: TArray<SoftObjectPath>);
        BundleScope: PrimaryAssetId;
        BundleName: string;
        BundleAssets: TArray<SoftObjectPath>;
    }
    
    class AssetBundleData {
        constructor(Bundles: TArray<AssetBundleEntry>);
        Bundles: TArray<AssetBundleEntry>;
    }
    
    class PrimaryDataAsset extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetBundleData: AssetBundleData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimaryDataAsset;
        static Load(InName: string): PrimaryDataAsset;
    }
    
    class DataTableFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetDataTableRowNames(Table: DataTable, OutRowNames: $Ref<TArray<string>>): void;
        static GetDataTableRowFromName(Table: DataTable, RowName: string, OutRow: $Ref<TableRowBase>): boolean;
        static GetDataTableColumnAsString(DataTable: DataTable, PropertyName: string): TArray<string>;
        static FillDataTableFromJSONString(DataTable: DataTable, JSONString: string): boolean;
        static FillDataTableFromJSONFile(DataTable: DataTable, JSONFilePath: string): boolean;
        static FillDataTableFromCSVString(DataTable: DataTable, CSVString: string): boolean;
        static FillDataTableFromCSVFile(DataTable: DataTable, CSVFilePath: string): boolean;
        static EvaluateCurveTableRow(CurveTable: CurveTable, RowName: string, InXY: number, OutResult: $Ref<number>, OutXY: $Ref<number>, ContextString: string): void;
        static DoesDataTableRowExist(Table: DataTable, RowName: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataTableFunctionLibrary;
        static Load(InName: string): DataTableFunctionLibrary;
    }
    
    class DebugCameraControllerSettingsViewModeIndex {
        constructor(ViewModeIndex: number);
        ViewModeIndex: number;
    }
    
    class DebugCameraControllerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CycleViewModes: TArray<DebugCameraControllerSettingsViewModeIndex>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugCameraControllerSettings;
        static Load(InName: string): DebugCameraControllerSettings;
    }
    
    class DebugCameraHUD extends HUD {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugCameraHUD;
        static Load(InName: string): DebugCameraHUD;
    }
    
    class DebugDrawService extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DebugDrawService;
        static Load(InName: string): DebugDrawService;
    }
    
    class DecalComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DecalMaterial: MaterialInterface;
        SortOrder: number;
        FadeScreenSize: number;
        FadeStartDelay: number;
        FadeDuration: number;
        FadeInDuration: number;
        FadeInStartDelay: number;
        bDestroyOwnerAfterFade: boolean;
        DecalSize: Vector;
        SetSortOrder(Value: number): void;
        SetFadeScreenSize(NewFadeScreenSize: number): void;
        SetFadeOut(StartDelay: number, Duration: number, DestroyOwnerAfterFade: boolean): void;
        SetFadeIn(StartDelay: number, Duaration: number): void;
        SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
        GetFadeStartDelay(): number;
        GetFadeInStartDelay(): number;
        GetFadeInDuration(): number;
        GetFadeDuration(): number;
        GetDecalMaterial(): MaterialInterface;
        CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DecalComponent;
        static Load(InName: string): DecalComponent;
    }
    
    class DecalActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Decal: DecalComponent;
        ArrowComponent: ArrowComponent;
        SpriteComponent: BillboardComponent;
        BoxComponent: BoxComponent;
        SetDecalMaterial(NewDecalMaterial: MaterialInterface): void;
        GetDecalMaterial(): MaterialInterface;
        CreateDynamicMaterialInstance(): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DecalActor;
        static Load(InName: string): DecalActor;
    }
    
    class DefaultPhysicsVolume extends PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DefaultPhysicsVolume;
        static Load(InName: string): DefaultPhysicsVolume;
    }
    
    class DemoNetConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DemoNetConnection;
        static Load(InName: string): DemoNetConnection;
    }
    
    class PendingNetGame extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NetDriver: NetDriver;
        DemoNetDriver: DemoNetDriver;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PendingNetGame;
        static Load(InName: string): PendingNetGame;
    }
    
    class DemoPendingNetGame extends PendingNetGame {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DemoPendingNetGame;
        static Load(InName: string): DemoPendingNetGame;
    }
    
    class DestructibleInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DestructibleInterface;
        static Load(InName: string): DestructibleInterface;
    }
    
    class TextureLODGroup {
        constructor(Group: number, LODBias: number, LODBias_Smaller: number, LODBias_Smallest: number, NumStreamedMips: number, MipGenSettings: number, MinLODSize: number, MaxLODSize: number, MaxLODSize_Smaller: number, MaxLODSize_Smallest: number, OptionalLODBias: number, OptionalMaxLODSize: number, MinMagFilter: string, MipFilter: string, MipLoadOptions: ETextureMipLoadOptions, DuplicateNonOptionalMips: boolean);
        Group: number;
        LODBias: number;
        LODBias_Smaller: number;
        LODBias_Smallest: number;
        NumStreamedMips: number;
        MipGenSettings: number;
        MinLODSize: number;
        MaxLODSize: number;
        MaxLODSize_Smaller: number;
        MaxLODSize_Smallest: number;
        OptionalLODBias: number;
        OptionalMaxLODSize: number;
        MinMagFilter: string;
        MipFilter: string;
        MipLoadOptions: ETextureMipLoadOptions;
        DuplicateNonOptionalMips: boolean;
    }
    
    class TextureLODSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureLODGroups: TArray<TextureLODGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureLODSettings;
        static Load(InName: string): TextureLODSettings;
    }
    
    class DeviceProfile extends TextureLODSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeviceType: string;
        BaseProfileName: string;
        Parent: Object;
        CVars: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DeviceProfile;
        static Load(InName: string): DeviceProfile;
    }
    
    class DeviceProfileManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Profiles: TArray<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DeviceProfileManager;
        static Load(InName: string): DeviceProfileManager;
    }
    
    class DialogueSoundWaveProxy extends SoundBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueSoundWaveProxy;
        static Load(InName: string): DialogueSoundWaveProxy;
    }
    
    class DialogueVoice extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Gender: number;
        Plurality: number;
        LocalizationGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueVoice;
        static Load(InName: string): DialogueVoice;
    }
    
    class DialogueContext {
        constructor(Speaker: DialogueVoice, Targets: TArray<DialogueVoice>);
        Speaker: DialogueVoice;
        Targets: TArray<DialogueVoice>;
    }
    
    class DialogueContextMapping {
        constructor(Context: DialogueContext, SoundWave: SoundWave, LocalizationKeyFormat: string, Proxy: DialogueSoundWaveProxy);
        Context: DialogueContext;
        SoundWave: SoundWave;
        LocalizationKeyFormat: string;
        Proxy: DialogueSoundWaveProxy;
    }
    
    class DialogueWave extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMature: boolean;
        bOverride_SubtitleOverride: boolean;
        SpokenText: string;
        SubtitleOverride: string;
        VoiceActorDirection: string;
        ContextMappings: TArray<DialogueContextMapping>;
        LocalizationGUID: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueWave;
        static Load(InName: string): DialogueWave;
    }
    
    class Light extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightComponent: LightComponent;
        bEnabled: boolean;
        ToggleEnabled(): void;
        SetLightFunctionScale(NewLightFunctionScale: Vector): void;
        SetLightFunctionMaterial(NewLightFunctionMaterial: MaterialInterface): void;
        SetLightFunctionFadeDistance(NewLightFunctionFadeDistance: number): void;
        SetLightColor(NewLightColor: LinearColor): void;
        SetEnabled(bSetEnabled: boolean): void;
        SetCastShadows(bNewValue: boolean): void;
        SetBrightness(NewBrightness: number): void;
        SetAffectTranslucentLighting(bNewValue: boolean): void;
        OnRep_bEnabled(): void;
        IsEnabled(): boolean;
        GetLightColor(): LinearColor;
        GetBrightness(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Light;
        static Load(InName: string): Light;
    }
    
    class LightmassDirectionalLightSettings extends LightmassLightSettings {
        constructor(LightSourceAngle: number);
        LightSourceAngle: number;
    }
    
    class DirectionalLightComponent extends LightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShadowCascadeBiasDistribution: number;
        bEnableLightShaftOcclusion: boolean;
        OcclusionMaskDarkness: number;
        OcclusionDepthRange: number;
        LightShaftOverrideDirection: Vector;
        WholeSceneDynamicShadowRadius: number;
        DynamicShadowDistanceMovableLight: number;
        DynamicShadowDistanceStationaryLight: number;
        DynamicShadowCascades: number;
        CascadeDistributionExponent: number;
        CascadeTransitionFraction: number;
        ShadowDistanceFadeoutFraction: number;
        bUseInsetShadowsForMovableObjects: boolean;
        FarShadowCascadeCount: number;
        FarShadowDistance: number;
        DistanceFieldShadowDistance: number;
        LightSourceAngle: number;
        LightSourceSoftAngle: number;
        TraceDistance: number;
        LightmassSettings: LightmassDirectionalLightSettings;
        bCastModulatedShadows: boolean;
        ModulatedShadowColor: Color;
        ShadowAmount: number;
        bUsedAsAtmosphereSunLight: boolean;
        AtmosphereSunLightIndex: number;
        SetShadowDistanceFadeoutFraction(NewValue: number): void;
        SetShadowAmount(NewValue: number): void;
        SetOcclusionMaskDarkness(NewValue: number): void;
        SetLightShaftOverrideDirection(NewValue: Vector): void;
        SetEnableLightShaftOcclusion(bNewValue: boolean): void;
        SetDynamicShadowDistanceStationaryLight(NewValue: number): void;
        SetDynamicShadowDistanceMovableLight(NewValue: number): void;
        SetDynamicShadowCascades(NewValue: number): void;
        SetCascadeTransitionFraction(NewValue: number): void;
        SetCascadeDistributionExponent(NewValue: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DirectionalLightComponent;
        static Load(InName: string): DirectionalLightComponent;
    }
    
    class DirectionalLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ArrowComponent: ArrowComponent;
        DirectionalLightComponent: DirectionalLightComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DirectionalLight;
        static Load(InName: string): DirectionalLight;
    }
    
    class DistributionFloatConstant extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatConstant;
        static Load(InName: string): DistributionFloatConstant;
    }
    
    class DistributionFloatConstantCurve extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: InterpCurveFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatConstantCurve;
        static Load(InName: string): DistributionFloatConstantCurve;
    }
    
    class DistributionFloatParameterBase extends DistributionFloatConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        MinInput: number;
        MaxInput: number;
        MinOutput: number;
        MaxOutput: number;
        ParamMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatParameterBase;
        static Load(InName: string): DistributionFloatParameterBase;
    }
    
    class DistributionFloatParticleParameter extends DistributionFloatParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatParticleParameter;
        static Load(InName: string): DistributionFloatParticleParameter;
    }
    
    class DistributionFloatUniform extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Min: number;
        Max: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatUniform;
        static Load(InName: string): DistributionFloatUniform;
    }
    
    class InterpCurvePointVector2D {
        constructor(InVal: number, OutVal: Vector2D, ArriveTangent: Vector2D, LeaveTangent: Vector2D, InterpMode: number);
        InVal: number;
        OutVal: Vector2D;
        ArriveTangent: Vector2D;
        LeaveTangent: Vector2D;
        InterpMode: number;
    }
    
    class InterpCurveVector2D {
        constructor(Points: TArray<InterpCurvePointVector2D>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<InterpCurvePointVector2D>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
    }
    
    class DistributionFloatUniformCurve extends DistributionFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: InterpCurveVector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionFloatUniformCurve;
        static Load(InName: string): DistributionFloatUniformCurve;
    }
    
    class DistributionVectorConstant extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: Vector;
        bLockAxes: boolean;
        LockedAxes: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorConstant;
        static Load(InName: string): DistributionVectorConstant;
    }
    
    class DistributionVectorConstantCurve extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: InterpCurveVector;
        bLockAxes: boolean;
        LockedAxes: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorConstantCurve;
        static Load(InName: string): DistributionVectorConstantCurve;
    }
    
    class DistributionVectorParameterBase extends DistributionVectorConstant {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        MinInput: Vector;
        MaxInput: Vector;
        MinOutput: Vector;
        MaxOutput: Vector;
        ParamModes: FixSizeArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorParameterBase;
        static Load(InName: string): DistributionVectorParameterBase;
    }
    
    class DistributionVectorParticleParameter extends DistributionVectorParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorParticleParameter;
        static Load(InName: string): DistributionVectorParticleParameter;
    }
    
    class DistributionVectorUniform extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Max: Vector;
        Min: Vector;
        bLockAxes: boolean;
        LockedAxes: number;
        MirrorFlags: FixSizeArray<number>;
        bUseExtremes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorUniform;
        static Load(InName: string): DistributionVectorUniform;
    }
    
    class TwoVectors {
        constructor(v1: Vector, v2: Vector);
        v1: Vector;
        v2: Vector;
    }
    
    class InterpCurvePointTwoVectors {
        constructor(InVal: number, OutVal: TwoVectors, ArriveTangent: TwoVectors, LeaveTangent: TwoVectors, InterpMode: number);
        InVal: number;
        OutVal: TwoVectors;
        ArriveTangent: TwoVectors;
        LeaveTangent: TwoVectors;
        InterpMode: number;
    }
    
    class InterpCurveTwoVectors {
        constructor(Points: TArray<InterpCurvePointTwoVectors>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<InterpCurvePointTwoVectors>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
    }
    
    class DistributionVectorUniformCurve extends DistributionVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstantCurve: InterpCurveTwoVectors;
        bLockAxes1: boolean;
        bLockAxes2: boolean;
        LockedAxes: FixSizeArray<number>;
        MirrorFlags: FixSizeArray<number>;
        bUseExtremes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DistributionVectorUniformCurve;
        static Load(InName: string): DistributionVectorUniformCurve;
    }
    
    class MaterialSpriteElement {
        constructor(Material: MaterialInterface, DistanceToOpacityCurve: CurveFloat, bSizeIsInScreenSpace: boolean, BaseSizeX: number, BaseSizeY: number, DistanceToSizeCurve: CurveFloat);
        Material: MaterialInterface;
        DistanceToOpacityCurve: CurveFloat;
        bSizeIsInScreenSpace: boolean;
        BaseSizeX: number;
        BaseSizeY: number;
        DistanceToSizeCurve: CurveFloat;
    }
    
    class MaterialBillboardComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Elements: TArray<MaterialSpriteElement>;
        SetElements(NewElements: TArray<MaterialSpriteElement>): void;
        AddElement(Material: MaterialInterface, DistanceToOpacityCurve: CurveFloat, bSizeIsInScreenSpace: boolean, BaseSizeX: number, BaseSizeY: number, DistanceToSizeCurve: CurveFloat): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialBillboardComponent;
        static Load(InName: string): MaterialBillboardComponent;
    }
    
    class DocumentationActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DocumentLink: string;
        Billboard: MaterialBillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DocumentationActor;
        static Load(InName: string): DocumentationActor;
    }
    
    class DPICustomScalingRule extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DPICustomScalingRule;
        static Load(InName: string): DPICustomScalingRule;
    }
    
    class DrawSphereComponent extends SphereComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DrawSphereComponent;
        static Load(InName: string): DrawSphereComponent;
    }
    
    class GraphNodeContextMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Blueprint: Blueprint;
        Graph: EdGraph;
        Node: EdGraphNode;
        bIsDebugging: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GraphNodeContextMenuContext;
        static Load(InName: string): GraphNodeContextMenuContext;
    }
    
    class EdGraphNode_Documentation extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Link: string;
        Excerpt: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Documentation;
        static Load(InName: string): EdGraphNode_Documentation;
    }
    
    class EngineBaseTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineBaseTypes;
        static Load(InName: string): EngineBaseTypes;
    }
    
    class EngineHandlerComponentFactory extends HandlerComponentFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineHandlerComponentFactory;
        static Load(InName: string): EngineHandlerComponentFactory;
    }
    
    class LocalMessage extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalMessage;
        static Load(InName: string): LocalMessage;
    }
    
    class EngineMessage extends LocalMessage {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FailedPlaceMessage: string;
        MaxedOutMessage: string;
        EnteredMessage: string;
        LeftMessage: string;
        GlobalNameChange: string;
        SpecEnteredMessage: string;
        NewPlayerMessage: string;
        NewSpecMessage: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineMessage;
        static Load(InName: string): EngineMessage;
    }
    
    class EngineSubsystem extends DynamicSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineSubsystem;
        static Load(InName: string): EngineSubsystem;
    }
    
    class EngineTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EngineTypes;
        static Load(InName: string): EngineTypes;
    }
    
    class ExponentialHeightFogData {
        constructor(FogDensity: number, FogHeightFalloff: number, FogHeightOffset: number);
        FogDensity: number;
        FogHeightFalloff: number;
        FogHeightOffset: number;
    }
    
    class ExponentialHeightFogComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FogDensity: number;
        FogHeightFalloff: number;
        SecondFogData: ExponentialHeightFogData;
        FogInscatteringColor: LinearColor;
        InscatteringColorCubemap: TextureCube;
        InscatteringColorCubemapAngle: number;
        InscatteringTextureTint: LinearColor;
        FullyDirectionalInscatteringColorDistance: number;
        NonDirectionalInscatteringColorDistance: number;
        DirectionalInscatteringExponent: number;
        DirectionalInscatteringStartDistance: number;
        DirectionalInscatteringColor: LinearColor;
        FogMaxOpacity: number;
        StartDistance: number;
        FogCutoffDistance: number;
        bEnableVolumetricFog: boolean;
        VolumetricFogScatteringDistribution: number;
        VolumetricFogAlbedo: Color;
        VolumetricFogEmissive: LinearColor;
        VolumetricFogExtinctionScale: number;
        VolumetricFogDistance: number;
        VolumetricFogStaticLightingScatteringIntensity: number;
        bOverrideLightColorsWithFogInscatteringColors: boolean;
        SetVolumetricFogScatteringDistribution(NewValue: number): void;
        SetVolumetricFogExtinctionScale(NewValue: number): void;
        SetVolumetricFogEmissive(NewValue: LinearColor): void;
        SetVolumetricFogDistance(NewValue: number): void;
        SetVolumetricFogAlbedo(NewValue: Color): void;
        SetVolumetricFog(bNewValue: boolean): void;
        SetStartDistance(Value: number): void;
        SetNonDirectionalInscatteringColorDistance(Value: number): void;
        SetInscatteringTextureTint(Value: LinearColor): void;
        SetInscatteringColorCubemapAngle(Value: number): void;
        SetInscatteringColorCubemap(Value: TextureCube): void;
        SetFullyDirectionalInscatteringColorDistance(Value: number): void;
        SetFogMaxOpacity(Value: number): void;
        SetFogInscatteringColor(Value: LinearColor): void;
        SetFogHeightFalloff(Value: number): void;
        SetFogDensity(Value: number): void;
        SetFogCutoffDistance(Value: number): void;
        SetDirectionalInscatteringStartDistance(Value: number): void;
        SetDirectionalInscatteringExponent(Value: number): void;
        SetDirectionalInscatteringColor(Value: LinearColor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExponentialHeightFogComponent;
        static Load(InName: string): ExponentialHeightFogComponent;
    }
    
    class ExponentialHeightFog extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: ExponentialHeightFogComponent;
        bEnabled: boolean;
        OnRep_bEnabled(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExponentialHeightFog;
        static Load(InName: string): ExponentialHeightFog;
    }
    
    class FloatingPawnMovement extends PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxSpeed: number;
        Acceleration: number;
        Deceleration: number;
        TurningBoost: number;
        bPositionCorrected: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FloatingPawnMovement;
        static Load(InName: string): FloatingPawnMovement;
    }
    
    enum EFontLayoutMethod { Metrics, BoundingBox, EFontLayoutMethod_MAX}
    class FontFace extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFilename: string;
        Hinting: EFontHinting;
        LoadingPolicy: EFontLoadingPolicy;
        LayoutMethod: EFontLayoutMethod;
        FontFaceData: TArray<number>;
        SubFaces: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FontFace;
        static Load(InName: string): FontFace;
    }
    
    class ForceFeedbackAttenuationSettings extends BaseAttenuationSettings {
        constructor();
    }
    
    class ForceFeedbackAttenuation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Attenuation: ForceFeedbackAttenuationSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackAttenuation;
        static Load(InName: string): ForceFeedbackAttenuation;
    }
    
    class ForceFeedbackComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForceFeedbackEffect: ForceFeedbackEffect;
        bAutoDestroy: boolean;
        bStopWhenOwnerDestroyed: boolean;
        bLooping: boolean;
        bIgnoreTimeDilation: boolean;
        bOverrideAttenuation: boolean;
        IntensityMultiplier: number;
        AttenuationSettings: ForceFeedbackAttenuation;
        AttenuationOverrides: ForceFeedbackAttenuationSettings;
        OnForceFeedbackFinished: $MulticastDelegate<(ForceFeedbackComponent: ForceFeedbackComponent) => void>;
        Stop(): void;
        SetIntensityMultiplier(NewIntensityMultiplier: number): void;
        SetForceFeedbackEffect(NewForceFeedbackEffect: ForceFeedbackEffect): void;
        Play(StartTime: number): void;
        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<ForceFeedbackAttenuationSettings>): boolean;
        AdjustAttenuation(InAttenuationSettings: ForceFeedbackAttenuationSettings): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ForceFeedbackComponent;
        static Load(InName: string): ForceFeedbackComponent;
    }
    
    class GameEngine extends Engine {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxDeltaTime: number;
        ServerFlushLogInterval: number;
        GameInstance: GameInstance;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameEngine;
        static Load(InName: string): GameEngine;
    }
    
    class GameInstanceSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameInstanceSubsystem;
        static Load(InName: string): GameInstanceSubsystem;
    }
    
    enum EPSCPoolMethod { None, AutoRelease, ManualRelease, ManualRelease_OnComplete, FreeInPool, EPSCPoolMethod_MAX}
    enum EMouseCaptureMode { NoCapture, CapturePermanently, CapturePermanently_IncludingInitialMouseDown, CaptureDuringMouseDown, CaptureDuringRightMouseDown, EMouseCaptureMode_MAX}
    class PredictProjectilePathParams {
        constructor(StartLocation: Vector, LaunchVelocity: Vector, bTraceWithCollision: boolean, ProjectileRadius: number, MaxSimTime: number, bTraceWithChannel: boolean, TraceChannel: number, ObjectTypes: TArray<number>, ActorsToIgnore: TArray<Actor>, SimFrequency: number, OverrideGravityZ: number, DrawDebugType: number, DrawDebugTime: number, bTraceComplex: boolean);
        StartLocation: Vector;
        LaunchVelocity: Vector;
        bTraceWithCollision: boolean;
        ProjectileRadius: number;
        MaxSimTime: number;
        bTraceWithChannel: boolean;
        TraceChannel: number;
        ObjectTypes: TArray<number>;
        ActorsToIgnore: TArray<Actor>;
        SimFrequency: number;
        OverrideGravityZ: number;
        DrawDebugType: number;
        DrawDebugTime: number;
        bTraceComplex: boolean;
    }
    
    class PredictProjectilePathPointData {
        constructor(Location: Vector, Velocity: Vector, Time: number);
        Location: Vector;
        Velocity: Vector;
        Time: number;
    }
    
    class PredictProjectilePathResult {
        constructor(PathData: TArray<PredictProjectilePathPointData>, LastTraceDestination: PredictProjectilePathPointData, HitResult: HitResult);
        PathData: TArray<PredictProjectilePathPointData>;
        LastTraceDestination: PredictProjectilePathPointData;
        HitResult: HitResult;
    }
    
    class GameplayStatics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UnloadStreamLevel(WorldContextObject: Object, LevelName: string, LatentInfo: LatentActionInfo, bShouldBlockOnUnload: boolean): void;
        static SuggestProjectileVelocity_CustomArc(WorldContextObject: Object, OutLaunchVelocity: $Ref<Vector>, StartPos: Vector, EndPos: Vector, OverrideGravityZ: number, ArcParam: number): boolean;
        static SpawnSoundAttached(Sound: SoundBase, AttachToComponent: SceneComponent, AttachPointName: string, Location: Vector, Rotation: Rotator, LocationType: number, bStopWhenAttachedToDestroyed: boolean, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, AttenuationSettings: SoundAttenuation, ConcurrencySettings: SoundConcurrency, bAutoDestroy: boolean): AudioComponent;
        static SpawnSoundAtLocation(WorldContextObject: Object, Sound: SoundBase, Location: Vector, Rotation: Rotator, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, AttenuationSettings: SoundAttenuation, ConcurrencySettings: SoundConcurrency, bAutoDestroy: boolean): AudioComponent;
        static SpawnSound2D(WorldContextObject: Object, Sound: SoundBase, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, ConcurrencySettings: SoundConcurrency, bPersistAcrossLevelTransition: boolean, bAutoDestroy: boolean): AudioComponent;
        static SpawnObject(ObjectClass: Class, Outer: Object): Object;
        static SpawnForceFeedbackAttached(ForceFeedbackEffect: ForceFeedbackEffect, AttachToComponent: SceneComponent, AttachPointName: string, Location: Vector, Rotation: Rotator, LocationType: number, bStopWhenAttachedToDestroyed: boolean, bLooping: boolean, IntensityMultiplier: number, StartTime: number, AttenuationSettings: ForceFeedbackAttenuation, bAutoDestroy: boolean): ForceFeedbackComponent;
        static SpawnForceFeedbackAtLocation(WorldContextObject: Object, ForceFeedbackEffect: ForceFeedbackEffect, Location: Vector, Rotation: Rotator, bLooping: boolean, IntensityMultiplier: number, StartTime: number, AttenuationSettings: ForceFeedbackAttenuation, bAutoDestroy: boolean): ForceFeedbackComponent;
        static SpawnEmitterAttached(EmitterTemplate: ParticleSystem, AttachToComponent: SceneComponent, AttachPointName: string, Location: Vector, Rotation: Rotator, Scale: Vector, LocationType: number, bAutoDestroy: boolean, PoolingMethod: EPSCPoolMethod, bAutoActivate: boolean): ParticleSystemComponent;
        static SpawnEmitterAtLocation(WorldContextObject: Object, EmitterTemplate: ParticleSystem, Location: Vector, Rotation: Rotator, Scale: Vector, bAutoDestroy: boolean, PoolingMethod: EPSCPoolMethod, bAutoActivateSystem: boolean): ParticleSystemComponent;
        static SpawnDialogueAttached(Dialogue: DialogueWave, Context: DialogueContext, AttachToComponent: SceneComponent, AttachPointName: string, Location: Vector, Rotation: Rotator, LocationType: number, bStopWhenAttachedToDestroyed: boolean, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, AttenuationSettings: SoundAttenuation, bAutoDestroy: boolean): AudioComponent;
        static SpawnDialogueAtLocation(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, Location: Vector, Rotation: Rotator, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, AttenuationSettings: SoundAttenuation, bAutoDestroy: boolean): AudioComponent;
        static SpawnDialogue2D(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, bAutoDestroy: boolean): AudioComponent;
        static SpawnDecalAttached(DecalMaterial: MaterialInterface, DecalSize: Vector, AttachToComponent: SceneComponent, AttachPointName: string, Location: Vector, Rotation: Rotator, LocationType: number, LifeSpan: number): DecalComponent;
        static SpawnDecalAtLocation(WorldContextObject: Object, DecalMaterial: MaterialInterface, DecalSize: Vector, Location: Vector, Rotation: Rotator, LifeSpan: number): DecalComponent;
        static SetWorldOriginLocation(WorldContextObject: Object, NewLocation: IntVector): void;
        static SetViewportMouseCaptureMode(WorldContextObject: Object, MouseCaptureMode: EMouseCaptureMode): void;
        static SetSubtitlesEnabled(bEnabled: boolean): void;
        static SetSoundMixClassOverride(WorldContextObject: Object, InSoundMixModifier: SoundMix, InSoundClass: SoundClass, Volume: number, Pitch: number, FadeInTime: number, bApplyToChildren: boolean): void;
        static SetPlayerControllerID(Player: PlayerController, ControllerId: number): void;
        static SetMaxAudioChannelsScaled(WorldContextObject: Object, MaxChannelCountScale: number): void;
        static SetGlobalTimeDilation(WorldContextObject: Object, TimeDilation: number): void;
        static SetGlobalPitchModulation(WorldContextObject: Object, PitchModulation: number, TimeSec: number): void;
        static SetGlobalListenerFocusParameters(WorldContextObject: Object, FocusAzimuthScale: number, NonFocusAzimuthScale: number, FocusDistanceScale: number, NonFocusDistanceScale: number, FocusVolumeScale: number, NonFocusVolumeScale: number, FocusPriorityScale: number, NonFocusPriorityScale: number): void;
        static SetGamePaused(WorldContextObject: Object, bPaused: boolean): boolean;
        static SetForceDisableSplitscreen(WorldContextObject: Object, bDisable: boolean): void;
        static SetEnableWorldRendering(WorldContextObject: Object, bEnable: boolean): void;
        static SetBaseSoundMix(WorldContextObject: Object, InSoundMix: SoundMix): void;
        static SaveGameToSlot(SaveGameObject: SaveGame, SlotName: string, UserIndex: number): boolean;
        static RemovePlayer(Player: PlayerController, bDestroyPawn: boolean): void;
        static RebaseZeroOriginOntoLocal(WorldContextObject: Object, WorldLocation: Vector): Vector;
        static RebaseLocalOriginOntoZero(WorldContextObject: Object, WorldLocation: Vector): Vector;
        static PushSoundMixModifier(WorldContextObject: Object, InSoundMixModifier: SoundMix): void;
        static ProjectWorldToScreen(Player: PlayerController, WorldPosition: Vector, ScreenPosition: $Ref<Vector2D>, bPlayerViewportRelative: boolean): boolean;
        static PrimeSound(InSound: SoundBase): void;
        static PopSoundMixModifier(WorldContextObject: Object, InSoundMixModifier: SoundMix): void;
        static PlayWorldCameraShake(WorldContextObject: Object, Shake: Class, Epicenter: Vector, InnerRadius: number, OuterRadius: number, Falloff: number, bOrientShakeTowardsEpicenter: boolean): void;
        static PlaySoundAtLocation(WorldContextObject: Object, Sound: SoundBase, Location: Vector, Rotation: Rotator, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, AttenuationSettings: SoundAttenuation, ConcurrencySettings: SoundConcurrency, OwningActor: Actor): void;
        static PlaySound2D(WorldContextObject: Object, Sound: SoundBase, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, ConcurrencySettings: SoundConcurrency, OwningActor: Actor): void;
        static PlayDialogueAtLocation(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, Location: Vector, Rotation: Rotator, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, AttenuationSettings: SoundAttenuation): void;
        static PlayDialogue2D(WorldContextObject: Object, Dialogue: DialogueWave, Context: DialogueContext, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number): void;
        static ParseOption(Options: string, Key: string): string;
        static OpenLevel(WorldContextObject: Object, LevelName: string, bAbsolute: boolean, Options: string): void;
        static MakeHitResult(bBlockingHit: boolean, bInitialOverlap: boolean, Time: number, Distance: number, Location: Vector, ImpactPoint: Vector, Normal: Vector, ImpactNormal: Vector, PhysMat: PhysicalMaterial, HitActor: Actor, HitComponent: PrimitiveComponent, HitBoneName: string, HitItem: number, FaceIndex: number, TraceStart: Vector, TraceEnd: Vector): HitResult;
        static LoadStreamLevel(WorldContextObject: Object, LevelName: string, bMakeVisibleAfterLoad: boolean, bShouldBlockOnLoad: boolean, LatentInfo: LatentActionInfo): void;
        static LoadGameFromSlot(SlotName: string, UserIndex: number): SaveGame;
        static IsSplitscreenForceDisabled(WorldContextObject: Object): boolean;
        static IsGamePaused(WorldContextObject: Object): boolean;
        static HasOption(Options: string, InKey: string): boolean;
        static HasLaunchOption(OptionToCheck: string): boolean;
        static GrassOverlappingSphereCount(WorldContextObject: Object, StaticMesh: StaticMesh, CenterPosition: Vector, Radius: number): number;
        static GetWorldOriginLocation(WorldContextObject: Object): IntVector;
        static GetWorldDeltaSeconds(WorldContextObject: Object): number;
        static GetViewProjectionMatrix(DesiredView: MinimalViewInfo, ViewMatrix: $Ref<Matrix>, ProjectionMatrix: $Ref<Matrix>, ViewProjectionMatrix: $Ref<Matrix>): void;
        static GetViewportMouseCaptureMode(WorldContextObject: Object): EMouseCaptureMode;
        static GetUnpausedTimeSeconds(WorldContextObject: Object): number;
        static GetTimeSeconds(WorldContextObject: Object): number;
        static GetSurfaceType(Hit: HitResult): number;
        static GetStreamingLevel(WorldContextObject: Object, PackageName: string): LevelStreaming;
        static GetRealTimeSeconds(WorldContextObject: Object): number;
        static GetPlayerPawn(WorldContextObject: Object, PlayerIndex: number): Pawn;
        static GetPlayerControllerID(Player: PlayerController): number;
        static GetPlayerControllerFromID(WorldContextObject: Object, ControllerID: number): PlayerController;
        static GetPlayerController(WorldContextObject: Object, PlayerIndex: number): PlayerController;
        static GetPlayerCharacter(WorldContextObject: Object, PlayerIndex: number): Character;
        static GetPlayerCameraManager(WorldContextObject: Object, PlayerIndex: number): PlayerCameraManager;
        static GetPlatformName(): string;
        static GetObjectClass(Object: Object): Class;
        static GetMaxAudioChannelCount(WorldContextObject: Object): number;
        static GetKeyValue(Pair: string, Key: $Ref<string>, Value: $Ref<string>): void;
        static GetIntOption(Options: string, Key: string, DefaultValue: number): number;
        static GetGlobalTimeDilation(WorldContextObject: Object): number;
        static GetGameState(WorldContextObject: Object): GameStateBase;
        static GetGameMode(WorldContextObject: Object): GameModeBase;
        static GetGameInstance(WorldContextObject: Object): GameInstance;
        static GetEnableWorldRendering(WorldContextObject: Object): boolean;
        static GetCurrentReverbEffect(WorldContextObject: Object): ReverbEffect;
        static GetCurrentLevelName(WorldContextObject: Object, bRemovePrefixString: boolean): string;
        static GetAudioTimeSeconds(WorldContextObject: Object): number;
        static GetAllActorsWithTag(WorldContextObject: Object, Tag: string, OutActors: $Ref<TArray<Actor>>): void;
        static GetAllActorsWithInterface(WorldContextObject: Object, Interface: Class, OutActors: $Ref<TArray<Actor>>): void;
        static GetAllActorsOfClassWithTag(WorldContextObject: Object, ActorClass: Class, Tag: string, OutActors: $Ref<TArray<Actor>>): void;
        static GetAllActorsOfClass(WorldContextObject: Object, ActorClass: Class, OutActors: $Ref<TArray<Actor>>): void;
        static GetActorOfClass(WorldContextObject: Object, ActorClass: Class): Actor;
        static GetActorArrayBounds(Actors: TArray<Actor>, bOnlyCollidingComponents: boolean, Center: $Ref<Vector>, BoxExtent: $Ref<Vector>): void;
        static GetActorArrayAverageLocation(Actors: TArray<Actor>): Vector;
        static GetAccurateRealTime(WorldContextObject: Object, Seconds: $Ref<number>, PartialSeconds: $Ref<number>): void;
        static FlushLevelStreaming(WorldContextObject: Object): void;
        static FinishSpawningActor(Actor: Actor, SpawnTransform: Transform): Actor;
        static FindCollisionUV(Hit: HitResult, UVChannel: number, UV: $Ref<Vector2D>): boolean;
        static EnableLiveStreaming(Enable: boolean): void;
        static DoesSaveGameExist(SlotName: string, UserIndex: number): boolean;
        static DeprojectScreenToWorld(Player: PlayerController, ScreenPosition: Vector2D, WorldPosition: $Ref<Vector>, WorldDirection: $Ref<Vector>): boolean;
        static DeleteGameInSlot(SlotName: string, UserIndex: number): boolean;
        static DeactivateReverbEffect(WorldContextObject: Object, TagName: string): void;
        static CreateSound2D(WorldContextObject: Object, Sound: SoundBase, VolumeMultiplier: number, PitchMultiplier: number, StartTime: number, ConcurrencySettings: SoundConcurrency, bPersistAcrossLevelTransition: boolean, bAutoDestroy: boolean): AudioComponent;
        static CreateSaveGameObject(SaveGameClass: Class): SaveGame;
        static CreatePlayer(WorldContextObject: Object, ControllerId: number, bSpawnPlayerController: boolean): PlayerController;
        static ClearSoundMixModifiers(WorldContextObject: Object): void;
        static ClearSoundMixClassOverride(WorldContextObject: Object, InSoundMixModifier: SoundMix, InSoundClass: SoundClass, FadeOutTime: number): void;
        static CancelAsyncLoading(): void;
        static BreakHitResult(Hit: HitResult, bBlockingHit: $Ref<boolean>, bInitialOverlap: $Ref<boolean>, Time: $Ref<number>, Distance: $Ref<number>, Location: $Ref<Vector>, ImpactPoint: $Ref<Vector>, Normal: $Ref<Vector>, ImpactNormal: $Ref<Vector>, PhysMat: $Ref<PhysicalMaterial>, HitActor: $Ref<Actor>, HitComponent: $Ref<PrimitiveComponent>, HitBoneName: $Ref<string>, HitItem: $Ref<number>, FaceIndex: $Ref<number>, TraceStart: $Ref<Vector>, TraceEnd: $Ref<Vector>): void;
        static BlueprintSuggestProjectileVelocity(WorldContextObject: Object, TossVelocity: $Ref<Vector>, StartLocation: Vector, EndLocation: Vector, LaunchSpeed: number, OverrideGravityZ: number, TraceOption: number, CollisionRadius: number, bFavorHighArc: boolean, bDrawDebug: boolean): boolean;
        static Blueprint_PredictProjectilePath_ByTraceChannel(WorldContextObject: Object, OutHit: $Ref<HitResult>, OutPathPositions: $Ref<TArray<Vector>>, OutLastTraceDestination: $Ref<Vector>, StartPos: Vector, LaunchVelocity: Vector, bTracePath: boolean, ProjectileRadius: number, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, DrawDebugTime: number, SimFrequency: number, MaxSimTime: number, OverrideGravityZ: number): boolean;
        static Blueprint_PredictProjectilePath_ByObjectType(WorldContextObject: Object, OutHit: $Ref<HitResult>, OutPathPositions: $Ref<TArray<Vector>>, OutLastTraceDestination: $Ref<Vector>, StartPos: Vector, LaunchVelocity: Vector, bTracePath: boolean, ProjectileRadius: number, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, DrawDebugTime: number, SimFrequency: number, MaxSimTime: number, OverrideGravityZ: number): boolean;
        static Blueprint_PredictProjectilePath_Advanced(WorldContextObject: Object, PredictParams: PredictProjectilePathParams, PredictResult: $Ref<PredictProjectilePathResult>): boolean;
        static BeginSpawningActorFromClass(WorldContextObject: Object, ActorClass: Class, SpawnTransform: Transform, bNoCollisionFail: boolean, Owner: Actor): Actor;
        static BeginSpawningActorFromBlueprint(WorldContextObject: Object, Blueprint: Blueprint, SpawnTransform: Transform, bNoCollisionFail: boolean): Actor;
        static BeginDeferredActorSpawnFromClass(WorldContextObject: Object, ActorClass: Class, SpawnTransform: Transform, CollisionHandlingOverride: ESpawnActorCollisionHandlingMethod, Owner: Actor): Actor;
        static AreSubtitlesEnabled(): boolean;
        static AreAnyListenersWithinRange(WorldContextObject: Object, Location: Vector, MaximumRange: number): boolean;
        static ApplyRadialDamageWithFalloff(WorldContextObject: Object, BaseDamage: number, MinimumDamage: number, Origin: Vector, DamageInnerRadius: number, DamageOuterRadius: number, DamageFalloff: number, DamageTypeClass: Class, IgnoreActors: TArray<Actor>, DamageCauser: Actor, InstigatedByController: Controller, DamagePreventionChannel: number): boolean;
        static ApplyRadialDamage(WorldContextObject: Object, BaseDamage: number, Origin: Vector, DamageRadius: number, DamageTypeClass: Class, IgnoreActors: TArray<Actor>, DamageCauser: Actor, InstigatedByController: Controller, bDoFullDamage: boolean, DamagePreventionChannel: number): boolean;
        static ApplyPointDamage(DamagedActor: Actor, BaseDamage: number, HitFromDirection: Vector, HitInfo: HitResult, EventInstigator: Controller, DamageCauser: Actor, DamageTypeClass: Class): number;
        static ApplyDamage(DamagedActor: Actor, BaseDamage: number, EventInstigator: Controller, DamageCauser: Actor, DamageTypeClass: Class): number;
        static ActivateReverbEffect(WorldContextObject: Object, ReverbEffect: ReverbEffect, TagName: string, Priority: number, Volume: number, FadeTime: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayStatics;
        static Load(InName: string): GameplayStatics;
    }
    
    class SpotLightComponent extends PointLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerConeAngle: number;
        OuterConeAngle: number;
        LightShaftConeAngle: number;
        SetOuterConeAngle(NewOuterConeAngle: number): void;
        SetInnerConeAngle(NewInnerConeAngle: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpotLightComponent;
        static Load(InName: string): SpotLightComponent;
    }
    
    class SpotLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpotLightComponent: SpotLightComponent;
        ArrowComponent: ArrowComponent;
        SetOuterConeAngle(NewOuterConeAngle: number): void;
        SetInnerConeAngle(NewInnerConeAngle: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpotLight;
        static Load(InName: string): SpotLight;
    }
    
    class GeneratedMeshAreaLight extends SpotLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeneratedMeshAreaLight;
        static Load(InName: string): GeneratedMeshAreaLight;
    }
    
    class HapticFeedbackEffect_Buffer extends HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Amplitudes: TArray<number>;
        SampleRate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Buffer;
        static Load(InName: string): HapticFeedbackEffect_Buffer;
    }
    
    class HapticFeedbackDetails_Curve {
        constructor(Frequency: RuntimeFloatCurve, Amplitude: RuntimeFloatCurve);
        Frequency: RuntimeFloatCurve;
        Amplitude: RuntimeFloatCurve;
    }
    
    class HapticFeedbackEffect_Curve extends HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HapticDetails: HapticFeedbackDetails_Curve;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_Curve;
        static Load(InName: string): HapticFeedbackEffect_Curve;
    }
    
    class HapticFeedbackEffect_SoundWave extends HapticFeedbackEffect_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundWave: SoundWave;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HapticFeedbackEffect_SoundWave;
        static Load(InName: string): HapticFeedbackEffect_SoundWave;
    }
    
    class HealthSnapshotBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StopPerformanceSnapshots(): void;
        static StartPerformanceSnapshots(): void;
        static LogPerformanceSnapshot(SnapshotTitle: string, bResetStats: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HealthSnapshotBlueprintLibrary;
        static Load(InName: string): HealthSnapshotBlueprintLibrary;
    }
    
    class LODActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMeshComponent: StaticMeshComponent;
        ImpostersStaticMeshComponents: TMap<MaterialInterface, InstancedStaticMeshComponent>;
        Proxy: HLODProxy;
        Key: string;
        LODDrawDistance: number;
        LODLevel: number;
        SubActors: TArray<Actor>;
        CachedNumHLODLevels: number;
        NumTrianglesInSubActors: number;
        NumTrianglesInMergedMesh: number;
        bOverrideMaterialMergeSettings: boolean;
        MaterialSettings: MaterialProxySettings;
        bOverrideTransitionScreenSize: boolean;
        TransitionScreenSize: number;
        bOverrideScreenSize: boolean;
        ScreenSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LODActor;
        static Load(InName: string): LODActor;
    }
    
    class HLODProxyMesh {
        constructor(LODActor: TLazyObjectPtr<LODActor>, StaticMesh: StaticMesh, Key: string);
        LODActor: TLazyObjectPtr<LODActor>;
        StaticMesh: StaticMesh;
        Key: string;
    }
    
    class HLODProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwningMap: TSoftObjectPtr<World>;
        ProxyMeshes: TArray<HLODProxyMesh>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HLODProxy;
        static Load(InName: string): HLODProxy;
    }
    
    class ImportanceTexture {
        constructor(Size: IntPoint, NumMips: number, MarginalCDF: TArray<number>, ConditionalCDF: TArray<number>, TextureData: TArray<Color>, Texture: TWeakObjectPtr<Texture2D>, Weighting: number);
        Size: IntPoint;
        NumMips: number;
        MarginalCDF: TArray<number>;
        ConditionalCDF: TArray<number>;
        TextureData: TArray<Color>;
        Texture: TWeakObjectPtr<Texture2D>;
        Weighting: number;
    }
    
    class ImportanceSamplingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RandomSobolFloat(Index: number, Dimension: number, Seed: number): number;
        static RandomSobolCell3D(Index: number, NumCells: number, Cell: Vector, Seed: Vector): Vector;
        static RandomSobolCell2D(Index: number, NumCells: number, Cell: Vector2D, Seed: Vector2D): Vector2D;
        static NextSobolFloat(Index: number, Dimension: number, PreviousValue: number): number;
        static NextSobolCell3D(Index: number, NumCells: number, PreviousValue: Vector): Vector;
        static NextSobolCell2D(Index: number, NumCells: number, PreviousValue: Vector2D): Vector2D;
        static MakeImportanceTexture(Texture: Texture2D, WeightingFunc: number): ImportanceTexture;
        static ImportanceSample(Texture: ImportanceTexture, Rand: Vector2D, Samples: number, Intensity: number, SamplePosition: $Ref<Vector2D>, SampleColor: $Ref<LinearColor>, SampleIntensity: $Ref<number>, SampleSize: $Ref<number>): void;
        static BreakImportanceTexture(ImportanceTexture: ImportanceTexture, Texture: $Ref<Texture2D>, WeightingFunc: $Ref<number>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportanceSamplingLibrary;
        static Load(InName: string): ImportanceSamplingLibrary;
    }
    
    class ImportantToggleSettingInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImportantToggleSettingInterface;
        static Load(InName: string): ImportantToggleSettingInterface;
    }
    
    class InGameAdManager extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShouldPauseWhileAdOpen: boolean;
        ClickedBannerDelegates: TArray<$Delegate<() => void>>;
        ClosedAdDelegates: TArray<$Delegate<() => void>>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InGameAdManager;
        static Load(InName: string): InGameAdManager;
    }
    
    class InputDelegateBinding extends DynamicBlueprintBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputDelegateBinding;
        static Load(InName: string): InputDelegateBinding;
    }
    
    class BlueprintInputDelegateBinding {
        constructor(bConsumeInput: boolean, bExecuteWhenPaused: boolean, bOverrideParentBinding: boolean);
        bConsumeInput: boolean;
        bExecuteWhenPaused: boolean;
        bOverrideParentBinding: boolean;
    }
    
    class BlueprintInputActionDelegateBinding extends BlueprintInputDelegateBinding {
        constructor(InputActionName: string, InputKeyEvent: number, FunctionNameToBind: string);
        InputActionName: string;
        InputKeyEvent: number;
        FunctionNameToBind: string;
    }
    
    class InputActionDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputActionDelegateBindings: TArray<BlueprintInputActionDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputActionDelegateBinding;
        static Load(InName: string): InputActionDelegateBinding;
    }
    
    class BlueprintInputAxisDelegateBinding extends BlueprintInputDelegateBinding {
        constructor(InputAxisName: string, FunctionNameToBind: string);
        InputAxisName: string;
        FunctionNameToBind: string;
    }
    
    class InputAxisDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisDelegateBindings: TArray<BlueprintInputAxisDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputAxisDelegateBinding;
        static Load(InName: string): InputAxisDelegateBinding;
    }
    
    class BlueprintInputAxisKeyDelegateBinding extends BlueprintInputDelegateBinding {
        constructor(AxisKey: Key, FunctionNameToBind: string);
        AxisKey: Key;
        FunctionNameToBind: string;
    }
    
    class InputAxisKeyDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputAxisKeyDelegateBindings: TArray<BlueprintInputAxisKeyDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputAxisKeyDelegateBinding;
        static Load(InName: string): InputAxisKeyDelegateBinding;
    }
    
    class BlueprintInputKeyDelegateBinding extends BlueprintInputDelegateBinding {
        constructor(InputChord: InputChord, InputKeyEvent: number, FunctionNameToBind: string);
        InputChord: InputChord;
        InputKeyEvent: number;
        FunctionNameToBind: string;
    }
    
    class InputKeyDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputKeyDelegateBindings: TArray<BlueprintInputKeyDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputKeyDelegateBinding;
        static Load(InName: string): InputKeyDelegateBinding;
    }
    
    class InputAxisProperties {
        constructor(DeadZone: number, Sensitivity: number, Exponent: number, bInvert: boolean);
        DeadZone: number;
        Sensitivity: number;
        Exponent: number;
        bInvert: boolean;
    }
    
    class InputAxisConfigEntry {
        constructor(AxisKeyName: string, AxisProperties: InputAxisProperties);
        AxisKeyName: string;
        AxisProperties: InputAxisProperties;
    }
    
    class InputActionKeyMapping {
        constructor(ActionName: string, bShift: boolean, bCtrl: boolean, bAlt: boolean, bCmd: boolean, Key: Key);
        ActionName: string;
        bShift: boolean;
        bCtrl: boolean;
        bAlt: boolean;
        bCmd: boolean;
        Key: Key;
    }
    
    class InputAxisKeyMapping {
        constructor(AxisName: string, Scale: number, Key: Key);
        AxisName: string;
        Scale: number;
        Key: Key;
    }
    
    class InputActionSpeechMapping {
        constructor(ActionName: string, SpeechKeyword: string);
        ActionName: string;
        SpeechKeyword: string;
    }
    
    class InputSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AxisConfig: TArray<InputAxisConfigEntry>;
        bAltEnterTogglesFullscreen: boolean;
        bF11TogglesFullscreen: boolean;
        bUseMouseForTouch: boolean;
        bEnableMouseSmoothing: boolean;
        bEnableFOVScaling: boolean;
        bCaptureMouseOnLaunch: boolean;
        bDefaultViewportMouseLock: boolean;
        bAlwaysShowTouchInterface: boolean;
        bShowConsoleOnFourFingerTap: boolean;
        bEnableGestureRecognizer: boolean;
        bUseAutocorrect: boolean;
        ExcludedAutocorrectOS: TArray<string>;
        ExcludedAutocorrectCultures: TArray<string>;
        ExcludedAutocorrectDeviceModels: TArray<string>;
        DefaultViewportMouseCaptureMode: EMouseCaptureMode;
        DefaultViewportMouseLockMode: EMouseLockMode;
        FOVScale: number;
        DoubleClickTime: number;
        ActionMappings: TArray<InputActionKeyMapping>;
        AxisMappings: TArray<InputAxisKeyMapping>;
        SpeechMappings: TArray<InputActionSpeechMapping>;
        DefaultTouchInterface: SoftObjectPath;
        ConsoleKey: Key;
        ConsoleKeys: TArray<Key>;
        SaveKeyMappings(): void;
        RemoveAxisMapping(KeyMapping: InputAxisKeyMapping, bForceRebuildKeymaps: boolean): void;
        RemoveActionMapping(KeyMapping: InputActionKeyMapping, bForceRebuildKeymaps: boolean): void;
        static GetInputSettings(): InputSettings;
        GetAxisNames(AxisNames: $Ref<TArray<string>>): void;
        GetAxisMappingByName(InAxisName: string, OutMappings: $Ref<TArray<InputAxisKeyMapping>>): void;
        GetActionNames(ActionNames: $Ref<TArray<string>>): void;
        GetActionMappingByName(InActionName: string, OutMappings: $Ref<TArray<InputActionKeyMapping>>): void;
        ForceRebuildKeymaps(): void;
        AddAxisMapping(KeyMapping: InputAxisKeyMapping, bForceRebuildKeymaps: boolean): void;
        AddActionMapping(KeyMapping: InputActionKeyMapping, bForceRebuildKeymaps: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputSettings;
        static Load(InName: string): InputSettings;
    }
    
    class BlueprintInputTouchDelegateBinding extends BlueprintInputDelegateBinding {
        constructor(InputKeyEvent: number, FunctionNameToBind: string);
        InputKeyEvent: number;
        FunctionNameToBind: string;
    }
    
    class InputTouchDelegateBinding extends InputDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputTouchDelegateBindings: TArray<BlueprintInputTouchDelegateBinding>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputTouchDelegateBinding;
        static Load(InName: string): InputTouchDelegateBinding;
    }
    
    class InputVectorAxisDelegateBinding extends InputAxisKeyDelegateBinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InputVectorAxisDelegateBinding;
        static Load(InName: string): InputVectorAxisDelegateBinding;
    }
    
    class Interface_AssetUserData extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_AssetUserData;
        static Load(InName: string): Interface_AssetUserData;
    }
    
    class Interface_CollisionDataProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_CollisionDataProvider;
        static Load(InName: string): Interface_CollisionDataProvider;
    }
    
    class Interface_PostProcessVolume extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_PostProcessVolume;
        static Load(InName: string): Interface_PostProcessVolume;
    }
    
    class Interface_PreviewMeshProvider extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Interface_PreviewMeshProvider;
        static Load(InName: string): Interface_PreviewMeshProvider;
    }
    
    class InterpFilter_Classes extends InterpFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClassToFilterBy: Class;
        TrackClasses: TArray<Class>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpFilter_Classes;
        static Load(InName: string): InterpFilter_Classes;
    }
    
    class InterpFilter_Custom extends InterpFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupsToInclude: TArray<InterpGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpFilter_Custom;
        static Load(InName: string): InterpFilter_Custom;
    }
    
    class CameraPreviewInfo {
        constructor(PawnClass: Class, AnimSeq: AnimSequence, Location: Vector, Rotation: Rotator, PawnInst: Pawn);
        PawnClass: Class;
        AnimSeq: AnimSequence;
        Location: Vector;
        Rotation: Rotator;
        PawnInst: Pawn;
    }
    
    class InterpGroupCamera extends InterpGroup {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraAnimInst: CameraAnim;
        Target: CameraPreviewInfo;
        CompressTolerance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupCamera;
        static Load(InName: string): InterpGroupCamera;
    }
    
    class InterpGroupInstCamera extends InterpGroupInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupInstCamera;
        static Load(InName: string): InterpGroupInstCamera;
    }
    
    class InterpGroupInstDirector extends InterpGroupInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpGroupInstDirector;
        static Load(InName: string): InterpGroupInstDirector;
    }
    
    enum EInterpToBehaviourType { OneShot, OneShot_Reverse, Loop_Reset, PingPong, EInterpToBehaviourType_MAX}
    class InterpControlPoint {
        constructor(PositionControlPoint: Vector, bPositionIsRelative: boolean);
        PositionControlPoint: Vector;
        bPositionIsRelative: boolean;
    }
    
    class InterpToMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Duration: number;
        bPauseOnImpact: boolean;
        bSweep: boolean;
        TeleportType: ETeleportType;
        BehaviourType: EInterpToBehaviourType;
        bCheckIfStillInWorld: boolean;
        bForceSubStepping: boolean;
        OnInterpToReverse: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnInterpToStop: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnWaitBeginDelegate: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnWaitEndDelegate: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        OnResetDelegate: $MulticastDelegate<(ImpactResult: HitResult, Time: number) => void>;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        ControlPoints: TArray<InterpControlPoint>;
        StopSimulating(HitResult: HitResult): void;
        RestartMovement(InitialDirection: number): void;
        OnInterpToWaitEndDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;
        OnInterpToWaitBeginDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;
        OnInterpToStopDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;
        OnInterpToReverseDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;
        OnInterpToResetDelegate__DelegateSignature(ImpactResult: HitResult, Time: number): void;
        FinaliseControlPoints(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpToMovementComponent;
        static Load(InName: string): InterpToMovementComponent;
    }
    
    class InterpTrackFloatBase extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatTrack: InterpCurveFloat;
        CurveTension: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatBase;
        static Load(InName: string): InterpTrackFloatBase;
    }
    
    class AnimControlTrackKey {
        constructor(StartTime: number, AnimSeq: AnimSequence, AnimStartOffset: number, AnimEndOffset: number, AnimPlayRate: number, bLooping: boolean, bReverse: boolean);
        StartTime: number;
        AnimSeq: AnimSequence;
        AnimStartOffset: number;
        AnimEndOffset: number;
        AnimPlayRate: number;
        bLooping: boolean;
        bReverse: boolean;
    }
    
    class InterpTrackAnimControl extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SlotName: string;
        AnimSeqs: TArray<AnimControlTrackKey>;
        bSkipAnimNotifiers: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackAnimControl;
        static Load(InName: string): InterpTrackAnimControl;
    }
    
    class InterpTrackVectorBase extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorTrack: InterpCurveVector;
        CurveTension: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorBase;
        static Load(InName: string): InterpTrackVectorBase;
    }
    
    class InterpTrackAudioMaster extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackAudioMaster;
        static Load(InName: string): InterpTrackAudioMaster;
    }
    
    class BoolTrackKey {
        constructor(Time: number, Value: boolean);
        Time: number;
        Value: boolean;
    }
    
    class InterpTrackBoolProp extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolTrack: TArray<BoolTrackKey>;
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackBoolProp;
        static Load(InName: string): InterpTrackBoolProp;
    }
    
    class InterpTrackColorProp extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackColorProp;
        static Load(InName: string): InterpTrackColorProp;
    }
    
    class InterpTrackColorScale extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackColorScale;
        static Load(InName: string): InterpTrackColorScale;
    }
    
    class DirectorTrackCut {
        constructor(Time: number, TransitionTime: number, TargetCamGroup: string, ShotNumber: number);
        Time: number;
        TransitionTime: number;
        TargetCamGroup: string;
        ShotNumber: number;
    }
    
    class InterpTrackDirector extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CutTrack: TArray<DirectorTrackCut>;
        bSimulateCameraCutsOnClients: boolean;
        PreviewCamera: CameraActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackDirector;
        static Load(InName: string): InterpTrackDirector;
    }
    
    class EventTrackKey {
        constructor(Time: number, EventName: string);
        Time: number;
        EventName: string;
    }
    
    class InterpTrackEvent extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventTrack: TArray<EventTrackKey>;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        bUseCustomEventName: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackEvent;
        static Load(InName: string): InterpTrackEvent;
    }
    
    class InterpTrackFade extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPersistFade: boolean;
        bFadeAudio: boolean;
        FadeColor: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFade;
        static Load(InName: string): InterpTrackFade;
    }
    
    class InterpTrackFloatAnimBPParam extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimBlueprintClass: AnimBlueprintGeneratedClass;
        AnimClass: Class;
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatAnimBPParam;
        static Load(InName: string): InterpTrackFloatAnimBPParam;
    }
    
    class InterpTrackFloatMaterialParam extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetMaterials: TArray<MaterialInterface>;
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatMaterialParam;
        static Load(InName: string): InterpTrackFloatMaterialParam;
    }
    
    class InterpTrackFloatParticleParam extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatParticleParam;
        static Load(InName: string): InterpTrackFloatParticleParam;
    }
    
    class InterpTrackFloatProp extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackFloatProp;
        static Load(InName: string): InterpTrackFloatProp;
    }
    
    class InterpTrackInstAnimControl extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        InitPosition: Vector;
        InitRotation: Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstAnimControl;
        static Load(InName: string): InterpTrackInstAnimControl;
    }
    
    class InterpTrackInstAudioMaster extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstAudioMaster;
        static Load(InName: string): InterpTrackInstAudioMaster;
    }
    
    class InterpTrackInstProperty extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InterpProperty: Property;
        PropertyOuterObjectInst: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstProperty;
        static Load(InName: string): InterpTrackInstProperty;
    }
    
    class InterpTrackInstBoolProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolProperty: BoolProperty;
        ResetBool: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstBoolProp;
        static Load(InName: string): InterpTrackInstBoolProp;
    }
    
    class InterpTrackInstColorProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetColor: Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstColorProp;
        static Load(InName: string): InterpTrackInstColorProp;
    }
    
    class InterpTrackInstColorScale extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstColorScale;
        static Load(InName: string): InterpTrackInstColorScale;
    }
    
    class InterpTrackInstEvent extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstEvent;
        static Load(InName: string): InterpTrackInstEvent;
    }
    
    class InterpTrackInstFade extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFade;
        static Load(InName: string): InterpTrackInstFade;
    }
    
    class InterpTrackInstFloatAnimBPParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimScriptInstance: AnimInstance;
        ResetFloat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatAnimBPParam;
        static Load(InName: string): InterpTrackInstFloatAnimBPParam;
    }
    
    class PrimitiveMaterialRef {
        constructor(Primitive: PrimitiveComponent, Decal: DecalComponent, ElementIndex: number);
        Primitive: PrimitiveComponent;
        Decal: DecalComponent;
        ElementIndex: number;
    }
    
    class InterpTrackInstFloatMaterialParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialInstances: TArray<MaterialInstanceDynamic>;
        ResetFloats: TArray<number>;
        PrimitiveMaterialRefs: TArray<PrimitiveMaterialRef>;
        InstancedTrack: InterpTrackFloatMaterialParam;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatMaterialParam;
        static Load(InName: string): InterpTrackInstFloatMaterialParam;
    }
    
    class InterpTrackInstFloatParticleParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetFloat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatParticleParam;
        static Load(InName: string): InterpTrackInstFloatParticleParam;
    }
    
    class InterpTrackInstFloatProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetFloat: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstFloatProp;
        static Load(InName: string): InterpTrackInstFloatProp;
    }
    
    class InterpTrackInstLinearColorProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetColor: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstLinearColorProp;
        static Load(InName: string): InterpTrackInstLinearColorProp;
    }
    
    class InterpTrackInstParticleReplay extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstParticleReplay;
        static Load(InName: string): InterpTrackInstParticleReplay;
    }
    
    class InterpTrackInstSlomo extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OldTimeDilation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstSlomo;
        static Load(InName: string): InterpTrackInstSlomo;
    }
    
    class InterpTrackInstSound extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LastUpdatePosition: number;
        PlayAudioComp: AudioComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstSound;
        static Load(InName: string): InterpTrackInstSound;
    }
    
    class InterpTrackInstToggle extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: number;
        LastUpdatePosition: number;
        bSavedActiveState: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstToggle;
        static Load(InName: string): InterpTrackInstToggle;
    }
    
    class InterpTrackVectorMaterialParam extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetMaterials: TArray<MaterialInterface>;
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorMaterialParam;
        static Load(InName: string): InterpTrackVectorMaterialParam;
    }
    
    class InterpTrackInstVectorMaterialParam extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialInstances: TArray<MaterialInstanceDynamic>;
        ResetVectors: TArray<Vector>;
        PrimitiveMaterialRefs: TArray<PrimitiveMaterialRef>;
        InstancedTrack: InterpTrackVectorMaterialParam;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVectorMaterialParam;
        static Load(InName: string): InterpTrackInstVectorMaterialParam;
    }
    
    class InterpTrackInstVectorProp extends InterpTrackInstProperty {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResetVector: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVectorProp;
        static Load(InName: string): InterpTrackInstVectorProp;
    }
    
    class InterpTrackInstVisibility extends InterpTrackInst {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: number;
        LastUpdatePosition: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackInstVisibility;
        static Load(InName: string): InterpTrackInstVisibility;
    }
    
    class InterpCurvePointLinearColor {
        constructor(InVal: number, OutVal: LinearColor, ArriveTangent: LinearColor, LeaveTangent: LinearColor, InterpMode: number);
        InVal: number;
        OutVal: LinearColor;
        ArriveTangent: LinearColor;
        LeaveTangent: LinearColor;
        InterpMode: number;
    }
    
    class InterpCurveLinearColor {
        constructor(Points: TArray<InterpCurvePointLinearColor>, bIsLooped: boolean, LoopKeyOffset: number);
        Points: TArray<InterpCurvePointLinearColor>;
        bIsLooped: boolean;
        LoopKeyOffset: number;
    }
    
    class InterpTrackLinearColorBase extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LinearColorTrack: InterpCurveLinearColor;
        CurveTension: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackLinearColorBase;
        static Load(InName: string): InterpTrackLinearColorBase;
    }
    
    class InterpTrackLinearColorProp extends InterpTrackLinearColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackLinearColorProp;
        static Load(InName: string): InterpTrackLinearColorProp;
    }
    
    class InterpTrackMoveAxis extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MoveAxis: number;
        LookupTrack: InterpLookupTrack;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackMoveAxis;
        static Load(InName: string): InterpTrackMoveAxis;
    }
    
    class ParticleReplayTrackKey {
        constructor(Time: number, Duration: number, ClipIDNumber: number);
        Time: number;
        Duration: number;
        ClipIDNumber: number;
    }
    
    class InterpTrackParticleReplay extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackKeys: TArray<ParticleReplayTrackKey>;
        bIsCapturingReplay: boolean;
        FixedTimeStep: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackParticleReplay;
        static Load(InName: string): InterpTrackParticleReplay;
    }
    
    class InterpTrackSlomo extends InterpTrackFloatBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackSlomo;
        static Load(InName: string): InterpTrackSlomo;
    }
    
    class SoundTrackKey {
        constructor(Time: number, Volume: number, Pitch: number, Sound: SoundBase);
        Time: number;
        Volume: number;
        Pitch: number;
        Sound: SoundBase;
    }
    
    class InterpTrackSound extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sounds: TArray<SoundTrackKey>;
        bPlayOnReverse: boolean;
        bContinueSoundOnMatineeEnd: boolean;
        bSuppressSubtitles: boolean;
        bTreatAsDialogue: boolean;
        bAttach: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackSound;
        static Load(InName: string): InterpTrackSound;
    }
    
    class ToggleTrackKey {
        constructor(Time: number, ToggleAction: number);
        Time: number;
        ToggleAction: number;
    }
    
    class InterpTrackToggle extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ToggleTrack: TArray<ToggleTrackKey>;
        bActivateSystemEachUpdate: boolean;
        bActivateWithJustAttachedFlag: boolean;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackToggle;
        static Load(InName: string): InterpTrackToggle;
    }
    
    class InterpTrackVectorProp extends InterpTrackVectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVectorProp;
        static Load(InName: string): InterpTrackVectorProp;
    }
    
    class VisibilityTrackKey {
        constructor(Time: number, Action: number, ActiveCondition: number);
        Time: number;
        Action: number;
        ActiveCondition: number;
    }
    
    class InterpTrackVisibility extends InterpTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VisibilityTrack: TArray<VisibilityTrackKey>;
        bFireEventsWhenForwards: boolean;
        bFireEventsWhenBackwards: boolean;
        bFireEventsWhenJumpingForwards: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InterpTrackVisibility;
        static Load(InName: string): InterpTrackVisibility;
    }
    
    class IntSerialization extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UnsignedInt16Variable: number;
        UnsignedInt32Variable: number;
        UnsignedInt64Variable: bigint;
        SignedInt8Variable: number;
        SignedInt16Variable: number;
        SignedInt64Variable: bigint;
        UnsignedInt8Variable: number;
        SignedInt32Variable: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IntSerialization;
        static Load(InName: string): IntSerialization;
    }
    
    class KillZVolume extends PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KillZVolume;
        static Load(InName: string): KillZVolume;
    }
    
    class KismetArrayLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetArrayPropertyByName(Object: Object, PropertyName: string, Value: TArray<number>): void;
        static FilterArray(TargetArray: TArray<Actor>, FilterClass: Class, FilteredArray: $Ref<TArray<Actor>>): void;
        static Array_Swap(TargetArray: TArray<number>, FirstIndex: number, SecondIndex: number): void;
        static Array_Shuffle(TargetArray: TArray<number>): void;
        static Array_Set(TargetArray: TArray<number>, Index: number, Item: number, bSizeToFit: boolean): void;
        static Array_Resize(TargetArray: TArray<number>, Size: number): void;
        static Array_RemoveItem(TargetArray: TArray<number>, Item: number): boolean;
        static Array_Remove(TargetArray: TArray<number>, IndexToRemove: number): void;
        static Array_Length(TargetArray: TArray<number>): number;
        static Array_LastIndex(TargetArray: TArray<number>): number;
        static Array_IsValidIndex(TargetArray: TArray<number>, IndexToTest: number): boolean;
        static Array_Insert(TargetArray: TArray<number>, NewItem: number, Index: number): void;
        static Array_Identical(ArrayA: TArray<number>, ArrayB: TArray<number>): boolean;
        static Array_Get(TargetArray: TArray<number>, Index: number, Item: $Ref<number>): void;
        static Array_Find(TargetArray: TArray<number>, ItemToFind: number): number;
        static Array_Contains(TargetArray: TArray<number>, ItemToFind: number): boolean;
        static Array_Clear(TargetArray: TArray<number>): void;
        static Array_Append(TargetArray: TArray<number>, SourceArray: TArray<number>): void;
        static Array_AddUnique(TargetArray: TArray<number>, NewItem: number): number;
        static Array_Add(TargetArray: TArray<number>, NewItem: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetArrayLibrary;
        static Load(InName: string): KismetArrayLibrary;
    }
    
    class KismetGuidLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Parse_StringToGuid(GuidString: string, OutGuid: $Ref<Guid>, Success: $Ref<boolean>): void;
        static NotEqual_GuidGuid(A: Guid, B: Guid): boolean;
        static NewGuid(): Guid;
        static IsValid_Guid(InGuid: Guid): boolean;
        static Invalidate_Guid(InGuid: $Ref<Guid>): void;
        static EqualEqual_GuidGuid(A: Guid, B: Guid): boolean;
        static Conv_GuidToString(InGuid: Guid): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetGuidLibrary;
        static Load(InName: string): KismetGuidLibrary;
    }
    
    enum ESlateGesture { None, Scroll, Magnify, Swipe, Rotate, LongPress, ESlateGesture_MAX}
    enum EUINavigationAction { Accept, Back, Num, Invalid, EUINavigationAction_MAX}
    class KismetInputLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static PointerEvent_IsTouchEvent(Input: PointerEvent): boolean;
        static PointerEvent_IsMouseButtonDown(Input: PointerEvent, MouseButton: Key): boolean;
        static PointerEvent_GetWheelDelta(Input: PointerEvent): number;
        static PointerEvent_GetUserIndex(Input: PointerEvent): number;
        static PointerEvent_GetTouchpadIndex(Input: PointerEvent): number;
        static PointerEvent_GetScreenSpacePosition(Input: PointerEvent): Vector2D;
        static PointerEvent_GetPointerIndex(Input: PointerEvent): number;
        static PointerEvent_GetLastScreenSpacePosition(Input: PointerEvent): Vector2D;
        static PointerEvent_GetGestureType(Input: PointerEvent): ESlateGesture;
        static PointerEvent_GetGestureDelta(Input: PointerEvent): Vector2D;
        static PointerEvent_GetEffectingButton(Input: PointerEvent): Key;
        static PointerEvent_GetCursorDelta(Input: PointerEvent): Vector2D;
        static Key_IsVectorAxis(Key: Key): boolean;
        static Key_IsValid(Key: Key): boolean;
        static Key_IsMouseButton(Key: Key): boolean;
        static Key_IsModifierKey(Key: Key): boolean;
        static Key_IsKeyboardKey(Key: Key): boolean;
        static Key_IsGamepadKey(Key: Key): boolean;
        static Key_IsFloatAxis(Key: Key): boolean;
        static Key_GetNavigationDirectionFromKey(InKeyEvent: KeyEvent): EUINavigation;
        static Key_GetNavigationDirectionFromAnalog(InAnalogEvent: AnalogInputEvent): EUINavigation;
        static Key_GetNavigationActionFromKey(InKeyEvent: KeyEvent): EUINavigationAction;
        static Key_GetNavigationAction(InKey: Key): EUINavigationAction;
        static Key_GetDisplayName(Key: Key): string;
        static InputEvent_IsShiftDown(Input: InputEvent): boolean;
        static InputEvent_IsRightShiftDown(Input: InputEvent): boolean;
        static InputEvent_IsRightControlDown(Input: InputEvent): boolean;
        static InputEvent_IsRightCommandDown(Input: InputEvent): boolean;
        static InputEvent_IsRightAltDown(Input: InputEvent): boolean;
        static InputEvent_IsRepeat(Input: InputEvent): boolean;
        static InputEvent_IsLeftShiftDown(Input: InputEvent): boolean;
        static InputEvent_IsLeftControlDown(Input: InputEvent): boolean;
        static InputEvent_IsLeftCommandDown(Input: InputEvent): boolean;
        static InputEvent_IsLeftAltDown(Input: InputEvent): boolean;
        static InputEvent_IsControlDown(Input: InputEvent): boolean;
        static InputEvent_IsCommandDown(Input: InputEvent): boolean;
        static InputEvent_IsAltDown(Input: InputEvent): boolean;
        static InputChord_GetDisplayName(Key: InputChord): string;
        static GetUserIndex(Input: KeyEvent): number;
        static GetKey(Input: KeyEvent): Key;
        static GetAnalogValue(Input: AnalogInputEvent): number;
        static EqualEqual_KeyKey(A: Key, B: Key): boolean;
        static EqualEqual_InputChordInputChord(A: InputChord, B: InputChord): boolean;
        static CalibrateTilt(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetInputLibrary;
        static Load(InName: string): KismetInputLibrary;
    }
    
    enum ELocalizedTextSourceCategory { Game, Engine, Editor, ELocalizedTextSourceCategory_MAX}
    class KismetInternationalizationLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetCurrentLocale(Culture: string, SaveToConfig: boolean): boolean;
        static SetCurrentLanguageAndLocale(Culture: string, SaveToConfig: boolean): boolean;
        static SetCurrentLanguage(Culture: string, SaveToConfig: boolean): boolean;
        static SetCurrentCulture(Culture: string, SaveToConfig: boolean): boolean;
        static SetCurrentAssetGroupCulture(AssetGroup: string, Culture: string, SaveToConfig: boolean): boolean;
        static GetSuitableCulture(AvailableCultures: TArray<string>, CultureToMatch: string, FallbackCulture: string): string;
        static GetNativeCulture(TextCategory: ELocalizedTextSourceCategory): string;
        static GetLocalizedCultures(IncludeGame: boolean, IncludeEngine: boolean, IncludeEditor: boolean, IncludeAdditional: boolean): TArray<string>;
        static GetCurrentLocale(): string;
        static GetCurrentLanguage(): string;
        static GetCurrentCulture(): string;
        static GetCurrentAssetGroupCulture(AssetGroup: string): string;
        static GetCultureDisplayName(Culture: string, Localized: boolean): string;
        static ClearCurrentAssetGroupCulture(AssetGroup: string, SaveToConfig: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetInternationalizationLibrary;
        static Load(InName: string): KismetInternationalizationLibrary;
    }
    
    class KismetMaterialLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetVectorParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: string, ParameterValue: LinearColor): void;
        static SetScalarParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: string, ParameterValue: number): void;
        static GetVectorParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: string): LinearColor;
        static GetScalarParameterValue(WorldContextObject: Object, Collection: MaterialParameterCollection, ParameterName: string): number;
        static CreateDynamicMaterialInstance(WorldContextObject: Object, Parent: MaterialInterface, OptionalName: string): MaterialInstanceDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetMaterialLibrary;
        static Load(InName: string): KismetMaterialLibrary;
    }
    
    class VectorSpringState {
        constructor();
    }
    
    class Timespan {
        constructor();
    }
    
    class RandomStream {
        constructor(InitialSeed: number, Seed: number);
        InitialSeed: number;
        Seed: number;
    }
    
    class FloatSpringState {
        constructor();
    }
    
    class KismetMathLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Xor_IntInt(A: number, B: number): number;
        static Xor_Int64Int64(A: bigint, B: bigint): bigint;
        static WeightedMovingAverage_FVector(CurrentSample: Vector, PreviousSample: Vector, Weight: number): Vector;
        static WeightedMovingAverage_FRotator(CurrentSample: Rotator, PreviousSample: Rotator, Weight: number): Rotator;
        static WeightedMovingAverage_Float(CurrentSample: number, PreviousSample: number, Weight: number): number;
        static VSizeXYSquared(A: Vector): number;
        static VSizeXY(A: Vector): number;
        static VSizeSquared(A: Vector): number;
        static VSize2DSquared(A: Vector2D): number;
        static VSize2D(A: Vector2D): number;
        static VSize(A: Vector): number;
        static VLerp(A: Vector, B: Vector, Alpha: number): Vector;
        static VInterpTo_Constant(Current: Vector, Target: Vector, DeltaTime: number, InterpSpeed: number): Vector;
        static VInterpTo(Current: Vector, Target: Vector, DeltaTime: number, InterpSpeed: number): Vector;
        static VectorSpringInterp(Current: Vector, Target: Vector, SpringState: $Ref<VectorSpringState>, Stiffness: number, CriticalDampingFactor: number, DeltaTime: number, Mass: number): Vector;
        static Vector_Zero(): Vector;
        static Vector_Up(): Vector;
        static Vector_UnwindEuler(A: $Ref<Vector>): void;
        static Vector_UnitCartesianToSpherical(A: Vector): Vector2D;
        static Vector_ToRadians(A: Vector): Vector;
        static Vector_ToDegrees(A: Vector): Vector;
        static Vector_SnappedToGrid(InVect: Vector, InGridSize: number): Vector;
        static Vector_Set(A: $Ref<Vector>, X: number, Y: number, Z: number): void;
        static Vector_Right(): Vector;
        static Vector_Reciprocal(A: Vector): Vector;
        static Vector_ProjectOnToNormal(V: Vector, InNormal: Vector): Vector;
        static Vector_One(): Vector;
        static Vector_NormalUnsafe(A: Vector): Vector;
        static Vector_Normalize(A: $Ref<Vector>, Tolerance: number): void;
        static Vector_Normal2D(A: Vector, Tolerance: number): Vector;
        static Vector_MirrorByPlane(A: Vector, InPlane: Plane): Vector;
        static Vector_Left(): Vector;
        static Vector_IsZero(A: Vector): boolean;
        static Vector_IsUnit(A: Vector, SquaredLenthTolerance: number): boolean;
        static Vector_IsUniform(A: Vector, Tolerance: number): boolean;
        static Vector_IsNormal(A: Vector): boolean;
        static Vector_IsNearlyZero(A: Vector, Tolerance: number): boolean;
        static Vector_IsNAN(A: Vector): boolean;
        static Vector_HeadingAngle(A: Vector): number;
        static Vector_GetSignVector(A: Vector): Vector;
        static Vector_GetProjection(A: Vector): Vector;
        static Vector_GetAbsMin(A: Vector): number;
        static Vector_GetAbsMax(A: Vector): number;
        static Vector_GetAbs(A: Vector): Vector;
        static Vector_Forward(): Vector;
        static Vector_Down(): Vector;
        static Vector_DistanceSquared(V1: Vector, V2: Vector): number;
        static Vector_Distance2DSquared(V1: Vector, V2: Vector): number;
        static Vector_Distance2D(V1: Vector, V2: Vector): number;
        static Vector_Distance(V1: Vector, V2: Vector): number;
        static Vector_CosineAngle2D(A: Vector, B: Vector): number;
        static Vector_ComponentMin(A: Vector, B: Vector): Vector;
        static Vector_ComponentMax(A: Vector, B: Vector): Vector;
        static Vector_ClampSizeMax2D(A: Vector, Max: number): Vector;
        static Vector_ClampSizeMax(A: Vector, Max: number): Vector;
        static Vector_ClampSize2D(A: Vector, Min: number, Max: number): Vector;
        static Vector_BoundedToCube(InVect: Vector, InRadius: number): Vector;
        static Vector_BoundedToBox(InVect: Vector, InBoxMin: Vector, InBoxMax: Vector): Vector;
        static Vector_Backward(): Vector;
        static Vector_Assign(A: $Ref<Vector>, InVector: Vector): void;
        static Vector_AddBounded(A: $Ref<Vector>, InAddVect: Vector, InRadius: number): void;
        static Vector4_Zero(): Vector4;
        static Vector4_SizeSquared3(A: Vector4): number;
        static Vector4_SizeSquared(A: Vector4): number;
        static Vector4_Size3(A: Vector4): number;
        static Vector4_Size(A: Vector4): number;
        static Vector4_Set(A: $Ref<Vector4>, X: number, Y: number, Z: number, W: number): void;
        static Vector4_NormalUnsafe3(A: Vector4): Vector4;
        static Vector4_Normalize3(A: $Ref<Vector4>, Tolerance: number): void;
        static Vector4_Normal3(A: Vector4, Tolerance: number): Vector4;
        static Vector4_Negated(A: Vector4): Vector4;
        static Vector4_MirrorByVector3(Direction: Vector4, SurfaceNormal: Vector4): Vector4;
        static Vector4_IsZero(A: Vector4): boolean;
        static Vector4_IsUnit3(A: Vector4, SquaredLenthTolerance: number): boolean;
        static Vector4_IsNormal3(A: Vector4): boolean;
        static Vector4_IsNearlyZero3(A: Vector4, Tolerance: number): boolean;
        static Vector4_IsNAN(A: Vector4): boolean;
        static Vector4_DotProduct3(A: Vector4, B: Vector4): number;
        static Vector4_DotProduct(A: Vector4, B: Vector4): number;
        static Vector4_CrossProduct3(A: Vector4, B: Vector4): Vector4;
        static Vector4_Assign(A: $Ref<Vector4>, InVector: Vector4): void;
        static Vector2DInterpTo_Constant(Current: Vector2D, Target: Vector2D, DeltaTime: number, InterpSpeed: number): Vector2D;
        static Vector2DInterpTo(Current: Vector2D, Target: Vector2D, DeltaTime: number, InterpSpeed: number): Vector2D;
        static Vector2D_Zero(): Vector2D;
        static Vector2D_Unit45Deg(): Vector2D;
        static Vector2D_One(): Vector2D;
        static VEase(A: Vector, B: Vector, Alpha: number, EasingFunc: number, BlendExp: number, Steps: number): Vector;
        static UtcNow(): DateTime;
        static TransformRotation(T: Transform, Rotation: Rotator): Rotator;
        static TransformLocation(T: Transform, Location: Vector): Vector;
        static TransformDirection(T: Transform, Direction: Vector): Vector;
        static Transform_Determinant(Transform: Transform): number;
        static ToSign2D(A: Vector2D): Vector2D;
        static ToRounded2D(A: Vector2D): Vector2D;
        static ToDirectionAndLength2D(A: Vector2D, OutDir: $Ref<Vector2D>, OutLength: $Ref<number>): void;
        static Today(): DateTime;
        static TLerp(A: Transform, B: Transform, Alpha: number, InterpMode: number): Transform;
        static TInterpTo(Current: Transform, Target: Transform, DeltaTime: number, InterpSpeed: number): Transform;
        static TimespanZeroValue(): Timespan;
        static TimespanRatio(A: Timespan, B: Timespan): number;
        static TimespanMinValue(): Timespan;
        static TimespanMaxValue(): Timespan;
        static TimespanFromString(TimespanString: string, Result: $Ref<Timespan>): boolean;
        static TEase(A: Transform, B: Transform, Alpha: number, EasingFunc: number, BlendExp: number, Steps: number): Transform;
        static Tan(A: number): number;
        static Subtract_VectorVector(A: Vector, B: Vector): Vector;
        static Subtract_VectorInt(A: Vector, B: number): Vector;
        static Subtract_VectorFloat(A: Vector, B: number): Vector;
        static Subtract_Vector4Vector4(A: Vector4, B: Vector4): Vector4;
        static Subtract_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;
        static Subtract_Vector2DFloat(A: Vector2D, B: number): Vector2D;
        static Subtract_TimespanTimespan(A: Timespan, B: Timespan): Timespan;
        static Subtract_QuatQuat(A: Quat, B: Quat): Quat;
        static Subtract_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;
        static Subtract_IntInt(A: number, B: number): number;
        static Subtract_Int64Int64(A: bigint, B: bigint): bigint;
        static Subtract_FloatFloat(A: number, B: number): number;
        static Subtract_DateTimeTimespan(A: DateTime, B: Timespan): DateTime;
        static Subtract_DateTimeDateTime(A: DateTime, B: DateTime): Timespan;
        static Subtract_ByteByte(A: number, B: number): number;
        static Square(A: number): number;
        static Sqrt(A: number): number;
        static Spherical2DToUnitCartesian(A: Vector2D): Vector;
        static Sin(A: number): number;
        static SignOfInteger64(A: bigint): bigint;
        static SignOfInteger(A: number): number;
        static SignOfFloat(A: number): number;
        static SetRandomStreamSeed(Stream: $Ref<RandomStream>, NewSeed: number): void;
        static Set2D(A: $Ref<Vector2D>, X: number, Y: number): void;
        static SelectVector(A: Vector, B: Vector, bPickA: boolean): Vector;
        static SelectTransform(A: Transform, B: Transform, bPickA: boolean): Transform;
        static SelectString(A: string, B: string, bPickA: boolean): string;
        static SelectRotator(A: Rotator, B: Rotator, bPickA: boolean): Rotator;
        static SelectObject(A: Object, B: Object, bSelectA: boolean): Object;
        static SelectInt(A: number, B: number, bPickA: boolean): number;
        static SelectFloat(A: number, B: number, bPickA: boolean): number;
        static SelectColor(A: LinearColor, B: LinearColor, bPickA: boolean): LinearColor;
        static SelectClass(A: Class, B: Class, bSelectA: boolean): Class;
        static SeedRandomStream(Stream: $Ref<RandomStream>): void;
        static SafeDivide(A: number, B: number): number;
        static Round64(A: number): bigint;
        static Round(A: number): number;
        static RotatorFromAxisAndAngle(Axis: Vector, Angle: number): Rotator;
        static RotateAngleAxis(InVect: Vector, AngleDeg: number, Axis: Vector): Vector;
        static RLerp(A: Rotator, B: Rotator, Alpha: number, bShortestPath: boolean): Rotator;
        static RInterpTo_Constant(Current: Rotator, Target: Rotator, DeltaTime: number, InterpSpeed: number): Rotator;
        static RInterpTo(Current: Rotator, Target: Rotator, DeltaTime: number, InterpSpeed: number): Rotator;
        static RGBToHSV_Vector(RGB: LinearColor, HSV: $Ref<LinearColor>): void;
        static RGBToHSV(InColor: LinearColor, H: $Ref<number>, S: $Ref<number>, V: $Ref<number>, A: $Ref<number>): void;
        static RGBLinearToHSV(RGB: LinearColor): LinearColor;
        static ResetVectorSpringState(SpringState: $Ref<VectorSpringState>): void;
        static ResetRandomStream(Stream: RandomStream): void;
        static ResetFloatSpringState(SpringState: $Ref<FloatSpringState>): void;
        static REase(A: Rotator, B: Rotator, Alpha: number, bShortestPath: boolean, EasingFunc: number, BlendExp: number, Steps: number): Rotator;
        static RandomUnitVectorInEllipticalConeInRadiansFromStream(ConeDir: Vector, MaxYawInRadians: number, MaxPitchInRadians: number, Stream: RandomStream): Vector;
        static RandomUnitVectorInEllipticalConeInRadians(ConeDir: Vector, MaxYawInRadians: number, MaxPitchInRadians: number): Vector;
        static RandomUnitVectorInEllipticalConeInDegreesFromStream(ConeDir: Vector, MaxYawInDegrees: number, MaxPitchInDegrees: number, Stream: RandomStream): Vector;
        static RandomUnitVectorInEllipticalConeInDegrees(ConeDir: Vector, MaxYawInDegrees: number, MaxPitchInDegrees: number): Vector;
        static RandomUnitVectorInConeInRadiansFromStream(ConeDir: Vector, ConeHalfAngleInRadians: number, Stream: RandomStream): Vector;
        static RandomUnitVectorInConeInRadians(ConeDir: Vector, ConeHalfAngleInRadians: number): Vector;
        static RandomUnitVectorInConeInDegreesFromStream(ConeDir: Vector, ConeHalfAngleInDegrees: number, Stream: RandomStream): Vector;
        static RandomUnitVectorInConeInDegrees(ConeDir: Vector, ConeHalfAngleInDegrees: number): Vector;
        static RandomUnitVectorFromStream(Stream: RandomStream): Vector;
        static RandomUnitVector(): Vector;
        static RandomRotatorFromStream(bRoll: boolean, Stream: RandomStream): Rotator;
        static RandomRotator(bRoll: boolean): Rotator;
        static RandomPointInBoundingBox(Origin: Vector, BoxExtent: Vector): Vector;
        static RandomIntegerInRangeFromStream(Min: number, Max: number, Stream: RandomStream): number;
        static RandomIntegerInRange(Min: number, Max: number): number;
        static RandomIntegerFromStream(Max: number, Stream: RandomStream): number;
        static RandomInteger64InRange(Min: bigint, Max: bigint): bigint;
        static RandomInteger64(Max: bigint): bigint;
        static RandomInteger(Max: number): number;
        static RandomFloatInRangeFromStream(Min: number, Max: number, Stream: RandomStream): number;
        static RandomFloatInRange(Min: number, Max: number): number;
        static RandomFloatFromStream(Stream: RandomStream): number;
        static RandomFloat(): number;
        static RandomBoolWithWeightFromStream(Weight: number, RandomStream: RandomStream): boolean;
        static RandomBoolWithWeight(Weight: number): boolean;
        static RandomBoolFromStream(Stream: RandomStream): boolean;
        static RandomBool(): boolean;
        static RadiansToDegrees(A: number): number;
        static Quat_VectorUp(Q: Quat): Vector;
        static Quat_VectorRight(Q: Quat): Vector;
        static Quat_VectorForward(Q: Quat): Vector;
        static Quat_UnrotateVector(Q: Quat, V: Vector): Vector;
        static Quat_SizeSquared(Q: Quat): number;
        static Quat_Size(Q: Quat): number;
        static Quat_SetFromEuler(Q: $Ref<Quat>, Euler: Vector): void;
        static Quat_SetComponents(Q: $Ref<Quat>, X: number, Y: number, Z: number, W: number): void;
        static Quat_Rotator(Q: Quat): Rotator;
        static Quat_RotateVector(Q: Quat, V: Vector): Vector;
        static Quat_Normalized(Q: Quat, Tolerance: number): Quat;
        static Quat_Normalize(Q: $Ref<Quat>, Tolerance: number): void;
        static Quat_MakeFromEuler(Euler: Vector): Quat;
        static Quat_Log(Q: Quat): Quat;
        static Quat_IsNormalized(Q: Quat): boolean;
        static Quat_IsNonFinite(Q: Quat): boolean;
        static Quat_IsIdentity(Q: Quat, Tolerance: number): boolean;
        static Quat_IsFinite(Q: Quat): boolean;
        static Quat_Inversed(Q: Quat): Quat;
        static Quat_Identity(): Quat;
        static Quat_GetRotationAxis(Q: Quat): Vector;
        static Quat_GetAxisZ(Q: Quat): Vector;
        static Quat_GetAxisY(Q: Quat): Vector;
        static Quat_GetAxisX(Q: Quat): Vector;
        static Quat_GetAngle(Q: Quat): number;
        static Quat_Exp(Q: Quat): Quat;
        static Quat_Euler(Q: Quat): Vector;
        static Quat_EnforceShortestArcWith(A: $Ref<Quat>, B: Quat): void;
        static Quat_AngularDistance(A: Quat, B: Quat): number;
        static ProjectVectorOnToVector(V: Vector, Target: Vector): Vector;
        static ProjectVectorOnToPlane(V: Vector, PlaneNormal: Vector): Vector;
        static ProjectPointOnToPlane(Point: Vector, PlaneBase: Vector, PlaneNormal: Vector): Vector;
        static PointsAreCoplanar(Points: TArray<Vector>, Tolerance: number): boolean;
        static PerlinNoise1D(Value: number): number;
        static Percent_IntInt(A: number, B: number): number;
        static Percent_FloatFloat(A: number, B: number): number;
        static Percent_ByteByte(A: number, B: number): number;
        static Or_IntInt(A: number, B: number): number;
        static Or_Int64Int64(A: bigint, B: bigint): bigint;
        static Now(): DateTime;
        static NotEqualExactly_VectorVector(A: Vector, B: Vector): boolean;
        static NotEqualExactly_Vector4Vector4(A: Vector4, B: Vector4): boolean;
        static NotEqualExactly_Vector2DVector2D(A: Vector2D, B: Vector2D): boolean;
        static NotEqual_VectorVector(A: Vector, B: Vector, ErrorTolerance: number): boolean;
        static NotEqual_Vector4Vector4(A: Vector4, B: Vector4, ErrorTolerance: number): boolean;
        static NotEqual_Vector2DVector2D(A: Vector2D, B: Vector2D, ErrorTolerance: number): boolean;
        static NotEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;
        static NotEqual_RotatorRotator(A: Rotator, B: Rotator, ErrorTolerance: number): boolean;
        static NotEqual_QuatQuat(A: Quat, B: Quat, ErrorTolerance: number): boolean;
        static NotEqual_ObjectObject(A: Object, B: Object): boolean;
        static NotEqual_NameName(A: string, B: string): boolean;
        static NotEqual_MatrixMatrix(A: Matrix, B: Matrix, Tolerance: number): boolean;
        static NotEqual_LinearColorLinearColor(A: LinearColor, B: LinearColor): boolean;
        static NotEqual_IntInt(A: number, B: number): boolean;
        static NotEqual_Int64Int64(A: bigint, B: bigint): boolean;
        static NotEqual_FloatFloat(A: number, B: number): boolean;
        static NotEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;
        static NotEqual_ClassClass(A: Class, B: Class): boolean;
        static NotEqual_ByteByte(A: number, B: number): boolean;
        static NotEqual_BoolBool(A: boolean, B: boolean): boolean;
        static Not_PreBool(A: boolean): boolean;
        static Not_Int64(A: bigint): bigint;
        static Not_Int(A: number): number;
        static NormalSafe2D(A: Vector2D, Tolerance: number): Vector2D;
        static NormalizeToRange(Value: number, RangeMin: number, RangeMax: number): number;
        static NormalizedDeltaRotator(A: Rotator, B: Rotator): Rotator;
        static NormalizeAxis(Angle: number): number;
        static Normalize2D(A: $Ref<Vector2D>, Tolerance: number): void;
        static Normal2D(A: Vector2D): Vector2D;
        static Normal(A: Vector, Tolerance: number): Vector;
        static NegateVector(A: Vector): Vector;
        static NegateRotator(A: Rotator): Rotator;
        static Negated2D(A: Vector2D): Vector2D;
        static NearlyEqual_TransformTransform(A: Transform, B: Transform, LocationTolerance: number, RotationTolerance: number, Scale3DTolerance: number): boolean;
        static NearlyEqual_FloatFloat(A: number, B: number, ErrorTolerance: number): boolean;
        static MultiplyMultiply_FloatFloat(Base: number, Exp: number): number;
        static MultiplyByPi(Value: number): number;
        static Multiply_VectorVector(A: Vector, B: Vector): Vector;
        static Multiply_VectorInt(A: Vector, B: number): Vector;
        static Multiply_VectorFloat(A: Vector, B: number): Vector;
        static Multiply_Vector4Vector4(A: Vector4, B: Vector4): Vector4;
        static Multiply_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;
        static Multiply_Vector2DFloat(A: Vector2D, B: number): Vector2D;
        static Multiply_TimespanFloat(A: Timespan, Scalar: number): Timespan;
        static Multiply_RotatorInt(A: Rotator, B: number): Rotator;
        static Multiply_RotatorFloat(A: Rotator, B: number): Rotator;
        static Multiply_QuatQuat(A: Quat, B: Quat): Quat;
        static Multiply_MatrixMatrix(A: Matrix, B: Matrix): Matrix;
        static Multiply_MatrixFloat(A: Matrix, B: number): Matrix;
        static Multiply_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;
        static Multiply_LinearColorFloat(A: LinearColor, B: number): LinearColor;
        static Multiply_IntInt(A: number, B: number): number;
        static Multiply_IntFloat(A: number, B: number): number;
        static Multiply_Int64Int64(A: bigint, B: bigint): bigint;
        static Multiply_FloatFloat(A: number, B: number): number;
        static Multiply_ByteByte(A: number, B: number): number;
        static MirrorVectorByNormal(InVect: Vector, InNormal: Vector): Vector;
        static MinOfIntArray(IntArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>): void;
        static MinOfFloatArray(FloatArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>): void;
        static MinOfByteArray(ByteArray: TArray<number>, IndexOfMinValue: $Ref<number>, MinValue: $Ref<number>): void;
        static MinInt64(A: bigint, B: bigint): bigint;
        static MinimumAreaRectangle(WorldContextObject: Object, InVerts: TArray<Vector>, SampleSurfaceNormal: Vector, OutRectCenter: $Ref<Vector>, OutRectRotation: $Ref<Rotator>, OutSideLengthX: $Ref<number>, OutSideLengthY: $Ref<number>, bDebugDraw: boolean): void;
        static Min(A: number, B: number): number;
        static MaxOfIntArray(IntArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>): void;
        static MaxOfFloatArray(FloatArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>): void;
        static MaxOfByteArray(ByteArray: TArray<number>, IndexOfMaxValue: $Ref<number>, MaxValue: $Ref<number>): void;
        static MaxInt64(A: bigint, B: bigint): bigint;
        static Max(A: number, B: number): number;
        static Matrix_TransformVector4(M: Matrix, V: Vector4): Vector4;
        static Matrix_TransformVector(M: Matrix, V: Vector): Vector4;
        static Matrix_TransformPosition(M: Matrix, V: Vector): Vector4;
        static Matrix_ToQuat(M: Matrix): Quat;
        static Matrix_SetOrigin(M: $Ref<Matrix>, NewOrigin: Vector): void;
        static Matrix_SetColumn(M: $Ref<Matrix>, Column: number, Value: Vector): void;
        static Matrix_SetAxis(M: $Ref<Matrix>, Axis: number, AxisVector: Vector): void;
        static Matrix_ScaleTranslation(M: Matrix, Scale3D: Vector): Matrix;
        static Matrix_RemoveTranslation(M: Matrix): Matrix;
        static Matrix_RemoveScaling(M: $Ref<Matrix>, Tolerance: number): void;
        static Matrix_Mirror(M: Matrix, MirrorAxis: number, FlipAxis: number): Matrix;
        static Matrix_InverseTransformVector(M: Matrix, V: Vector): Vector;
        static Matrix_InverseTransformPosition(M: Matrix, V: Vector): Vector;
        static Matrix_Identity(): Matrix;
        static Matrix_GetUnitAxis(M: Matrix, Axis: number): Vector;
        static Matrix_GetUnitAxes(M: Matrix, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;
        static Matrix_GetTransposed(M: Matrix): Matrix;
        static Matrix_GetTransposeAdjoint(M: Matrix): Matrix;
        static Matrix_GetScaleVector(M: Matrix, Tolerance: number): Vector;
        static Matrix_GetScaledAxis(M: Matrix, Axis: number): Vector;
        static Matrix_GetScaledAxes(M: Matrix, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;
        static Matrix_GetRotDeterminant(M: Matrix): number;
        static Matrix_GetRotator(M: Matrix): Rotator;
        static Matrix_GetOrigin(InMatrix: Matrix): Vector;
        static Matrix_GetMaximumAxisScale(M: Matrix): number;
        static Matrix_GetMatrixWithoutScale(M: Matrix, Tolerance: number): Matrix;
        static Matrix_GetInverse(M: Matrix): Matrix;
        static Matrix_GetFrustumTopPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;
        static Matrix_GetFrustumRightPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;
        static Matrix_GetFrustumNearPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;
        static Matrix_GetFrustumLeftPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;
        static Matrix_GetFrustumFarPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;
        static Matrix_GetFrustumBottomPlane(M: Matrix, OutPlane: $Ref<Plane>): boolean;
        static Matrix_GetDeterminant(M: Matrix): number;
        static Matrix_GetColumn(M: Matrix, Column: number): Vector;
        static Matrix_ContainsNaN(M: Matrix): boolean;
        static Matrix_ConcatenateTranslation(M: Matrix, Translation: Vector): Matrix;
        static Matrix_ApplyScale(M: Matrix, Scale: number): Matrix;
        static MapRangeUnclamped(Value: number, InRangeA: number, InRangeB: number, OutRangeA: number, OutRangeB: number): number;
        static MapRangeClamped(Value: number, InRangeA: number, InRangeB: number, OutRangeA: number, OutRangeB: number): number;
        static MakeVector4(X: number, Y: number, Z: number, W: number): Vector4;
        static MakeVector2D(X: number, Y: number): Vector2D;
        static MakeVector(X: number, Y: number, Z: number): Vector;
        static MakeTransform(Location: Vector, Rotation: Rotator, Scale: Vector): Transform;
        static MakeTimespan2(Days: number, Hours: number, Minutes: number, Seconds: number, FractionNano: number): Timespan;
        static MakeTimespan(Days: number, Hours: number, Minutes: number, Seconds: number, Milliseconds: number): Timespan;
        static MakeRotFromZY(Z: Vector, Y: Vector): Rotator;
        static MakeRotFromZX(Z: Vector, X: Vector): Rotator;
        static MakeRotFromZ(Z: Vector): Rotator;
        static MakeRotFromYZ(Y: Vector, Z: Vector): Rotator;
        static MakeRotFromYX(Y: Vector, X: Vector): Rotator;
        static MakeRotFromY(Y: Vector): Rotator;
        static MakeRotFromXZ(X: Vector, Z: Vector): Rotator;
        static MakeRotFromXY(X: Vector, Y: Vector): Rotator;
        static MakeRotFromX(X: Vector): Rotator;
        static MakeRotator(Roll: number, Pitch: number, Yaw: number): Rotator;
        static MakeRotationFromAxes(Forward: Vector, Right: Vector, Up: Vector): Rotator;
        static MakeRelativeTransform(A: Transform, RelativeTo: Transform): Transform;
        static MakeRandomStream(InitialSeed: number): RandomStream;
        static MakeQualifiedFrameTime(Frame: FrameNumber, FrameRate: FrameRate, SubFrame: number): QualifiedFrameTime;
        static MakePulsatingValue(InCurrentTime: number, InPulsesPerSecond: number, InPhase: number): number;
        static MakePlaneFromPointAndNormal(Point: Vector, Normal: Vector): Plane;
        static MakeFrameRate(Numerator: number, Denominator: number): FrameRate;
        static MakeDateTime(Year: number, Month: number, Day: number, Hour: number, Minute: number, Second: number, Millisecond: number): DateTime;
        static MakeColor(R: number, G: number, B: number, A: number): LinearColor;
        static MakeBox2D(Min: Vector2D, Max: Vector2D): Box2D;
        static MakeBox(Min: Vector, Max: Vector): Box;
        static Loge(A: number): number;
        static Log(A: number, Base: number): number;
        static LinePlaneIntersection_OriginNormal(LineStart: Vector, LineEnd: Vector, PlaneOrigin: Vector, PlaneNormal: Vector, T: $Ref<number>, Intersection: $Ref<Vector>): boolean;
        static LinePlaneIntersection(LineStart: Vector, LineEnd: Vector, APlane: Plane, T: $Ref<number>, Intersection: $Ref<Vector>): boolean;
        static LinearColorLerpUsingHSV(A: LinearColor, B: LinearColor, Alpha: number): LinearColor;
        static LinearColorLerp(A: LinearColor, B: LinearColor, Alpha: number): LinearColor;
        static LinearColor_Yellow(): LinearColor;
        static LinearColor_White(): LinearColor;
        static LinearColor_Transparent(): LinearColor;
        static LinearColor_ToRGBE(InLinearColor: LinearColor): Color;
        static LinearColor_ToNewOpacity(InColor: LinearColor, InOpacity: number): LinearColor;
        static LinearColor_SetTemperature(InOutColor: $Ref<LinearColor>, InTemperature: number): void;
        static LinearColor_SetRGBA(InOutColor: $Ref<LinearColor>, R: number, G: number, B: number, A: number): void;
        static LinearColor_SetRandomHue(InOutColor: $Ref<LinearColor>): void;
        static LinearColor_SetFromSRGB(InOutColor: $Ref<LinearColor>, InSRGB: Color): void;
        static LinearColor_SetFromPow22(InOutColor: $Ref<LinearColor>, InColor: Color): void;
        static LinearColor_SetFromHSV(InOutColor: $Ref<LinearColor>, H: number, S: number, V: number, A: number): void;
        static LinearColor_Set(InOutColor: $Ref<LinearColor>, InColor: LinearColor): void;
        static LinearColor_Red(): LinearColor;
        static LinearColor_QuantizeRound(InColor: LinearColor): Color;
        static LinearColor_Quantize(InColor: LinearColor): Color;
        static LinearColor_IsNearEqual(A: LinearColor, B: LinearColor, Tolerance: number): boolean;
        static LinearColor_Green(): LinearColor;
        static LinearColor_Gray(): LinearColor;
        static LinearColor_GetMin(InColor: LinearColor): number;
        static LinearColor_GetMax(InColor: LinearColor): number;
        static LinearColor_GetLuminance(InColor: LinearColor): number;
        static LinearColor_Distance(C1: LinearColor, C2: LinearColor): number;
        static LinearColor_Desaturated(InColor: LinearColor, InDesaturation: number): LinearColor;
        static LinearColor_Blue(): LinearColor;
        static LinearColor_Black(): LinearColor;
        static LessLess_VectorRotator(A: Vector, B: Rotator): Vector;
        static LessEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;
        static LessEqual_IntInt(A: number, B: number): boolean;
        static LessEqual_Int64Int64(A: bigint, B: bigint): boolean;
        static LessEqual_FloatFloat(A: number, B: number): boolean;
        static LessEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;
        static LessEqual_ByteByte(A: number, B: number): boolean;
        static Less_TimespanTimespan(A: Timespan, B: Timespan): boolean;
        static Less_IntInt(A: number, B: number): boolean;
        static Less_Int64Int64(A: bigint, B: bigint): boolean;
        static Less_FloatFloat(A: number, B: number): boolean;
        static Less_DateTimeDateTime(A: DateTime, B: DateTime): boolean;
        static Less_ByteByte(A: number, B: number): boolean;
        static Lerp(A: number, B: number, Alpha: number): number;
        static IsZero2D(A: Vector2D): boolean;
        static IsPointInBoxWithTransform(Point: Vector, BoxWorldTransform: Transform, BoxExtent: Vector): boolean;
        static IsPointInBox(Point: Vector, BoxOrigin: Vector, BoxExtent: Vector): boolean;
        static IsNearlyZero2D(A: Vector2D, Tolerance: number): boolean;
        static IsMorning(A: DateTime): boolean;
        static IsLeapYear(Year: number): boolean;
        static IsAfternoon(A: DateTime): boolean;
        static InvertTransform(T: Transform): Transform;
        static InverseTransformRotation(T: Transform, Rotation: Rotator): Rotator;
        static InverseTransformLocation(T: Transform, Location: Vector): Vector;
        static InverseTransformDirection(T: Transform, Direction: Vector): Vector;
        static InRange_IntInt(Value: number, Min: number, Max: number, InclusiveMin: boolean, InclusiveMax: boolean): boolean;
        static InRange_Int64Int64(Value: bigint, Min: bigint, Max: bigint, InclusiveMin: boolean, InclusiveMax: boolean): boolean;
        static InRange_FloatFloat(Value: number, Min: number, Max: number, InclusiveMin: boolean, InclusiveMax: boolean): boolean;
        static Hypotenuse(Width: number, Height: number): number;
        static HSVToRGBLinear(HSV: LinearColor): LinearColor;
        static HSVToRGB_Vector(HSV: LinearColor, RGB: $Ref<LinearColor>): void;
        static HSVToRGB(H: number, S: number, V: number, A: number): LinearColor;
        static GridSnap_Float(Location: number, GridSize: number): number;
        static GreaterGreater_VectorRotator(A: Vector, B: Rotator): Vector;
        static GreaterEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;
        static GreaterEqual_IntInt(A: number, B: number): boolean;
        static GreaterEqual_Int64Int64(A: bigint, B: bigint): boolean;
        static GreaterEqual_FloatFloat(A: number, B: number): boolean;
        static GreaterEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;
        static GreaterEqual_ByteByte(A: number, B: number): boolean;
        static Greater_TimespanTimespan(A: Timespan, B: Timespan): boolean;
        static Greater_IntInt(A: number, B: number): boolean;
        static Greater_Int64Int64(A: bigint, B: bigint): boolean;
        static Greater_FloatFloat(A: number, B: number): boolean;
        static Greater_DateTimeDateTime(A: DateTime, B: DateTime): boolean;
        static Greater_ByteByte(A: number, B: number): boolean;
        static GetYear(A: DateTime): number;
        static GetYawPitchFromVector(InVec: Vector, Yaw: $Ref<number>, Pitch: $Ref<number>): void;
        static GetVectorArrayAverage(Vectors: TArray<Vector>): Vector;
        static GetUpVector(InRot: Rotator): Vector;
        static GetTotalSeconds(A: Timespan): number;
        static GetTotalMinutes(A: Timespan): number;
        static GetTotalMilliseconds(A: Timespan): number;
        static GetTotalHours(A: Timespan): number;
        static GetTotalDays(A: Timespan): number;
        static GetTimeOfDay(A: DateTime): Timespan;
        static GetTAU(): number;
        static GetSlopeDegreeAngles(MyRightYAxis: Vector, FloorNormal: Vector, UpVector: Vector, OutSlopePitchDegreeAngle: $Ref<number>, OutSlopeRollDegreeAngle: $Ref<number>): void;
        static GetSeconds(A: Timespan): number;
        static GetSecond(A: DateTime): number;
        static GetRotated2D(A: Vector2D, AngleDeg: number): Vector2D;
        static GetRightVector(InRot: Rotator): Vector;
        static GetReflectionVector(Direction: Vector, SurfaceNormal: Vector): Vector;
        static GetPointDistanceToSegment(Point: Vector, SegmentStart: Vector, SegmentEnd: Vector): number;
        static GetPointDistanceToLine(Point: Vector, LineOrigin: Vector, LineDirection: Vector): number;
        static GetPI(): number;
        static GetMonth(A: DateTime): number;
        static GetMinutes(A: Timespan): number;
        static GetMinute(A: DateTime): number;
        static GetMinElement(A: Vector): number;
        static GetMin2D(A: Vector2D): number;
        static GetMilliseconds(A: Timespan): number;
        static GetMillisecond(A: DateTime): number;
        static GetMaxElement(A: Vector): number;
        static GetMax2D(A: Vector2D): number;
        static GetHours(A: Timespan): number;
        static GetHour12(A: DateTime): number;
        static GetHour(A: DateTime): number;
        static GetForwardVector(InRot: Rotator): Vector;
        static GetDuration(A: Timespan): Timespan;
        static GetDirectionUnitVector(From: Vector, To: Vector): Vector;
        static GetDays(A: Timespan): number;
        static GetDayOfYear(A: DateTime): number;
        static GetDay(A: DateTime): number;
        static GetDate(A: DateTime): DateTime;
        static GetAzimuthAndElevation(InDirection: Vector, ReferenceFrame: Transform, Azimuth: $Ref<number>, Elevation: $Ref<number>): void;
        static GetAxes(A: Rotator, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;
        static GetAbsMax2D(A: Vector2D): number;
        static GetAbs2D(A: Vector2D): Vector2D;
        static FTruncVector(InVector: Vector): IntVector;
        static FTrunc64(A: number): bigint;
        static FTrunc(A: number): number;
        static FromSeconds(Seconds: number): Timespan;
        static FromMinutes(Minutes: number): Timespan;
        static FromMilliseconds(Milliseconds: number): Timespan;
        static FromHours(Hours: number): Timespan;
        static FromDays(Days: number): Timespan;
        static Fraction(A: number): number;
        static FMod(Dividend: number, Divisor: number, Remainder: $Ref<number>): number;
        static FMin(A: number, B: number): number;
        static FMax(A: number, B: number): number;
        static FloatSpringInterp(Current: number, Target: number, SpringState: $Ref<FloatSpringState>, Stiffness: number, CriticalDampingFactor: number, DeltaTime: number, Mass: number): number;
        static FixedTurn(InCurrent: number, InDesired: number, InDeltaRate: number): number;
        static FInterpTo_Constant(Current: number, Target: number, DeltaTime: number, InterpSpeed: number): number;
        static FInterpTo(Current: number, Target: number, DeltaTime: number, InterpSpeed: number): number;
        static FInterpEaseInOut(A: number, B: number, Alpha: number, Exponent: number): number;
        static FindNearestPointsOnLineSegments(Segment1Start: Vector, Segment1End: Vector, Segment2Start: Vector, Segment2End: Vector, Segment1Point: $Ref<Vector>, Segment2Point: $Ref<Vector>): void;
        static FindLookAtRotation(Start: Vector, Target: Vector): Rotator;
        static FindClosestPointOnSegment(Point: Vector, SegmentStart: Vector, SegmentEnd: Vector): Vector;
        static FindClosestPointOnLine(Point: Vector, LineOrigin: Vector, LineDirection: Vector): Vector;
        static FFloor64(A: number): bigint;
        static FFloor(A: number): number;
        static FClamp(Value: number, Min: number, Max: number): number;
        static FCeil64(A: number): bigint;
        static FCeil(A: number): number;
        static Exp(A: number): number;
        static EqualExactly_VectorVector(A: Vector, B: Vector): boolean;
        static EqualExactly_Vector4Vector4(A: Vector4, B: Vector4): boolean;
        static EqualExactly_Vector2DVector2D(A: Vector2D, B: Vector2D): boolean;
        static EqualEqual_VectorVector(A: Vector, B: Vector, ErrorTolerance: number): boolean;
        static EqualEqual_Vector4Vector4(A: Vector4, B: Vector4, ErrorTolerance: number): boolean;
        static EqualEqual_Vector2DVector2D(A: Vector2D, B: Vector2D, ErrorTolerance: number): boolean;
        static EqualEqual_TransformTransform(A: Transform, B: Transform): boolean;
        static EqualEqual_TimespanTimespan(A: Timespan, B: Timespan): boolean;
        static EqualEqual_RotatorRotator(A: Rotator, B: Rotator, ErrorTolerance: number): boolean;
        static EqualEqual_QuatQuat(A: Quat, B: Quat, Tolerance: number): boolean;
        static EqualEqual_ObjectObject(A: Object, B: Object): boolean;
        static EqualEqual_NameName(A: string, B: string): boolean;
        static EqualEqual_MatrixMatrix(A: Matrix, B: Matrix, Tolerance: number): boolean;
        static EqualEqual_LinearColorLinearColor(A: LinearColor, B: LinearColor): boolean;
        static EqualEqual_IntInt(A: number, B: number): boolean;
        static EqualEqual_Int64Int64(A: bigint, B: bigint): boolean;
        static EqualEqual_FloatFloat(A: number, B: number): boolean;
        static EqualEqual_DateTimeDateTime(A: DateTime, B: DateTime): boolean;
        static EqualEqual_ClassClass(A: Class, B: Class): boolean;
        static EqualEqual_ByteByte(A: number, B: number): boolean;
        static EqualEqual_BoolBool(A: boolean, B: boolean): boolean;
        static Ease(A: number, B: number, Alpha: number, EasingFunc: number, BlendExp: number, Steps: number): number;
        static DynamicWeightedMovingAverage_FVector(CurrentSample: Vector, PreviousSample: Vector, MaxDistance: number, MinWeight: number, MaxWeight: number): Vector;
        static DynamicWeightedMovingAverage_FRotator(CurrentSample: Rotator, PreviousSample: Rotator, MaxDistance: number, MinWeight: number, MaxWeight: number): Rotator;
        static DynamicWeightedMovingAverage_Float(CurrentSample: number, PreviousSample: number, MaxDistance: number, MinWeight: number, MaxWeight: number): number;
        static DotProduct2D(A: Vector2D, B: Vector2D): number;
        static Dot_VectorVector(A: Vector, B: Vector): number;
        static Divide_VectorVector(A: Vector, B: Vector): Vector;
        static Divide_VectorInt(A: Vector, B: number): Vector;
        static Divide_VectorFloat(A: Vector, B: number): Vector;
        static Divide_Vector4Vector4(A: Vector4, B: Vector4): Vector4;
        static Divide_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;
        static Divide_Vector2DFloat(A: Vector2D, B: number): Vector2D;
        static Divide_TimespanFloat(A: Timespan, Scalar: number): Timespan;
        static Divide_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;
        static Divide_IntInt(A: number, B: number): number;
        static Divide_Int64Int64(A: bigint, B: bigint): bigint;
        static Divide_FloatFloat(A: number, B: number): number;
        static Divide_ByteByte(A: number, B: number): number;
        static DistanceSquared2D(V1: Vector2D, V2: Vector2D): number;
        static Distance2D(V1: Vector2D, V2: Vector2D): number;
        static DegTan(A: number): number;
        static DegSin(A: number): number;
        static DegreesToRadians(A: number): number;
        static DegCos(A: number): number;
        static DegAtan2(Y: number, X: number): number;
        static DegAtan(A: number): number;
        static DegAsin(A: number): number;
        static DegAcos(A: number): number;
        static DaysInYear(Year: number): number;
        static DaysInMonth(Year: number, Month: number): number;
        static DateTimeMinValue(): DateTime;
        static DateTimeMaxValue(): DateTime;
        static DateTimeFromString(DateTimeString: string, Result: $Ref<DateTime>): boolean;
        static DateTimeFromIsoString(IsoString: string, Result: $Ref<DateTime>): boolean;
        static CrossProduct2D(A: Vector2D, B: Vector2D): number;
        static Cross_VectorVector(A: Vector, B: Vector): Vector;
        static CreateVectorFromYawPitch(Yaw: number, Pitch: number, Length: number): Vector;
        static Cos(A: number): number;
        static ConvertTransformToRelative(Transform: Transform, ParentTransform: Transform): Transform;
        static Conv_VectorToVector2D(InVector: Vector): Vector2D;
        static Conv_VectorToTransform(InLocation: Vector): Transform;
        static Conv_VectorToRotator(InVec: Vector): Rotator;
        static Conv_VectorToQuaterion(InVec: Vector): Quat;
        static Conv_VectorToLinearColor(InVec: Vector): LinearColor;
        static Conv_Vector4ToVector(InVector4: Vector4): Vector;
        static Conv_Vector4ToRotator(InVec: Vector4): Rotator;
        static Conv_Vector4ToQuaterion(InVec: Vector4): Quat;
        static Conv_Vector2DToVector(InVector2D: Vector2D, Z: number): Vector;
        static Conv_Vector2DToIntPoint(InVector2D: Vector2D): IntPoint;
        static Conv_TransformToMatrix(Transform: Transform): Matrix;
        static Conv_RotatorToVector(InRot: Rotator): Vector;
        static Conv_RotatorToTransform(InRotator: Rotator): Transform;
        static Conv_MatrixToTransform(InMatrix: Matrix): Transform;
        static Conv_MatrixToRotator(InMatrix: Matrix): Rotator;
        static Conv_LinearColorToVector(InLinearColor: LinearColor): Vector;
        static Conv_LinearColorToColor(InLinearColor: LinearColor, InUseSRGB: boolean): Color;
        static Conv_IntVectorToVector(InIntVector: IntVector): Vector;
        static Conv_IntToIntVector(InInt: number): IntVector;
        static Conv_IntToInt64(InInt: number): bigint;
        static Conv_IntToFloat(InInt: number): number;
        static Conv_IntToByte(InInt: number): number;
        static Conv_IntToBool(InInt: number): boolean;
        static Conv_FloatToVector(InFloat: number): Vector;
        static Conv_FloatToLinearColor(InFloat: number): LinearColor;
        static Conv_ColorToLinearColor(InColor: Color): LinearColor;
        static Conv_ByteToInt(InByte: number): number;
        static Conv_ByteToFloat(InByte: number): number;
        static Conv_BoolToInt(InBool: boolean): number;
        static Conv_BoolToFloat(InBool: boolean): number;
        static Conv_BoolToByte(InBool: boolean): number;
        static ComposeTransforms(A: Transform, B: Transform): Transform;
        static ComposeRotators(A: Rotator, B: Rotator): Rotator;
        static ClassIsChildOf(TestClass: Class, ParentClass: Class): boolean;
        static ClampVectorSize(A: Vector, Min: number, Max: number): Vector;
        static ClampInt64(Value: bigint, Min: bigint, Max: bigint): bigint;
        static ClampAxis(Angle: number): number;
        static ClampAxes2D(A: Vector2D, MinAxisVal: number, MaxAxisVal: number): Vector2D;
        static ClampAngle(AngleDegrees: number, MinAngleDegrees: number, MaxAngleDegrees: number): number;
        static Clamp(Value: number, Min: number, Max: number): number;
        static CInterpTo(Current: LinearColor, Target: LinearColor, DeltaTime: number, InterpSpeed: number): LinearColor;
        static BreakVector4(InVec: Vector4, X: $Ref<number>, Y: $Ref<number>, Z: $Ref<number>, W: $Ref<number>): void;
        static BreakVector2D(InVec: Vector2D, X: $Ref<number>, Y: $Ref<number>): void;
        static BreakVector(InVec: Vector, X: $Ref<number>, Y: $Ref<number>, Z: $Ref<number>): void;
        static BreakTransform(InTransform: Transform, Location: $Ref<Vector>, Rotation: $Ref<Rotator>, Scale: $Ref<Vector>): void;
        static BreakTimespan2(InTimespan: Timespan, Days: $Ref<number>, Hours: $Ref<number>, Minutes: $Ref<number>, Seconds: $Ref<number>, FractionNano: $Ref<number>): void;
        static BreakTimespan(InTimespan: Timespan, Days: $Ref<number>, Hours: $Ref<number>, Minutes: $Ref<number>, Seconds: $Ref<number>, Milliseconds: $Ref<number>): void;
        static BreakRotIntoAxes(InRot: Rotator, X: $Ref<Vector>, Y: $Ref<Vector>, Z: $Ref<Vector>): void;
        static BreakRotator(InRot: Rotator, Roll: $Ref<number>, Pitch: $Ref<number>, Yaw: $Ref<number>): void;
        static BreakRandomStream(InRandomStream: RandomStream, InitialSeed: $Ref<number>): void;
        static BreakQualifiedFrameTime(InFrameTime: QualifiedFrameTime, Frame: $Ref<FrameNumber>, FrameRate: $Ref<FrameRate>, SubFrame: $Ref<number>): void;
        static BreakFrameRate(InFrameRate: FrameRate, Numerator: $Ref<number>, Denominator: $Ref<number>): void;
        static BreakDateTime(InDateTime: DateTime, Year: $Ref<number>, Month: $Ref<number>, Day: $Ref<number>, Hour: $Ref<number>, Minute: $Ref<number>, Second: $Ref<number>, Millisecond: $Ref<number>): void;
        static BreakColor(InColor: LinearColor, R: $Ref<number>, G: $Ref<number>, B: $Ref<number>, A: $Ref<number>): void;
        static BooleanXOR(A: boolean, B: boolean): boolean;
        static BooleanOR(A: boolean, B: boolean): boolean;
        static BooleanNOR(A: boolean, B: boolean): boolean;
        static BooleanNAND(A: boolean, B: boolean): boolean;
        static BooleanAND(A: boolean, B: boolean): boolean;
        static BMin(A: number, B: number): number;
        static BMax(A: number, B: number): number;
        static Atan2(Y: number, X: number): number;
        static Atan(A: number): number;
        static Asin(A: number): number;
        static And_IntInt(A: number, B: number): number;
        static And_Int64Int64(A: bigint, B: bigint): bigint;
        static Add_VectorVector(A: Vector, B: Vector): Vector;
        static Add_VectorInt(A: Vector, B: number): Vector;
        static Add_VectorFloat(A: Vector, B: number): Vector;
        static Add_Vector4Vector4(A: Vector4, B: Vector4): Vector4;
        static Add_Vector2DVector2D(A: Vector2D, B: Vector2D): Vector2D;
        static Add_Vector2DFloat(A: Vector2D, B: number): Vector2D;
        static Add_TimespanTimespan(A: Timespan, B: Timespan): Timespan;
        static Add_QuatQuat(A: Quat, B: Quat): Quat;
        static Add_MatrixMatrix(A: Matrix, B: Matrix): Matrix;
        static Add_LinearColorLinearColor(A: LinearColor, B: LinearColor): LinearColor;
        static Add_IntInt(A: number, B: number): number;
        static Add_Int64Int64(A: bigint, B: bigint): bigint;
        static Add_FloatFloat(A: number, B: number): number;
        static Add_DateTimeTimespan(A: DateTime, B: Timespan): DateTime;
        static Add_DateTimeDateTime(A: DateTime, B: DateTime): DateTime;
        static Add_ByteByte(A: number, B: number): number;
        static Acos(A: number): number;
        static Abs_Int64(A: bigint): bigint;
        static Abs_Int(A: number): number;
        static Abs(A: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetMathLibrary;
        static Load(InName: string): KismetMathLibrary;
    }
    
    class KismetNodeHelperLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MarkBit(Data: $Ref<number>, Index: number): void;
        static HasUnmarkedBit(Data: number, NumBits: number): boolean;
        static HasMarkedBit(Data: number, NumBits: number): boolean;
        static GetValidValue(Enum: Enum, EnumeratorValue: number): number;
        static GetUnmarkedBit(Data: number, StartIdx: number, NumBits: number, bRandom: boolean): number;
        static GetRandomUnmarkedBit(Data: number, StartIdx: number, NumBits: number): number;
        static GetFirstUnmarkedBit(Data: number, StartIdx: number, NumBits: number): number;
        static GetEnumeratorValueFromIndex(Enum: Enum, EnumeratorIndex: number): number;
        static GetEnumeratorUserFriendlyName(Enum: Enum, EnumeratorValue: number): string;
        static GetEnumeratorName(Enum: Enum, EnumeratorValue: number): string;
        static ClearBit(Data: $Ref<number>, Index: number): void;
        static ClearAllBits(Data: $Ref<number>): void;
        static BitIsMarked(Data: number, Index: number): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetNodeHelperLibrary;
        static Load(InName: string): KismetNodeHelperLibrary;
    }
    
    class DrawToRenderTargetContext {
        constructor(RenderTarget: TextureRenderTarget2D);
        RenderTarget: TextureRenderTarget2D;
    }
    
    class KismetRenderingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetCastInsetShadowForAllAttachments(PrimitiveComponent: PrimitiveComponent, bCastInsetShadow: boolean, bLightAttachmentsAsGroup: boolean): void;
        static RenderTargetCreateStaticTexture2DEditorOnly(RenderTarget: TextureRenderTarget2D, Name: string, CompressionSettings: number, MipSettings: number): Texture2D;
        static ReleaseRenderTarget2D(TextureRenderTarget: TextureRenderTarget2D): void;
        static ReadRenderTargetUV(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, U: number, V: number): Color;
        static ReadRenderTargetRawUV(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, U: number, V: number): LinearColor;
        static ReadRenderTargetRawPixel(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, X: number, Y: number): LinearColor;
        static ReadRenderTargetPixel(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, X: number, Y: number): Color;
        static MakeSkinWeightInfo(Bone0: number, Weight0: number, Bone1: number, Weight1: number, Bone2: number, Weight2: number, Bone3: number, Weight3: number): SkelMeshSkinWeightInfo;
        static ImportFileAsTexture2D(WorldContextObject: Object, Filename: string): Texture2D;
        static ImportBufferAsTexture2D(WorldContextObject: Object, Buffer: TArray<number>): Texture2D;
        static ExportTexture2D(WorldContextObject: Object, Texture: Texture2D, FilePath: string, FileName: string): void;
        static ExportRenderTarget(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, FilePath: string, FileName: string): void;
        static EndDrawCanvasToRenderTarget(WorldContextObject: Object, Context: DrawToRenderTargetContext): void;
        static DrawMaterialToRenderTarget(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, Material: MaterialInterface): void;
        static CreateRenderTarget2D(WorldContextObject: Object, Width: number, Height: number, Format: number, ClearColor: LinearColor, bAutoGenerateMipMaps: boolean): TextureRenderTarget2D;
        static ConvertRenderTargetToTexture2DEditorOnly(WorldContextObject: Object, RenderTarget: TextureRenderTarget2D, Texture: Texture2D): void;
        static ClearRenderTarget2D(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, ClearColor: LinearColor): void;
        static BreakSkinWeightInfo(InWeight: SkelMeshSkinWeightInfo, Bone0: $Ref<number>, Weight0: $Ref<number>, Bone1: $Ref<number>, Weight1: $Ref<number>, Bone2: $Ref<number>, Weight2: $Ref<number>, Bone3: $Ref<number>, Weight3: $Ref<number>): void;
        static BeginDrawCanvasToRenderTarget(WorldContextObject: Object, TextureRenderTarget: TextureRenderTarget2D, Canvas: $Ref<Canvas>, Size: $Ref<Vector2D>, Context: $Ref<DrawToRenderTargetContext>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetRenderingLibrary;
        static Load(InName: string): KismetRenderingLibrary;
    }
    
    class KismetStringLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TrimTrailing(SourceString: string): string;
        static Trim(SourceString: string): string;
        static ToUpper(SourceString: string): string;
        static ToLower(SourceString: string): string;
        static TimeSecondsToString(InSeconds: number): string;
        static StartsWith(SourceString: string, InPrefix: string, SearchCase: number): boolean;
        static Split(SourceString: string, InStr: string, LeftS: $Ref<string>, RightS: $Ref<string>, SearchCase: number, SearchDir: number): boolean;
        static RightPad(SourceString: string, ChCount: number): string;
        static RightChop(SourceString: string, Count: number): string;
        static Right(SourceString: string, Count: number): string;
        static Reverse(SourceString: string): string;
        static ReplaceInline(SourceString: $Ref<string>, SearchText: string, ReplacementText: string, SearchCase: number): number;
        static Replace(SourceString: string, From: string, To: string, SearchCase: number): string;
        static ParseIntoArray(SourceString: string, Delimiter: string, CullEmptyStrings: boolean): TArray<string>;
        static NotEqual_StrStr(A: string, B: string): boolean;
        static NotEqual_StriStri(A: string, B: string): boolean;
        static Mid(SourceString: string, Start: number, Count: number): string;
        static MatchesWildcard(SourceString: string, Wildcard: string, SearchCase: number): boolean;
        static Len(S: string): number;
        static LeftPad(SourceString: string, ChCount: number): string;
        static LeftChop(SourceString: string, Count: number): string;
        static Left(SourceString: string, Count: number): string;
        static JoinStringArray(SourceArray: TArray<string>, Separator: string): string;
        static IsNumeric(SourceString: string): boolean;
        static GetSubstring(SourceString: string, StartIndex: number, Length: number): string;
        static GetCharacterAsNumber(SourceString: string, Index: number): number;
        static GetCharacterArrayFromString(SourceString: string): TArray<string>;
        static FindSubstring(SearchIn: string, Substring: string, bUseCase: boolean, bSearchFromEnd: boolean, StartPosition: number): number;
        static EqualEqual_StrStr(A: string, B: string): boolean;
        static EqualEqual_StriStri(A: string, B: string): boolean;
        static EndsWith(SourceString: string, InSuffix: string, SearchCase: number): boolean;
        static CullArray(SourceString: string, InArray: $Ref<TArray<string>>): number;
        static Conv_VectorToString(InVec: Vector): string;
        static Conv_Vector2dToString(InVec: Vector2D): string;
        static Conv_TransformToString(InTrans: Transform): string;
        static Conv_StringToVector2D(InString: string, OutConvertedVector2D: $Ref<Vector2D>, OutIsValid: $Ref<boolean>): void;
        static Conv_StringToVector(InString: string, OutConvertedVector: $Ref<Vector>, OutIsValid: $Ref<boolean>): void;
        static Conv_StringToRotator(InString: string, OutConvertedRotator: $Ref<Rotator>, OutIsValid: $Ref<boolean>): void;
        static Conv_StringToName(InString: string): string;
        static Conv_StringToInt(InString: string): number;
        static Conv_StringToFloat(InString: string): number;
        static Conv_StringToColor(InString: string, OutConvertedColor: $Ref<LinearColor>, OutIsValid: $Ref<boolean>): void;
        static Conv_RotatorToString(InRot: Rotator): string;
        static Conv_ObjectToString(InObj: Object): string;
        static Conv_NameToString(InName: string): string;
        static Conv_MatrixToString(InMatrix: Matrix): string;
        static Conv_IntVectorToString(InIntVec: IntVector): string;
        static Conv_IntToString(InInt: number): string;
        static Conv_FloatToString(InFloat: number): string;
        static Conv_ColorToString(InColor: LinearColor): string;
        static Conv_ByteToString(InByte: number): string;
        static Conv_BoolToString(InBool: boolean): string;
        static Contains(SearchIn: string, Substring: string, bUseCase: boolean, bSearchFromEnd: boolean): boolean;
        static Concat_StrStr(A: string, B: string): string;
        static BuildString_Vector2d(AppendTo: string, Prefix: string, InVector2d: Vector2D, Suffix: string): string;
        static BuildString_Vector(AppendTo: string, Prefix: string, InVector: Vector, Suffix: string): string;
        static BuildString_Rotator(AppendTo: string, Prefix: string, InRot: Rotator, Suffix: string): string;
        static BuildString_Object(AppendTo: string, Prefix: string, InObj: Object, Suffix: string): string;
        static BuildString_Name(AppendTo: string, Prefix: string, InName: string, Suffix: string): string;
        static BuildString_IntVector(AppendTo: string, Prefix: string, InIntVector: IntVector, Suffix: string): string;
        static BuildString_Int(AppendTo: string, Prefix: string, InInt: number, Suffix: string): string;
        static BuildString_Float(AppendTo: string, Prefix: string, InFloat: number, Suffix: string): string;
        static BuildString_Color(AppendTo: string, Prefix: string, InColor: LinearColor, Suffix: string): string;
        static BuildString_Bool(AppendTo: string, Prefix: string, InBool: boolean, Suffix: string): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetStringLibrary;
        static Load(InName: string): KismetStringLibrary;
    }
    
    class KismetStringTableLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static IsRegisteredTableId(TableId: string): boolean;
        static IsRegisteredTableEntry(TableId: string, Key: string): boolean;
        static GetTableNamespace(TableId: string): string;
        static GetTableEntrySourceString(TableId: string, Key: string): string;
        static GetTableEntryMetaData(TableId: string, Key: string, MetaDataId: string): string;
        static GetRegisteredStringTables(): TArray<string>;
        static GetMetaDataIdsFromStringTableEntry(TableId: string, Key: string): TArray<string>;
        static GetKeysFromStringTable(TableId: string): TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetStringTableLibrary;
        static Load(InName: string): KismetStringTableLibrary;
    }
    
    class UserActivity {
        constructor(ActionName: string);
        ActionName: string;
    }
    
    class GenericStruct {
        constructor(Data: number);
        Data: number;
    }
    
    class CollisionProfileName {
        constructor(Name: string);
        Name: string;
    }
    
    class TimerHandle {
        constructor(Handle: bigint);
        Handle: bigint;
    }
    
    class DebugFloatHistory {
        constructor(Samples: TArray<number>, MaxSamples: number, MinValue: number, MaxValue: number, bAutoAdjustMinMax: boolean);
        Samples: TArray<number>;
        MaxSamples: number;
        MinValue: number;
        MaxValue: number;
        bAutoAdjustMinMax: boolean;
    }
    
    class KismetSystemLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UnregisterForRemoteNotifications(): void;
        static UnloadPrimaryAssetList(PrimaryAssetIdList: TArray<PrimaryAssetId>): void;
        static UnloadPrimaryAsset(PrimaryAssetId: PrimaryAssetId): void;
        static TransactObject(Object: Object): void;
        static StackTrace(): void;
        static SphereTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static SphereTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static SphereTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static SphereTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static SphereTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static SphereTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static SphereOverlapComponents(WorldContextObject: Object, SpherePos: Vector, SphereRadius: number, ObjectTypes: TArray<number>, ComponentClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;
        static SphereOverlapActors(WorldContextObject: Object, SpherePos: Vector, SphereRadius: number, ObjectTypes: TArray<number>, ActorClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;
        static SnapshotObject(Object: Object): void;
        static ShowPlatformSpecificLeaderboardScreen(CategoryName: string): void;
        static ShowPlatformSpecificAchievementsScreen(SpecificPlayer: PlayerController): void;
        static ShowInterstitialAd(): void;
        static ShowAdBanner(AdIdIndex: number, bShowOnBottomOfScreen: boolean): void;
        static SetWindowTitle(Title: string): void;
        static SetVolumeButtonsHandledBySystem(bEnabled: boolean): void;
        static SetVectorPropertyByName(Object: Object, PropertyName: string, Value: Vector): void;
        static SetUserActivity(UserActivity: UserActivity): void;
        static SetTransformPropertyByName(Object: Object, PropertyName: string, Value: Transform): void;
        static SetTextPropertyByName(Object: Object, PropertyName: string, Value: string): void;
        static SetSuppressViewportTransitionMessage(WorldContextObject: Object, bState: boolean): void;
        static SetStructurePropertyByName(Object: Object, PropertyName: string, Value: GenericStruct): void;
        static SetStringPropertyByName(Object: Object, PropertyName: string, Value: string): void;
        static SetSoftObjectPropertyByName(Object: Object, PropertyName: string, Value: TSoftObjectPtr<Object>): void;
        static SetSoftClassPropertyByName(Object: Object, PropertyName: string, Value: TSoftObjectPtr<Class>): void;
        static SetRotatorPropertyByName(Object: Object, PropertyName: string, Value: Rotator): void;
        static SetObjectPropertyByName(Object: Object, PropertyName: string, Value: Object): void;
        static SetNamePropertyByName(Object: Object, PropertyName: string, Value: string): void;
        static SetLinearColorPropertyByName(Object: Object, PropertyName: string, Value: LinearColor): void;
        static SetIntPropertyByName(Object: Object, PropertyName: string, Value: number): void;
        static SetInterfacePropertyByName(Object: Object, PropertyName: string, Value: Interface): void;
        static SetInt64PropertyByName(Object: Object, PropertyName: string, Value: bigint): void;
        static SetFloatPropertyByName(Object: Object, PropertyName: string, Value: number): void;
        static SetCollisionProfileNameProperty(Object: Object, PropertyName: string, Value: CollisionProfileName): void;
        static SetClassPropertyByName(Object: Object, PropertyName: string, Value: Class): void;
        static SetBytePropertyByName(Object: Object, PropertyName: string, Value: number): void;
        static SetBoolPropertyByName(Object: Object, PropertyName: string, Value: boolean): void;
        static RetriggerableDelay(WorldContextObject: Object, Duration: number, LatentInfo: LatentActionInfo): void;
        static ResetGamepadAssignmentToController(ControllerId: number): void;
        static ResetGamepadAssignments(): void;
        static RegisterForRemoteNotifications(): void;
        static QuitGame(WorldContextObject: Object, SpecificPlayer: PlayerController, QuitPreference: number, bIgnorePlatformRestrictions: boolean): void;
        static QuitEditor(): void;
        static PrintWarning(InString: string): void;
        static PrintText(WorldContextObject: Object, InText: string, bPrintToScreen: boolean, bPrintToLog: boolean, TextColor: LinearColor, Duration: number): void;
        static PrintString(WorldContextObject: Object, InString: string, bPrintToScreen: boolean, bPrintToLog: boolean, TextColor: LinearColor, Duration: number): void;
        OnAssetLoaded__DelegateSignature(Loaded: Object): void;
        OnAssetClassLoaded__DelegateSignature(Loaded: Class): void;
        static NotEqual_SoftObjectReference(A: TSoftObjectPtr<Object>, B: TSoftObjectPtr<Object>): boolean;
        static NotEqual_SoftClassReference(A: TSoftObjectPtr<Class>, B: TSoftObjectPtr<Class>): boolean;
        static NotEqual_PrimaryAssetType(A: PrimaryAssetType, B: PrimaryAssetType): boolean;
        static NotEqual_PrimaryAssetId(A: PrimaryAssetId, B: PrimaryAssetId): boolean;
        static NormalizeFilename(InFilename: string): string;
        static MoveComponentTo(Component: SceneComponent, TargetRelativeLocation: Vector, TargetRelativeRotation: Rotator, bEaseOut: boolean, bEaseIn: boolean, OverTime: number, bForceShortestRotationPath: boolean, MoveAction: number, LatentInfo: LatentActionInfo): void;
        static MakeSoftObjectPath(PathString: string): SoftObjectPath;
        static MakeSoftClassPath(PathString: string): SoftClassPath;
        static MakeLiteralText(Value: string): string;
        static MakeLiteralString(Value: string): string;
        static MakeLiteralName(Value: string): string;
        static MakeLiteralInt(Value: number): number;
        static MakeLiteralFloat(Value: number): number;
        static MakeLiteralByte(Value: number): number;
        static MakeLiteralBool(Value: boolean): boolean;
        static LoadInterstitialAd(AdIdIndex: number): void;
        static LoadClassAsset_Blocking(AssetClass: TSoftObjectPtr<Class>): Class;
        static LoadAssetClass(WorldContextObject: Object, AssetClass: TSoftObjectPtr<Class>, OnLoaded: $Delegate<(Loaded: Class) => void>, LatentInfo: LatentActionInfo): void;
        static LoadAsset_Blocking(Asset: TSoftObjectPtr<Object>): Object;
        static LoadAsset(WorldContextObject: Object, Asset: TSoftObjectPtr<Object>, OnLoaded: $Delegate<(Loaded: Object) => void>, LatentInfo: LatentActionInfo): void;
        static LineTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static LineTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static LineTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static LineTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static LineTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static LineTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static LaunchURL(URL: string): void;
        static K2_UnPauseTimerHandle(WorldContextObject: Object, Handle: TimerHandle): void;
        static K2_UnPauseTimerDelegate(Delegate: $Delegate<() => void>): void;
        static K2_UnPauseTimer(Object: Object, FunctionName: string): void;
        static K2_TimerExistsHandle(WorldContextObject: Object, Handle: TimerHandle): boolean;
        static K2_TimerExistsDelegate(Delegate: $Delegate<() => void>): boolean;
        static K2_TimerExists(Object: Object, FunctionName: string): boolean;
        static K2_SetTimerDelegate(Delegate: $Delegate<() => void>, Time: number, bLooping: boolean, InitialStartDelay: number, InitialStartDelayVariance: number): TimerHandle;
        static K2_SetTimer(Object: Object, FunctionName: string, Time: number, bLooping: boolean, InitialStartDelay: number, InitialStartDelayVariance: number): TimerHandle;
        static K2_PauseTimerHandle(WorldContextObject: Object, Handle: TimerHandle): void;
        static K2_PauseTimerDelegate(Delegate: $Delegate<() => void>): void;
        static K2_PauseTimer(Object: Object, FunctionName: string): void;
        static K2_IsValidTimerHandle(Handle: TimerHandle): boolean;
        static K2_IsTimerPausedHandle(WorldContextObject: Object, Handle: TimerHandle): boolean;
        static K2_IsTimerPausedDelegate(Delegate: $Delegate<() => void>): boolean;
        static K2_IsTimerPaused(Object: Object, FunctionName: string): boolean;
        static K2_IsTimerActiveHandle(WorldContextObject: Object, Handle: TimerHandle): boolean;
        static K2_IsTimerActiveDelegate(Delegate: $Delegate<() => void>): boolean;
        static K2_IsTimerActive(Object: Object, FunctionName: string): boolean;
        static K2_InvalidateTimerHandle(Handle: $Ref<TimerHandle>): TimerHandle;
        static K2_GetTimerRemainingTimeHandle(WorldContextObject: Object, Handle: TimerHandle): number;
        static K2_GetTimerRemainingTimeDelegate(Delegate: $Delegate<() => void>): number;
        static K2_GetTimerRemainingTime(Object: Object, FunctionName: string): number;
        static K2_GetTimerElapsedTimeHandle(WorldContextObject: Object, Handle: TimerHandle): number;
        static K2_GetTimerElapsedTimeDelegate(Delegate: $Delegate<() => void>): number;
        static K2_GetTimerElapsedTime(Object: Object, FunctionName: string): number;
        static K2_ClearTimerHandle(WorldContextObject: Object, Handle: TimerHandle): void;
        static K2_ClearTimerDelegate(Delegate: $Delegate<() => void>): void;
        static K2_ClearTimer(Object: Object, FunctionName: string): void;
        static K2_ClearAndInvalidateTimerHandle(WorldContextObject: Object, Handle: $Ref<TimerHandle>): void;
        static IsValidSoftObjectReference(SoftObjectReference: TSoftObjectPtr<Object>): boolean;
        static IsValidSoftClassReference(SoftClassReference: TSoftObjectPtr<Class>): boolean;
        static IsValidPrimaryAssetType(PrimaryAssetType: PrimaryAssetType): boolean;
        static IsValidPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): boolean;
        static IsValidClass(Class: Class): boolean;
        static IsValid(Object: Object): boolean;
        static IsUnattended(): boolean;
        static IsStandalone(WorldContextObject: Object): boolean;
        static IsServer(WorldContextObject: Object): boolean;
        static IsScreensaverEnabled(): boolean;
        static IsPackagedForDistribution(): boolean;
        static IsLoggedIn(SpecificPlayer: PlayerController): boolean;
        static IsInterstitialAdRequested(): boolean;
        static IsInterstitialAdAvailable(): boolean;
        static IsDedicatedServer(WorldContextObject: Object): boolean;
        static IsControllerAssignedToGamepad(ControllerId: number): boolean;
        static HideAdBanner(): void;
        static GetVolumeButtonsHandledBySystem(): boolean;
        static GetUniqueDeviceId(): string;
        static GetSupportedFullscreenResolutions(Resolutions: $Ref<TArray<IntPoint>>): boolean;
        static GetSoftObjectReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): TSoftObjectPtr<Object>;
        static GetSoftClassReferenceFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): TSoftObjectPtr<Class>;
        static GetRenderingMaterialQualityLevel(): number;
        static GetRenderingDetailMode(): number;
        static GetProjectSavedDirectory(): string;
        static GetProjectDirectory(): string;
        static GetProjectContentDirectory(): string;
        static GetPrimaryAssetsWithBundleState(RequiredBundles: TArray<string>, ExcludedBundles: TArray<string>, ValidTypes: TArray<PrimaryAssetType>, bForceCurrentState: boolean, OutPrimaryAssetIdList: $Ref<TArray<PrimaryAssetId>>): void;
        static GetPrimaryAssetIdList(PrimaryAssetType: PrimaryAssetType, OutPrimaryAssetIdList: $Ref<TArray<PrimaryAssetId>>): void;
        static GetPrimaryAssetIdFromSoftObjectReference(SoftObjectReference: TSoftObjectPtr<Object>): PrimaryAssetId;
        static GetPrimaryAssetIdFromSoftClassReference(SoftClassReference: TSoftObjectPtr<Class>): PrimaryAssetId;
        static GetPrimaryAssetIdFromObject(Object: Object): PrimaryAssetId;
        static GetPrimaryAssetIdFromClass(Class: Class): PrimaryAssetId;
        static GetPreferredLanguages(): TArray<string>;
        static GetPlatformUserName(): string;
        static GetPathName(Object: Object): string;
        static GetOuterObject(Object: Object): Object;
        static GetObjectName(Object: Object): string;
        static GetObjectFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Object;
        static GetMinYResolutionForUI(): number;
        static GetMinYResolutionFor3DView(): number;
        static GetLocalCurrencySymbol(): string;
        static GetLocalCurrencyCode(): string;
        static GetGameTimeInSeconds(WorldContextObject: Object): number;
        static GetGamepadControllerName(ControllerId: number): string;
        static GetGameName(): string;
        static GetGameBundleId(): string;
        static GetFrameCount(): bigint;
        static GetEngineVersion(): string;
        static GetDisplayName(Object: Object): string;
        static GetDeviceId(): string;
        static GetDefaultLocale(): string;
        static GetDefaultLanguage(): string;
        static GetCurrentBundleState(PrimaryAssetId: PrimaryAssetId, bForceCurrentState: boolean, OutBundles: $Ref<TArray<string>>): boolean;
        static GetConvenientWindowedResolutions(Resolutions: $Ref<TArray<IntPoint>>): boolean;
        static GetConsoleVariableIntValue(VariableName: string): number;
        static GetConsoleVariableFloatValue(VariableName: string): number;
        static GetConsoleVariableBoolValue(VariableName: string): boolean;
        static GetComponentBounds(Component: SceneComponent, Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, SphereRadius: $Ref<number>): void;
        static GetCommandLine(): string;
        static GetClassFromPrimaryAssetId(PrimaryAssetId: PrimaryAssetId): Class;
        static GetClassDisplayName(Class: Class): string;
        static GetAdIDCount(): number;
        static GetActorListFromComponentList(ComponentList: TArray<PrimitiveComponent>, ActorClassFilter: Class, OutActorList: $Ref<TArray<Actor>>): void;
        static GetActorBounds(Actor: Actor, Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>): void;
        static ForceCloseAdBanner(): void;
        static FlushPersistentDebugLines(WorldContextObject: Object): void;
        static FlushDebugStrings(WorldContextObject: Object): void;
        static ExecuteConsoleCommand(WorldContextObject: Object, Command: string, SpecificPlayer: PlayerController): void;
        static EqualEqual_SoftObjectReference(A: TSoftObjectPtr<Object>, B: TSoftObjectPtr<Object>): boolean;
        static EqualEqual_SoftClassReference(A: TSoftObjectPtr<Class>, B: TSoftObjectPtr<Class>): boolean;
        static EqualEqual_PrimaryAssetType(A: PrimaryAssetType, B: PrimaryAssetType): boolean;
        static EqualEqual_PrimaryAssetId(A: PrimaryAssetId, B: PrimaryAssetId): boolean;
        static EndTransaction(): number;
        static DrawDebugString(WorldContextObject: Object, TextLocation: Vector, Text: string, TestBaseActor: Actor, TextColor: LinearColor, Duration: number): void;
        static DrawDebugSphere(WorldContextObject: Object, Center: Vector, Radius: number, Segments: number, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugPoint(WorldContextObject: Object, Position: Vector, Size: number, PointColor: LinearColor, Duration: number): void;
        static DrawDebugPlane(WorldContextObject: Object, PlaneCoordinates: Plane, Location: Vector, Size: number, PlaneColor: LinearColor, Duration: number): void;
        static DrawDebugLine(WorldContextObject: Object, LineStart: Vector, LineEnd: Vector, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugFrustum(WorldContextObject: Object, FrustumTransform: Transform, FrustumColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugFloatHistoryTransform(WorldContextObject: Object, FloatHistory: DebugFloatHistory, DrawTransform: Transform, DrawSize: Vector2D, DrawColor: LinearColor, Duration: number): void;
        static DrawDebugFloatHistoryLocation(WorldContextObject: Object, FloatHistory: DebugFloatHistory, DrawLocation: Vector, DrawSize: Vector2D, DrawColor: LinearColor, Duration: number): void;
        static DrawDebugCylinder(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, Segments: number, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugCoordinateSystem(WorldContextObject: Object, AxisLoc: Vector, AxisRot: Rotator, Scale: number, Duration: number, Thickness: number): void;
        static DrawDebugConeInDegrees(WorldContextObject: Object, Origin: Vector, Direction: Vector, Length: number, AngleWidth: number, AngleHeight: number, NumSides: number, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugCone(WorldContextObject: Object, Origin: Vector, Direction: Vector, Length: number, AngleWidth: number, AngleHeight: number, NumSides: number, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugCircle(WorldContextObject: Object, Center: Vector, Radius: number, NumSegments: number, LineColor: LinearColor, Duration: number, Thickness: number, YAxis: Vector, ZAxis: Vector, bDrawAxis: boolean): void;
        static DrawDebugCapsule(WorldContextObject: Object, Center: Vector, HalfHeight: number, Radius: number, Rotation: Rotator, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DrawDebugCamera(CameraActor: CameraActor, CameraColor: LinearColor, Duration: number): void;
        static DrawDebugBox(WorldContextObject: Object, Center: Vector, Extent: Vector, LineColor: LinearColor, Rotation: Rotator, Duration: number, Thickness: number): void;
        static DrawDebugArrow(WorldContextObject: Object, LineStart: Vector, LineEnd: Vector, ArrowSize: number, LineColor: LinearColor, Duration: number, Thickness: number): void;
        static DoesImplementInterface(TestObject: Object, Interface: Class): boolean;
        static Delay(WorldContextObject: Object, Duration: number, LatentInfo: LatentActionInfo): void;
        static CreateCopyForUndoBuffer(ObjectToModify: Object): void;
        static ConvertToRelativePath(Filename: string): string;
        static ConvertToAbsolutePath(Filename: string): string;
        static Conv_SoftObjPathToSoftObjRef(SoftObjectPath: SoftObjectPath): TSoftObjectPtr<Object>;
        static Conv_SoftObjectReferenceToString(SoftObjectReference: TSoftObjectPtr<Object>): string;
        static Conv_SoftObjectReferenceToObject(SoftObject: TSoftObjectPtr<Object>): Object;
        static Conv_SoftClassReferenceToString(SoftClassReference: TSoftObjectPtr<Class>): string;
        static Conv_SoftClassReferenceToClass(SoftClass: TSoftObjectPtr<Class>): Class;
        static Conv_SoftClassPathToSoftClassRef(SoftClassPath: SoftClassPath): TSoftObjectPtr<Class>;
        static Conv_PrimaryAssetTypeToString(PrimaryAssetType: PrimaryAssetType): string;
        static Conv_PrimaryAssetIdToString(PrimaryAssetId: PrimaryAssetId): string;
        static Conv_ObjectToSoftObjectReference(Object: Object): TSoftObjectPtr<Object>;
        static Conv_InterfaceToObject(Interface: Interface): Object;
        static Conv_ClassToSoftClassReference(Class: Class): TSoftObjectPtr<Class>;
        static ControlScreensaver(bAllowScreenSaver: boolean): void;
        static ComponentOverlapComponents(Component: PrimitiveComponent, ComponentTransform: Transform, ObjectTypes: TArray<number>, ComponentClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;
        static ComponentOverlapActors(Component: PrimitiveComponent, ComponentTransform: Transform, ObjectTypes: TArray<number>, ActorClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;
        static CollectGarbage(): void;
        static CapsuleTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static CapsuleTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static CapsuleTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, HalfHeight: number, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static CapsuleTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static CapsuleTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, HalfHeight: number, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static CapsuleTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, Radius: number, HalfHeight: number, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static CapsuleOverlapComponents(WorldContextObject: Object, CapsulePos: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<number>, ComponentClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;
        static CapsuleOverlapActors(WorldContextObject: Object, CapsulePos: Vector, Radius: number, HalfHeight: number, ObjectTypes: TArray<number>, ActorClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;
        static CanLaunchURL(URL: string): boolean;
        static CancelTransaction(Index: number): void;
        static BreakSoftObjectPath(InSoftObjectPath: SoftObjectPath, PathString: $Ref<string>): void;
        static BreakSoftClassPath(InSoftClassPath: SoftClassPath, PathString: $Ref<string>): void;
        static BoxTraceSingleForObjects(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static BoxTraceSingleByProfile(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static BoxTraceSingle(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHit: $Ref<HitResult>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static BoxTraceMultiForObjects(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ObjectTypes: TArray<number>, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static BoxTraceMultiByProfile(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static BoxTraceMulti(WorldContextObject: Object, Start: Vector, End: Vector, HalfSize: Vector, Orientation: Rotator, TraceChannel: number, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, DrawDebugType: number, OutHits: $Ref<TArray<HitResult>>, bIgnoreSelf: boolean, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): boolean;
        static BoxOverlapComponents(WorldContextObject: Object, BoxPos: Vector, Extent: Vector, ObjectTypes: TArray<number>, ComponentClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutComponents: $Ref<TArray<PrimitiveComponent>>): boolean;
        static BoxOverlapActors(WorldContextObject: Object, BoxPos: Vector, BoxExtent: Vector, ObjectTypes: TArray<number>, ActorClassFilter: Class, ActorsToIgnore: TArray<Actor>, OutActors: $Ref<TArray<Actor>>): boolean;
        static BeginTransaction(Context: string, Description: string, PrimaryObject: Object): number;
        static AddFloatHistorySample(Value: number, FloatHistory: DebugFloatHistory): DebugFloatHistory;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetSystemLibrary;
        static Load(InName: string): KismetSystemLibrary;
    }
    
    class PolyglotTextData {
        constructor(Category: ELocalizedTextSourceCategory, NativeCulture: string, Namespace: string, Key: string, NativeString: string, LocalizedStrings: TMap<string, string>, bIsMinimalPatch: boolean, CachedText: string);
        Category: ELocalizedTextSourceCategory;
        NativeCulture: string;
        Namespace: string;
        Key: string;
        NativeString: string;
        LocalizedStrings: TMap<string, string>;
        bIsMinimalPatch: boolean;
        CachedText: string;
    }
    
    enum ETextGender { Masculine, Feminine, Neuter, ETextGender_MAX}
    class FormatArgumentData {
        constructor(ArgumentName: string, ArgumentValueType: number, ArgumentValue: string, ArgumentValueInt: number, ArgumentValueFloat: number, ArgumentValueGender: ETextGender);
        ArgumentName: string;
        ArgumentValueType: number;
        ArgumentValue: string;
        ArgumentValueInt: number;
        ArgumentValueFloat: number;
        ArgumentValueGender: ETextGender;
    }
    
    class KismetTextLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TextTrimTrailing(InText: string): string;
        static TextTrimPrecedingAndTrailing(InText: string): string;
        static TextTrimPreceding(InText: string): string;
        static TextToUpper(InText: string): string;
        static TextToLower(InText: string): string;
        static TextIsTransient(InText: string): boolean;
        static TextIsFromStringTable(Text: string): boolean;
        static TextIsEmpty(InText: string): boolean;
        static TextIsCultureInvariant(InText: string): boolean;
        static TextFromStringTable(TableId: string, Key: string): string;
        static StringTableIdAndKeyFromText(Text: string, OutTableId: $Ref<string>, OutKey: $Ref<string>): boolean;
        static PolyglotDataToText(PolyglotData: PolyglotTextData): string;
        static NotEqual_TextText(A: string, B: string): boolean;
        static NotEqual_IgnoreCase_TextText(A: string, B: string): boolean;
        static IsPolyglotDataValid(PolyglotData: PolyglotTextData, IsValid: $Ref<boolean>, ErrorMessage: $Ref<string>): void;
        static GetEmptyText(): string;
        static Format(InPattern: string, InArgs: TArray<FormatArgumentData>): string;
        static FindTextInLocalizationTable(Namespace: string, Key: string, OutText: $Ref<string>): boolean;
        static EqualEqual_TextText(A: string, B: string): boolean;
        static EqualEqual_IgnoreCase_TextText(A: string, B: string): boolean;
        static Conv_VectorToText(InVec: Vector): string;
        static Conv_Vector2dToText(InVec: Vector2D): string;
        static Conv_TransformToText(InTrans: Transform): string;
        static Conv_TextToString(InText: string): string;
        static Conv_StringToText(InString: string): string;
        static Conv_RotatorToText(InRot: Rotator): string;
        static Conv_ObjectToText(InObj: Object): string;
        static Conv_NameToText(InName: string): string;
        static Conv_IntToText(Value: number, bAlwaysSign: boolean, bUseGrouping: boolean, MinimumIntegralDigits: number, MaximumIntegralDigits: number): string;
        static Conv_Int64ToText(Value: bigint, bAlwaysSign: boolean, bUseGrouping: boolean, MinimumIntegralDigits: number, MaximumIntegralDigits: number): string;
        static Conv_FloatToText(Value: number, RoundingMode: number, bAlwaysSign: boolean, bUseGrouping: boolean, MinimumIntegralDigits: number, MaximumIntegralDigits: number, MinimumFractionalDigits: number, MaximumFractionalDigits: number): string;
        static Conv_ColorToText(InColor: LinearColor): string;
        static Conv_ByteToText(Value: number): string;
        static Conv_BoolToText(InBool: boolean): string;
        static AsTimeZoneTime_DateTime(InDateTime: DateTime, InTimeZone: string): string;
        static AsTimeZoneDateTime_DateTime(InDateTime: DateTime, InTimeZone: string): string;
        static AsTimeZoneDate_DateTime(InDateTime: DateTime, InTimeZone: string): string;
        static AsTimespan_Timespan(InTimespan: Timespan): string;
        static AsTime_DateTime(In: DateTime): string;
        static AsPercent_Float(Value: number, RoundingMode: number, bAlwaysSign: boolean, bUseGrouping: boolean, MinimumIntegralDigits: number, MaximumIntegralDigits: number, MinimumFractionalDigits: number, MaximumFractionalDigits: number): string;
        static AsDateTime_DateTime(In: DateTime): string;
        static AsDate_DateTime(InDateTime: DateTime): string;
        static AsCurrencyBase(BaseValue: number, CurrencyCode: string): string;
        static AsCurrency_Integer(Value: number, RoundingMode: number, bAlwaysSign: boolean, bUseGrouping: boolean, MinimumIntegralDigits: number, MaximumIntegralDigits: number, MinimumFractionalDigits: number, MaximumFractionalDigits: number, CurrencyCode: string): string;
        static AsCurrency_Float(Value: number, RoundingMode: number, bAlwaysSign: boolean, bUseGrouping: boolean, MinimumIntegralDigits: number, MaximumIntegralDigits: number, MinimumFractionalDigits: number, MaximumFractionalDigits: number, CurrencyCode: string): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetTextLibrary;
        static Load(InName: string): KismetTextLibrary;
    }
    
    class LevelBounds extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoUpdateBounds: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelBounds;
        static Load(InName: string): LevelBounds;
    }
    
    class LevelStreamingAlwaysLoaded extends LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingAlwaysLoaded;
        static Load(InName: string): LevelStreamingAlwaysLoaded;
    }
    
    class LevelStreamingDynamic extends LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInitiallyLoaded: boolean;
        bInitiallyVisible: boolean;
        static LoadLevelInstanceBySoftObjectPtr(WorldContextObject: Object, Level: TSoftObjectPtr<World>, Location: Vector, Rotation: Rotator, bOutSuccess: $Ref<boolean>): LevelStreamingDynamic;
        static LoadLevelInstance(WorldContextObject: Object, LevelName: string, Location: Vector, Rotation: Rotator, bOutSuccess: $Ref<boolean>): LevelStreamingDynamic;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingDynamic;
        static Load(InName: string): LevelStreamingDynamic;
    }
    
    class LevelStreamingPersistent extends LevelStreaming {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelStreamingPersistent;
        static Load(InName: string): LevelStreamingPersistent;
    }
    
    class LightmappedSurfaceCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceModel: Model;
        Surfaces: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmappedSurfaceCollection;
        static Load(InName: string): LightmappedSurfaceCollection;
    }
    
    class LightMapTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightMapTexture2D;
        static Load(InName: string): LightMapTexture2D;
    }
    
    class LightmassCharacterIndirectDetailVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassCharacterIndirectDetailVolume;
        static Load(InName: string): LightmassCharacterIndirectDetailVolume;
    }
    
    class LightmassImportanceVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassImportanceVolume;
        static Load(InName: string): LightmassImportanceVolume;
    }
    
    class LightmassPortalComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewBox: BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassPortalComponent;
        static Load(InName: string): LightmassPortalComponent;
    }
    
    class LightmassPortal extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PortalComponent: LightmassPortalComponent;
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassPortal;
        static Load(InName: string): LightmassPortal;
    }
    
    class LightmassPrimitiveSettingsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightmassSettings: LightmassPrimitiveSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightmassPrimitiveSettingsObject;
        static Load(InName: string): LightmassPrimitiveSettingsObject;
    }
    
    class LocalPlayerSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalPlayerSubsystem;
        static Load(InName: string): LocalPlayerSubsystem;
    }
    
    class MaterialExpressionAbs extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAbs;
        static Load(InName: string): MaterialExpressionAbs;
    }
    
    class MaterialExpressionActorPositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionActorPositionWS;
        static Load(InName: string): MaterialExpressionActorPositionWS;
    }
    
    class MaterialExpressionAdd extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAdd;
        static Load(InName: string): MaterialExpressionAdd;
    }
    
    class MaterialExpressionTextureBase extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Texture: Texture;
        SamplerType: number;
        IsDefaultMeshpaintTexture: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureBase;
        static Load(InName: string): MaterialExpressionTextureBase;
    }
    
    class MaterialExpressionTextureSample extends MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: ExpressionInput;
        TextureObject: ExpressionInput;
        MipValue: ExpressionInput;
        CoordinatesDX: ExpressionInput;
        CoordinatesDY: ExpressionInput;
        AutomaticViewMipBiasValue: ExpressionInput;
        MipValueMode: number;
        SamplerSource: number;
        AutomaticViewMipBias: boolean;
        ConstCoordinate: number;
        ConstMipValue: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSample;
        static Load(InName: string): MaterialExpressionTextureSample;
    }
    
    class MaterialExpressionTextureSampleParameter extends MaterialExpressionTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;
        ChannelNames: ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter;
        static Load(InName: string): MaterialExpressionTextureSampleParameter;
    }
    
    class MaterialExpressionTextureSampleParameter2D extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter2D;
        static Load(InName: string): MaterialExpressionTextureSampleParameter2D;
    }
    
    class MaterialExpressionAntialiasedTextureMask extends MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Threshold: number;
        Channel: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAntialiasedTextureMask;
        static Load(InName: string): MaterialExpressionAntialiasedTextureMask;
    }
    
    class MaterialExpressionAppendVector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAppendVector;
        static Load(InName: string): MaterialExpressionAppendVector;
    }
    
    class MaterialExpressionArccosine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArccosine;
        static Load(InName: string): MaterialExpressionArccosine;
    }
    
    class MaterialExpressionArccosineFast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArccosineFast;
        static Load(InName: string): MaterialExpressionArccosineFast;
    }
    
    class MaterialExpressionArcsine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArcsine;
        static Load(InName: string): MaterialExpressionArcsine;
    }
    
    class MaterialExpressionArcsineFast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArcsineFast;
        static Load(InName: string): MaterialExpressionArcsineFast;
    }
    
    class MaterialExpressionArctangent extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent;
        static Load(InName: string): MaterialExpressionArctangent;
    }
    
    class MaterialExpressionArctangent2 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Y: ExpressionInput;
        X: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent2;
        static Load(InName: string): MaterialExpressionArctangent2;
    }
    
    class MaterialExpressionArctangent2Fast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Y: ExpressionInput;
        X: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangent2Fast;
        static Load(InName: string): MaterialExpressionArctangent2Fast;
    }
    
    class MaterialExpressionArctangentFast extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionArctangentFast;
        static Load(InName: string): MaterialExpressionArctangentFast;
    }
    
    class MaterialExpressionAtmosphericFogColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WorldPosition: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericFogColor;
        static Load(InName: string): MaterialExpressionAtmosphericFogColor;
    }
    
    class MaterialExpressionAtmosphericLightColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericLightColor;
        static Load(InName: string): MaterialExpressionAtmosphericLightColor;
    }
    
    class MaterialExpressionAtmosphericLightVector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionAtmosphericLightVector;
        static Load(InName: string): MaterialExpressionAtmosphericLightVector;
    }
    
    class MaterialExpressionBentNormalCustomOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBentNormalCustomOutput;
        static Load(InName: string): MaterialExpressionBentNormalCustomOutput;
    }
    
    class MaterialExpressionBlackBody extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Temp: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBlackBody;
        static Load(InName: string): MaterialExpressionBlackBody;
    }
    
    class MaterialExpressionBlendMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: MaterialAttributesInput;
        B: MaterialAttributesInput;
        Alpha: ExpressionInput;
        PixelAttributeBlendType: number;
        VertexAttributeBlendType: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBlendMaterialAttributes;
        static Load(InName: string): MaterialExpressionBlendMaterialAttributes;
    }
    
    class MaterialExpressionBreakMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialAttributes: MaterialAttributesInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBreakMaterialAttributes;
        static Load(InName: string): MaterialExpressionBreakMaterialAttributes;
    }
    
    class MaterialExpressionBumpOffset extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinate: ExpressionInput;
        Height: ExpressionInput;
        HeightRatioInput: ExpressionInput;
        HeightRatio: number;
        ReferencePlane: number;
        ConstCoordinate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionBumpOffset;
        static Load(InName: string): MaterialExpressionBumpOffset;
    }
    
    class MaterialExpressionCameraPositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCameraPositionWS;
        static Load(InName: string): MaterialExpressionCameraPositionWS;
    }
    
    class MaterialExpressionCameraVectorWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCameraVectorWS;
        static Load(InName: string): MaterialExpressionCameraVectorWS;
    }
    
    class MaterialExpressionCeil extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCeil;
        static Load(InName: string): MaterialExpressionCeil;
    }
    
    class MaterialExpressionParameter extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParameter;
        static Load(InName: string): MaterialExpressionParameter;
    }
    
    class MaterialExpressionVectorParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: LinearColor;
        bUseCustomPrimitiveData: boolean;
        PrimitiveDataIndex: number;
        ChannelNames: ParameterChannelNames;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVectorParameter;
        static Load(InName: string): MaterialExpressionVectorParameter;
    }
    
    class MaterialExpressionChannelMaskParameter extends MaterialExpressionVectorParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaskChannel: number;
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionChannelMaskParameter;
        static Load(InName: string): MaterialExpressionChannelMaskParameter;
    }
    
    class MaterialExpressionClamp extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        Min: ExpressionInput;
        Max: ExpressionInput;
        ClampMode: number;
        MinDefault: number;
        MaxDefault: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClamp;
        static Load(InName: string): MaterialExpressionClamp;
    }
    
    class MaterialExpressionClearCoatNormalCustomOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionClearCoatNormalCustomOutput;
        static Load(InName: string): MaterialExpressionClearCoatNormalCustomOutput;
    }
    
    class MaterialExpressionCollectionParameter extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Collection: MaterialParameterCollection;
        ParameterName: string;
        ParameterId: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCollectionParameter;
        static Load(InName: string): MaterialExpressionCollectionParameter;
    }
    
    class MaterialExpressionComponentMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        R: boolean;
        G: boolean;
        B: boolean;
        A: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionComponentMask;
        static Load(InName: string): MaterialExpressionComponentMask;
    }
    
    class MaterialExpressionConstant extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        R: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant;
        static Load(InName: string): MaterialExpressionConstant;
    }
    
    class MaterialExpressionConstant2Vector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        R: number;
        G: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant2Vector;
        static Load(InName: string): MaterialExpressionConstant2Vector;
    }
    
    class MaterialExpressionConstant3Vector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant3Vector;
        static Load(InName: string): MaterialExpressionConstant3Vector;
    }
    
    class MaterialExpressionConstant4Vector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Constant: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstant4Vector;
        static Load(InName: string): MaterialExpressionConstant4Vector;
    }
    
    class MaterialExpressionConstantBiasScale extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        Bias: number;
        Scale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionConstantBiasScale;
        static Load(InName: string): MaterialExpressionConstantBiasScale;
    }
    
    class MaterialExpressionCosine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCosine;
        static Load(InName: string): MaterialExpressionCosine;
    }
    
    class MaterialExpressionCrossProduct extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCrossProduct;
        static Load(InName: string): MaterialExpressionCrossProduct;
    }
    
    class MaterialExpressionScalarParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: number;
        bUseCustomPrimitiveData: boolean;
        PrimitiveDataIndex: number;
        SliderMin: number;
        SliderMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionScalarParameter;
        static Load(InName: string): MaterialExpressionScalarParameter;
    }
    
    class MaterialExpressionCurveAtlasRowParameter extends MaterialExpressionScalarParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Curve: CurveLinearColor;
        Atlas: CurveLinearColorAtlas;
        InputTime: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCurveAtlasRowParameter;
        static Load(InName: string): MaterialExpressionCurveAtlasRowParameter;
    }
    
    class CustomInput {
        constructor(InputName: string, Input: ExpressionInput);
        InputName: string;
        Input: ExpressionInput;
    }
    
    class MaterialExpressionCustom extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Code: string;
        OutputType: number;
        Description: string;
        Inputs: TArray<CustomInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionCustom;
        static Load(InName: string): MaterialExpressionCustom;
    }
    
    class MaterialExpressionDDX extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDDX;
        static Load(InName: string): MaterialExpressionDDX;
    }
    
    class MaterialExpressionDDY extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDDY;
        static Load(InName: string): MaterialExpressionDDY;
    }
    
    class MaterialExpressionDecalDerivative extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalDerivative;
        static Load(InName: string): MaterialExpressionDecalDerivative;
    }
    
    class MaterialExpressionDecalLifetimeOpacity extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalLifetimeOpacity;
        static Load(InName: string): MaterialExpressionDecalLifetimeOpacity;
    }
    
    class MaterialExpressionDecalMipmapLevel extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureSize: ExpressionInput;
        ConstWidth: number;
        ConstHeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDecalMipmapLevel;
        static Load(InName: string): MaterialExpressionDecalMipmapLevel;
    }
    
    class MaterialExpressionDeltaTime extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDeltaTime;
        static Load(InName: string): MaterialExpressionDeltaTime;
    }
    
    class MaterialExpressionDepthFade extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InOpacity: ExpressionInput;
        FadeDistance: ExpressionInput;
        OpacityDefault: number;
        FadeDistanceDefault: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDepthFade;
        static Load(InName: string): MaterialExpressionDepthFade;
    }
    
    class MaterialExpressionDepthOfFieldFunction extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FunctionValue: number;
        Depth: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDepthOfFieldFunction;
        static Load(InName: string): MaterialExpressionDepthOfFieldFunction;
    }
    
    class MaterialExpressionDeriveNormalZ extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InXY: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDeriveNormalZ;
        static Load(InName: string): MaterialExpressionDeriveNormalZ;
    }
    
    class MaterialExpressionDesaturation extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        Fraction: ExpressionInput;
        LuminanceFactors: LinearColor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDesaturation;
        static Load(InName: string): MaterialExpressionDesaturation;
    }
    
    class MaterialExpressionDistance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistance;
        static Load(InName: string): MaterialExpressionDistance;
    }
    
    class MaterialExpressionDistanceCullFade extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceCullFade;
        static Load(InName: string): MaterialExpressionDistanceCullFade;
    }
    
    class MaterialExpressionDistanceFieldGradient extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceFieldGradient;
        static Load(InName: string): MaterialExpressionDistanceFieldGradient;
    }
    
    class MaterialExpressionDistanceToNearestSurface extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDistanceToNearestSurface;
        static Load(InName: string): MaterialExpressionDistanceToNearestSurface;
    }
    
    class MaterialExpressionDivide extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDivide;
        static Load(InName: string): MaterialExpressionDivide;
    }
    
    class MaterialExpressionDotProduct extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDotProduct;
        static Load(InName: string): MaterialExpressionDotProduct;
    }
    
    class MaterialExpressionDynamicParameter extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamNames: TArray<string>;
        DefaultValue: LinearColor;
        ParameterIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionDynamicParameter;
        static Load(InName: string): MaterialExpressionDynamicParameter;
    }
    
    class MaterialExpressionEyeAdaptation extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionEyeAdaptation;
        static Load(InName: string): MaterialExpressionEyeAdaptation;
    }
    
    class MaterialExpressionFeatureLevelSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: ExpressionInput;
        Inputs: FixSizeArray<ExpressionInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFeatureLevelSwitch;
        static Load(InName: string): MaterialExpressionFeatureLevelSwitch;
    }
    
    class MaterialExpressionFloor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFloor;
        static Load(InName: string): MaterialExpressionFloor;
    }
    
    class MaterialExpressionFmod extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFmod;
        static Load(InName: string): MaterialExpressionFmod;
    }
    
    class MaterialExpressionFontSample extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Font: Font;
        FontTexturePage: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFontSample;
        static Load(InName: string): MaterialExpressionFontSample;
    }
    
    class MaterialExpressionFontSampleParameter extends MaterialExpressionFontSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFontSampleParameter;
        static Load(InName: string): MaterialExpressionFontSampleParameter;
    }
    
    class MaterialExpressionFrac extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFrac;
        static Load(InName: string): MaterialExpressionFrac;
    }
    
    class MaterialExpressionFresnel extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExponentIn: ExpressionInput;
        Exponent: number;
        BaseReflectFractionIn: ExpressionInput;
        BaseReflectFraction: number;
        Normal: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFresnel;
        static Load(InName: string): MaterialExpressionFresnel;
    }
    
    class MaterialExpressionFunctionInput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Preview: ExpressionInput;
        InputName: string;
        Description: string;
        Id: Guid;
        InputType: number;
        PreviewValue: Vector4;
        bUsePreviewValueAsDefault: boolean;
        SortPriority: number;
        bCompilingFunctionPreview: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFunctionInput;
        static Load(InName: string): MaterialExpressionFunctionInput;
    }
    
    class MaterialExpressionFunctionOutput extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OutputName: string;
        Description: string;
        SortPriority: number;
        A: ExpressionInput;
        bLastPreviewed: boolean;
        Id: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionFunctionOutput;
        static Load(InName: string): MaterialExpressionFunctionOutput;
    }
    
    class MaterialExpressionGetMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialAttributes: MaterialAttributesInput;
        AttributeGetTypes: TArray<Guid>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGetMaterialAttributes;
        static Load(InName: string): MaterialExpressionGetMaterialAttributes;
    }
    
    class MaterialExpressionGIReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: ExpressionInput;
        StaticIndirect: ExpressionInput;
        DynamicIndirect: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionGIReplace;
        static Load(InName: string): MaterialExpressionGIReplace;
    }
    
    class MaterialExpressionHairAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionHairAttributes;
        static Load(InName: string): MaterialExpressionHairAttributes;
    }
    
    class MaterialExpressionIf extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        AGreaterThanB: ExpressionInput;
        AEqualsB: ExpressionInput;
        ALessThanB: ExpressionInput;
        EqualsThreshold: number;
        ConstB: number;
        ConstAEqualsB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionIf;
        static Load(InName: string): MaterialExpressionIf;
    }
    
    class MaterialExpressionLightmapUVs extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightmapUVs;
        static Load(InName: string): MaterialExpressionLightmapUVs;
    }
    
    class MaterialExpressionLightmassReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Realtime: ExpressionInput;
        Lightmass: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightmassReplace;
        static Load(InName: string): MaterialExpressionLightmassReplace;
    }
    
    class MaterialExpressionLightVector extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLightVector;
        static Load(InName: string): MaterialExpressionLightVector;
    }
    
    class MaterialExpressionLinearInterpolate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        Alpha: ExpressionInput;
        ConstA: number;
        ConstB: number;
        ConstAlpha: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLinearInterpolate;
        static Load(InName: string): MaterialExpressionLinearInterpolate;
    }
    
    class MaterialExpressionLogarithm10 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLogarithm10;
        static Load(InName: string): MaterialExpressionLogarithm10;
    }
    
    class MaterialExpressionLogarithm2 extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        X: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionLogarithm2;
        static Load(InName: string): MaterialExpressionLogarithm2;
    }
    
    class MaterialExpressionMakeMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseColor: ExpressionInput;
        Metallic: ExpressionInput;
        Specular: ExpressionInput;
        Roughness: ExpressionInput;
        EmissiveColor: ExpressionInput;
        Opacity: ExpressionInput;
        OpacityMask: ExpressionInput;
        Normal: ExpressionInput;
        WorldPositionOffset: ExpressionInput;
        WorldDisplacement: ExpressionInput;
        TessellationMultiplier: ExpressionInput;
        SubsurfaceColor: ExpressionInput;
        ClearCoat: ExpressionInput;
        ClearCoatRoughness: ExpressionInput;
        AmbientOcclusion: ExpressionInput;
        Refraction: ExpressionInput;
        CustomizedUVs: FixSizeArray<ExpressionInput>;
        PixelDepthOffset: ExpressionInput;
        ShadingModel: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMakeMaterialAttributes;
        static Load(InName: string): MaterialExpressionMakeMaterialAttributes;
    }
    
    class MaterialExpressionMapARPassthroughCameraUV extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMapARPassthroughCameraUV;
        static Load(InName: string): MaterialExpressionMapARPassthroughCameraUV;
    }
    
    class FunctionExpressionInput {
        constructor(ExpressionInput: MaterialExpressionFunctionInput, ExpressionInputId: Guid, Input: ExpressionInput);
        ExpressionInput: MaterialExpressionFunctionInput;
        ExpressionInputId: Guid;
        Input: ExpressionInput;
    }
    
    class FunctionExpressionOutput {
        constructor(ExpressionOutput: MaterialExpressionFunctionOutput, ExpressionOutputId: Guid, Output: ExpressionOutput);
        ExpressionOutput: MaterialExpressionFunctionOutput;
        ExpressionOutputId: Guid;
        Output: ExpressionOutput;
    }
    
    class MaterialExpressionMaterialFunctionCall extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaterialFunction: MaterialFunctionInterface;
        FunctionInputs: TArray<FunctionExpressionInput>;
        FunctionOutputs: TArray<FunctionExpressionOutput>;
        FunctionParameterInfo: MaterialParameterInfo;
        SetMaterialFunction(NewMaterialFunction: MaterialFunctionInterface): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialFunctionCall;
        static Load(InName: string): MaterialExpressionMaterialFunctionCall;
    }
    
    class MaterialExpressionMaterialAttributeLayers extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: Guid;
        Input: MaterialAttributesInput;
        DefaultLayers: MaterialLayersFunctions;
        LayerCallers: TArray<MaterialExpressionMaterialFunctionCall>;
        NumActiveLayerCallers: number;
        BlendCallers: TArray<MaterialExpressionMaterialFunctionCall>;
        NumActiveBlendCallers: number;
        bIsLayerGraphBuilt: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialAttributeLayers;
        static Load(InName: string): MaterialExpressionMaterialAttributeLayers;
    }
    
    class MaterialExpressionMaterialLayerOutput extends MaterialExpressionFunctionOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialLayerOutput;
        static Load(InName: string): MaterialExpressionMaterialLayerOutput;
    }
    
    class MaterialExpressionMaterialProxyReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Realtime: ExpressionInput;
        MaterialProxy: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMaterialProxyReplace;
        static Load(InName: string): MaterialExpressionMaterialProxyReplace;
    }
    
    class MaterialExpressionMax extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMax;
        static Load(InName: string): MaterialExpressionMax;
    }
    
    class MaterialExpressionMin extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMin;
        static Load(InName: string): MaterialExpressionMin;
    }
    
    class MaterialExpressionMultiply extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionMultiply;
        static Load(InName: string): MaterialExpressionMultiply;
    }
    
    class MaterialExpressionNoise extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: ExpressionInput;
        FilterWidth: ExpressionInput;
        Scale: number;
        Quality: number;
        NoiseFunction: number;
        bTurbulence: boolean;
        Levels: number;
        OutputMin: number;
        OutputMax: number;
        LevelScale: number;
        bTiling: boolean;
        RepeatSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNoise;
        static Load(InName: string): MaterialExpressionNoise;
    }
    
    class MaterialExpressionNormalize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorInput: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionNormalize;
        static Load(InName: string): MaterialExpressionNormalize;
    }
    
    class MaterialExpressionObjectBounds extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectBounds;
        static Load(InName: string): MaterialExpressionObjectBounds;
    }
    
    class MaterialExpressionObjectOrientation extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectOrientation;
        static Load(InName: string): MaterialExpressionObjectOrientation;
    }
    
    class MaterialExpressionObjectPositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectPositionWS;
        static Load(InName: string): MaterialExpressionObjectPositionWS;
    }
    
    class MaterialExpressionObjectRadius extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionObjectRadius;
        static Load(InName: string): MaterialExpressionObjectRadius;
    }
    
    class MaterialExpressionOneMinus extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionOneMinus;
        static Load(InName: string): MaterialExpressionOneMinus;
    }
    
    class MaterialExpressionPanner extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinate: ExpressionInput;
        Time: ExpressionInput;
        Speed: ExpressionInput;
        SpeedX: number;
        SpeedY: number;
        ConstCoordinate: number;
        bFractionalPart: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPanner;
        static Load(InName: string): MaterialExpressionPanner;
    }
    
    class MaterialExpressionParticleColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleColor;
        static Load(InName: string): MaterialExpressionParticleColor;
    }
    
    class MaterialExpressionParticleDirection extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleDirection;
        static Load(InName: string): MaterialExpressionParticleDirection;
    }
    
    class MaterialExpressionParticleMacroUV extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleMacroUV;
        static Load(InName: string): MaterialExpressionParticleMacroUV;
    }
    
    class MaterialExpressionParticleMotionBlurFade extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleMotionBlurFade;
        static Load(InName: string): MaterialExpressionParticleMotionBlurFade;
    }
    
    class MaterialExpressionParticlePositionWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticlePositionWS;
        static Load(InName: string): MaterialExpressionParticlePositionWS;
    }
    
    class MaterialExpressionParticleRadius extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRadius;
        static Load(InName: string): MaterialExpressionParticleRadius;
    }
    
    class MaterialExpressionParticleRandom extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRandom;
        static Load(InName: string): MaterialExpressionParticleRandom;
    }
    
    class MaterialExpressionParticleRelativeTime extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleRelativeTime;
        static Load(InName: string): MaterialExpressionParticleRelativeTime;
    }
    
    class MaterialExpressionParticleSize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSize;
        static Load(InName: string): MaterialExpressionParticleSize;
    }
    
    class MaterialExpressionParticleSpeed extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSpeed;
        static Load(InName: string): MaterialExpressionParticleSpeed;
    }
    
    class MaterialExpressionParticleSubUV extends MaterialExpressionTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bBlend: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSubUV;
        static Load(InName: string): MaterialExpressionParticleSubUV;
    }
    
    class MaterialExpressionParticleSubUVProperties extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionParticleSubUVProperties;
        static Load(InName: string): MaterialExpressionParticleSubUVProperties;
    }
    
    class MaterialExpressionPerInstanceFadeAmount extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceFadeAmount;
        static Load(InName: string): MaterialExpressionPerInstanceFadeAmount;
    }
    
    class MaterialExpressionPerInstanceRandom extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPerInstanceRandom;
        static Load(InName: string): MaterialExpressionPerInstanceRandom;
    }
    
    class MaterialExpressionPixelDepth extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPixelDepth;
        static Load(InName: string): MaterialExpressionPixelDepth;
    }
    
    class MaterialExpressionPixelNormalWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPixelNormalWS;
        static Load(InName: string): MaterialExpressionPixelNormalWS;
    }
    
    class MaterialExpressionPower extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Base: ExpressionInput;
        Exponent: ExpressionInput;
        ConstExponent: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPower;
        static Load(InName: string): MaterialExpressionPower;
    }
    
    class MaterialExpressionPrecomputedAOMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPrecomputedAOMask;
        static Load(InName: string): MaterialExpressionPrecomputedAOMask;
    }
    
    class MaterialExpressionPreSkinnedLocalBounds extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedLocalBounds;
        static Load(InName: string): MaterialExpressionPreSkinnedLocalBounds;
    }
    
    class MaterialExpressionPreSkinnedNormal extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedNormal;
        static Load(InName: string): MaterialExpressionPreSkinnedNormal;
    }
    
    class MaterialExpressionPreSkinnedPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreSkinnedPosition;
        static Load(InName: string): MaterialExpressionPreSkinnedPosition;
    }
    
    class MaterialExpressionPreviousFrameSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurrentFrame: ExpressionInput;
        PreviousFrame: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionPreviousFrameSwitch;
        static Load(InName: string): MaterialExpressionPreviousFrameSwitch;
    }
    
    class MaterialExpressionQualitySwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: ExpressionInput;
        Inputs: FixSizeArray<ExpressionInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionQualitySwitch;
        static Load(InName: string): MaterialExpressionQualitySwitch;
    }
    
    class MaterialExpressionRayTracingQualitySwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Normal: ExpressionInput;
        RayTraced: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRayTracingQualitySwitch;
        static Load(InName: string): MaterialExpressionRayTracingQualitySwitch;
    }
    
    class MaterialExpressionReflectionVectorWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CustomWorldNormal: ExpressionInput;
        bNormalizeCustomWorldNormal: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReflectionVectorWS;
        static Load(InName: string): MaterialExpressionReflectionVectorWS;
    }
    
    class MaterialExpressionReroute extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionReroute;
        static Load(InName: string): MaterialExpressionReroute;
    }
    
    class MaterialExpressionRotateAboutAxis extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NormalizedRotationAxis: ExpressionInput;
        RotationAngle: ExpressionInput;
        PivotPoint: ExpressionInput;
        Position: ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRotateAboutAxis;
        static Load(InName: string): MaterialExpressionRotateAboutAxis;
    }
    
    class MaterialExpressionRotator extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinate: ExpressionInput;
        Time: ExpressionInput;
        CenterX: number;
        CenterY: number;
        Speed: number;
        ConstCoordinate: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRotator;
        static Load(InName: string): MaterialExpressionRotator;
    }
    
    class MaterialExpressionRound extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRound;
        static Load(InName: string): MaterialExpressionRound;
    }
    
    class MaterialExpressionRuntimeVirtualTextureOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseColor: ExpressionInput;
        Specular: ExpressionInput;
        Roughness: ExpressionInput;
        Normal: ExpressionInput;
        WorldHeight: ExpressionInput;
        Opacity: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureOutput;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureOutput;
    }
    
    class MaterialExpressionRuntimeVirtualTextureReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: ExpressionInput;
        VirtualTextureOutput: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureReplace;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureReplace;
    }
    
    class MaterialExpressionRuntimeVirtualTextureSample extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: ExpressionInput;
        MipValue: ExpressionInput;
        VirtualTexture: RuntimeVirtualTexture;
        MaterialType: ERuntimeVirtualTextureMaterialType;
        bSinglePhysicalSpace: boolean;
        MipValueMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureSample;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureSample;
    }
    
    class MaterialExpressionRuntimeVirtualTextureSampleParameter extends MaterialExpressionRuntimeVirtualTextureSample {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParameterName: string;
        ExpressionGUID: Guid;
        Group: string;
        SortPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionRuntimeVirtualTextureSampleParameter;
        static Load(InName: string): MaterialExpressionRuntimeVirtualTextureSampleParameter;
    }
    
    class MaterialExpressionSaturate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSaturate;
        static Load(InName: string): MaterialExpressionSaturate;
    }
    
    class MaterialExpressionSceneColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputMode: number;
        Input: ExpressionInput;
        OffsetFraction: ExpressionInput;
        ConstInput: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneColor;
        static Load(InName: string): MaterialExpressionSceneColor;
    }
    
    class MaterialExpressionSceneDepth extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputMode: number;
        Input: ExpressionInput;
        Coordinates: ExpressionInput;
        ConstInput: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneDepth;
        static Load(InName: string): MaterialExpressionSceneDepth;
    }
    
    class MaterialExpressionSceneTexelSize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneTexelSize;
        static Load(InName: string): MaterialExpressionSceneTexelSize;
    }
    
    class MaterialExpressionSceneTexture extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Coordinates: ExpressionInput;
        SceneTextureId: number;
        bFiltered: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSceneTexture;
        static Load(InName: string): MaterialExpressionSceneTexture;
    }
    
    class MaterialExpressionScreenPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionScreenPosition;
        static Load(InName: string): MaterialExpressionScreenPosition;
    }
    
    class MaterialExpressionSetMaterialAttributes extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Inputs: TArray<ExpressionInput>;
        AttributeSetTypes: TArray<Guid>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSetMaterialAttributes;
        static Load(InName: string): MaterialExpressionSetMaterialAttributes;
    }
    
    class MaterialExpressionShaderStageSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PixelShader: ExpressionInput;
        VertexShader: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShaderStageSwitch;
        static Load(InName: string): MaterialExpressionShaderStageSwitch;
    }
    
    class MaterialExpressionShadingModel extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShadingModel: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadingModel;
        static Load(InName: string): MaterialExpressionShadingModel;
    }
    
    class MaterialExpressionShadingPathSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: ExpressionInput;
        Inputs: FixSizeArray<ExpressionInput>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadingPathSwitch;
        static Load(InName: string): MaterialExpressionShadingPathSwitch;
    }
    
    class MaterialExpressionShadowReplace extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Default: ExpressionInput;
        Shadow: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionShadowReplace;
        static Load(InName: string): MaterialExpressionShadowReplace;
    }
    
    class MaterialExpressionSign extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSign;
        static Load(InName: string): MaterialExpressionSign;
    }
    
    class MaterialExpressionSine extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSine;
        static Load(InName: string): MaterialExpressionSine;
    }
    
    class MaterialExpressionSingleLayerWaterMaterialOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScatteringCoefficients: ExpressionInput;
        AbsorptionCoefficients: ExpressionInput;
        PhaseG: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSingleLayerWaterMaterialOutput;
        static Load(InName: string): MaterialExpressionSingleLayerWaterMaterialOutput;
    }
    
    class MaterialExpressionSkyAtmosphereLightDirection extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightDirection;
        static Load(InName: string): MaterialExpressionSkyAtmosphereLightDirection;
    }
    
    class MaterialExpressionSkyAtmosphereLightIlluminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightIndex: number;
        WorldPosition: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightIlluminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereLightIlluminance;
    }
    
    class MaterialExpressionSkyAtmosphereLightDiskLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereLightDiskLuminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereLightDiskLuminance;
    }
    
    class MaterialExpressionSkyAtmosphereAerialPerspective extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WorldPosition: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereAerialPerspective;
        static Load(InName: string): MaterialExpressionSkyAtmosphereAerialPerspective;
    }
    
    class MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereDistantLightScatteredLuminance;
    }
    
    class MaterialExpressionSkyAtmosphereViewLuminance extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSkyAtmosphereViewLuminance;
        static Load(InName: string): MaterialExpressionSkyAtmosphereViewLuminance;
    }
    
    class MaterialExpressionSobol extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Cell: ExpressionInput;
        Index: ExpressionInput;
        Seed: ExpressionInput;
        ConstIndex: number;
        ConstSeed: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSobol;
        static Load(InName: string): MaterialExpressionSobol;
    }
    
    class MaterialExpressionSpeedTree extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryInput: ExpressionInput;
        WindInput: ExpressionInput;
        LODInput: ExpressionInput;
        ExtraBendWS: ExpressionInput;
        GeometryType: number;
        WindType: number;
        LODType: number;
        BillboardThreshold: number;
        bAccurateWindVelocities: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSpeedTree;
        static Load(InName: string): MaterialExpressionSpeedTree;
    }
    
    class MaterialExpressionSphereMask extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        Radius: ExpressionInput;
        Hardness: ExpressionInput;
        AttenuationRadius: number;
        HardnessPercent: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSphereMask;
        static Load(InName: string): MaterialExpressionSphereMask;
    }
    
    class MaterialExpressionSphericalParticleOpacity extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Density: ExpressionInput;
        ConstantDensity: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSphericalParticleOpacity;
        static Load(InName: string): MaterialExpressionSphericalParticleOpacity;
    }
    
    class MaterialExpressionSquareRoot extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSquareRoot;
        static Load(InName: string): MaterialExpressionSquareRoot;
    }
    
    class MaterialExpressionStaticBool extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Value: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticBool;
        static Load(InName: string): MaterialExpressionStaticBool;
    }
    
    class MaterialExpressionStaticBoolParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticBoolParameter;
        static Load(InName: string): MaterialExpressionStaticBoolParameter;
    }
    
    class MaterialExpressionStaticComponentMaskParameter extends MaterialExpressionParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        DefaultR: boolean;
        DefaultG: boolean;
        DefaultB: boolean;
        DefaultA: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticComponentMaskParameter;
        static Load(InName: string): MaterialExpressionStaticComponentMaskParameter;
    }
    
    class MaterialExpressionStaticSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultValue: boolean;
        A: ExpressionInput;
        B: ExpressionInput;
        Value: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticSwitch;
        static Load(InName: string): MaterialExpressionStaticSwitch;
    }
    
    class MaterialExpressionStaticSwitchParameter extends MaterialExpressionStaticBoolParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionStaticSwitchParameter;
        static Load(InName: string): MaterialExpressionStaticSwitchParameter;
    }
    
    class MaterialExpressionSubtract extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        A: ExpressionInput;
        B: ExpressionInput;
        ConstA: number;
        ConstB: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSubtract;
        static Load(InName: string): MaterialExpressionSubtract;
    }
    
    class MaterialExpressionTangent extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTangent;
        static Load(InName: string): MaterialExpressionTangent;
    }
    
    class MaterialExpressionTangentOutput extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTangentOutput;
        static Load(InName: string): MaterialExpressionTangentOutput;
    }
    
    class MaterialExpressionTemporalSobol extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Index: ExpressionInput;
        Seed: ExpressionInput;
        ConstIndex: number;
        ConstSeed: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTemporalSobol;
        static Load(InName: string): MaterialExpressionTemporalSobol;
    }
    
    class MaterialExpressionTextureCoordinate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CoordinateIndex: number;
        UTiling: number;
        VTiling: number;
        UnMirrorU: boolean;
        UnMirrorV: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureCoordinate;
        static Load(InName: string): MaterialExpressionTextureCoordinate;
    }
    
    class MaterialExpressionTextureObject extends MaterialExpressionTextureBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureObject;
        static Load(InName: string): MaterialExpressionTextureObject;
    }
    
    class MaterialExpressionTextureObjectParameter extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureObjectParameter;
        static Load(InName: string): MaterialExpressionTextureObjectParameter;
    }
    
    class MaterialExpressionTextureProperty extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureObject: ExpressionInput;
        Property: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureProperty;
        static Load(InName: string): MaterialExpressionTextureProperty;
    }
    
    class MaterialExpressionTextureSampleParameter2DArray extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameter2DArray;
        static Load(InName: string): MaterialExpressionTextureSampleParameter2DArray;
    }
    
    class MaterialExpressionTextureSampleParameterCube extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterCube;
        static Load(InName: string): MaterialExpressionTextureSampleParameterCube;
    }
    
    class MaterialExpressionTextureSampleParameterSubUV extends MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bBlend: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterSubUV;
        static Load(InName: string): MaterialExpressionTextureSampleParameterSubUV;
    }
    
    class MaterialExpressionTextureSampleParameterVolume extends MaterialExpressionTextureSampleParameter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTextureSampleParameterVolume;
        static Load(InName: string): MaterialExpressionTextureSampleParameterVolume;
    }
    
    class MaterialExpressionTime extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIgnorePause: boolean;
        bOverride_Period: boolean;
        Period: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTime;
        static Load(InName: string): MaterialExpressionTime;
    }
    
    class MaterialExpressionTransform extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        TransformSourceType: number;
        TransformType: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTransform;
        static Load(InName: string): MaterialExpressionTransform;
    }
    
    class MaterialExpressionTransformPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        TransformSourceType: number;
        TransformType: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTransformPosition;
        static Load(InName: string): MaterialExpressionTransformPosition;
    }
    
    class MaterialExpressionTruncate extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTruncate;
        static Load(InName: string): MaterialExpressionTruncate;
    }
    
    class MaterialExpressionTwoSidedSign extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionTwoSidedSign;
        static Load(InName: string): MaterialExpressionTwoSidedSign;
    }
    
    class MaterialExpressionVectorNoise extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: ExpressionInput;
        NoiseFunction: number;
        Quality: number;
        bTiling: boolean;
        TileSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVectorNoise;
        static Load(InName: string): MaterialExpressionVectorNoise;
    }
    
    class MaterialExpressionVertexColor extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexColor;
        static Load(InName: string): MaterialExpressionVertexColor;
    }
    
    class MaterialExpressionVertexInterpolator extends MaterialExpressionCustomOutput {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Input: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexInterpolator;
        static Load(InName: string): MaterialExpressionVertexInterpolator;
    }
    
    class MaterialExpressionVertexNormalWS extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVertexNormalWS;
        static Load(InName: string): MaterialExpressionVertexNormalWS;
    }
    
    class MaterialExpressionViewProperty extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Property: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewProperty;
        static Load(InName: string): MaterialExpressionViewProperty;
    }
    
    class MaterialExpressionViewSize extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionViewSize;
        static Load(InName: string): MaterialExpressionViewSize;
    }
    
    class MaterialExpressionVirtualTextureFeatureSwitch extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        No: ExpressionInput;
        Yes: ExpressionInput;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionVirtualTextureFeatureSwitch;
        static Load(InName: string): MaterialExpressionVirtualTextureFeatureSwitch;
    }
    
    class MaterialExpressionWorldPosition extends MaterialExpression {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WorldPositionShaderOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionWorldPosition;
        static Load(InName: string): MaterialExpressionWorldPosition;
    }
    
    class MaterialFunctionMaterialLayer extends MaterialFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayer;
        static Load(InName: string): MaterialFunctionMaterialLayer;
    }
    
    class MaterialFunctionMaterialLayerInstance extends MaterialFunctionInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerInstance;
        static Load(InName: string): MaterialFunctionMaterialLayerInstance;
    }
    
    class MaterialFunctionMaterialLayerBlend extends MaterialFunction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlend;
        static Load(InName: string): MaterialFunctionMaterialLayerBlend;
    }
    
    class MaterialFunctionMaterialLayerBlendInstance extends MaterialFunctionInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialFunctionMaterialLayerBlendInstance;
        static Load(InName: string): MaterialFunctionMaterialLayerBlendInstance;
    }
    
    class MaterialInstanceActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetActors: TArray<Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialInstanceActor;
        static Load(InName: string): MaterialInstanceActor;
    }
    
    class MatineeActorCameraAnim extends MatineeActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraAnim: CameraAnim;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeActorCameraAnim;
        static Load(InName: string): MatineeActorCameraAnim;
    }
    
    class MatineeAnimInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeAnimInterface;
        static Load(InName: string): MatineeAnimInterface;
    }
    
    class MatineeInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MatineeInterface;
        static Load(InName: string): MatineeInterface;
    }
    
    class MeshMergeCullingVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshMergeCullingVolume;
        static Load(InName: string): MeshMergeCullingVolume;
    }
    
    class MeshSimplificationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshReductionModuleName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshSimplificationSettings;
        static Load(InName: string): MeshSimplificationSettings;
    }
    
    enum EVertexPaintAxis { X, Y, Z, EVertexPaintAxis_MAX}
    class MeshVertexPainterKismetLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RemovePaintedVertices(StaticMeshComponent: StaticMeshComponent): void;
        static PaintVerticesSingleColor(StaticMeshComponent: StaticMeshComponent, FillColor: LinearColor, bConvertToSRGB: boolean): void;
        static PaintVerticesLerpAlongAxis(StaticMeshComponent: StaticMeshComponent, StartColor: LinearColor, EndColor: LinearColor, Axis: EVertexPaintAxis, bConvertToSRGB: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshVertexPainterKismetLibrary;
        static Load(InName: string): MeshVertexPainterKismetLibrary;
    }
    
    class PurchaseInfo {
        constructor(Identifier: string, DisplayName: string, DisplayDescription: string, DisplayPrice: string);
        Identifier: string;
        DisplayName: string;
        DisplayDescription: string;
        DisplayPrice: string;
    }
    
    class MicroTransactionBase extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AvailableProducts: TArray<PurchaseInfo>;
        LastError: string;
        LastErrorSolution: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MicroTransactionBase;
        static Load(InName: string): MicroTransactionBase;
    }
    
    class NavAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavAgentInterface;
        static Load(InName: string): NavAgentInterface;
    }
    
    class NavEdgeProviderInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavEdgeProviderInterface;
        static Load(InName: string): NavEdgeProviderInterface;
    }
    
    class NavigationDataInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavigationDataInterface;
        static Load(InName: string): NavigationDataInterface;
    }
    
    class NullNavSysConfig extends NavigationSystemConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NullNavSysConfig;
        static Load(InName: string): NullNavSysConfig;
    }
    
    class NavPathObserverInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavPathObserverInterface;
        static Load(InName: string): NavPathObserverInterface;
    }
    
    class NavRelevantInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavRelevantInterface;
        static Load(InName: string): NavRelevantInterface;
    }
    
    class SimulatedClientNetConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SimulatedClientNetConnection;
        static Load(InName: string): SimulatedClientNetConnection;
    }
    
    class NetworkPredictionInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetworkPredictionInterface;
        static Load(InName: string): NetworkPredictionInterface;
    }
    
    class NetworkEmulationProfileDescription {
        constructor(ProfileName: string, ToolTip: string);
        ProfileName: string;
        ToolTip: string;
    }
    
    class NetworkSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bVerifyPeer: boolean;
        bEnableMultiplayerWorldOriginRebasing: boolean;
        MaxRepArraySize: number;
        MaxRepArrayMemory: number;
        NetworkEmulationProfiles: TArray<NetworkEmulationProfileDescription>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetworkSettings;
        static Load(InName: string): NetworkSettings;
    }
    
    class NodeMappingProviderInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NodeMappingProviderInterface;
        static Load(InName: string): NodeMappingProviderInterface;
    }
    
    class Note extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Text: string;
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Note;
        static Load(InName: string): Note;
    }
    
    class ObjectLibrary extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectBaseClass: Class;
        bHasBlueprintClasses: boolean;
        Objects: TArray<Object>;
        WeakObjects: TArray<TWeakObjectPtr<Object>>;
        bUseWeakReferences: boolean;
        bIsFullyLoaded: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectLibrary;
        static Load(InName: string): ObjectLibrary;
    }
    
    class ObjectReferencer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ReferencedObjects: TArray<Object>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectReferencer;
        static Load(InName: string): ObjectReferencer;
    }
    
    class OnlineBlueprintCallProxyBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Activate(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBlueprintCallProxyBase;
        static Load(InName: string): OnlineBlueprintCallProxyBase;
    }
    
    class OnlineEngineInterface extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineEngineInterface;
        static Load(InName: string): OnlineEngineInterface;
    }
    
    class PackageMapClient extends PackageMap {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackageMapClient;
        static Load(InName: string): PackageMapClient;
    }
    
    class PainCausingVolume extends PhysicsVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPainCausing: boolean;
        DamagePerSec: number;
        DamageType: Class;
        PainInterval: number;
        bEntryPain: boolean;
        BACKUP_bPainCausing: boolean;
        DamageInstigator: Controller;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PainCausingVolume;
        static Load(InName: string): PainCausingVolume;
    }
    
    class ParticleModuleAccelerationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAlwaysInWorldSpace: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationBase;
        static Load(InName: string): ParticleModuleAccelerationBase;
    }
    
    class ParticleModuleAcceleration extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Acceleration: RawDistributionVector;
        bApplyOwnerScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAcceleration;
        static Load(InName: string): ParticleModuleAcceleration;
    }
    
    class ParticleModuleAccelerationConstant extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Acceleration: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationConstant;
        static Load(InName: string): ParticleModuleAccelerationConstant;
    }
    
    class ParticleModuleAccelerationDrag extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DragCoefficient: DistributionFloat;
        DragCoefficientRaw: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationDrag;
        static Load(InName: string): ParticleModuleAccelerationDrag;
    }
    
    class ParticleModuleAccelerationDragScaleOverLife extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DragScale: DistributionFloat;
        DragScaleRaw: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationDragScaleOverLife;
        static Load(InName: string): ParticleModuleAccelerationDragScaleOverLife;
    }
    
    class ParticleModuleAccelerationOverLifetime extends ParticleModuleAccelerationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AccelOverLife: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAccelerationOverLifetime;
        static Load(InName: string): ParticleModuleAccelerationOverLifetime;
    }
    
    class ParticleModuleAttractorBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorBase;
        static Load(InName: string): ParticleModuleAttractorBase;
    }
    
    class ParticleModuleAttractorLine extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EndPoint0: Vector;
        EndPoint1: Vector;
        Range: RawDistributionFloat;
        Strength: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorLine;
        static Load(InName: string): ParticleModuleAttractorLine;
    }
    
    class ParticleModuleAttractorParticle extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        Range: RawDistributionFloat;
        bStrengthByDistance: boolean;
        Strength: RawDistributionFloat;
        bAffectBaseVelocity: boolean;
        SelectionMethod: number;
        bRenewSource: boolean;
        bInheritSourceVel: boolean;
        LastSelIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorParticle;
        static Load(InName: string): ParticleModuleAttractorParticle;
    }
    
    class ParticleModuleAttractorPoint extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: RawDistributionVector;
        Range: RawDistributionFloat;
        Strength: RawDistributionFloat;
        StrengthByDistance: boolean;
        bAffectBaseVelocity: boolean;
        bOverrideVelocity: boolean;
        bUseWorldSpacePosition: boolean;
        Positive_X: boolean;
        Positive_Y: boolean;
        Positive_Z: boolean;
        Negative_X: boolean;
        Negative_Y: boolean;
        Negative_Z: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorPoint;
        static Load(InName: string): ParticleModuleAttractorPoint;
    }
    
    class ParticleModuleAttractorPointGravity extends ParticleModuleAttractorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Position: Vector;
        Radius: number;
        Strength: DistributionFloat;
        StrengthRaw: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleAttractorPointGravity;
        static Load(InName: string): ParticleModuleAttractorPointGravity;
    }
    
    class ParticleModuleBeamBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamBase;
        static Load(InName: string): ParticleModuleBeamBase;
    }
    
    class BeamModifierOptions {
        constructor(bModify: boolean, bScale: boolean, bLock: boolean);
        bModify: boolean;
        bScale: boolean;
        bLock: boolean;
    }
    
    class ParticleModuleBeamModifier extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ModifierType: number;
        PositionOptions: BeamModifierOptions;
        Position: RawDistributionVector;
        TangentOptions: BeamModifierOptions;
        Tangent: RawDistributionVector;
        bAbsoluteTangent: boolean;
        StrengthOptions: BeamModifierOptions;
        Strength: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamModifier;
        static Load(InName: string): ParticleModuleBeamModifier;
    }
    
    class ParticleModuleBeamNoise extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLowFreq_Enabled: boolean;
        Frequency: number;
        Frequency_LowRange: number;
        NoiseRange: RawDistributionVector;
        NoiseRangeScale: RawDistributionFloat;
        bNRScaleEmitterTime: boolean;
        NoiseSpeed: RawDistributionVector;
        bSmooth: boolean;
        NoiseLockRadius: number;
        bNoiseLock: boolean;
        bOscillate: boolean;
        NoiseLockTime: number;
        NoiseTension: number;
        bUseNoiseTangents: boolean;
        NoiseTangentStrength: RawDistributionFloat;
        NoiseTessellation: number;
        bTargetNoise: boolean;
        FrequencyDistance: number;
        bApplyNoiseScale: boolean;
        NoiseScale: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamNoise;
        static Load(InName: string): ParticleModuleBeamNoise;
    }
    
    class ParticleModuleBeamSource extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMethod: number;
        SourceName: string;
        bSourceAbsolute: boolean;
        Source: RawDistributionVector;
        bLockSource: boolean;
        SourceTangentMethod: number;
        SourceTangent: RawDistributionVector;
        bLockSourceTangent: boolean;
        SourceStrength: RawDistributionFloat;
        bLockSourceStength: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamSource;
        static Load(InName: string): ParticleModuleBeamSource;
    }
    
    class ParticleModuleBeamTarget extends ParticleModuleBeamBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetMethod: number;
        TargetName: string;
        Target: RawDistributionVector;
        bTargetAbsolute: boolean;
        bLockTarget: boolean;
        TargetTangentMethod: number;
        TargetTangent: RawDistributionVector;
        bLockTargetTangent: boolean;
        TargetStrength: RawDistributionFloat;
        bLockTargetStength: boolean;
        LockRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleBeamTarget;
        static Load(InName: string): ParticleModuleBeamTarget;
    }
    
    class ParticleModuleCameraBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCameraBase;
        static Load(InName: string): ParticleModuleCameraBase;
    }
    
    class ParticleModuleCameraOffset extends ParticleModuleCameraBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CameraOffset: RawDistributionFloat;
        bSpawnTimeOnly: boolean;
        UpdateMethod: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCameraOffset;
        static Load(InName: string): ParticleModuleCameraOffset;
    }
    
    class ParticleModuleCollisionBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollisionBase;
        static Load(InName: string): ParticleModuleCollisionBase;
    }
    
    class ParticleModuleCollision extends ParticleModuleCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DampingFactor: RawDistributionVector;
        DampingFactorRotation: RawDistributionVector;
        MaxCollisions: RawDistributionFloat;
        CollisionCompletionOption: number;
        CollisionTypes: TArray<number>;
        bApplyPhysics: boolean;
        bIgnoreTriggerVolumes: boolean;
        ParticleMass: RawDistributionFloat;
        DirScalar: number;
        bPawnsDoNotDecrementCount: boolean;
        bOnlyVerticalNormalsDecrementCount: boolean;
        VerticalFudgeFactor: number;
        DelayAmount: RawDistributionFloat;
        bDropDetail: boolean;
        bCollideOnlyIfVisible: boolean;
        bIgnoreSourceActor: boolean;
        MaxCollisionDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollision;
        static Load(InName: string): ParticleModuleCollision;
    }
    
    class ParticleModuleCollisionGPU extends ParticleModuleCollisionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Resilience: RawDistributionFloat;
        ResilienceScaleOverLife: RawDistributionFloat;
        Friction: number;
        RandomSpread: number;
        RandomDistribution: number;
        RadiusScale: number;
        RadiusBias: number;
        Response: number;
        CollisionMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleCollisionGPU;
        static Load(InName: string): ParticleModuleCollisionGPU;
    }
    
    class ParticleModuleColorBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorBase;
        static Load(InName: string): ParticleModuleColorBase;
    }
    
    class ParticleModuleColor extends ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartColor: RawDistributionVector;
        StartAlpha: RawDistributionFloat;
        bClampAlpha: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColor;
        static Load(InName: string): ParticleModuleColor;
    }
    
    class ParticleRandomSeedInfo {
        constructor(ParameterName: string, bGetSeedFromInstance: boolean, bInstanceSeedIsIndex: boolean, bResetSeedOnEmitterLooping: boolean, bRandomlySelectSeedArray: boolean, RandomSeeds: TArray<number>);
        ParameterName: string;
        bGetSeedFromInstance: boolean;
        bInstanceSeedIsIndex: boolean;
        bResetSeedOnEmitterLooping: boolean;
        bRandomlySelectSeedArray: boolean;
        RandomSeeds: TArray<number>;
    }
    
    class ParticleModuleColor_Seeded extends ParticleModuleColor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColor_Seeded;
        static Load(InName: string): ParticleModuleColor_Seeded;
    }
    
    class ParticleModuleColorOverLife extends ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColorOverLife: RawDistributionVector;
        AlphaOverLife: RawDistributionFloat;
        bClampAlpha: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorOverLife;
        static Load(InName: string): ParticleModuleColorOverLife;
    }
    
    class ParticleModuleColorScaleOverLife extends ParticleModuleColorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ColorScaleOverLife: RawDistributionVector;
        AlphaScaleOverLife: RawDistributionFloat;
        bEmitterTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleColorScaleOverLife;
        static Load(InName: string): ParticleModuleColorScaleOverLife;
    }
    
    class ParticleModuleEventReceiverKillParticles extends ParticleModuleEventReceiverBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bStopSpawning: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverKillParticles;
        static Load(InName: string): ParticleModuleEventReceiverKillParticles;
    }
    
    class ParticleModuleEventReceiverSpawn extends ParticleModuleEventReceiverBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnCount: RawDistributionFloat;
        bUseParticleTime: boolean;
        bUsePSysLocation: boolean;
        bInheritVelocity: boolean;
        InheritVelocityScale: RawDistributionVector;
        PhysicalMaterials: TArray<PhysicalMaterial>;
        bBanPhysicalMaterials: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleEventReceiverSpawn;
        static Load(InName: string): ParticleModuleEventReceiverSpawn;
    }
    
    class ParticleModuleKillBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillBase;
        static Load(InName: string): ParticleModuleKillBase;
    }
    
    class ParticleModuleKillBox extends ParticleModuleKillBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LowerLeftCorner: RawDistributionVector;
        UpperRightCorner: RawDistributionVector;
        bAbsolute: boolean;
        bKillInside: boolean;
        bAxisAlignedAndFixedSize: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillBox;
        static Load(InName: string): ParticleModuleKillBox;
    }
    
    class ParticleModuleKillHeight extends ParticleModuleKillBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Height: RawDistributionFloat;
        bAbsolute: boolean;
        bFloor: boolean;
        bApplyPSysScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleKillHeight;
        static Load(InName: string): ParticleModuleKillHeight;
    }
    
    class ParticleModuleLifetimeBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetimeBase;
        static Load(InName: string): ParticleModuleLifetimeBase;
    }
    
    class ParticleModuleLifetime extends ParticleModuleLifetimeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Lifetime: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetime;
        static Load(InName: string): ParticleModuleLifetime;
    }
    
    class ParticleModuleLifetime_Seeded extends ParticleModuleLifetime {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLifetime_Seeded;
        static Load(InName: string): ParticleModuleLifetime_Seeded;
    }
    
    class ParticleModuleLightBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLightBase;
        static Load(InName: string): ParticleModuleLightBase;
    }
    
    class ParticleModuleLight extends ParticleModuleLightBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseInverseSquaredFalloff: boolean;
        bAffectsTranslucency: boolean;
        bPreviewLightRadius: boolean;
        SpawnFraction: number;
        ColorScaleOverLife: RawDistributionVector;
        BrightnessOverLife: RawDistributionFloat;
        RadiusScale: RawDistributionFloat;
        LightExponent: RawDistributionFloat;
        LightingChannels: LightingChannels;
        VolumetricScatteringIntensity: number;
        bHighQualityLights: boolean;
        bShadowCastingLights: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLight;
        static Load(InName: string): ParticleModuleLight;
    }
    
    class ParticleModuleLight_Seeded extends ParticleModuleLight {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLight_Seeded;
        static Load(InName: string): ParticleModuleLight_Seeded;
    }
    
    class ParticleModuleLocationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationBase;
        static Load(InName: string): ParticleModuleLocationBase;
    }
    
    class ParticleModuleLocation extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartLocation: RawDistributionVector;
        DistributeOverNPoints: number;
        DistributeThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocation;
        static Load(InName: string): ParticleModuleLocation;
    }
    
    class ParticleModuleLocation_Seeded extends ParticleModuleLocation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocation_Seeded;
        static Load(InName: string): ParticleModuleLocation_Seeded;
    }
    
    class LocationBoneSocketInfo {
        constructor(BoneSocketName: string, Offset: Vector);
        BoneSocketName: string;
        Offset: Vector;
    }
    
    class ParticleModuleLocationBoneSocket extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: number;
        UniversalOffset: Vector;
        SourceLocations: TArray<LocationBoneSocketInfo>;
        SelectionMethod: number;
        bUpdatePositionEachFrame: boolean;
        bOrientMeshEmitters: boolean;
        bInheritBoneVelocity: boolean;
        InheritVelocityScale: number;
        SkelMeshActorParamName: string;
        NumPreSelectedIndices: number;
        EditorSkelMesh: SkeletalMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationBoneSocket;
        static Load(InName: string): ParticleModuleLocationBoneSocket;
    }
    
    class ParticleModuleLocationDirect extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Location: RawDistributionVector;
        LocationOffset: RawDistributionVector;
        ScaleFactor: RawDistributionVector;
        Direction: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationDirect;
        static Load(InName: string): ParticleModuleLocationDirect;
    }
    
    class ParticleModuleLocationEmitter extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        SelectionMethod: number;
        InheritSourceVelocity: boolean;
        InheritSourceVelocityScale: number;
        bInheritSourceRotation: boolean;
        InheritSourceRotationScale: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationEmitter;
        static Load(InName: string): ParticleModuleLocationEmitter;
    }
    
    class ParticleModuleLocationEmitterDirect extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationEmitterDirect;
        static Load(InName: string): ParticleModuleLocationEmitterDirect;
    }
    
    class ParticleModuleLocationPrimitiveBase extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Positive_X: boolean;
        Positive_Y: boolean;
        Positive_Z: boolean;
        Negative_X: boolean;
        Negative_Y: boolean;
        Negative_Z: boolean;
        SurfaceOnly: boolean;
        Velocity: boolean;
        VelocityScale: RawDistributionFloat;
        StartLocation: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveBase;
        static Load(InName: string): ParticleModuleLocationPrimitiveBase;
    }
    
    class ParticleModuleLocationPrimitiveCylinder extends ParticleModuleLocationPrimitiveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RadialVelocity: boolean;
        StartRadius: RawDistributionFloat;
        StartHeight: RawDistributionFloat;
        HeightAxis: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveCylinder;
        static Load(InName: string): ParticleModuleLocationPrimitiveCylinder;
    }
    
    class ParticleModuleLocationPrimitiveCylinder_Seeded extends ParticleModuleLocationPrimitiveCylinder {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveCylinder_Seeded;
        static Load(InName: string): ParticleModuleLocationPrimitiveCylinder_Seeded;
    }
    
    class ParticleModuleLocationPrimitiveSphere extends ParticleModuleLocationPrimitiveBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRadius: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveSphere;
        static Load(InName: string): ParticleModuleLocationPrimitiveSphere;
    }
    
    class ParticleModuleLocationPrimitiveSphere_Seeded extends ParticleModuleLocationPrimitiveSphere {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveSphere_Seeded;
        static Load(InName: string): ParticleModuleLocationPrimitiveSphere_Seeded;
    }
    
    class ParticleModuleLocationPrimitiveTriangle extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartOffset: RawDistributionVector;
        Height: RawDistributionFloat;
        Angle: RawDistributionFloat;
        Thickness: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationPrimitiveTriangle;
        static Load(InName: string): ParticleModuleLocationPrimitiveTriangle;
    }
    
    class ParticleModuleLocationSkelVertSurface extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: number;
        UniversalOffset: Vector;
        bUpdatePositionEachFrame: boolean;
        bOrientMeshEmitters: boolean;
        bInheritBoneVelocity: boolean;
        InheritVelocityScale: number;
        SkelMeshActorParamName: string;
        EditorSkelMesh: SkeletalMesh;
        ValidAssociatedBones: TArray<string>;
        bEnforceNormalCheck: boolean;
        NormalToCompare: Vector;
        NormalCheckToleranceDegrees: number;
        NormalCheckTolerance: number;
        ValidMaterialIndices: TArray<number>;
        bInheritVertexColor: boolean;
        bInheritUV: boolean;
        InheritUVChannel: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationSkelVertSurface;
        static Load(InName: string): ParticleModuleLocationSkelVertSurface;
    }
    
    class ParticleModuleLocationWorldOffset extends ParticleModuleLocation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationWorldOffset;
        static Load(InName: string): ParticleModuleLocationWorldOffset;
    }
    
    class ParticleModuleLocationWorldOffset_Seeded extends ParticleModuleLocationWorldOffset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleLocationWorldOffset_Seeded;
        static Load(InName: string): ParticleModuleLocationWorldOffset_Seeded;
    }
    
    class ParticleModuleMaterialBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMaterialBase;
        static Load(InName: string): ParticleModuleMaterialBase;
    }
    
    class ParticleModuleMeshMaterial extends ParticleModuleMaterialBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshMaterials: TArray<MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshMaterial;
        static Load(InName: string): ParticleModuleMeshMaterial;
    }
    
    class ParticleModuleRotationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationBase;
        static Load(InName: string): ParticleModuleRotationBase;
    }
    
    class ParticleModuleMeshRotation extends ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotation: RawDistributionVector;
        bInheritParent: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotation;
        static Load(InName: string): ParticleModuleMeshRotation;
    }
    
    class ParticleModuleMeshRotation_Seeded extends ParticleModuleMeshRotation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotation_Seeded;
        static Load(InName: string): ParticleModuleMeshRotation_Seeded;
    }
    
    class ParticleModuleRotationRateBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRateBase;
        static Load(InName: string): ParticleModuleRotationRateBase;
    }
    
    class ParticleModuleMeshRotationRate extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotationRate: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRate;
        static Load(InName: string): ParticleModuleMeshRotationRate;
    }
    
    class ParticleModuleMeshRotationRate_Seeded extends ParticleModuleMeshRotationRate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRate_Seeded;
        static Load(InName: string): ParticleModuleMeshRotationRate_Seeded;
    }
    
    class ParticleModuleMeshRotationRateMultiplyLife extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LifeMultiplier: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRateMultiplyLife;
        static Load(InName: string): ParticleModuleMeshRotationRateMultiplyLife;
    }
    
    class ParticleModuleMeshRotationRateOverLife extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotRate: RawDistributionVector;
        bScaleRotRate: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleMeshRotationRateOverLife;
        static Load(InName: string): ParticleModuleMeshRotationRateOverLife;
    }
    
    class ParticleModuleOrientationBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrientationBase;
        static Load(InName: string): ParticleModuleOrientationBase;
    }
    
    class ParticleModuleOrientationAxisLock extends ParticleModuleOrientationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LockAxisFlags: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleOrientationAxisLock;
        static Load(InName: string): ParticleModuleOrientationAxisLock;
    }
    
    class ParticleModuleParameterBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterBase;
        static Load(InName: string): ParticleModuleParameterBase;
    }
    
    class EmitterDynamicParameter {
        constructor(ParamName: string, bUseEmitterTime: boolean, bSpawnTimeOnly: boolean, ValueMethod: number, bScaleVelocityByParamValue: boolean, ParamValue: RawDistributionFloat);
        ParamName: string;
        bUseEmitterTime: boolean;
        bSpawnTimeOnly: boolean;
        ValueMethod: number;
        bScaleVelocityByParamValue: boolean;
        ParamValue: RawDistributionFloat;
    }
    
    class ParticleModuleParameterDynamic extends ParticleModuleParameterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DynamicParams: TArray<EmitterDynamicParameter>;
        UpdateFlags: number;
        bUsesVelocity: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterDynamic;
        static Load(InName: string): ParticleModuleParameterDynamic;
    }
    
    class ParticleModuleParameterDynamic_Seeded extends ParticleModuleParameterDynamic {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleParameterDynamic_Seeded;
        static Load(InName: string): ParticleModuleParameterDynamic_Seeded;
    }
    
    class ParticleModulePivotOffset extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PivotOffset: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModulePivotOffset;
        static Load(InName: string): ParticleModulePivotOffset;
    }
    
    class ParticleModuleRotation extends ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotation: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotation;
        static Load(InName: string): ParticleModuleRotation;
    }
    
    class ParticleModuleRotation_Seeded extends ParticleModuleRotation {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotation_Seeded;
        static Load(InName: string): ParticleModuleRotation_Seeded;
    }
    
    class ParticleModuleRotationOverLifetime extends ParticleModuleRotationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationOverLife: RawDistributionFloat;
        Scale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationOverLifetime;
        static Load(InName: string): ParticleModuleRotationOverLifetime;
    }
    
    class ParticleModuleRotationRate extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartRotationRate: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRate;
        static Load(InName: string): ParticleModuleRotationRate;
    }
    
    class ParticleModuleRotationRate_Seeded extends ParticleModuleRotationRate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRate_Seeded;
        static Load(InName: string): ParticleModuleRotationRate_Seeded;
    }
    
    class ParticleModuleRotationRateMultiplyLife extends ParticleModuleRotationRateBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LifeMultiplier: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleRotationRateMultiplyLife;
        static Load(InName: string): ParticleModuleRotationRateMultiplyLife;
    }
    
    class ParticleModuleSizeBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeBase;
        static Load(InName: string): ParticleModuleSizeBase;
    }
    
    class ParticleModuleSize extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartSize: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSize;
        static Load(InName: string): ParticleModuleSize;
    }
    
    class ParticleModuleSize_Seeded extends ParticleModuleSize {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSize_Seeded;
        static Load(InName: string): ParticleModuleSize_Seeded;
    }
    
    class ParticleModuleSizeMultiplyLife extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LifeMultiplier: RawDistributionVector;
        MultiplyX: boolean;
        MultiplyY: boolean;
        MultiplyZ: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeMultiplyLife;
        static Load(InName: string): ParticleModuleSizeMultiplyLife;
    }
    
    class ParticleModuleSizeScale extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeScale: RawDistributionVector;
        EnableX: boolean;
        EnableY: boolean;
        EnableZ: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeScale;
        static Load(InName: string): ParticleModuleSizeScale;
    }
    
    class ParticleModuleSizeScaleBySpeed extends ParticleModuleSizeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpeedScale: Vector2D;
        MaxScale: Vector2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSizeScaleBySpeed;
        static Load(InName: string): ParticleModuleSizeScaleBySpeed;
    }
    
    class ParticleModuleSourceMovement extends ParticleModuleLocationBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMovementScale: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSourceMovement;
        static Load(InName: string): ParticleModuleSourceMovement;
    }
    
    class ParticleModuleSpawnPerUnit extends ParticleModuleSpawnBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UnitScalar: number;
        MovementTolerance: number;
        SpawnPerUnit: RawDistributionFloat;
        MaxFrameDistance: number;
        bIgnoreSpawnRateWhenMoving: boolean;
        bIgnoreMovementAlongX: boolean;
        bIgnoreMovementAlongY: boolean;
        bIgnoreMovementAlongZ: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSpawnPerUnit;
        static Load(InName: string): ParticleModuleSpawnPerUnit;
    }
    
    class ParticleModuleSubUVBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUVBase;
        static Load(InName: string): ParticleModuleSubUVBase;
    }
    
    class SubUVAnimation extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SubUVTexture: Texture2D;
        SubImages_Horizontal: number;
        SubImages_Vertical: number;
        BoundingMode: number;
        OpacitySourceMode: number;
        AlphaThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubUVAnimation;
        static Load(InName: string): SubUVAnimation;
    }
    
    class ParticleModuleSubUV extends ParticleModuleSubUVBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Animation: SubUVAnimation;
        SubImageIndex: RawDistributionFloat;
        bUseRealTime: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUV;
        static Load(InName: string): ParticleModuleSubUV;
    }
    
    class ParticleModuleSubUVMovie extends ParticleModuleSubUV {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseEmitterTime: boolean;
        FrameRate: RawDistributionFloat;
        StartingFrame: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleSubUVMovie;
        static Load(InName: string): ParticleModuleSubUVMovie;
    }
    
    class ParticleModuleTrailBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTrailBase;
        static Load(InName: string): ParticleModuleTrailBase;
    }
    
    class ParticleModuleTrailSource extends ParticleModuleTrailBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMethod: number;
        SourceName: string;
        SourceStrength: RawDistributionFloat;
        bLockSourceStength: boolean;
        SourceOffsetCount: number;
        SourceOffsetDefaults: TArray<Vector>;
        SelectionMethod: number;
        bInheritRotation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTrailSource;
        static Load(InName: string): ParticleModuleTrailSource;
    }
    
    class ParticleModuleTypeDataAnimTrail extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDeadTrailsOnDeactivate: boolean;
        bEnablePreviousTangentRecalculation: boolean;
        bTangentRecalculationEveryFrame: boolean;
        TilingDistance: number;
        DistanceTessellationStepSize: number;
        TangentTessellationStepSize: number;
        WidthTessellationStepSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataAnimTrail;
        static Load(InName: string): ParticleModuleTypeDataAnimTrail;
    }
    
    class ParticleModuleTypeDataBeam2 extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeamMethod: number;
        TextureTile: number;
        TextureTileDistance: number;
        Sheets: number;
        MaxBeamCount: number;
        Speed: number;
        InterpolationPoints: number;
        bAlwaysOn: boolean;
        UpVectorStepSize: number;
        BranchParentName: string;
        Distance: RawDistributionFloat;
        TaperMethod: number;
        TaperFactor: RawDistributionFloat;
        TaperScale: RawDistributionFloat;
        RenderGeometry: boolean;
        RenderDirectLine: boolean;
        RenderLines: boolean;
        RenderTessellation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataBeam2;
        static Load(InName: string): ParticleModuleTypeDataBeam2;
    }
    
    class VectorField extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Bounds: Box;
        Intensity: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorField;
        static Load(InName: string): VectorField;
    }
    
    class GPUSpriteLocalVectorFieldInfo {
        constructor(Field: VectorField, Transform: Transform, MinInitialRotation: Rotator, MaxInitialRotation: Rotator, RotationRate: Rotator, Intensity: number, Tightness: number, bIgnoreComponentTransform: boolean, bTileX: boolean, bTileY: boolean, bTileZ: boolean, bUseFixDT: boolean);
        Field: VectorField;
        Transform: Transform;
        MinInitialRotation: Rotator;
        MaxInitialRotation: Rotator;
        RotationRate: Rotator;
        Intensity: number;
        Tightness: number;
        bIgnoreComponentTransform: boolean;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;
        bUseFixDT: boolean;
    }
    
    class FloatDistribution {
        constructor(Table: DistributionLookupTable);
        Table: DistributionLookupTable;
    }
    
    class GPUSpriteEmitterInfo {
        constructor(RequiredModule: ParticleModuleRequired, SpawnModule: ParticleModuleSpawn, SpawnPerUnitModule: ParticleModuleSpawnPerUnit, SpawnModules: TArray<ParticleModule>, LocalVectorField: GPUSpriteLocalVectorFieldInfo, VectorFieldScale: FloatDistribution, DragCoefficient: FloatDistribution, PointAttractorStrength: FloatDistribution, Resilience: FloatDistribution, ConstantAcceleration: Vector, PointAttractorPosition: Vector, PointAttractorRadiusSq: number, OrbitOffsetBase: Vector, OrbitOffsetRange: Vector, InvMaxSize: Vector2D, InvRotationRateScale: number, MaxLifetime: number, MaxParticleCount: number, ScreenAlignment: number, LockAxisFlag: number, bEnableCollision: boolean, CollisionMode: number, bRemoveHMDRoll: boolean, MinFacingCameraBlendDistance: number, MaxFacingCameraBlendDistance: number, DynamicColor: RawDistributionVector, DynamicAlpha: RawDistributionFloat, DynamicColorScale: RawDistributionVector, DynamicAlphaScale: RawDistributionFloat);
        RequiredModule: ParticleModuleRequired;
        SpawnModule: ParticleModuleSpawn;
        SpawnPerUnitModule: ParticleModuleSpawnPerUnit;
        SpawnModules: TArray<ParticleModule>;
        LocalVectorField: GPUSpriteLocalVectorFieldInfo;
        VectorFieldScale: FloatDistribution;
        DragCoefficient: FloatDistribution;
        PointAttractorStrength: FloatDistribution;
        Resilience: FloatDistribution;
        ConstantAcceleration: Vector;
        PointAttractorPosition: Vector;
        PointAttractorRadiusSq: number;
        OrbitOffsetBase: Vector;
        OrbitOffsetRange: Vector;
        InvMaxSize: Vector2D;
        InvRotationRateScale: number;
        MaxLifetime: number;
        MaxParticleCount: number;
        ScreenAlignment: number;
        LockAxisFlag: number;
        bEnableCollision: boolean;
        CollisionMode: number;
        bRemoveHMDRoll: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
        DynamicColor: RawDistributionVector;
        DynamicAlpha: RawDistributionFloat;
        DynamicColorScale: RawDistributionVector;
        DynamicAlphaScale: RawDistributionFloat;
    }
    
    class GPUSpriteResourceData {
        constructor(QuantizedColorSamples: TArray<Color>, QuantizedMiscSamples: TArray<Color>, QuantizedSimulationAttrSamples: TArray<Color>, ColorScale: Vector4, ColorBias: Vector4, MiscScale: Vector4, MiscBias: Vector4, SimulationAttrCurveScale: Vector4, SimulationAttrCurveBias: Vector4, SubImageSize: Vector4, SizeBySpeed: Vector4, ConstantAcceleration: Vector, OrbitOffsetBase: Vector, OrbitOffsetRange: Vector, OrbitFrequencyBase: Vector, OrbitFrequencyRange: Vector, OrbitPhaseBase: Vector, OrbitPhaseRange: Vector, GlobalVectorFieldScale: number, GlobalVectorFieldTightness: number, PerParticleVectorFieldScale: number, PerParticleVectorFieldBias: number, DragCoefficientScale: number, DragCoefficientBias: number, ResilienceScale: number, ResilienceBias: number, CollisionRadiusScale: number, CollisionRadiusBias: number, CollisionTimeBias: number, CollisionRandomSpread: number, CollisionRandomDistribution: number, OneMinusFriction: number, RotationRateScale: number, CameraMotionBlurAmount: number, ScreenAlignment: number, LockAxisFlag: number, PivotOffset: Vector2D, bRemoveHMDRoll: boolean, MinFacingCameraBlendDistance: number, MaxFacingCameraBlendDistance: number);
        QuantizedColorSamples: TArray<Color>;
        QuantizedMiscSamples: TArray<Color>;
        QuantizedSimulationAttrSamples: TArray<Color>;
        ColorScale: Vector4;
        ColorBias: Vector4;
        MiscScale: Vector4;
        MiscBias: Vector4;
        SimulationAttrCurveScale: Vector4;
        SimulationAttrCurveBias: Vector4;
        SubImageSize: Vector4;
        SizeBySpeed: Vector4;
        ConstantAcceleration: Vector;
        OrbitOffsetBase: Vector;
        OrbitOffsetRange: Vector;
        OrbitFrequencyBase: Vector;
        OrbitFrequencyRange: Vector;
        OrbitPhaseBase: Vector;
        OrbitPhaseRange: Vector;
        GlobalVectorFieldScale: number;
        GlobalVectorFieldTightness: number;
        PerParticleVectorFieldScale: number;
        PerParticleVectorFieldBias: number;
        DragCoefficientScale: number;
        DragCoefficientBias: number;
        ResilienceScale: number;
        ResilienceBias: number;
        CollisionRadiusScale: number;
        CollisionRadiusBias: number;
        CollisionTimeBias: number;
        CollisionRandomSpread: number;
        CollisionRandomDistribution: number;
        OneMinusFriction: number;
        RotationRateScale: number;
        CameraMotionBlurAmount: number;
        ScreenAlignment: number;
        LockAxisFlag: number;
        PivotOffset: Vector2D;
        bRemoveHMDRoll: boolean;
        MinFacingCameraBlendDistance: number;
        MaxFacingCameraBlendDistance: number;
    }
    
    class ParticleModuleTypeDataGpu extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EmitterInfo: GPUSpriteEmitterInfo;
        ResourceData: GPUSpriteResourceData;
        CameraMotionBlurAmount: number;
        bClearExistingParticlesOnInit: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataGpu;
        static Load(InName: string): ParticleModuleTypeDataGpu;
    }
    
    class ParticleModuleTypeDataMesh extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: StaticMesh;
        LODSizeScale: number;
        bUseStaticMeshLODs: boolean;
        CastShadows: boolean;
        DoCollisions: boolean;
        MeshAlignment: number;
        bOverrideMaterial: boolean;
        bOverrideDefaultMotionBlurSettings: boolean;
        bEnableMotionBlur: boolean;
        RollPitchYawRange: RawDistributionVector;
        AxisLockOption: number;
        bCameraFacing: boolean;
        CameraFacingUpAxisOption: number;
        CameraFacingOption: number;
        bApplyParticleRotationAsSpin: boolean;
        bFaceCameraDirectionRatherThanPosition: boolean;
        bCollisionsConsiderPartilceSize: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataMesh;
        static Load(InName: string): ParticleModuleTypeDataMesh;
    }
    
    class ParticleModuleTypeDataRibbon extends ParticleModuleTypeDataBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxTessellationBetweenParticles: number;
        SheetsPerTrail: number;
        MaxTrailCount: number;
        MaxParticleInTrailCount: number;
        bDeadTrailsOnDeactivate: boolean;
        bDeadTrailsOnSourceLoss: boolean;
        bClipSourceSegement: boolean;
        bEnablePreviousTangentRecalculation: boolean;
        bTangentRecalculationEveryFrame: boolean;
        bSpawnInitialParticle: boolean;
        RenderAxis: number;
        TangentSpawningScalar: number;
        bRenderGeometry: boolean;
        bRenderSpawnPoints: boolean;
        bRenderTangents: boolean;
        bRenderTessellation: boolean;
        TilingDistance: number;
        DistanceTessellationStepSize: number;
        bEnableTangentDiffInterpScale: boolean;
        TangentTessellationScalar: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleTypeDataRibbon;
        static Load(InName: string): ParticleModuleTypeDataRibbon;
    }
    
    class ParticleModuleVectorFieldBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldBase;
        static Load(InName: string): ParticleModuleVectorFieldBase;
    }
    
    class ParticleModuleVectorFieldGlobal extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bOverrideGlobalVectorFieldTightness: boolean;
        GlobalVectorFieldScale: number;
        GlobalVectorFieldTightness: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldGlobal;
        static Load(InName: string): ParticleModuleVectorFieldGlobal;
    }
    
    class ParticleModuleVectorFieldLocal extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorField: VectorField;
        RelativeTranslation: Vector;
        RelativeRotation: Rotator;
        RelativeScale3D: Vector;
        Intensity: number;
        Tightness: number;
        bIgnoreComponentTransform: boolean;
        bTileX: boolean;
        bTileY: boolean;
        bTileZ: boolean;
        bUseFixDT: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldLocal;
        static Load(InName: string): ParticleModuleVectorFieldLocal;
    }
    
    class ParticleModuleVectorFieldRotation extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinInitialRotation: Vector;
        MaxInitialRotation: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldRotation;
        static Load(InName: string): ParticleModuleVectorFieldRotation;
    }
    
    class ParticleModuleVectorFieldRotationRate extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationRate: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldRotationRate;
        static Load(InName: string): ParticleModuleVectorFieldRotationRate;
    }
    
    class ParticleModuleVectorFieldScale extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorFieldScale: DistributionFloat;
        VectorFieldScaleRaw: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldScale;
        static Load(InName: string): ParticleModuleVectorFieldScale;
    }
    
    class ParticleModuleVectorFieldScaleOverLife extends ParticleModuleVectorFieldBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorFieldScaleOverLife: DistributionFloat;
        VectorFieldScaleOverLifeRaw: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVectorFieldScaleOverLife;
        static Load(InName: string): ParticleModuleVectorFieldScaleOverLife;
    }
    
    class ParticleModuleVelocityBase extends ParticleModule {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInWorldSpace: boolean;
        bApplyOwnerScale: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityBase;
        static Load(InName: string): ParticleModuleVelocityBase;
    }
    
    class ParticleModuleVelocity extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartVelocity: RawDistributionVector;
        StartVelocityRadial: RawDistributionFloat;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocity;
        static Load(InName: string): ParticleModuleVelocity;
    }
    
    class ParticleModuleVelocity_Seeded extends ParticleModuleVelocity {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RandomSeedInfo: ParticleRandomSeedInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocity_Seeded;
        static Load(InName: string): ParticleModuleVelocity_Seeded;
    }
    
    class ParticleModuleVelocityCone extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Angle: RawDistributionFloat;
        Velocity: RawDistributionFloat;
        Direction: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityCone;
        static Load(InName: string): ParticleModuleVelocityCone;
    }
    
    class ParticleModuleVelocityInheritParent extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Scale: RawDistributionVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityInheritParent;
        static Load(InName: string): ParticleModuleVelocityInheritParent;
    }
    
    class ParticleModuleVelocityOverLifetime extends ParticleModuleVelocityBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VelOverLife: RawDistributionVector;
        Absolute: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleModuleVelocityOverLifetime;
        static Load(InName: string): ParticleModuleVelocityOverLifetime;
    }
    
    class ParticleSpriteEmitter extends ParticleEmitter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ParticleSpriteEmitter;
        static Load(InName: string): ParticleSpriteEmitter;
    }
    
    class PathFollowingAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PathFollowingAgentInterface;
        static Load(InName: string): PathFollowingAgentInterface;
    }
    
    class PawnNoiseEmitterComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAIPerceptionSystemCompatibilityMode: boolean;
        LastRemoteNoisePosition: Vector;
        NoiseLifetime: number;
        LastRemoteNoiseVolume: number;
        LastRemoteNoiseTime: number;
        LastLocalNoiseVolume: number;
        LastLocalNoiseTime: number;
        MakeNoise(NoiseMaker: Actor, Loudness: number, NoiseLocation: Vector): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnNoiseEmitterComponent;
        static Load(InName: string): PawnNoiseEmitterComponent;
    }
    
    class PhysicalAnimationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StrengthMultiplyer: number;
        SkeletalMeshComponent: SkeletalMeshComponent;
        SetStrengthMultiplyer(InStrengthMultiplyer: number): void;
        SetSkeletalMeshComponent(InSkeletalMeshComponent: SkeletalMeshComponent): void;
        GetBodyTargetTransform(BodyName: string): Transform;
        ApplyPhysicalAnimationSettingsBelow(BodyName: string, PhysicalAnimationData: PhysicalAnimationData, bIncludeSelf: boolean): void;
        ApplyPhysicalAnimationSettings(BodyName: string, PhysicalAnimationData: PhysicalAnimationData): void;
        ApplyPhysicalAnimationProfileBelow(BodyName: string, ProfileName: string, bIncludeSelf: boolean, bClearNotFound: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicalAnimationComponent;
        static Load(InName: string): PhysicalAnimationComponent;
    }
    
    class RigidBodyBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RigidBodyBase;
        static Load(InName: string): RigidBodyBase;
    }
    
    class ConstrainComponentPropName {
        constructor(ComponentName: string);
        ComponentName: string;
    }
    
    class PhysicsConstraintComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintActor1: Actor;
        ComponentName1: ConstrainComponentPropName;
        ConstraintActor2: Actor;
        ComponentName2: ConstrainComponentPropName;
        ConstraintSetup: PhysicsConstraintTemplate;
        OnConstraintBroken: $MulticastDelegate<(ConstraintIndex: number) => void>;
        ConstraintInstance: ConstraintInstance;
        SetOrientationDriveTwistAndSwing(bEnableTwistDrive: boolean, bEnableSwingDrive: boolean): void;
        SetOrientationDriveSLERP(bEnableSLERP: boolean): void;
        SetLinearZLimit(ConstraintType: number, LimitSize: number): void;
        SetLinearYLimit(ConstraintType: number, LimitSize: number): void;
        SetLinearXLimit(ConstraintType: number, LimitSize: number): void;
        SetLinearVelocityTarget(InVelTarget: Vector): void;
        SetLinearVelocityDrive(bEnableDriveX: boolean, bEnableDriveY: boolean, bEnableDriveZ: boolean): void;
        SetLinearPositionTarget(InPosTarget: Vector): void;
        SetLinearPositionDrive(bEnableDriveX: boolean, bEnableDriveY: boolean, bEnableDriveZ: boolean): void;
        SetLinearDriveParams(PositionStrength: number, VelocityStrength: number, InForceLimit: number): void;
        SetLinearBreakable(bLinearBreakable: boolean, LinearBreakThreshold: number): void;
        SetDisableCollision(bDisableCollision: boolean): void;
        SetConstraintReferencePosition(Frame: number, RefPosition: Vector): void;
        SetConstraintReferenceOrientation(Frame: number, PriAxis: Vector, SecAxis: Vector): void;
        SetConstraintReferenceFrame(Frame: number, RefFrame: Transform): void;
        SetConstrainedComponents(Component1: PrimitiveComponent, BoneName1: string, Component2: PrimitiveComponent, BoneName2: string): void;
        SetAngularVelocityTarget(InVelTarget: Vector): void;
        SetAngularVelocityDriveTwistAndSwing(bEnableTwistDrive: boolean, bEnableSwingDrive: boolean): void;
        SetAngularVelocityDriveSLERP(bEnableSLERP: boolean): void;
        SetAngularVelocityDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean): void;
        SetAngularTwistLimit(ConstraintType: number, TwistLimitAngle: number): void;
        SetAngularSwing2Limit(MotionType: number, Swing2LimitAngle: number): void;
        SetAngularSwing1Limit(MotionType: number, Swing1LimitAngle: number): void;
        SetAngularOrientationTarget(InPosTarget: Rotator): void;
        SetAngularOrientationDrive(bEnableSwingDrive: boolean, bEnableTwistDrive: boolean): void;
        SetAngularDriveParams(PositionStrength: number, VelocityStrength: number, InForceLimit: number): void;
        SetAngularDriveMode(DriveMode: number): void;
        SetAngularBreakable(bAngularBreakable: boolean, AngularBreakThreshold: number): void;
        IsBroken(): boolean;
        GetCurrentTwist(): number;
        GetCurrentSwing2(): number;
        GetCurrentSwing1(): number;
        GetConstraintForce(OutLinearForce: $Ref<Vector>, OutAngularForce: $Ref<Vector>): void;
        BreakConstraint(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintComponent;
        static Load(InName: string): PhysicsConstraintComponent;
    }
    
    class PhysicsConstraintActor extends RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConstraintComp: PhysicsConstraintComponent;
        ConstraintActor1: Actor;
        ConstraintActor2: Actor;
        bDisableCollision: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsConstraintActor;
        static Load(InName: string): PhysicsConstraintActor;
    }
    
    class PhysicsHandleComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GrabbedComponent: PrimitiveComponent;
        bSoftAngularConstraint: boolean;
        bSoftLinearConstraint: boolean;
        bInterpolateTarget: boolean;
        LinearDamping: number;
        LinearStiffness: number;
        AngularDamping: number;
        AngularStiffness: number;
        InterpolationSpeed: number;
        SetTargetRotation(NewRotation: Rotator): void;
        SetTargetLocationAndRotation(NewLocation: Vector, NewRotation: Rotator): void;
        SetTargetLocation(NewLocation: Vector): void;
        SetLinearStiffness(NewLinearStiffness: number): void;
        SetLinearDamping(NewLinearDamping: number): void;
        SetInterpolationSpeed(NewInterpolationSpeed: number): void;
        SetAngularStiffness(NewAngularStiffness: number): void;
        SetAngularDamping(NewAngularDamping: number): void;
        ReleaseComponent(): void;
        GrabComponentAtLocationWithRotation(Component: PrimitiveComponent, InBoneName: string, Location: Vector, Rotation: Rotator): void;
        GrabComponentAtLocation(Component: PrimitiveComponent, InBoneName: string, GrabLocation: Vector): void;
        GrabComponent(Component: PrimitiveComponent, InBoneName: string, GrabLocation: Vector, bConstrainRotation: boolean): void;
        GetTargetLocationAndRotation(TargetLocation: $Ref<Vector>, TargetRotation: $Ref<Rotator>): void;
        GetGrabbedComponent(): PrimitiveComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsHandleComponent;
        static Load(InName: string): PhysicsHandleComponent;
    }
    
    class RigidBodyErrorCorrection {
        constructor(PingExtrapolation: number, PingLimit: number, ErrorPerLinearDifference: number, ErrorPerAngularDifference: number, MaxRestoredStateError: number, MaxLinearHardSnapDistance: number, PositionLerp: number, AngleLerp: number, LinearVelocityCoefficient: number, AngularVelocityCoefficient: number, ErrorAccumulationSeconds: number, ErrorAccumulationDistanceSq: number, ErrorAccumulationSimilarity: number);
        PingExtrapolation: number;
        PingLimit: number;
        ErrorPerLinearDifference: number;
        ErrorPerAngularDifference: number;
        MaxRestoredStateError: number;
        MaxLinearHardSnapDistance: number;
        PositionLerp: number;
        AngleLerp: number;
        LinearVelocityCoefficient: number;
        AngularVelocityCoefficient: number;
        ErrorAccumulationSeconds: number;
        ErrorAccumulationDistanceSq: number;
        ErrorAccumulationSimilarity: number;
    }
    
    class PhysicalSurfaceName {
        constructor(Type: number, Name: string);
        Type: number;
        Name: string;
    }
    
    enum EChaosThreadingMode { DedicatedThread, TaskGraph, SingleThread, Num, Invalid, EChaosThreadingMode_MAX}
    enum EChaosSolverTickMode { Fixed, Variable, VariableCapped, VariableCappedWithTarget, EChaosSolverTickMode_MAX}
    enum EChaosBufferMode { Double, Triple, Num, Invalid, EChaosBufferMode_MAX}
    class ChaosPhysicsSettings {
        constructor(DefaultThreadingModel: EChaosThreadingMode, DedicatedThreadTickMode: EChaosSolverTickMode, DedicatedThreadBufferMode: EChaosBufferMode);
        DefaultThreadingModel: EChaosThreadingMode;
        DedicatedThreadTickMode: EChaosSolverTickMode;
        DedicatedThreadBufferMode: EChaosBufferMode;
    }
    
    class PhysicsSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultGravityZ: number;
        DefaultTerminalVelocity: number;
        DefaultFluidFriction: number;
        SimulateScratchMemorySize: number;
        RagdollAggregateThreshold: number;
        TriangleMeshTriangleMinAreaThreshold: number;
        bEnableShapeSharing: boolean;
        bEnablePCM: boolean;
        bEnableStabilization: boolean;
        bWarnMissingLocks: boolean;
        bEnable2DPhysics: boolean;
        PhysicErrorCorrection: RigidBodyErrorCorrection;
        LockedAxis: number;
        DefaultDegreesOfFreedom: number;
        BounceThresholdVelocity: number;
        FrictionCombineMode: number;
        RestitutionCombineMode: number;
        MaxAngularVelocity: number;
        MaxDepenetrationVelocity: number;
        ContactOffsetMultiplier: number;
        MinContactOffset: number;
        MaxContactOffset: number;
        bSimulateSkeletalMeshOnDedicatedServer: boolean;
        DefaultShapeComplexity: number;
        bDefaultHasComplexCollision: boolean;
        bSuppressFaceRemapTable: boolean;
        bSupportUVFromHitResults: boolean;
        bDisableActiveActors: boolean;
        bDisableKinematicStaticPairs: boolean;
        bDisableKinematicKinematicPairs: boolean;
        bDisableCCD: boolean;
        bEnableEnhancedDeterminism: boolean;
        AnimPhysicsMinDeltaTime: number;
        bSimulateAnimPhysicsAfterReset: boolean;
        MaxPhysicsDeltaTime: number;
        bSubstepping: boolean;
        bSubsteppingAsync: boolean;
        MaxSubstepDeltaTime: number;
        MaxSubsteps: number;
        SyncSceneSmoothingFactor: number;
        InitialAverageFrameRate: number;
        PhysXTreeRebuildRate: number;
        PhysicalSurfaces: TArray<PhysicalSurfaceName>;
        DefaultBroadphaseSettings: BroadphaseSettings;
        ChaosSettings: ChaosPhysicsSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsSettings;
        static Load(InName: string): PhysicsSettings;
    }
    
    class PhysicsSpringComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpringStiffness: number;
        SpringDamping: number;
        SpringLengthAtRest: number;
        SpringRadius: number;
        SpringChannel: number;
        bIgnoreSelf: boolean;
        SpringCompression: number;
        GetSpringRestingPoint(): Vector;
        GetSpringDirection(): Vector;
        GetSpringCurrentEndPoint(): Vector;
        GetNormalizedCompressionScalar(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsSpringComponent;
        static Load(InName: string): PhysicsSpringComponent;
    }
    
    class PhysicsThrusterComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ThrustStrength: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsThrusterComponent;
        static Load(InName: string): PhysicsThrusterComponent;
    }
    
    class PhysicsThruster extends RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ThrusterComponent: PhysicsThrusterComponent;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhysicsThruster;
        static Load(InName: string): PhysicsThruster;
    }
    
    class SceneCapture extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MeshComp: StaticMeshComponent;
        SceneComponent: SceneComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCapture;
        static Load(InName: string): SceneCapture;
    }
    
    enum ESceneCapturePrimitiveRenderMode { PRM_LegacySceneCapture, PRM_RenderScenePrimitives, PRM_UseShowOnlyList, PRM_MAX}
    class EngineShowFlagsSetting {
        constructor(ShowFlagName: string, Enabled: boolean);
        ShowFlagName: string;
        Enabled: boolean;
    }
    
    class SceneCaptureComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimitiveRenderMode: ESceneCapturePrimitiveRenderMode;
        CaptureSource: number;
        HiddenComponents: TArray<TWeakObjectPtr<PrimitiveComponent>>;
        HiddenActors: TArray<Actor>;
        ShowOnlyComponents: TArray<TWeakObjectPtr<PrimitiveComponent>>;
        ShowOnlyActors: TArray<Actor>;
        bCaptureEveryFrame: boolean;
        bCaptureOnMovement: boolean;
        bAlwaysPersistRenderingState: boolean;
        LODDistanceFactor: number;
        MaxViewDistanceOverride: number;
        CaptureSortPriority: number;
        ShowFlagSettings: TArray<EngineShowFlagsSetting>;
        ProfilingEventName: string;
        CaptureMesh: StaticMesh;
        ShowOnlyComponent(InComponent: PrimitiveComponent): void;
        ShowOnlyActorComponents(InActor: Actor): void;
        SetCaptureSortPriority(NewCaptureSortPriority: number): void;
        RemoveShowOnlyComponent(InComponent: PrimitiveComponent): void;
        RemoveShowOnlyActorComponents(InActor: Actor): void;
        HideComponent(InComponent: PrimitiveComponent): void;
        HideActorComponents(InActor: Actor): void;
        ClearShowOnlyComponents(): void;
        ClearHiddenComponents(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponent;
        static Load(InName: string): SceneCaptureComponent;
    }
    
    class PlanarReflectionComponent extends SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewBox: BoxComponent;
        NormalDistortionStrength: number;
        PrefilterRoughness: number;
        PrefilterRoughnessDistance: number;
        ScreenPercentage: number;
        ExtraFOV: number;
        DistanceFromPlaneFadeStart: number;
        DistanceFromPlaneFadeEnd: number;
        DistanceFromPlaneFadeoutStart: number;
        DistanceFromPlaneFadeoutEnd: number;
        AngleFromPlaneFadeStart: number;
        AngleFromPlaneFadeEnd: number;
        bShowPreviewPlane: boolean;
        bRenderSceneTwoSided: boolean;
        CaptureMaterial: Material;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanarReflectionComponent;
        static Load(InName: string): PlanarReflectionComponent;
    }
    
    class PlanarReflection extends SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlanarReflectionComponent: PlanarReflectionComponent;
        SpriteComponent: BillboardComponent;
        bShowPreviewPlane: boolean;
        OnInterpToggle(bEnable: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlanarReflection;
        static Load(InName: string): PlanarReflection;
    }
    
    class PlaneReflectionCapture extends ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneReflectionCapture;
        static Load(InName: string): PlaneReflectionCapture;
    }
    
    class PlaneReflectionCaptureComponent extends ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InfluenceRadiusScale: number;
        PreviewInfluenceRadius: DrawSphereComponent;
        PreviewCaptureBox: BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneReflectionCaptureComponent;
        static Load(InName: string): PlaneReflectionCaptureComponent;
    }
    
    class PlatformEventsComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlatformChangedToLaptopModeDelegate: $MulticastDelegate<() => void>;
        PlatformChangedToTabletModeDelegate: $MulticastDelegate<() => void>;
        SupportsConvertibleLaptops(): boolean;
        PlatformEventDelegate__DelegateSignature(): void;
        IsInTabletMode(): boolean;
        IsInLaptopMode(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformEventsComponent;
        static Load(InName: string): PlatformEventsComponent;
    }
    
    class PlatformInterfaceWebResponse extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OriginalURL: string;
        ResponseCode: number;
        Tag: number;
        StringResponse: string;
        BinaryResponse: TArray<number>;
        GetNumHeaders(): number;
        GetHeaderValue(HeaderName: string): string;
        GetHeader(HeaderIndex: number, Header: $Ref<string>, Value: $Ref<string>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformInterfaceWebResponse;
        static Load(InName: string): PlatformInterfaceWebResponse;
    }
    
    class PlayerStart extends NavigationObjectBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerStartTag: string;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerStart;
        static Load(InName: string): PlayerStart;
    }
    
    class PlayerStartPIE extends PlayerStart {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlayerStartPIE;
        static Load(InName: string): PlayerStartPIE;
    }
    
    class PluginCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PluginCommandlet;
        static Load(InName: string): PluginCommandlet;
    }
    
    class PointLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PointLightComponent: PointLightComponent;
        SetRadius(NewRadius: number): void;
        SetLightFalloffExponent(NewLightFalloffExponent: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PointLight;
        static Load(InName: string): PointLight;
    }
    
    class Polys extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Polys;
        static Load(InName: string): Polys;
    }
    
    class PoseableMeshComponent extends SkinnedMeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetBoneTransformByName(BoneName: string, InTransform: Transform, BoneSpace: number): void;
        SetBoneScaleByName(BoneName: string, InScale3D: Vector, BoneSpace: number): void;
        SetBoneRotationByName(BoneName: string, InRotation: Rotator, BoneSpace: number): void;
        SetBoneLocationByName(BoneName: string, InLocation: Vector, BoneSpace: number): void;
        ResetBoneTransformByName(BoneName: string): void;
        GetBoneTransformByName(BoneName: string, BoneSpace: number): Transform;
        GetBoneScaleByName(BoneName: string, BoneSpace: number): Vector;
        GetBoneRotationByName(BoneName: string, BoneSpace: number): Rotator;
        GetBoneLocationByName(BoneName: string, BoneSpace: number): Vector;
        CopyPoseFromSkeletalComponent(InComponentToCopy: SkeletalMeshComponent): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PoseableMeshComponent;
        static Load(InName: string): PoseableMeshComponent;
    }
    
    class PostProcessVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: PostProcessSettings;
        Priority: number;
        BlendRadius: number;
        BlendWeight: number;
        bEnabled: boolean;
        bUnbound: boolean;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PostProcessVolume;
        static Load(InName: string): PostProcessVolume;
    }
    
    class PrecomputedVisibilityOverrideVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OverrideVisibleActors: TArray<Actor>;
        OverrideInvisibleActors: TArray<Actor>;
        OverrideInvisibleLevels: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrecomputedVisibilityOverrideVolume;
        static Load(InName: string): PrecomputedVisibilityOverrideVolume;
    }
    
    class PrecomputedVisibilityVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrecomputedVisibilityVolume;
        static Load(InName: string): PrecomputedVisibilityVolume;
    }
    
    class PreviewCollectionInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewCollectionInterface;
        static Load(InName: string): PreviewCollectionInterface;
    }
    
    class PreviewMeshCollectionEntry {
        constructor(SkeletalMesh: TSoftObjectPtr<SkeletalMesh>);
        SkeletalMesh: TSoftObjectPtr<SkeletalMesh>;
    }
    
    class PreviewMeshCollection extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeleton: Skeleton;
        SkeletalMeshes: TArray<PreviewMeshCollectionEntry>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PreviewMeshCollection;
        static Load(InName: string): PreviewMeshCollection;
    }
    
    class CollectionReference {
        constructor(CollectionName: string);
        CollectionName: string;
    }
    
    class PrimaryAssetLabel extends PrimaryDataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Rules: PrimaryAssetRules;
        bLabelAssetsInMyDirectory: boolean;
        bIsRuntimeLabel: boolean;
        ExplicitAssets: TArray<TSoftObjectPtr<Object>>;
        ExplicitBlueprints: TArray<TSoftObjectPtr<Class>>;
        AssetCollection: CollectionReference;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PrimaryAssetLabel;
        static Load(InName: string): PrimaryAssetLabel;
    }
    
    class ProjectileMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialSpeed: number;
        MaxSpeed: number;
        bRotationFollowsVelocity: boolean;
        bRotationRemainsVertical: boolean;
        bShouldBounce: boolean;
        bInitialVelocityInLocalSpace: boolean;
        bForceSubStepping: boolean;
        bSimulationEnabled: boolean;
        bSweepCollision: boolean;
        bIsHomingProjectile: boolean;
        bBounceAngleAffectsFriction: boolean;
        bIsSliding: boolean;
        bInterpMovement: boolean;
        bInterpRotation: boolean;
        PreviousHitTime: number;
        PreviousHitNormal: Vector;
        ProjectileGravityScale: number;
        Buoyancy: number;
        Bounciness: number;
        Friction: number;
        BounceVelocityStopSimulatingThreshold: number;
        MinFrictionFraction: number;
        OnProjectileBounce: $MulticastDelegate<(ImpactResult: HitResult, ImpactVelocity: Vector) => void>;
        OnProjectileStop: $MulticastDelegate<(ImpactResult: HitResult) => void>;
        HomingAccelerationMagnitude: number;
        HomingTargetComponent: TWeakObjectPtr<SceneComponent>;
        MaxSimulationTimeStep: number;
        MaxSimulationIterations: number;
        BounceAdditionalIterations: number;
        InterpLocationTime: number;
        InterpRotationTime: number;
        InterpLocationMaxLagDistance: number;
        InterpLocationSnapToTargetDistance: number;
        StopSimulating(HitResult: HitResult): void;
        SetVelocityInLocalSpace(NewVelocity: Vector): void;
        SetInterpolatedComponent(Component: SceneComponent): void;
        ResetInterpolation(): void;
        OnProjectileStopDelegate__DelegateSignature(ImpactResult: HitResult): void;
        OnProjectileBounceDelegate__DelegateSignature(ImpactResult: HitResult, ImpactVelocity: Vector): void;
        MoveInterpolationTarget(NewLocation: Vector, NewRotation: Rotator): void;
        LimitVelocity(NewVelocity: Vector): Vector;
        IsVelocityUnderSimulationThreshold(): boolean;
        IsInterpolationComplete(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProjectileMovementComponent;
        static Load(InName: string): ProjectileMovementComponent;
    }
    
    class ProxyLODMeshSimplificationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProxyLODMeshReductionModuleName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProxyLODMeshSimplificationSettings;
        static Load(InName: string): ProxyLODMeshSimplificationSettings;
    }
    
    class RadialForceComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Radius: number;
        Falloff: number;
        ImpulseStrength: number;
        bImpulseVelChange: boolean;
        bIgnoreOwningActor: boolean;
        ForceStrength: number;
        DestructibleDamage: number;
        ObjectTypesToAffect: TArray<number>;
        RemoveObjectTypeToAffect(ObjectType: number): void;
        FireImpulse(): void;
        AddObjectTypeToAffect(ObjectType: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialForceComponent;
        static Load(InName: string): RadialForceComponent;
    }
    
    class RadialForceActor extends RigidBodyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ForceComponent: RadialForceComponent;
        SpriteComponent: BillboardComponent;
        ToggleForce(): void;
        FireImpulse(): void;
        EnableForce(): void;
        DisableForce(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialForceActor;
        static Load(InName: string): RadialForceActor;
    }
    
    class RectLightComponent extends LocalLightComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceWidth: number;
        SourceHeight: number;
        BarnDoorAngle: number;
        BarnDoorLength: number;
        SourceTexture: Texture;
        SetSourceWidth(bNewValue: number): void;
        SetSourceTexture(bNewValue: Texture): void;
        SetSourceHeight(NewValue: number): void;
        SetBarnDoorLength(NewValue: number): void;
        SetBarnDoorAngle(NewValue: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RectLightComponent;
        static Load(InName: string): RectLightComponent;
    }
    
    class RectLight extends Light {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RectLightComponent: RectLightComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RectLight;
        static Load(InName: string): RectLight;
    }
    
    class RendererSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMobileHDR: boolean;
        bMobileDisableVertexFog: boolean;
        MaxMobileCascades: number;
        MobileMSAASampleCount: number;
        bMobileUseLegacyShadingModel: boolean;
        bMobileUseHWsRGBEncoding: boolean;
        bMobileAllowDitheredLODTransition: boolean;
        bMobileAllowSoftwareOcclusionCulling: boolean;
        bDiscardUnusedQualityLevels: boolean;
        bOcclusionCulling: boolean;
        MinScreenRadiusForLights: number;
        MinScreenRadiusForEarlyZPass: number;
        MinScreenRadiusForCSMdepth: number;
        bPrecomputedVisibilityWarning: boolean;
        bTextureStreaming: boolean;
        bUseDXT5NormalMaps: boolean;
        bVirtualTextures: boolean;
        bVirtualTexturedLightmaps: boolean;
        VirtualTextureTileSize: number;
        VirtualTextureTileBorderSize: number;
        VirtualTextureFeedbackFactor: number;
        bVirtualTextureEnableCompressZlib: boolean;
        bVirtualTextureEnableCompressCrunch: boolean;
        bClearCoatEnableSecondNormal: boolean;
        ReflectionCaptureResolution: number;
        ReflectionEnvironmentLightmapMixBasedOnRoughness: boolean;
        bForwardShading: boolean;
        bVertexFoggingForOpaque: boolean;
        bAllowStaticLighting: boolean;
        bUseNormalMapsForStaticLighting: boolean;
        bGenerateMeshDistanceFields: boolean;
        bEightBitMeshDistanceFields: boolean;
        bGenerateLandscapeGIData: boolean;
        bCompressMeshDistanceFields: boolean;
        TessellationAdaptivePixelsPerTriangle: number;
        bSeparateTranslucency: boolean;
        TranslucentSortPolicy: number;
        TranslucentSortAxis: Vector;
        CustomDepthStencil: number;
        bCustomDepthTaaJitter: boolean;
        bEnableAlphaChannelInPostProcessing: number;
        bDefaultFeatureBloom: boolean;
        bDefaultFeatureAmbientOcclusion: boolean;
        bDefaultFeatureAmbientOcclusionStaticFraction: boolean;
        bDefaultFeatureAutoExposure: boolean;
        DefaultFeatureAutoExposure: number;
        bExtendDefaultLuminanceRangeInAutoExposureSettings: boolean;
        bUsePreExposure: boolean;
        bEnablePreExposureOnlyInTheEditor: boolean;
        bDefaultFeatureMotionBlur: boolean;
        bDefaultFeatureLensFlare: boolean;
        bTemporalUpsampling: boolean;
        bSSGI: boolean;
        DefaultFeatureAntiAliasing: number;
        DefaultLightUnits: ELightUnits;
        DefaultBackBufferPixelFormat: number;
        bRenderUnbuiltPreviewShadowsInGame: boolean;
        bStencilForLODDither: boolean;
        EarlyZPass: number;
        bEarlyZPassOnlyMaterialMasking: boolean;
        bDBuffer: boolean;
        ClearSceneMethod: number;
        bBasePassOutputsVelocity: boolean;
        bSelectiveBasePassOutputs: boolean;
        bDefaultParticleCutouts: boolean;
        GPUSimulationTextureSizeX: number;
        GPUSimulationTextureSizeY: number;
        bGlobalClipPlane: boolean;
        GBufferFormat: number;
        bUseGPUMorphTargets: boolean;
        bNvidiaAftermathEnabled: boolean;
        bInstancedStereo: boolean;
        bMultiView: boolean;
        bMobileMultiView: boolean;
        bMobileMultiViewDirect: boolean;
        bRoundRobinOcclusion: boolean;
        bODSCapture: boolean;
        WireframeCullThreshold: number;
        bEnableRayTracing: boolean;
        bEnableRayTracingTextureLOD: boolean;
        bSupportStationarySkylight: boolean;
        bSupportLowQualityLightmaps: boolean;
        bSupportPointLightWholeSceneShadows: boolean;
        bSupportAtmosphericFog: boolean;
        bSupportSkyAtmosphere: boolean;
        bSupportSkyAtmosphereAffectsHeightFog: boolean;
        bSupportSkinCacheShaders: boolean;
        bMobileEnableStaticAndCSMShadowReceivers: boolean;
        bMobileEnableMovableLightCSMShaderCulling: boolean;
        bMobileAllowDistanceFieldShadows: boolean;
        bMobileAllowMovableDirectionalLights: boolean;
        MobileNumDynamicPointLights: number;
        bMobileDynamicPointLightsUseStaticBranch: boolean;
        bMobileAllowMovableSpotlights: boolean;
        SkinCacheSceneMemoryLimitInMB: number;
        bGPUSkinLimit2BoneInfluences: boolean;
        bSupportDepthOnlyIndexBuffers: boolean;
        bSupportReversedIndexBuffers: boolean;
        bSupportMaterialLayers: boolean;
        bLPV: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RendererSettings;
        static Load(InName: string): RendererSettings;
    }
    
    class RendererOverrideSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSupportAllShaderPermutations: boolean;
        bForceRecomputeTangents: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RendererOverrideSettings;
        static Load(InName: string): RendererOverrideSettings;
    }
    
    class ReplicationConnectionDriver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReplicationConnectionDriver;
        static Load(InName: string): ReplicationConnectionDriver;
    }
    
    class RotatingMovementComponent extends MovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationRate: Rotator;
        PivotTranslation: Vector;
        bRotationInLocalSpace: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RotatingMovementComponent;
        static Load(InName: string): RotatingMovementComponent;
    }
    
    class RuntimeOptionsBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeOptionsBase;
        static Load(InName: string): RuntimeOptionsBase;
    }
    
    class RuntimeVirtualTextureComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VirtualTexture: RuntimeVirtualTexture;
        bUseStreamingLowMipsInEditor: boolean;
        BoundsSourceActor: Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureComponent;
        static Load(InName: string): RuntimeVirtualTextureComponent;
    }
    
    class RuntimeVirtualTextureVolume extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VirtualTextureComponent: RuntimeVirtualTextureComponent;
        Box: BoxComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureVolume;
        static Load(InName: string): RuntimeVirtualTextureVolume;
    }
    
    class RVOAvoidanceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RVOAvoidanceInterface;
        static Load(InName: string): RVOAvoidanceInterface;
    }
    
    class Scene extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Scene;
        static Load(InName: string): Scene;
    }
    
    class SceneCaptureComponent2D extends SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProjectionType: number;
        FOVAngle: number;
        OrthoWidth: number;
        TextureTarget: TextureRenderTarget2D;
        CompositeMode: number;
        PostProcessSettings: PostProcessSettings;
        PostProcessBlendWeight: number;
        bOverride_CustomNearClippingPlane: boolean;
        CustomNearClippingPlane: number;
        bUseCustomProjectionMatrix: boolean;
        CustomProjectionMatrix: Matrix;
        bEnableClipPlane: boolean;
        ClipPlaneBase: Vector;
        ClipPlaneNormal: Vector;
        bCameraCutThisFrame: boolean;
        bConsiderUnrenderedOpaquePixelAsFullyTranslucent: boolean;
        CaptureScene(): void;
        AddOrUpdateBlendable(InBlendableObject: BlendableInterface, InWeight: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponent2D;
        static Load(InName: string): SceneCaptureComponent2D;
    }
    
    class SceneCapture2D extends SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponent2D: SceneCaptureComponent2D;
        OnInterpToggle(bEnable: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCapture2D;
        static Load(InName: string): SceneCapture2D;
    }
    
    class TextureRenderTargetCube extends TextureRenderTarget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        ClearColor: LinearColor;
        OverrideFormat: number;
        bHDR: boolean;
        bForceLinearGamma: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureRenderTargetCube;
        static Load(InName: string): TextureRenderTargetCube;
    }
    
    class SceneCaptureComponentCube extends SceneCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextureTarget: TextureRenderTargetCube;
        bCaptureRotation: boolean;
        TextureTargetLeft: TextureRenderTargetCube;
        TextureTargetRight: TextureRenderTargetCube;
        TextureTargetODS: TextureRenderTarget2D;
        IPD: number;
        CaptureScene(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureComponentCube;
        static Load(InName: string): SceneCaptureComponentCube;
    }
    
    class SceneCaptureCube extends SceneCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponentCube: SceneCaptureComponentCube;
        OnInterpToggle(bEnable: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneCaptureCube;
        static Load(InName: string): SceneCaptureCube;
    }
    
    class Selection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Selection;
        static Load(InName: string): Selection;
    }
    
    class ShadowMapTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShadowmapFlags: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShadowMapTexture2D;
        static Load(InName: string): ShadowMapTexture2D;
    }
    
    class SkeletalMeshSimplificationSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletalMeshReductionModuleName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSimplificationSettings;
        static Load(InName: string): SkeletalMeshSimplificationSettings;
    }
    
    class TentDistribution {
        constructor(TipAltitude: number, TipValue: number, Width: number);
        TipAltitude: number;
        TipValue: number;
        Width: number;
    }
    
    class SkyAtmosphereComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BottomRadius: number;
        GroundAlbedo: Color;
        AtmosphereHeight: number;
        MultiScatteringFactor: number;
        RayleighScatteringScale: number;
        RayleighScattering: LinearColor;
        RayleighExponentialDistribution: number;
        MieScatteringScale: number;
        MieScattering: LinearColor;
        MieAbsorptionScale: number;
        MieAbsorption: LinearColor;
        MieAnisotropy: number;
        MieExponentialDistribution: number;
        OtherAbsorptionScale: number;
        OtherAbsorption: LinearColor;
        OtherTentDistribution: TentDistribution;
        SkyLuminanceFactor: LinearColor;
        AerialPespectiveViewDistanceScale: number;
        HeightFogContribution: number;
        TransmittanceMinLightElevationAngle: number;
        bStaticLightingBuiltGUID: Guid;
        SetSkyLuminanceFactor(NewValue: LinearColor): void;
        SetRayleighScatteringScale(NewValue: number): void;
        SetRayleighScattering(NewValue: LinearColor): void;
        SetRayleighExponentialDistribution(NewValue: number): void;
        SetOtherAbsorptionScale(NewValue: number): void;
        SetOtherAbsorption(NewValue: LinearColor): void;
        SetMieScatteringScale(NewValue: number): void;
        SetMieScattering(NewValue: LinearColor): void;
        SetMieExponentialDistribution(NewValue: number): void;
        SetMieAnisotropy(NewValue: number): void;
        SetMieAbsorptionScale(NewValue: number): void;
        SetMieAbsorption(NewValue: LinearColor): void;
        SetHeightFogContribution(NewValue: number): void;
        SetAerialPespectiveViewDistanceScale(NewValue: number): void;
        OverrideAtmosphereLightDirection(AtmosphereLightIndex: number, LightDirection: Vector): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyAtmosphereComponent;
        static Load(InName: string): SkyAtmosphereComponent;
    }
    
    class SkyAtmosphere extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkyAtmosphereComponent: SkyAtmosphereComponent;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkyAtmosphere;
        static Load(InName: string): SkyAtmosphere;
    }
    
    class SmokeTestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SmokeTestCommandlet;
        static Load(InName: string): SmokeTestCommandlet;
    }
    
    class SoundCueTemplate extends SoundCue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueTemplate;
        static Load(InName: string): SoundCueTemplate;
    }
    
    class SoundGroup {
        constructor(SoundGroup: number, DisplayName: string, bAlwaysDecompressOnLoad: boolean, DecompressedDuration: number);
        SoundGroup: number;
        DisplayName: string;
        bAlwaysDecompressOnLoad: boolean;
        DecompressedDuration: number;
    }
    
    class SoundGroups extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundGroupProfiles: TArray<SoundGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundGroups;
        static Load(InName: string): SoundGroups;
    }
    
    class SoundNodeAssetReferencer extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeAssetReferencer;
        static Load(InName: string): SoundNodeAssetReferencer;
    }
    
    class SoundNodeAttenuation extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AttenuationSettings: SoundAttenuation;
        AttenuationOverrides: SoundAttenuationSettings;
        bOverrideAttenuation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeAttenuation;
        static Load(InName: string): SoundNodeAttenuation;
    }
    
    class SoundNodeBranch extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoolParameterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeBranch;
        static Load(InName: string): SoundNodeBranch;
    }
    
    class SoundNodeConcatenator extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputVolume: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeConcatenator;
        static Load(InName: string): SoundNodeConcatenator;
    }
    
    class SoundNodeDelay extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelayMin: number;
        DelayMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDelay;
        static Load(InName: string): SoundNodeDelay;
    }
    
    class DialogueWaveParameter {
        constructor(DialogueWave: DialogueWave, Context: DialogueContext);
        DialogueWave: DialogueWave;
        Context: DialogueContext;
    }
    
    class SoundNodeDialoguePlayer extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DialogueWaveParameter: DialogueWaveParameter;
        bLooping: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDialoguePlayer;
        static Load(InName: string): SoundNodeDialoguePlayer;
    }
    
    class DistanceDatum {
        constructor(FadeInDistanceStart: number, FadeInDistanceEnd: number, FadeOutDistanceStart: number, FadeOutDistanceEnd: number, Volume: number);
        FadeInDistanceStart: number;
        FadeInDistanceEnd: number;
        FadeOutDistanceStart: number;
        FadeOutDistanceEnd: number;
        Volume: number;
    }
    
    class SoundNodeDistanceCrossFade extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CrossFadeInput: TArray<DistanceDatum>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDistanceCrossFade;
        static Load(InName: string): SoundNodeDistanceCrossFade;
    }
    
    class SoundNodeDoppler extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DopplerIntensity: number;
        bUseSmoothing: boolean;
        SmoothingInterpSpeed: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeDoppler;
        static Load(InName: string): SoundNodeDoppler;
    }
    
    class SoundNodeEnveloper extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoopStart: number;
        LoopEnd: number;
        DurationAfterLoop: number;
        LoopCount: number;
        bLoopIndefinitely: boolean;
        bLoop: boolean;
        VolumeInterpCurve: DistributionFloatConstantCurve;
        PitchInterpCurve: DistributionFloatConstantCurve;
        VolumeCurve: RuntimeFloatCurve;
        PitchCurve: RuntimeFloatCurve;
        PitchMin: number;
        PitchMax: number;
        VolumeMin: number;
        VolumeMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeEnveloper;
        static Load(InName: string): SoundNodeEnveloper;
    }
    
    class SoundNodeGroupControl extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupSizes: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeGroupControl;
        static Load(InName: string): SoundNodeGroupControl;
    }
    
    class SoundNodeLooping extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoopCount: number;
        bLoopIndefinitely: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeLooping;
        static Load(InName: string): SoundNodeLooping;
    }
    
    class SoundNodeMature extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeMature;
        static Load(InName: string): SoundNodeMature;
    }
    
    class SoundNodeMixer extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InputVolume: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeMixer;
        static Load(InName: string): SoundNodeMixer;
    }
    
    class SoundNodeModulator extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PitchMin: number;
        PitchMax: number;
        VolumeMin: number;
        VolumeMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeModulator;
        static Load(InName: string): SoundNodeModulator;
    }
    
    class ModulatorContinuousParams {
        constructor(ParameterName: string, Default: number, MinInput: number, MaxInput: number, MinOutput: number, MaxOutput: number, ParamMode: number);
        ParameterName: string;
        Default: number;
        MinInput: number;
        MaxInput: number;
        MinOutput: number;
        MaxOutput: number;
        ParamMode: number;
    }
    
    class SoundNodeModulatorContinuous extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PitchModulationParams: ModulatorContinuousParams;
        VolumeModulationParams: ModulatorContinuousParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeModulatorContinuous;
        static Load(InName: string): SoundNodeModulatorContinuous;
    }
    
    class SoundNodeOscillator extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bModulateVolume: boolean;
        bModulatePitch: boolean;
        AmplitudeMin: number;
        AmplitudeMax: number;
        FrequencyMin: number;
        FrequencyMax: number;
        OffsetMin: number;
        OffsetMax: number;
        CenterMin: number;
        CenterMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeOscillator;
        static Load(InName: string): SoundNodeOscillator;
    }
    
    class SoundNodeParamCrossFade extends SoundNodeDistanceCrossFade {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeParamCrossFade;
        static Load(InName: string): SoundNodeParamCrossFade;
    }
    
    class SoundNodeQualityLevel extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeQualityLevel;
        static Load(InName: string): SoundNodeQualityLevel;
    }
    
    class SoundNodeRandom extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Weights: TArray<number>;
        HasBeenUsed: TArray<boolean>;
        NumRandomUsed: number;
        PreselectAtLevelLoad: number;
        bShouldExcludeFromBranchCulling: boolean;
        bSoundCueExcludedFromBranchCulling: boolean;
        bRandomizeWithoutReplacement: boolean;
        PIEHiddenNodes: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeRandom;
        static Load(InName: string): SoundNodeRandom;
    }
    
    class SoundNodeSoundClass extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundClassOverride: SoundClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeSoundClass;
        static Load(InName: string): SoundNodeSoundClass;
    }
    
    class SoundNodeSwitch extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntParameterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeSwitch;
        static Load(InName: string): SoundNodeSwitch;
    }
    
    class SoundNodeWaveParam extends SoundNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WaveParameterName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeWaveParam;
        static Load(InName: string): SoundNodeWaveParam;
    }
    
    class SoundNodeWavePlayer extends SoundNodeAssetReferencer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundWaveAssetPtr: TSoftObjectPtr<SoundWave>;
        SoundWave: SoundWave;
        bLooping: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundNodeWavePlayer;
        static Load(InName: string): SoundNodeWavePlayer;
    }
    
    class SpectatorPawnMovement extends FloatingPawnMovement {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIgnoreTimeDilation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorPawnMovement;
        static Load(InName: string): SpectatorPawnMovement;
    }
    
    class SphereReflectionCapture extends ReflectionCapture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DrawCaptureRadius: DrawSphereComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SphereReflectionCapture;
        static Load(InName: string): SphereReflectionCapture;
    }
    
    class SphereReflectionCaptureComponent extends ReflectionCaptureComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InfluenceRadius: number;
        CaptureDistanceScale: number;
        PreviewInfluenceRadius: DrawSphereComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SphereReflectionCaptureComponent;
        static Load(InName: string): SphereReflectionCaptureComponent;
    }
    
    class SplineMeshActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SplineMeshComponent: SplineMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMeshActor;
        static Load(InName: string): SplineMeshActor;
    }
    
    class SpringArmComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetArmLength: number;
        SocketOffset: Vector;
        TargetOffset: Vector;
        ProbeSize: number;
        ProbeChannel: number;
        bDoCollisionTest: boolean;
        bUsePawnControlRotation: boolean;
        bInheritPitch: boolean;
        bInheritYaw: boolean;
        bInheritRoll: boolean;
        bEnableCameraLag: boolean;
        bEnableCameraRotationLag: boolean;
        bUseCameraLagSubstepping: boolean;
        bDrawDebugLagMarkers: boolean;
        CameraLagSpeed: number;
        CameraRotationLagSpeed: number;
        CameraLagMaxTimeStep: number;
        CameraLagMaxDistance: number;
        IsCollisionFixApplied(): boolean;
        GetUnfixedCameraPosition(): Vector;
        GetTargetRotation(): Rotator;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpringArmComponent;
        static Load(InName: string): SpringArmComponent;
    }
    
    class EquirectProps {
        constructor(LeftUVRect: Box2D, RightUVRect: Box2D, LeftScale: Vector2D, RightScale: Vector2D, LeftBias: Vector2D, RightBias: Vector2D);
        LeftUVRect: Box2D;
        RightUVRect: Box2D;
        LeftScale: Vector2D;
        RightScale: Vector2D;
        LeftBias: Vector2D;
        RightBias: Vector2D;
    }
    
    class StereoLayerComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bLiveTexture: boolean;
        bSupportsDepth: boolean;
        bNoAlphaChannel: boolean;
        Texture: Texture;
        LeftTexture: Texture;
        bQuadPreserveTextureRatio: boolean;
        QuadSize: Vector2D;
        UVRect: Box2D;
        CylinderRadius: number;
        CylinderOverlayArc: number;
        CylinderHeight: number;
        EquirectProps: EquirectProps;
        StereoLayerType: number;
        StereoLayerShape: number;
        Priority: number;
        SetUVRect(InUVRect: Box2D): void;
        SetTexture(InTexture: Texture): void;
        SetQuadSize(InQuadSize: Vector2D): void;
        SetPriority(InPriority: number): void;
        SetLeftTexture(InTexture: Texture): void;
        SetEquirectProps(InScaleBiases: EquirectProps): void;
        MarkTextureForUpdate(): void;
        GetUVRect(): Box2D;
        GetTexture(): Texture;
        GetQuadSize(): Vector2D;
        GetPriority(): number;
        GetLeftTexture(): Texture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StereoLayerComponent;
        static Load(InName: string): StereoLayerComponent;
    }
    
    class StereoLayerFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ShowSplashScreen(): void;
        static SetSplashScreen(Texture: Texture, Scale: Vector2D, Offset: Vector, bShowLoadingMovie: boolean, bShowOnSet: boolean): void;
        static HideSplashScreen(): void;
        static EnableAutoLoadingSplashScreen(InAutoShowEnabled: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StereoLayerFunctionLibrary;
        static Load(InName: string): StereoLayerFunctionLibrary;
    }
    
    class StringTable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StringTable;
        static Load(InName: string): StringTable;
    }
    
    class WorldSubsystem extends Subsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldSubsystem;
        static Load(InName: string): WorldSubsystem;
    }
    
    class SubsystemBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetWorldSubsystem(ContextObject: Object, Class: Class): WorldSubsystem;
        static GetLocalPlayerSubSystemFromPlayerController(PlayerController: PlayerController, Class: Class): LocalPlayerSubsystem;
        static GetLocalPlayerSubsystem(ContextObject: Object, Class: Class): LocalPlayerSubsystem;
        static GetGameInstanceSubsystem(ContextObject: Object, Class: Class): GameInstanceSubsystem;
        static GetEngineSubsystem(Class: Class): EngineSubsystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SubsystemBlueprintLibrary;
        static Load(InName: string): SubsystemBlueprintLibrary;
    }
    
    class SystemTimeTimecodeProvider extends TimecodeProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameRate: FrameRate;
        SetFrameRate(InFrameRate: FrameRate): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SystemTimeTimecodeProvider;
        static Load(InName: string): SystemTimeTimecodeProvider;
    }
    
    class TargetPoint extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: BillboardComponent;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TargetPoint;
        static Load(InName: string): TargetPoint;
    }
    
    class TextPropertyTestObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultedText: string;
        UndefaultedText: string;
        TransientText: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextPropertyTestObject;
        static Load(InName: string): TextPropertyTestObject;
    }
    
    class TextRenderActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TextRender: TextRenderComponent;
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextRenderActor;
        static Load(InName: string): TextRenderActor;
    }
    
    class Texture2DArray extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddressX: number;
        AddressY: number;
        AddressZ: number;
        SourceTextures: TArray<Texture2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Texture2DArray;
        static Load(InName: string): Texture2DArray;
    }
    
    class TimelineEventEntry {
        constructor(Time: number, EventFunc: $Delegate<() => void>);
        Time: number;
        EventFunc: $Delegate<() => void>;
    }
    
    class TimelineVectorTrack {
        constructor(VectorCurve: CurveVector, InterpFunc: $Delegate<(Output: Vector) => void>, TrackName: string, VectorPropertyName: string, VectorProperty: StructProperty);
        VectorCurve: CurveVector;
        InterpFunc: $Delegate<(Output: Vector) => void>;
        TrackName: string;
        VectorPropertyName: string;
        VectorProperty: StructProperty;
    }
    
    class TimelineFloatTrack {
        constructor(FloatCurve: CurveFloat, InterpFunc: $Delegate<(Output: number) => void>, TrackName: string, FloatPropertyName: string, FloatProperty: FloatProperty);
        FloatCurve: CurveFloat;
        InterpFunc: $Delegate<(Output: number) => void>;
        TrackName: string;
        FloatPropertyName: string;
        FloatProperty: FloatProperty;
    }
    
    class TimelineLinearColorTrack {
        constructor(LinearColorCurve: CurveLinearColor, InterpFunc: $Delegate<(Output: LinearColor) => void>, TrackName: string, LinearColorPropertyName: string, LinearColorProperty: StructProperty);
        LinearColorCurve: CurveLinearColor;
        InterpFunc: $Delegate<(Output: LinearColor) => void>;
        TrackName: string;
        LinearColorPropertyName: string;
        LinearColorProperty: StructProperty;
    }
    
    class Timeline {
        constructor(LengthMode: number, bLooping: boolean, bReversePlayback: boolean, bPlaying: boolean, Length: number, PlayRate: number, Position: number, Events: TArray<TimelineEventEntry>, InterpVectors: TArray<TimelineVectorTrack>, InterpFloats: TArray<TimelineFloatTrack>, InterpLinearColors: TArray<TimelineLinearColorTrack>, TimelinePostUpdateFunc: $Delegate<() => void>, TimelineFinishedFunc: $Delegate<() => void>, PropertySetObject: TWeakObjectPtr<Object>, DirectionPropertyName: string, DirectionProperty: Property);
        LengthMode: number;
        bLooping: boolean;
        bReversePlayback: boolean;
        bPlaying: boolean;
        Length: number;
        PlayRate: number;
        Position: number;
        Events: TArray<TimelineEventEntry>;
        InterpVectors: TArray<TimelineVectorTrack>;
        InterpFloats: TArray<TimelineFloatTrack>;
        InterpLinearColors: TArray<TimelineLinearColorTrack>;
        TimelinePostUpdateFunc: $Delegate<() => void>;
        TimelineFinishedFunc: $Delegate<() => void>;
        PropertySetObject: TWeakObjectPtr<Object>;
        DirectionPropertyName: string;
        DirectionProperty: Property;
    }
    
    class TimelineComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TheTimeline: Timeline;
        bIgnoreTimeDilation: boolean;
        Stop(): void;
        SetVectorCurve(NewVectorCurve: CurveVector, VectorTrackName: string): void;
        SetTimelineLengthMode(NewLengthMode: number): void;
        SetTimelineLength(NewLength: number): void;
        SetPlayRate(NewRate: number): void;
        SetPlaybackPosition(NewPosition: number, bFireEvents: boolean, bFireUpdate: boolean): void;
        SetNewTime(NewTime: number): void;
        SetLooping(bNewLooping: boolean): void;
        SetLinearColorCurve(NewLinearColorCurve: CurveLinearColor, LinearColorTrackName: string): void;
        SetIgnoreTimeDilation(bNewIgnoreTimeDilation: boolean): void;
        SetFloatCurve(NewFloatCurve: CurveFloat, FloatTrackName: string): void;
        ReverseFromEnd(): void;
        Reverse(): void;
        PlayFromStart(): void;
        Play(): void;
        OnRep_Timeline(): void;
        IsReversing(): boolean;
        IsPlaying(): boolean;
        IsLooping(): boolean;
        GetTimelineLength(): number;
        GetPlayRate(): number;
        GetPlaybackPosition(): number;
        GetIgnoreTimeDilation(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimelineComponent;
        static Load(InName: string): TimelineComponent;
    }
    
    class TriggerBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CollisionComponent: ShapeComponent;
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerBase;
        static Load(InName: string): TriggerBase;
    }
    
    class TriggerBox extends TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerBox;
        static Load(InName: string): TriggerBox;
    }
    
    class TriggerCapsule extends TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerCapsule;
        static Load(InName: string): TriggerCapsule;
    }
    
    class TriggerSphere extends TriggerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerSphere;
        static Load(InName: string): TriggerSphere;
    }
    
    class TriggerVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TriggerVolume;
        static Load(InName: string): TriggerVolume;
    }
    
    class TwitterIntegrationBase extends PlatformInterfaceBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TwitterRequest(URL: string, ParamKeysAndValues: TArray<string>, RequestMethod: number, AccountIndex: number): boolean;
        ShowTweetUI(InitialMessage: string, URL: string, Picture: string): boolean;
        Init(): void;
        GetNumAccounts(): number;
        GetAccountName(AccountIndex: number): string;
        CanShowTweetUI(): boolean;
        AuthorizeAccounts(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TwitterIntegrationBase;
        static Load(InName: string): TwitterIntegrationBase;
    }
    
    class UserDefinedEnum extends Enum {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UniqueNameIndex: number;
        EnumDescription: string;
        DisplayNameMap: TMap<string, string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedEnum;
        static Load(InName: string): UserDefinedEnum;
    }
    
    class UserDefinedStruct extends ScriptStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PrimaryStruct: TWeakObjectPtr<UserDefinedStruct>;
        ErrorMessage: string;
        EditorData: Object;
        Status: number;
        Guid: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserDefinedStruct;
        static Load(InName: string): UserDefinedStruct;
    }
    
    enum ERenderFocusRule { Always, NonPointer, NavigationOnly, Never, ERenderFocusRule_MAX}
    class HardwareCursorReference {
        constructor(CursorPath: string, HotSpot: Vector2D);
        CursorPath: string;
        HotSpot: Vector2D;
    }
    
    enum EUIScalingRule { ShortestSide, LongestSide, Horizontal, Vertical, Custom, EUIScalingRule_MAX}
    class UserInterfaceSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderFocusRule: ERenderFocusRule;
        HardwareCursors: TMap<number, HardwareCursorReference>;
        SoftwareCursors: TMap<number, SoftClassPath>;
        DefaultCursor: SoftClassPath;
        TextEditBeamCursor: SoftClassPath;
        CrosshairsCursor: SoftClassPath;
        HandCursor: SoftClassPath;
        GrabHandCursor: SoftClassPath;
        GrabHandClosedCursor: SoftClassPath;
        SlashedCircleCursor: SoftClassPath;
        ApplicationScale: number;
        UIScaleRule: EUIScalingRule;
        CustomScalingRuleClass: SoftClassPath;
        UIScaleCurve: RuntimeFloatCurve;
        bAllowHighDPIInGameMode: boolean;
        bLoadWidgetsOnDedicatedServer: boolean;
        CursorClasses: TArray<Object>;
        CustomScalingRuleClassInstance: Class;
        CustomScalingRule: DPICustomScalingRule;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UserInterfaceSettings;
        static Load(InName: string): UserInterfaceSettings;
    }
    
    class VectorFieldStatic extends VectorField {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SizeX: number;
        SizeY: number;
        SizeZ: number;
        bAllowCPUAccess: boolean;
        CPUData: TArray<Vector4>;
        SourceFilePath: string;
        AssetImportData: AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldStatic;
        static Load(InName: string): VectorFieldStatic;
    }
    
    class VectorFieldAnimated extends VectorField {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Texture: Texture2D;
        ConstructionOp: number;
        VolumeSizeX: number;
        VolumeSizeY: number;
        VolumeSizeZ: number;
        SubImagesX: number;
        SubImagesY: number;
        FrameCount: number;
        FramesPerSecond: number;
        bLoop: boolean;
        NoiseField: VectorFieldStatic;
        NoiseScale: number;
        NoiseMax: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldAnimated;
        static Load(InName: string): VectorFieldAnimated;
    }
    
    class VectorFieldComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorField: VectorField;
        Intensity: number;
        Tightness: number;
        bPreviewVectorField: boolean;
        SetIntensity(NewIntensity: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldComponent;
        static Load(InName: string): VectorFieldComponent;
    }
    
    class VectorFieldVolume extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VectorFieldComponent: VectorFieldComponent;
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorFieldVolume;
        static Load(InName: string): VectorFieldVolume;
    }
    
    class VirtualTexture extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VirtualTexture;
        static Load(InName: string): VirtualTexture;
    }
    
    class LightMapVirtualTexture extends VirtualTexture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightMapVirtualTexture;
        static Load(InName: string): LightMapVirtualTexture;
    }
    
    class LightMapVirtualTexture2D extends Texture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TypeToLayer: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightMapVirtualTexture2D;
        static Load(InName: string): LightMapVirtualTexture2D;
    }
    
    class VirtualTextureSpacePoolConfig {
        constructor(MinTileSize: number, MaxTileSize: number, Formats: TArray<number>, SizeInMegabyte: number, bAllowSizeScale: boolean);
        MinTileSize: number;
        MaxTileSize: number;
        Formats: TArray<number>;
        SizeInMegabyte: number;
        bAllowSizeScale: boolean;
    }
    
    class VirtualTexturePoolConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultSizeInMegabyte: number;
        Pools: TArray<VirtualTextureSpacePoolConfig>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VirtualTexturePoolConfig;
        static Load(InName: string): VirtualTexturePoolConfig;
    }
    
    class VisualLoggerAutomationTests extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerAutomationTests;
        static Load(InName: string): VisualLoggerAutomationTests;
    }
    
    class VisualLoggerDebugSnapshotInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerDebugSnapshotInterface;
        static Load(InName: string): VisualLoggerDebugSnapshotInterface;
    }
    
    class VisualLoggerKismetLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RedirectVislog(SourceOwner: Object, DestinationOwner: Object): void;
        static LogText(WorldContextObject: Object, Text: string, LogCategory: string, bAddToMessageLog: boolean): void;
        static LogSegment(WorldContextObject: Object, SegmentStart: Vector, SegmentEnd: Vector, Text: string, ObjectColor: LinearColor, Thickness: number, CategoryName: string, bAddToMessageLog: boolean): void;
        static LogLocation(WorldContextObject: Object, Location: Vector, Text: string, ObjectColor: LinearColor, Radius: number, LogCategory: string, bAddToMessageLog: boolean): void;
        static LogBox(WorldContextObject: Object, BoxShape: Box, Text: string, ObjectColor: LinearColor, LogCategory: string, bAddToMessageLog: boolean): void;
        static EnableRecording(bEnabled: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerKismetLibrary;
        static Load(InName: string): VisualLoggerKismetLibrary;
    }
    
    class VoiceChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VoiceChannel;
        static Load(InName: string): VoiceChannel;
    }
    
    class VoiceSettings {
        constructor(ComponentToAttachTo: SceneComponent, AttenuationSettings: SoundAttenuation, SourceEffectChain: SoundEffectSourcePresetChain);
        ComponentToAttachTo: SceneComponent;
        AttenuationSettings: SoundAttenuation;
        SourceEffectChain: SoundEffectSourcePresetChain;
    }
    
    class VOIPTalker extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: VoiceSettings;
        RegisterWithPlayerState(OwningState: PlayerState): void;
        GetVoiceLevel(): number;
        static CreateTalkerForPlayer(OwningState: PlayerState): VOIPTalker;
        BPOnTalkingEnd(): void;
        BPOnTalkingBegin(AudioComponent: AudioComponent): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VOIPTalker;
        static Load(InName: string): VOIPTalker;
    }
    
    class VOIPStatics extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetMicThreshold(InThreshold: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VOIPStatics;
        static Load(InName: string): VOIPStatics;
    }
    
    class VolumeTexture extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Source2DTexture: Texture2D;
        SourceLightingGuid: Guid;
        Source2DTileSizeX: number;
        Source2DTileSizeY: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumeTexture;
        static Load(InName: string): VolumeTexture;
    }
    
    class VolumetricLightmapDensityVolume extends Volume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllowedMipLevelRange: Int32Interval;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VolumetricLightmapDensityVolume;
        static Load(InName: string): VolumetricLightmapDensityVolume;
    }
    
    enum EWindSourceType { Directional, Point, EWindSourceType_MAX}
    class WindDirectionalSourceComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Strength: number;
        Speed: number;
        MinGustAmount: number;
        MaxGustAmount: number;
        Radius: number;
        bPointWind: boolean;
        SetWindType(InNewType: EWindSourceType): void;
        SetStrength(InNewStrength: number): void;
        SetSpeed(InNewSpeed: number): void;
        SetRadius(InNewRadius: number): void;
        SetMinimumGustAmount(InNewMinGust: number): void;
        SetMaximumGustAmount(InNewMaxGust: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindDirectionalSourceComponent;
        static Load(InName: string): WindDirectionalSourceComponent;
    }
    
    class WindDirectionalSource extends Info {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Component: WindDirectionalSourceComponent;
        ArrowComponent: ArrowComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindDirectionalSource;
        static Load(InName: string): WindDirectionalSource;
    }
    
    class HierarchicalLODSetup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HierarchicalLODSetup: TArray<HierarchicalSimplification>;
        OverrideBaseMaterial: TSoftObjectPtr<MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): HierarchicalLODSetup;
        static Load(InName: string): HierarchicalLODSetup;
    }
    
    class MoviePlayerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bWaitForMoviesToComplete: boolean;
        bMoviesAreSkippable: boolean;
        StartupMovies: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MoviePlayerSettings;
        static Load(InName: string): MoviePlayerSettings;
    }
    
    class SHAHashData {
        constructor(Hash: FixSizeArray<number>);
        Hash: FixSizeArray<number>;
    }
    
    class ChunkPartData {
        constructor(Guid: Guid, Offset: number, Size: number);
        Guid: Guid;
        Offset: number;
        Size: number;
    }
    
    class FileManifestData {
        constructor(Filename: string, FileHash: SHAHashData, FileChunkParts: TArray<ChunkPartData>, InstallTags: TArray<string>, bIsUnixExecutable: boolean, SymlinkTarget: string, bIsReadOnly: boolean, bIsCompressed: boolean);
        Filename: string;
        FileHash: SHAHashData;
        FileChunkParts: TArray<ChunkPartData>;
        InstallTags: TArray<string>;
        bIsUnixExecutable: boolean;
        SymlinkTarget: string;
        bIsReadOnly: boolean;
        bIsCompressed: boolean;
    }
    
    class ChunkInfoData {
        constructor(Guid: Guid, Hash: bigint, ShaHash: SHAHashData, FileSize: bigint, GroupNumber: number);
        Guid: Guid;
        Hash: bigint;
        ShaHash: SHAHashData;
        FileSize: bigint;
        GroupNumber: number;
    }
    
    class CustomFieldData {
        constructor(Key: string, Value: string);
        Key: string;
        Value: string;
    }
    
    class BuildPatchManifest extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ManifestFileVersion: number;
        bIsFileData: boolean;
        AppID: number;
        AppName: string;
        BuildVersion: string;
        LaunchExe: string;
        LaunchCommand: string;
        PrereqIds: TSet<string>;
        PrereqName: string;
        PrereqPath: string;
        PrereqArgs: string;
        FileManifestList: TArray<FileManifestData>;
        ChunkList: TArray<ChunkInfoData>;
        CustomFields: TArray<CustomFieldData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BuildPatchManifest;
        static Load(InName: string): BuildPatchManifest;
    }
    
    class SoundFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoCreateCue: boolean;
        bIncludeAttenuationNode: boolean;
        bIncludeLoopingNode: boolean;
        bIncludeModulatorNode: boolean;
        CueVolume: number;
        CuePackageSuffix: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundFactory;
        static Load(InName: string): SoundFactory;
    }
    
    class ReimportSoundFactory extends SoundFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportSoundFactory;
        static Load(InName: string): ReimportSoundFactory;
    }
    
    class SoundSurroundFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CueVolume: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSurroundFactory;
        static Load(InName: string): SoundSurroundFactory;
    }
    
    class ReimportSoundSurroundFactory extends SoundSurroundFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ReimportPaths: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportSoundSurroundFactory;
        static Load(InName: string): ReimportSoundSurroundFactory;
    }
    
    class DialogueVoiceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueVoiceFactory;
        static Load(InName: string): DialogueVoiceFactory;
    }
    
    class DialogueWaveFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialSoundWave: SoundWave;
        InitialSpeakerVoice: DialogueVoice;
        HasSetInitialTargetVoice: boolean;
        InitialTargetVoices: TArray<DialogueVoice>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DialogueWaveFactory;
        static Load(InName: string): DialogueWaveFactory;
    }
    
    class ReverbEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReverbEffectFactory;
        static Load(InName: string): ReverbEffectFactory;
    }
    
    class SoundAttenuationFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundAttenuationFactory;
        static Load(InName: string): SoundAttenuationFactory;
    }
    
    class SoundClassFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassFactory;
        static Load(InName: string): SoundClassFactory;
    }
    
    class SoundClassGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassGraph;
        static Load(InName: string): SoundClassGraph;
    }
    
    class SoundClassGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundClass: SoundClass;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassGraphNode;
        static Load(InName: string): SoundClassGraphNode;
    }
    
    class SoundClassGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundClassGraphSchema;
        static Load(InName: string): SoundClassGraphSchema;
    }
    
    class SoundConcurrencyFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundConcurrencyFactory;
        static Load(InName: string): SoundConcurrencyFactory;
    }
    
    class SoundCueFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InitialSoundWave: SoundWave;
        InitialDialogueWave: DialogueWave;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueFactoryNew;
        static Load(InName: string): SoundCueFactoryNew;
    }
    
    class SoundCueGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraph;
        static Load(InName: string): SoundCueGraph;
    }
    
    class SoundCueGraphNode_Base extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode_Base;
        static Load(InName: string): SoundCueGraphNode_Base;
    }
    
    class SoundCueGraphNode extends SoundCueGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundNode: SoundNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode;
        static Load(InName: string): SoundCueGraphNode;
    }
    
    class SoundCueGraphNode_Root extends SoundCueGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphNode_Root;
        static Load(InName: string): SoundCueGraphNode_Root;
    }
    
    class SoundCueGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueGraphSchema;
        static Load(InName: string): SoundCueGraphSchema;
    }
    
    class SoundCueTemplateCopyFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundCueTemplate: TWeakObjectPtr<SoundCueTemplate>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueTemplateCopyFactory;
        static Load(InName: string): SoundCueTemplateCopyFactory;
    }
    
    class SoundCueTemplateFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundCueTemplateFactory;
        static Load(InName: string): SoundCueTemplateFactory;
    }
    
    class SoundMixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundMixFactory;
        static Load(InName: string): SoundMixFactory;
    }
    
    class SoundSourceBusFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceBusFactory;
        static Load(InName: string): SoundSourceBusFactory;
    }
    
    class SoundSourceEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundEffectSourcepresetClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceEffectFactory;
        static Load(InName: string): SoundSourceEffectFactory;
    }
    
    class SoundSourceEffectChainFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSourceEffectChainFactory;
        static Load(InName: string): SoundSourceEffectChainFactory;
    }
    
    class SoundSubmixEffectFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundEffectSubmixPresetClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixEffectFactory;
        static Load(InName: string): SoundSubmixEffectFactory;
    }
    
    class SoundSubmixFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixFactory;
        static Load(InName: string): SoundSubmixFactory;
    }
    
    class SoundSubmixGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraph;
        static Load(InName: string): SoundSubmixGraph;
    }
    
    class SoundSubmixGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundSubmix: SoundSubmix;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraphNode;
        static Load(InName: string): SoundSubmixGraphNode;
    }
    
    class SoundSubmixGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SoundSubmixGraphSchema;
        static Load(InName: string): SoundSubmixGraphSchema;
    }
    
    enum ERawCurveTrackTypes { RCT_Float, RCT_Vector, RCT_Transform, RCT_MAX}
    class AnimationBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetRootMotionLockType(AnimationSequence: AnimSequence, RootMotionLockType: number): void;
        static SetRootMotionEnabled(AnimationSequence: AnimSequence, bEnabled: boolean): void;
        static SetRateScale(AnimationSequence: AnimSequence, RateScale: number): void;
        static SetIsRootMotionLockForced(AnimationSequence: AnimSequence, bForced: boolean): void;
        static SetCompressionScheme(AnimationSequence: AnimSequence, CompressionScheme: AnimCompress): void;
        static SetAnimationInterpolationType(AnimationSequence: AnimSequence, InterpolationType: EAnimInterpolationType): void;
        static SetAdditiveBasePoseType(AnimationSequence: AnimSequence, AdditiveBasePoseType: number): void;
        static SetAdditiveAnimationType(AnimationSequence: AnimSequence, AdditiveAnimationType: number): void;
        static ReplaceAnimNotifyStates(AnimationSequence: AnimSequenceBase, OldNotifyClass: Class, NewNotifyClass: Class, OnNotifyStateReplaced: $Delegate<(OldNotifyState: AnimNotifyState, NewNotifyState: AnimNotifyState) => void>): void;
        static ReplaceAnimNotifies(AnimationSequence: AnimSequenceBase, OldNotifyClass: Class, NewNotifyClass: Class, OnNotifyReplaced: $Delegate<(OldNotify: AnimNotify, NewNotify: AnimNotify) => void>): void;
        static RemoveVirtualBones(AnimationSequence: AnimSequence, VirtualBoneNames: TArray<string>): void;
        static RemoveVirtualBone(AnimationSequence: AnimSequence, VirtualBoneName: string): void;
        static RemoveMetaDataOfClass(AnimationSequence: AnimSequence, MetaDataClass: Class): void;
        static RemoveMetaData(AnimationSequence: AnimSequence, MetaDataObject: AnimMetaData): void;
        static RemoveCurve(AnimationSequence: AnimSequence, CurveName: string, bRemoveNameFromSkeleton: boolean): void;
        static RemoveBoneAnimation(AnimationSequence: AnimSequence, BoneName: string, bIncludeChildren: boolean, bFinalize: boolean): void;
        static RemoveAnimationSyncMarkersByTrack(AnimationSequence: AnimSequence, NotifyTrackName: string): number;
        static RemoveAnimationSyncMarkersByName(AnimationSequence: AnimSequence, MarkerName: string): number;
        static RemoveAnimationNotifyTrack(AnimationSequence: AnimSequence, NotifyTrackName: string): void;
        static RemoveAnimationNotifyEventsByTrack(AnimationSequence: AnimSequence, NotifyTrackName: string): number;
        static RemoveAnimationNotifyEventsByName(AnimationSequence: AnimSequence, NotifyName: string): number;
        static RemoveAllVirtualBones(AnimationSequence: AnimSequence): void;
        static RemoveAllMetaData(AnimationSequence: AnimSequence): void;
        static RemoveAllCurveData(AnimationSequence: AnimSequence): void;
        static RemoveAllBoneAnimation(AnimationSequence: AnimSequence): void;
        static RemoveAllAnimationSyncMarkers(AnimationSequence: AnimSequence): void;
        static RemoveAllAnimationNotifyTracks(AnimationSequence: AnimSequence): void;
        static IsValidTime(AnimationSequence: AnimSequence, Time: number, IsValid: $Ref<boolean>): void;
        static IsValidRawAnimationTrackName(AnimationSequence: AnimSequence, TrackName: string): boolean;
        static IsValidAnimNotifyTrackName(AnimationSequence: AnimSequence, NotifyTrackName: string): boolean;
        static IsValidAnimationSyncMarkerName(AnimationSequence: AnimSequence, MarkerName: string): boolean;
        static IsRootMotionLockForced(AnimationSequence: AnimSequence): boolean;
        static IsRootMotionEnabled(AnimationSequence: AnimSequence): boolean;
        static GetVectorKeys(AnimationSequence: AnimSequence, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<Vector>>): void;
        static GetUniqueMarkerNames(AnimationSequence: AnimSequence, MarkerNames: $Ref<TArray<string>>): void;
        static GetTransformationKeys(AnimationSequence: AnimSequence, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<Transform>>): void;
        static GetTimeAtFrame(AnimationSequence: AnimSequence, Frame: number, Time: $Ref<number>): void;
        static GetSequenceLength(AnimationSequence: AnimSequence, Length: $Ref<number>): void;
        static GetRootMotionLockType(AnimationSequence: AnimSequence, LockType: $Ref<number>): void;
        static GetRawTrackScaleData(AnimationSequence: AnimSequence, TrackName: string, ScaleData: $Ref<TArray<Vector>>): void;
        static GetRawTrackRotationData(AnimationSequence: AnimSequence, TrackName: string, RotationData: $Ref<TArray<Quat>>): void;
        static GetRawTrackPositionData(AnimationSequence: AnimSequence, TrackName: string, PositionData: $Ref<TArray<Vector>>): void;
        static GetRawTrackData(AnimationSequence: AnimSequence, TrackName: string, PositionKeys: $Ref<TArray<Vector>>, RotationKeys: $Ref<TArray<Quat>>, ScalingKeys: $Ref<TArray<Vector>>): void;
        static GetRateScale(AnimationSequence: AnimSequence, RateScale: $Ref<number>): void;
        static GetNumFrames(AnimationSequence: AnimSequence, NumFrames: $Ref<number>): void;
        static GetMetaDataOfClass(AnimationSequence: AnimSequence, MetaDataClass: Class, MetaDataOfClass: TArray<AnimMetaData>): void;
        static GetMetaData(AnimationSequence: AnimSequence, MetaData: TArray<AnimMetaData>): void;
        static GetFrameAtTime(AnimationSequence: AnimSequence, Time: number, Frame: $Ref<number>): void;
        static GetFloatKeys(AnimationSequence: AnimSequence, CurveName: string, Times: $Ref<TArray<number>>, Values: $Ref<TArray<number>>): void;
        static GetCompressionScheme(AnimationSequence: AnimSequence, CompressionScheme: $Ref<AnimCompress>): void;
        static GetBonePosesForTime(AnimationSequence: AnimSequence, BoneNames: TArray<string>, Time: number, bExtractRootMotion: boolean, Poses: $Ref<TArray<Transform>>, PreviewMesh: SkeletalMesh): void;
        static GetBonePosesForFrame(AnimationSequence: AnimSequence, BoneNames: TArray<string>, Frame: number, bExtractRootMotion: boolean, Poses: $Ref<TArray<Transform>>, PreviewMesh: SkeletalMesh): void;
        static GetBonePoseForTime(AnimationSequence: AnimSequence, BoneName: string, Time: number, bExtractRootMotion: boolean, Pose: $Ref<Transform>): void;
        static GetBonePoseForFrame(AnimationSequence: AnimSequence, BoneName: string, Frame: number, bExtractRootMotion: boolean, Pose: $Ref<Transform>): void;
        static GetAnimNotifyEventTriggerTime(NotifyEvent: AnimNotifyEvent): number;
        static GetAnimationTrackNames(AnimationSequence: AnimSequence, TrackNames: $Ref<TArray<string>>): void;
        static GetAnimationSyncMarkersForTrack(AnimationSequence: AnimSequence, NotifyTrackName: string, Markers: $Ref<TArray<AnimSyncMarker>>): void;
        static GetAnimationSyncMarkers(AnimationSequence: AnimSequence, Markers: $Ref<TArray<AnimSyncMarker>>): void;
        static GetAnimationNotifyTrackNames(AnimationSequence: AnimSequence, TrackNames: $Ref<TArray<string>>): void;
        static GetAnimationNotifyEventsForTrack(AnimationSequence: AnimSequence, NotifyTrackName: string, Events: $Ref<TArray<AnimNotifyEvent>>): void;
        static GetAnimationNotifyEvents(AnimationSequence: AnimSequence, NotifyEvents: $Ref<TArray<AnimNotifyEvent>>): void;
        static GetAnimationNotifyEventNames(AnimationSequence: AnimSequence, EventNames: $Ref<TArray<string>>): void;
        static GetAnimationInterpolationType(AnimationSequence: AnimSequence, InterpolationType: $Ref<EAnimInterpolationType>): void;
        static GetAdditiveBasePoseType(AnimationSequence: AnimSequence, AdditiveBasePoseType: $Ref<number>): void;
        static GetAdditiveAnimationType(AnimationSequence: AnimSequence, AdditiveAnimationType: $Ref<number>): void;
        static FindBonePathToRoot(AnimationSequence: AnimSequence, BoneName: string, BonePath: $Ref<TArray<string>>): void;
        static FinalizeBoneAnimation(AnimationSequence: AnimSequence): void;
        static DoesCurveExist(AnimationSequence: AnimSequence, CurveName: string, CurveType: ERawCurveTrackTypes): boolean;
        static DoesBoneNameExist(AnimationSequence: AnimSequence, BoneName: string, bExists: $Ref<boolean>): void;
        static CopyAnimNotifiesFromSequence(SrcAnimSequence: AnimSequence, DestAnimSequence: AnimSequence): void;
        static ContainsMetaDataOfClass(AnimationSequence: AnimSequence, MetaDataClass: Class): boolean;
        static AddVirtualBone(AnimationSequence: AnimSequence, SourceBoneName: string, TargetBoneName: string, VirtualBoneName: $Ref<string>): void;
        static AddVectorCurveKeys(AnimationSequence: AnimSequence, CurveName: string, Times: TArray<number>, Vectors: TArray<Vector>): void;
        static AddVectorCurveKey(AnimationSequence: AnimSequence, CurveName: string, Time: number, Vector: Vector): void;
        static AddTransformationCurveKeys(AnimationSequence: AnimSequence, CurveName: string, Times: TArray<number>, Transforms: TArray<Transform>): void;
        static AddTransformationCurveKey(AnimationSequence: AnimSequence, CurveName: string, Time: number, Transform: Transform): void;
        static AddMetaDataObject(AnimationSequence: AnimSequence, MetaDataObject: AnimMetaData): void;
        static AddMetaData(AnimationSequence: AnimSequence, MetaDataClass: Class, MetaDataInstance: AnimMetaData): void;
        static AddFloatCurveKeys(AnimationSequence: AnimSequence, CurveName: string, Times: TArray<number>, Values: TArray<number>): void;
        static AddFloatCurveKey(AnimationSequence: AnimSequence, CurveName: string, Time: number, Value: number): void;
        static AddCurve(AnimationSequence: AnimSequence, CurveName: string, CurveType: ERawCurveTrackTypes, bMetaDataCurve: boolean): void;
        static AddAnimationSyncMarker(AnimationSequence: AnimSequence, MarkerName: string, Time: number, NotifyTrackName: string): void;
        static AddAnimationNotifyTrack(AnimationSequence: AnimSequence, NotifyTrackName: string, TrackColor: LinearColor): void;
        static AddAnimationNotifyStateEventObject(AnimationSequence: AnimSequence, StartTime: number, Duration: number, NotifyState: AnimNotifyState, NotifyTrackName: string): void;
        static AddAnimationNotifyStateEvent(AnimationSequence: AnimSequence, NotifyTrackName: string, StartTime: number, Duration: number, NotifyStateClass: Class): AnimNotifyState;
        static AddAnimationNotifyEventObject(AnimationSequence: AnimSequence, StartTime: number, Notify: AnimNotify, NotifyTrackName: string): void;
        static AddAnimationNotifyEvent(AnimationSequence: AnimSequence, NotifyTrackName: string, StartTime: number, NotifyClass: Class): AnimNotify;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationBlueprintLibrary;
        static Load(InName: string): AnimationBlueprintLibrary;
    }
    
    class AnimationModifier extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RevisionGuid: Guid;
        AppliedGuid: Guid;
        StoredNativeRevision: number;
        PreviouslyAppliedModifier: AnimationModifier;
        OnRevert(AnimationSequence: AnimSequence): void;
        OnApply(AnimationSequence: AnimSequence): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationModifier;
        static Load(InName: string): AnimationModifier;
    }
    
    class AnimationModifiersAssetUserData extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationModifierInstances: TArray<AnimationModifier>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationModifiersAssetUserData;
        static Load(InName: string): AnimationModifiersAssetUserData;
    }
    
    class GameplayDebuggerNetPack {
        constructor();
    }
    
    class GameplayDebuggerDebugActor {
        constructor(Actor: Actor, ActorName: string, SyncCounter: number);
        Actor: Actor;
        ActorName: string;
        SyncCounter: number;
    }
    
    class GameplayDebuggerVisLogSync {
        constructor(DeviceIDs: string);
        DeviceIDs: string;
    }
    
    class GameplayDebuggerRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerRenderingComponent;
        static Load(InName: string): GameplayDebuggerRenderingComponent;
    }
    
    class GameplayDebuggerCategoryReplicator extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwnerPC: PlayerController;
        bIsEnabled: boolean;
        ReplicatedData: GameplayDebuggerNetPack;
        DebugActor: GameplayDebuggerDebugActor;
        VisLogSync: GameplayDebuggerVisLogSync;
        RenderingComp: GameplayDebuggerRenderingComponent;
        ServerSetEnabled(bEnable: boolean): void;
        ServerSetDebugActor(Actor: Actor, bSelectInEditor: boolean): void;
        ServerSetCategoryEnabled(CategoryId: number, bEnable: boolean): void;
        ServerSendExtensionInputEvent(ExtensionId: number, HandlerId: number): void;
        ServerSendCategoryInputEvent(CategoryId: number, HandlerId: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerCategoryReplicator;
        static Load(InName: string): GameplayDebuggerCategoryReplicator;
    }
    
    enum EGameplayDebuggerOverrideMode { Enable, Disable, UseDefault, EGameplayDebuggerOverrideMode_MAX}
    class GameplayDebuggerInputConfig {
        constructor(ConfigName: string, Key: Key, bModShift: boolean, bModCtrl: boolean, bModAlt: boolean, bModCmd: boolean);
        ConfigName: string;
        Key: Key;
        bModShift: boolean;
        bModCtrl: boolean;
        bModAlt: boolean;
        bModCmd: boolean;
    }
    
    class GameplayDebuggerCategoryConfig {
        constructor(CategoryName: string, SlotIdx: number, ActiveInGame: EGameplayDebuggerOverrideMode, ActiveInSimulate: EGameplayDebuggerOverrideMode, Hidden: EGameplayDebuggerOverrideMode, bOverrideSlotIdx: boolean, InputHandlers: TArray<GameplayDebuggerInputConfig>);
        CategoryName: string;
        SlotIdx: number;
        ActiveInGame: EGameplayDebuggerOverrideMode;
        ActiveInSimulate: EGameplayDebuggerOverrideMode;
        Hidden: EGameplayDebuggerOverrideMode;
        bOverrideSlotIdx: boolean;
        InputHandlers: TArray<GameplayDebuggerInputConfig>;
    }
    
    class GameplayDebuggerExtensionConfig {
        constructor(ExtensionName: string, UseExtension: EGameplayDebuggerOverrideMode, InputHandlers: TArray<GameplayDebuggerInputConfig>);
        ExtensionName: string;
        UseExtension: EGameplayDebuggerOverrideMode;
        InputHandlers: TArray<GameplayDebuggerInputConfig>;
    }
    
    class GameplayDebuggerConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActivationKey: Key;
        CategoryRowNextKey: Key;
        CategoryRowPrevKey: Key;
        CategorySlot0: Key;
        CategorySlot1: Key;
        CategorySlot2: Key;
        CategorySlot3: Key;
        CategorySlot4: Key;
        CategorySlot5: Key;
        CategorySlot6: Key;
        CategorySlot7: Key;
        CategorySlot8: Key;
        CategorySlot9: Key;
        DebugCanvasPaddingLeft: number;
        DebugCanvasPaddingRight: number;
        DebugCanvasPaddingTop: number;
        DebugCanvasPaddingBottom: number;
        Categories: TArray<GameplayDebuggerCategoryConfig>;
        Extensions: TArray<GameplayDebuggerExtensionConfig>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerConfig;
        static Load(InName: string): GameplayDebuggerConfig;
    }
    
    class GameplayDebuggerPlayerData {
        constructor(Controller: GameplayDebuggerLocalController, InputComponent: InputComponent, Replicator: GameplayDebuggerCategoryReplicator);
        Controller: GameplayDebuggerLocalController;
        InputComponent: InputComponent;
        Replicator: GameplayDebuggerCategoryReplicator;
    }
    
    class GameplayDebuggerPlayerManager extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlayerData: TArray<GameplayDebuggerPlayerData>;
        PendingRegistrations: TArray<GameplayDebuggerCategoryReplicator>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerPlayerManager;
        static Load(InName: string): GameplayDebuggerPlayerManager;
    }
    
    class GameplayDebuggerLocalController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CachedReplicator: GameplayDebuggerCategoryReplicator;
        CachedPlayerManager: GameplayDebuggerPlayerManager;
        DebugActorCandidate: Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayDebuggerLocalController;
        static Load(InName: string): GameplayDebuggerLocalController;
    }
    
    enum ETaskResourceOverlapPolicy { StartOnTop, StartAtEnd, ETaskResourceOverlapPolicy_MAX}
    class GameplayTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InstanceName: string;
        ResourceOverlapPolicy: ETaskResourceOverlapPolicy;
        ChildTask: GameplayTask;
        ReadyForActivation(): void;
        GenericGameplayTaskDelegate__DelegateSignature(): void;
        EndTask(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask;
        static Load(InName: string): GameplayTask;
    }
    
    class GameplayTaskOwnerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTaskOwnerInterface;
        static Load(InName: string): GameplayTaskOwnerInterface;
    }
    
    class GameplayTask_ClaimResource extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ClaimResources(InTaskOwner: GameplayTaskOwnerInterface, ResourceClasses: TArray<Class>, Priority: number, TaskInstanceName: string): GameplayTask_ClaimResource;
        static ClaimResource(InTaskOwner: GameplayTaskOwnerInterface, ResourceClass: Class, Priority: number, TaskInstanceName: string): GameplayTask_ClaimResource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_ClaimResource;
        static Load(InName: string): GameplayTask_ClaimResource;
    }
    
    class GameplayTask_SpawnActor extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Success: $MulticastDelegate<(SpawnedActor: Actor) => void>;
        DidNotSpawn: $MulticastDelegate<(SpawnedActor: Actor) => void>;
        ClassToSpawn: Class;
        static SpawnActor(TaskOwner: GameplayTaskOwnerInterface, SpawnLocation: Vector, SpawnRotation: Rotator, Class: Class, bSpawnOnlyOnAuthority: boolean): GameplayTask_SpawnActor;
        FinishSpawningActor(WorldContextObject: Object, SpawnedActor: Actor): void;
        BeginSpawningActor(WorldContextObject: Object, SpawnedActor: $Ref<Actor>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_SpawnActor;
        static Load(InName: string): GameplayTask_SpawnActor;
    }
    
    class GameplayTask_TimeLimitedExecution extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnFinished: $MulticastDelegate<() => void>;
        OnTimeExpired: $MulticastDelegate<() => void>;
        TaskFinishDelegate__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_TimeLimitedExecution;
        static Load(InName: string): GameplayTask_TimeLimitedExecution;
    }
    
    class GameplayTask_WaitDelay extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnFinish: $MulticastDelegate<() => void>;
        static TaskWaitDelay(TaskOwner: GameplayTaskOwnerInterface, Time: number, Priority: number): GameplayTask_WaitDelay;
        TaskDelayDelegate__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTask_WaitDelay;
        static Load(InName: string): GameplayTask_WaitDelay;
    }
    
    class GameplayTaskResource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ManualResourceID: number;
        AutoResourceID: number;
        bManuallySetID: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTaskResource;
        static Load(InName: string): GameplayTaskResource;
    }
    
    class GameplayResourceSet {
        constructor();
    }
    
    enum EGameplayTaskRunResult { Error, Failed, Success_Paused, Success_Active, Success_Finished, EGameplayTaskRunResult_MAX}
    class GameplayTasksComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsNetDirty: boolean;
        SimulatedTasks: TArray<GameplayTask>;
        TaskPriorityQueue: TArray<GameplayTask>;
        TickingTasks: TArray<GameplayTask>;
        KnownTasks: TArray<GameplayTask>;
        OnClaimedResourcesChange: $MulticastDelegate<(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet) => void>;
        OnRep_SimulatedTasks(): void;
        static K2_RunGameplayTask(TaskOwner: GameplayTaskOwnerInterface, Task: GameplayTask, Priority: number, AdditionalRequiredResources: TArray<Class>, AdditionalClaimedResources: TArray<Class>): EGameplayTaskRunResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTasksComponent;
        static Load(InName: string): GameplayTasksComponent;
    }
    
    class AIRequestID {
        constructor(RequestID: number);
        RequestID: number;
    }
    
    class AIAsyncTaskBlueprintProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(MovementResult: number) => void>;
        OnFail: $MulticastDelegate<(MovementResult: number) => void>;
        OnMoveCompleted(RequestID: AIRequestID, MovementResult: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIAsyncTaskBlueprintProxy;
        static Load(InName: string): AIAsyncTaskBlueprintProxy;
    }
    
    class BTNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeName: string;
        TreeAsset: BehaviorTree;
        ParentNode: BTCompositeNode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTNode;
        static Load(InName: string): BTNode;
    }
    
    class BTAuxiliaryNode extends BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTAuxiliaryNode;
        static Load(InName: string): BTAuxiliaryNode;
    }
    
    class BTService extends BTAuxiliaryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Interval: number;
        RandomDeviation: number;
        bCallTickOnSearchStart: boolean;
        bRestartTimerOnEachActivation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService;
        static Load(InName: string): BTService;
    }
    
    class BTTaskNode extends BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Services: TArray<BTService>;
        bIgnoreRestartSelf: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTaskNode;
        static Load(InName: string): BTTaskNode;
    }
    
    class BTDecorator extends BTAuxiliaryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bInverseCondition: boolean;
        FlowAbortMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator;
        static Load(InName: string): BTDecorator;
    }
    
    class BTDecoratorLogic {
        constructor(Operation: number, Number: number);
        Operation: number;
        Number: number;
    }
    
    class BTCompositeChild {
        constructor(ChildComposite: BTCompositeNode, ChildTask: BTTaskNode, Decorators: TArray<BTDecorator>, DecoratorOps: TArray<BTDecoratorLogic>);
        ChildComposite: BTCompositeNode;
        ChildTask: BTTaskNode;
        Decorators: TArray<BTDecorator>;
        DecoratorOps: TArray<BTDecoratorLogic>;
    }
    
    class BTCompositeNode extends BTNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Children: TArray<BTCompositeChild>;
        Services: TArray<BTService>;
        bApplyDecoratorScope: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTCompositeNode;
        static Load(InName: string): BTCompositeNode;
    }
    
    class BlackboardKeyType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType;
        static Load(InName: string): BlackboardKeyType;
    }
    
    class BlackboardEntry {
        constructor(EntryName: string, EntryDescription: string, KeyType: BlackboardKeyType, bInstanceSynced: boolean);
        EntryName: string;
        EntryDescription: string;
        KeyType: BlackboardKeyType;
        bInstanceSynced: boolean;
    }
    
    class BlackboardData extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Parent: BlackboardData;
        ParentKeys: TArray<BlackboardEntry>;
        Keys: TArray<BlackboardEntry>;
        bHasSynchronizedKeys: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardData;
        static Load(InName: string): BlackboardData;
    }
    
    class BehaviorTree extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RootNode: BTCompositeNode;
        BTGraph: EdGraph;
        LastEditedDocuments: TArray<EditedDocumentInfo>;
        BlackboardAsset: BlackboardData;
        RootDecorators: TArray<BTDecorator>;
        RootDecoratorOps: TArray<BTDecoratorLogic>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTree;
        static Load(InName: string): BehaviorTree;
    }
    
    class PathFollowingComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovementComp: NavMovementComponent;
        MyNavData: NavigationData;
        OnNavDataRegistered(NavData: NavigationData): void;
        OnActorBump(SelfActor: Actor, OtherActor: Actor, NormalImpulse: Vector, Hit: HitResult): void;
        GetPathDestination(): Vector;
        GetPathActionType(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PathFollowingComponent;
        static Load(InName: string): PathFollowingComponent;
    }
    
    class AISenseConfig extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DebugColor: Color;
        MaxAge: number;
        bStartsEnabled: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig;
        static Load(InName: string): AISenseConfig;
    }
    
    class AIStimulus {
        constructor(Age: number, ExpirationAge: number, Strength: number, StimulusLocation: Vector, ReceiverLocation: Vector, Tag: string, bSuccessfullySensed: boolean);
        Age: number;
        ExpirationAge: number;
        Strength: number;
        StimulusLocation: Vector;
        ReceiverLocation: Vector;
        Tag: string;
        bSuccessfullySensed: boolean;
    }
    
    class ActorPerceptionBlueprintInfo {
        constructor(Target: Actor, LastSensedStimuli: TArray<AIStimulus>, bIsHostile: boolean);
        Target: Actor;
        LastSensedStimuli: TArray<AIStimulus>;
        bIsHostile: boolean;
    }
    
    class AIPerceptionComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SensesConfig: TArray<AISenseConfig>;
        DominantSense: Class;
        AIOwner: AIController;
        OnPerceptionUpdated: $MulticastDelegate<(UpdatedActors: TArray<Actor>) => void>;
        OnTargetPerceptionUpdated: $MulticastDelegate<(Actor: Actor, Stimulus: AIStimulus) => void>;
        SetSenseEnabled(SenseClass: Class, bEnable: boolean): void;
        RequestStimuliListenerUpdate(): void;
        OnOwnerEndPlay(Actor: Actor, EndPlayReason: number): void;
        GetPerceivedHostileActors(OutActors: $Ref<TArray<Actor>>): void;
        GetPerceivedActors(SenseToUse: Class, OutActors: $Ref<TArray<Actor>>): void;
        GetKnownPerceivedActors(SenseToUse: Class, OutActors: $Ref<TArray<Actor>>): void;
        GetCurrentlyPerceivedActors(SenseToUse: Class, OutActors: $Ref<TArray<Actor>>): void;
        GetActorsPerception(Actor: Actor, Info: $Ref<ActorPerceptionBlueprintInfo>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionComponent;
        static Load(InName: string): AIPerceptionComponent;
    }
    
    class PawnAction extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChildAction: PawnAction;
        ParentAction: PawnAction;
        OwnerComponent: PawnActionsComponent;
        Instigator: Object;
        BrainComp: BrainComponent;
        bAllowNewSameClassInstance: boolean;
        bReplaceActiveSameClassInstance: boolean;
        bShouldPauseMovement: boolean;
        bAlwaysNotifyOnFinished: boolean;
        GetActionPriority(): number;
        Finish(WithResult: number): void;
        static CreateActionInstance(WorldContextObject: Object, ActionClass: Class): PawnAction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction;
        static Load(InName: string): PawnAction;
    }
    
    class PawnActionStack {
        constructor(TopAction: PawnAction);
        TopAction: PawnAction;
    }
    
    class PawnActionEvent {
        constructor(Action: PawnAction);
        Action: PawnAction;
    }
    
    class PawnActionsComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ControlledPawn: Pawn;
        ActionStacks: TArray<PawnActionStack>;
        ActionEvents: TArray<PawnActionEvent>;
        CurrentAction: PawnAction;
        K2_PushAction(NewAction: PawnAction, Priority: number, Instigator: Object): boolean;
        static K2_PerformAction(Pawn: Pawn, Action: PawnAction, Priority: number): boolean;
        K2_ForceAbortAction(ActionToAbort: PawnAction): number;
        K2_AbortAction(ActionToAbort: PawnAction): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnActionsComponent;
        static Load(InName: string): PawnActionsComponent;
    }
    
    class AIController extends Controller {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bStopAILogicOnUnposses: boolean;
        bLOSflag: boolean;
        bSkipExtraLOSChecks: boolean;
        bAllowStrafe: boolean;
        bWantsPlayerState: boolean;
        bSetControlRotationFromPawnOrientation: boolean;
        PathFollowingComponent: PathFollowingComponent;
        BrainComponent: BrainComponent;
        PerceptionComponent: AIPerceptionComponent;
        ActionsComp: PawnActionsComponent;
        Blackboard: BlackboardComponent;
        CachedGameplayTasksComponent: GameplayTasksComponent;
        DefaultNavigationFilterClass: Class;
        ReceiveMoveCompleted: $MulticastDelegate<(RequestID: AIRequestID, Result: number) => void>;
        UseBlackboard(BlackboardAsset: BlackboardData, BlackboardComponent: $Ref<BlackboardComponent>): boolean;
        UnclaimTaskResource(ResourceClass: Class): void;
        SetPathFollowingComponent(NewPFComponent: PathFollowingComponent): void;
        SetMoveBlockDetection(bEnable: boolean): void;
        RunBehaviorTree(BTAsset: BehaviorTree): boolean;
        OnUsingBlackBoard(BlackboardComp: BlackboardComponent, BlackboardAsset: BlackboardData): void;
        OnGameplayTaskResourcesClaimed(NewlyClaimed: GameplayResourceSet, FreshlyReleased: GameplayResourceSet): void;
        MoveToLocation(Dest: Vector, AcceptanceRadius: number, bStopOnOverlap: boolean, bUsePathfinding: boolean, bProjectDestinationToNavigation: boolean, bCanStrafe: boolean, FilterClass: Class, bAllowPartialPath: boolean): number;
        MoveToActor(Goal: Actor, AcceptanceRadius: number, bStopOnOverlap: boolean, bUsePathfinding: boolean, bCanStrafe: boolean, FilterClass: Class, bAllowPartialPath: boolean): number;
        K2_SetFocus(NewFocus: Actor): void;
        K2_SetFocalPoint(FP: Vector): void;
        K2_ClearFocus(): void;
        HasPartialPath(): boolean;
        GetPathFollowingComponent(): PathFollowingComponent;
        GetMoveStatus(): number;
        GetImmediateMoveDestination(): Vector;
        GetFocusActor(): Actor;
        GetFocalPointOnActor(Actor: Actor): Vector;
        GetFocalPoint(): Vector;
        GetAIPerceptionComponent(): AIPerceptionComponent;
        ClaimTaskResource(ResourceClass: Class): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIController;
        static Load(InName: string): AIController;
    }
    
    class BrainComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardComp: BlackboardComponent;
        AIOwner: AIController;
        StopLogic(Reason: string): void;
        RestartLogic(): void;
        IsRunning(): boolean;
        IsPaused(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BrainComponent;
        static Load(InName: string): BrainComponent;
    }
    
    class BlackboardComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrainComp: BrainComponent;
        BlackboardAsset: BlackboardData;
        KeyInstances: TArray<BlackboardKeyType>;
        SetValueAsVector(KeyName: string, VectorValue: Vector): void;
        SetValueAsString(KeyName: string, StringValue: string): void;
        SetValueAsRotator(KeyName: string, VectorValue: Rotator): void;
        SetValueAsObject(KeyName: string, ObjectValue: Object): void;
        SetValueAsName(KeyName: string, NameValue: string): void;
        SetValueAsInt(KeyName: string, IntValue: number): void;
        SetValueAsFloat(KeyName: string, FloatValue: number): void;
        SetValueAsEnum(KeyName: string, EnumValue: number): void;
        SetValueAsClass(KeyName: string, ClassValue: Class): void;
        SetValueAsBool(KeyName: string, BoolValue: boolean): void;
        IsVectorValueSet(KeyName: string): boolean;
        GetValueAsVector(KeyName: string): Vector;
        GetValueAsString(KeyName: string): string;
        GetValueAsRotator(KeyName: string): Rotator;
        GetValueAsObject(KeyName: string): Object;
        GetValueAsName(KeyName: string): string;
        GetValueAsInt(KeyName: string): number;
        GetValueAsFloat(KeyName: string): number;
        GetValueAsEnum(KeyName: string): number;
        GetValueAsClass(KeyName: string): Class;
        GetValueAsBool(KeyName: string): boolean;
        GetRotationFromEntry(KeyName: string, ResultRotation: $Ref<Rotator>): boolean;
        GetLocationFromEntry(KeyName: string, ResultLocation: $Ref<Vector>): boolean;
        ClearValue(KeyName: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardComponent;
        static Load(InName: string): BlackboardComponent;
    }
    
    class AIBlueprintHelperLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static UnlockAIResourcesWithAnimation(AnimInstance: AnimInstance, bUnlockMovement: boolean, UnlockAILogic: boolean): void;
        static SpawnAIFromClass(WorldContextObject: Object, PawnClass: Class, BehaviorTree: BehaviorTree, Location: Vector, Rotation: Rotator, bNoCollisionFail: boolean): Pawn;
        static SimpleMoveToLocation(Controller: Controller, Goal: Vector): void;
        static SimpleMoveToActor(Controller: Controller, Goal: Actor): void;
        static SendAIMessage(Target: Pawn, Message: string, MessageSource: Object, bSuccess: boolean): void;
        static LockAIResourcesWithAnimation(AnimInstance: AnimInstance, bLockMovement: boolean, LockAILogic: boolean): void;
        static IsValidAIRotation(Rotation: Rotator): boolean;
        static IsValidAILocation(Location: Vector): boolean;
        static IsValidAIDirection(DirectionVector: Vector): boolean;
        static GetCurrentPath(Controller: Controller): NavigationPath;
        static GetBlackboard(Target: Actor): BlackboardComponent;
        static GetAIController(ControlledActor: Actor): AIController;
        static CreateMoveToProxyObject(WorldContextObject: Object, Pawn: Pawn, Destination: Vector, TargetActor: Actor, AcceptanceRadius: number, bStopOnOverlap: boolean): AIAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIBlueprintHelperLibrary;
        static Load(InName: string): AIBlueprintHelperLibrary;
    }
    
    class AIDataProvider extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIDataProvider;
        static Load(InName: string): AIDataProvider;
    }
    
    class AIDataProvider_QueryParams extends AIDataProvider {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParamName: string;
        FloatValue: number;
        IntValue: number;
        BoolValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIDataProvider_QueryParams;
        static Load(InName: string): AIDataProvider_QueryParams;
    }
    
    class AIDataProvider_Random extends AIDataProvider_QueryParams {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Min: number;
        Max: number;
        bInteger: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIDataProvider_Random;
        static Load(InName: string): AIDataProvider_Random;
    }
    
    class AIHotSpotManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIHotSpotManager;
        static Load(InName: string): AIHotSpotManager;
    }
    
    class AIPerceptionListenerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionListenerInterface;
        static Load(InName: string): AIPerceptionListenerInterface;
    }
    
    class AIPerceptionStimuliSourceComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoRegisterAsSource: boolean;
        RegisterAsSourceForSenses: TArray<Class>;
        UnregisterFromSense(SenseClass: Class): void;
        UnregisterFromPerceptionSystem(): void;
        RegisterWithPerceptionSystem(): void;
        RegisterForSense(SenseClass: Class): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionStimuliSourceComponent;
        static Load(InName: string): AIPerceptionStimuliSourceComponent;
    }
    
    class BehaviorTreeTemplateInfo {
        constructor(Asset: BehaviorTree, Template: BTCompositeNode);
        Asset: BehaviorTree;
        Template: BTCompositeNode;
    }
    
    class BehaviorTreeComponent extends BrainComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeInstances: TArray<BTNode>;
        SetDynamicSubtree(InjectTag: GameplayTag, BehaviorAsset: BehaviorTree): void;
        GetTagCooldownEndTime(CooldownTag: GameplayTag): number;
        AddCooldownTagDuration(CooldownTag: GameplayTag, CooldownDuration: number, bAddToExistingDuration: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeComponent;
        static Load(InName: string): BehaviorTreeComponent;
    }
    
    class BehaviorTreeManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxDebuggerSteps: number;
        LoadedTemplates: TArray<BehaviorTreeTemplateInfo>;
        ActiveComponents: TArray<BehaviorTreeComponent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeManager;
        static Load(InName: string): BehaviorTreeManager;
    }
    
    class EnvQueryNode extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VerNum: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryNode;
        static Load(InName: string): EnvQueryNode;
    }
    
    class EnvQueryGenerator extends EnvQueryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OptionName: string;
        ItemType: Class;
        bAutoSortTests: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator;
        static Load(InName: string): EnvQueryGenerator;
    }
    
    class AIDataProviderValue {
        constructor(CachedProperty: Property, DataBinding: AIDataProvider, DataField: string);
        CachedProperty: Property;
        DataBinding: AIDataProvider;
        DataField: string;
    }
    
    class AIDataProviderTypedValue extends AIDataProviderValue {
        constructor(PropertyType: Class);
        PropertyType: Class;
    }
    
    class AIDataProviderBoolValue extends AIDataProviderTypedValue {
        constructor(DefaultValue: boolean);
        DefaultValue: boolean;
    }
    
    class AIDataProviderFloatValue extends AIDataProviderTypedValue {
        constructor(DefaultValue: number);
        DefaultValue: number;
    }
    
    enum EEQSNormalizationType { Absolute, RelativeToScores, EEQSNormalizationType_MAX}
    class EnvQueryTest extends EnvQueryNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestOrder: number;
        TestPurpose: number;
        TestComment: string;
        MultipleContextFilterOp: number;
        MultipleContextScoreOp: number;
        FilterType: number;
        BoolValue: AIDataProviderBoolValue;
        FloatValueMin: AIDataProviderFloatValue;
        FloatValueMax: AIDataProviderFloatValue;
        ScoringEquation: number;
        ClampMinType: number;
        ClampMaxType: number;
        NormalizationType: EEQSNormalizationType;
        ScoreClampMin: AIDataProviderFloatValue;
        ScoreClampMax: AIDataProviderFloatValue;
        ScoringFactor: AIDataProviderFloatValue;
        ReferenceValue: AIDataProviderFloatValue;
        bDefineReferenceValue: boolean;
        bWorkOnFloatValues: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest;
        static Load(InName: string): EnvQueryTest;
    }
    
    class EnvQueryOption extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Generator: EnvQueryGenerator;
        Tests: TArray<EnvQueryTest>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryOption;
        static Load(InName: string): EnvQueryOption;
    }
    
    class EnvQuery extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EdGraph: EdGraph;
        QueryName: string;
        Options: TArray<EnvQueryOption>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQuery;
        static Load(InName: string): EnvQuery;
    }
    
    class EnvQueryInstanceCache {
        constructor(Template: EnvQuery);
        Template: EnvQuery;
    }
    
    class EnvQueryContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext;
        static Load(InName: string): EnvQueryContext;
    }
    
    class EnvQueryInstanceBlueprintWrapper extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryID: number;
        ItemType: Class;
        OptionIndex: number;
        OnQueryFinishedEvent: $MulticastDelegate<(QueryInstance: EnvQueryInstanceBlueprintWrapper, QueryStatus: number) => void>;
        SetNamedParam(ParamName: string, Value: number): void;
        GetResultsAsLocations(): TArray<Vector>;
        GetResultsAsActors(): TArray<Actor>;
        GetQueryResultsAsLocations(ResultLocations: $Ref<TArray<Vector>>): boolean;
        GetQueryResultsAsActors(ResultActors: $Ref<TArray<Actor>>): boolean;
        GetItemScore(ItemIndex: number): number;
        EQSQueryDoneSignature__DelegateSignature(QueryInstance: EnvQueryInstanceBlueprintWrapper, QueryStatus: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryInstanceBlueprintWrapper;
        static Load(InName: string): EnvQueryInstanceBlueprintWrapper;
    }
    
    class EnvQueryManager extends AISubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InstanceCache: TArray<EnvQueryInstanceCache>;
        LocalContexts: TArray<EnvQueryContext>;
        GCShieldedWrappers: TArray<EnvQueryInstanceBlueprintWrapper>;
        MaxAllowedTestingTime: number;
        bTestQueriesUsingBreadth: boolean;
        QueryCountWarningThreshold: number;
        QueryCountWarningInterval: number;
        static RunEQSQuery(WorldContextObject: Object, QueryTemplate: EnvQuery, Querier: Object, RunMode: number, WrapperClass: Class): EnvQueryInstanceBlueprintWrapper;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryManager;
        static Load(InName: string): EnvQueryManager;
    }
    
    enum EAISenseNotifyType { OnEveryPerception, OnPerceptionChange, EAISenseNotifyType_MAX}
    class AISense extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultExpirationAge: number;
        NotifyType: EAISenseNotifyType;
        bWantsNewPawnNotification: boolean;
        bAutoRegisterAllPawnsAsSources: boolean;
        PerceptionSystemInstance: AIPerceptionSystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense;
        static Load(InName: string): AISense;
    }
    
    class AISenseEvent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseEvent;
        static Load(InName: string): AISenseEvent;
    }
    
    class AIPerceptionSystem extends AISubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Senses: TArray<AISense>;
        PerceptionAgingRate: number;
        static ReportPerceptionEvent(WorldContextObject: Object, PerceptionEvent: AISenseEvent): void;
        ReportEvent(PerceptionEvent: AISenseEvent): void;
        static RegisterPerceptionStimuliSource(WorldContextObject: Object, Sense: Class, Target: Actor): boolean;
        OnPerceptionStimuliSourceEndPlay(Actor: Actor, EndPlayReason: number): void;
        static GetSenseClassForStimulus(WorldContextObject: Object, Stimulus: AIStimulus): Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIPerceptionSystem;
        static Load(InName: string): AIPerceptionSystem;
    }
    
    class NavLocalGridManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetLocalNavigationGridDensity(WorldContextObject: Object, CellSize: number): boolean;
        static RemoveLocalNavigationGrid(WorldContextObject: Object, GridId: number, bRebuildGrids: boolean): void;
        static FindLocalNavigationGridPath(WorldContextObject: Object, Start: Vector, End: Vector, PathPoints: $Ref<TArray<Vector>>): boolean;
        static AddLocalNavigationGridForPoints(WorldContextObject: Object, Locations: TArray<Vector>, Radius2D: number, Height: number, bRebuildGrids: boolean): number;
        static AddLocalNavigationGridForPoint(WorldContextObject: Object, Location: Vector, Radius2D: number, Height: number, bRebuildGrids: boolean): number;
        static AddLocalNavigationGridForCapsule(WorldContextObject: Object, Location: Vector, CapsuleRadius: number, CapsuleHalfHeight: number, Radius2D: number, Height: number, bRebuildGrids: boolean): number;
        static AddLocalNavigationGridForBox(WorldContextObject: Object, Location: Vector, Extent: Vector, Rotation: Rotator, Radius2D: number, Height: number, bRebuildGrids: boolean): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLocalGridManager;
        static Load(InName: string): NavLocalGridManager;
    }
    
    class AISystem extends AISystemBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PerceptionSystemClassName: SoftClassPath;
        HotSpotManagerClassName: SoftClassPath;
        AcceptanceRadius: number;
        PathfollowingRegularPathPointAcceptanceRadius: number;
        PathfollowingNavLinkAcceptanceRadius: number;
        bFinishMoveOnGoalOverlap: boolean;
        bAcceptPartialPaths: boolean;
        bAllowStrafing: boolean;
        bEnableBTAITasks: boolean;
        bAllowControllersAsEQSQuerier: boolean;
        bEnableDebuggerPlugin: boolean;
        DefaultSightCollisionChannel: number;
        BehaviorTreeManager: BehaviorTreeManager;
        EnvironmentQueryManager: EnvQueryManager;
        PerceptionSystem: AIPerceptionSystem;
        AllProxyObjects: TArray<AIAsyncTaskBlueprintProxy>;
        HotSpotManager: AIHotSpotManager;
        NavLocalGrids: NavLocalGridManager;
        AILoggingVerbose(): void;
        AIIgnorePlayers(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISystem;
        static Load(InName: string): AISystem;
    }
    
    class AISubsystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AISystem: AISystem;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISubsystem;
        static Load(InName: string): AISubsystem;
    }
    
    class AIResourceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIResourceInterface;
        static Load(InName: string): AIResourceInterface;
    }
    
    class AIResource_Movement extends GameplayTaskResource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIResource_Movement;
        static Load(InName: string): AIResource_Movement;
    }
    
    class AIResource_Logic extends GameplayTaskResource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIResource_Logic;
        static Load(InName: string): AIResource_Logic;
    }
    
    class AISense_Blueprint extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ListenerDataType: Class;
        ListenerContainer: TArray<AIPerceptionComponent>;
        UnprocessedEvents: TArray<AISenseEvent>;
        OnUpdate(EventsToProcess: TArray<AISenseEvent>): number;
        OnListenerUpdated(ActorListener: Actor, PerceptionComponent: AIPerceptionComponent): void;
        OnListenerUnregistered(ActorListener: Actor, PerceptionComponent: AIPerceptionComponent): void;
        OnListenerRegistered(ActorListener: Actor, PerceptionComponent: AIPerceptionComponent): void;
        K2_OnNewPawn(NewPawn: Pawn): void;
        GetAllListenerComponents(ListenerComponents: $Ref<TArray<AIPerceptionComponent>>): void;
        GetAllListenerActors(ListenerActors: $Ref<TArray<Actor>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Blueprint;
        static Load(InName: string): AISense_Blueprint;
    }
    
    class AIDamageEvent {
        constructor(Amount: number, Location: Vector, HitLocation: Vector, DamagedActor: Actor, Instigator: Actor);
        Amount: number;
        Location: Vector;
        HitLocation: Vector;
        DamagedActor: Actor;
        Instigator: Actor;
    }
    
    class AISense_Damage extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<AIDamageEvent>;
        static ReportDamageEvent(WorldContextObject: Object, DamagedActor: Actor, Instigator: Actor, DamageAmount: number, EventLocation: Vector, HitLocation: Vector): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Damage;
        static Load(InName: string): AISense_Damage;
    }
    
    class AINoiseEvent {
        constructor(NoiseLocation: Vector, Loudness: number, MaxRange: number, Instigator: Actor, Tag: string);
        NoiseLocation: Vector;
        Loudness: number;
        MaxRange: number;
        Instigator: Actor;
        Tag: string;
    }
    
    class AISense_Hearing extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NoiseEvents: TArray<AINoiseEvent>;
        SpeedOfSoundSq: number;
        static ReportNoiseEvent(WorldContextObject: Object, NoiseLocation: Vector, Loudness: number, Instigator: Actor, MaxRange: number, Tag: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Hearing;
        static Load(InName: string): AISense_Hearing;
    }
    
    class AIPredictionEvent {
        constructor(Requestor: Actor, PredictedActor: Actor);
        Requestor: Actor;
        PredictedActor: Actor;
    }
    
    class AISense_Prediction extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<AIPredictionEvent>;
        static RequestPawnPredictionEvent(Requestor: Pawn, PredictedActor: Actor, PredictionTime: number): void;
        static RequestControllerPredictionEvent(Requestor: AIController, PredictedActor: Actor, PredictionTime: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Prediction;
        static Load(InName: string): AISense_Prediction;
    }
    
    class AISense_Sight extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxTracesPerTick: number;
        MinQueriesPerTimeSliceCheck: number;
        MaxTimeSlicePerTick: number;
        HighImportanceQueryDistanceThreshold: number;
        MaxQueryImportance: number;
        SightLimitQueryImportance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Sight;
        static Load(InName: string): AISense_Sight;
    }
    
    class AITeamStimulusEvent {
        constructor(Broadcaster: Actor, Enemy: Actor);
        Broadcaster: Actor;
        Enemy: Actor;
    }
    
    class AISense_Team extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<AITeamStimulusEvent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Team;
        static Load(InName: string): AISense_Team;
    }
    
    class AITouchEvent {
        constructor(TouchReceiver: Actor, OtherActor: Actor);
        TouchReceiver: Actor;
        OtherActor: Actor;
    }
    
    class AISense_Touch extends AISense {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredEvents: TArray<AITouchEvent>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISense_Touch;
        static Load(InName: string): AISense_Touch;
    }
    
    class AISenseBlueprintListener extends UserDefinedStruct {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseBlueprintListener;
        static Load(InName: string): AISenseBlueprintListener;
    }
    
    class AISenseConfig_Blueprint extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Blueprint;
        static Load(InName: string): AISenseConfig_Blueprint;
    }
    
    class AISenseConfig_Damage extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Damage;
        static Load(InName: string): AISenseConfig_Damage;
    }
    
    class AISenseAffiliationFilter {
        constructor(bDetectEnemies: boolean, bDetectNeutrals: boolean, bDetectFriendlies: boolean);
        bDetectEnemies: boolean;
        bDetectNeutrals: boolean;
        bDetectFriendlies: boolean;
    }
    
    class AISenseConfig_Hearing extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: Class;
        HearingRange: number;
        LoSHearingRange: number;
        bUseLoSHearing: boolean;
        DetectionByAffiliation: AISenseAffiliationFilter;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Hearing;
        static Load(InName: string): AISenseConfig_Hearing;
    }
    
    class AISenseConfig_Prediction extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Prediction;
        static Load(InName: string): AISenseConfig_Prediction;
    }
    
    class AISenseConfig_Sight extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Implementation: Class;
        SightRadius: number;
        LoseSightRadius: number;
        PeripheralVisionAngleDegrees: number;
        DetectionByAffiliation: AISenseAffiliationFilter;
        AutoSuccessRangeFromLastSeenLocation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Sight;
        static Load(InName: string): AISenseConfig_Sight;
    }
    
    class AISenseConfig_Team extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Team;
        static Load(InName: string): AISenseConfig_Team;
    }
    
    class AISenseConfig_Touch extends AISenseConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseConfig_Touch;
        static Load(InName: string): AISenseConfig_Touch;
    }
    
    class AISenseEvent_Damage extends AISenseEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: AIDamageEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseEvent_Damage;
        static Load(InName: string): AISenseEvent_Damage;
    }
    
    class AISenseEvent_Hearing extends AISenseEvent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Event: AINoiseEvent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISenseEvent_Hearing;
        static Load(InName: string): AISenseEvent_Hearing;
    }
    
    class AISightTargetInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AISightTargetInterface;
        static Load(InName: string): AISightTargetInterface;
    }
    
    class AITask extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OwnerController: AIController;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask;
        static Load(InName: string): AITask;
    }
    
    class AITask_LockLogic extends AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask_LockLogic;
        static Load(InName: string): AITask_LockLogic;
    }
    
    class AIMoveRequest {
        constructor(GoalActor: Actor);
        GoalActor: Actor;
    }
    
    class AITask_MoveTo extends AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnRequestFailed: $MulticastDelegate<() => void>;
        OnMoveFinished: $MulticastDelegate<(Result: number, AIController: AIController) => void>;
        MoveRequest: AIMoveRequest;
        static AIMoveTo(Controller: AIController, GoalLocation: Vector, GoalActor: Actor, AcceptanceRadius: number, StopOnOverlap: number, AcceptPartialPath: number, bUsePathfinding: boolean, bLockAILogic: boolean, bUseContinuosGoalTracking: boolean, ProjectGoalOnNavigation: number): AITask_MoveTo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask_MoveTo;
        static Load(InName: string): AITask_MoveTo;
    }
    
    class AITask_RunEQS extends AITask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RunEQS(Controller: AIController, QueryTemplate: EnvQuery): AITask_RunEQS;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AITask_RunEQS;
        static Load(InName: string): AITask_RunEQS;
    }
    
    class BehaviorTreeTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeTypes;
        static Load(InName: string): BehaviorTreeTypes;
    }
    
    class BlackboardKeyType_Bool extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Bool;
        static Load(InName: string): BlackboardKeyType_Bool;
    }
    
    class BlackboardKeyType_Class extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Class;
        static Load(InName: string): BlackboardKeyType_Class;
    }
    
    class BlackboardKeyType_Enum extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumType: Enum;
        EnumName: string;
        bIsEnumNameValid: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Enum;
        static Load(InName: string): BlackboardKeyType_Enum;
    }
    
    class BlackboardKeyType_Float extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Float;
        static Load(InName: string): BlackboardKeyType_Float;
    }
    
    class BlackboardKeyType_Int extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Int;
        static Load(InName: string): BlackboardKeyType_Int;
    }
    
    class BlackboardKeyType_Name extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Name;
        static Load(InName: string): BlackboardKeyType_Name;
    }
    
    class BlackboardKeyType_NativeEnum extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumName: string;
        EnumType: Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_NativeEnum;
        static Load(InName: string): BlackboardKeyType_NativeEnum;
    }
    
    class BlackboardKeyType_Object extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Object;
        static Load(InName: string): BlackboardKeyType_Object;
    }
    
    class BlackboardKeyType_Rotator extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Rotator;
        static Load(InName: string): BlackboardKeyType_Rotator;
    }
    
    class BlackboardKeyType_String extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StringValue: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_String;
        static Load(InName: string): BlackboardKeyType_String;
    }
    
    class BlackboardKeyType_Vector extends BlackboardKeyType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardKeyType_Vector;
        static Load(InName: string): BlackboardKeyType_Vector;
    }
    
    class BTComposite_Selector extends BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTComposite_Selector;
        static Load(InName: string): BTComposite_Selector;
    }
    
    class BTComposite_Sequence extends BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTComposite_Sequence;
        static Load(InName: string): BTComposite_Sequence;
    }
    
    class BTComposite_SimpleParallel extends BTCompositeNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FinishMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTComposite_SimpleParallel;
        static Load(InName: string): BTComposite_SimpleParallel;
    }
    
    class BlackboardKeySelector {
        constructor(AllowedTypes: TArray<BlackboardKeyType>, SelectedKeyName: string, SelectedKeyType: Class, SelectedKeyID: number, bNoneIsAllowedValue: boolean);
        AllowedTypes: TArray<BlackboardKeyType>;
        SelectedKeyName: string;
        SelectedKeyType: Class;
        SelectedKeyID: number;
        bNoneIsAllowedValue: boolean;
    }
    
    class BTDecorator_BlackboardBase extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_BlackboardBase;
        static Load(InName: string): BTDecorator_BlackboardBase;
    }
    
    class BTDecorator_Blackboard extends BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntValue: number;
        FloatValue: number;
        StringValue: string;
        CachedDescription: string;
        OperationType: number;
        NotifyObserver: number;
        BasicOperation: number;
        ArithmeticOperation: number;
        TextOperation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_Blackboard;
        static Load(InName: string): BTDecorator_Blackboard;
    }
    
    class BTDecorator_BlueprintBase extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AIOwner: AIController;
        ActorOwner: Actor;
        ObservedKeyNames: TArray<string>;
        bShowPropertyDetails: boolean;
        bCheckConditionOnlyBlackBoardChanges: boolean;
        bIsObservingBB: boolean;
        ReceiveTickAI(OwnerController: AIController, ControlledPawn: Pawn, DeltaSeconds: number): void;
        ReceiveTick(OwnerActor: Actor, DeltaSeconds: number): void;
        ReceiveObserverDeactivatedAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveObserverDeactivated(OwnerActor: Actor): void;
        ReceiveObserverActivatedAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveObserverActivated(OwnerActor: Actor): void;
        ReceiveExecutionStartAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveExecutionStart(OwnerActor: Actor): void;
        ReceiveExecutionFinishAI(OwnerController: AIController, ControlledPawn: Pawn, NodeResult: number): void;
        ReceiveExecutionFinish(OwnerActor: Actor, NodeResult: number): void;
        PerformConditionCheckAI(OwnerController: AIController, ControlledPawn: Pawn): boolean;
        PerformConditionCheck(OwnerActor: Actor): boolean;
        IsDecoratorObserverActive(): boolean;
        IsDecoratorExecutionActive(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_BlueprintBase;
        static Load(InName: string): BTDecorator_BlueprintBase;
    }
    
    enum EGameplayContainerMatchType { Any, All, EGameplayContainerMatchType_MAX}
    class BTDecorator_CheckGameplayTagsOnActor extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorToCheck: BlackboardKeySelector;
        TagsToMatch: EGameplayContainerMatchType;
        GameplayTags: GameplayTagContainer;
        CachedDescription: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_CheckGameplayTagsOnActor;
        static Load(InName: string): BTDecorator_CheckGameplayTagsOnActor;
    }
    
    class BTDecorator_CompareBBEntries extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Operator: number;
        BlackboardKeyA: BlackboardKeySelector;
        BlackboardKeyB: BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_CompareBBEntries;
        static Load(InName: string): BTDecorator_CompareBBEntries;
    }
    
    class BTDecorator_ConditionalLoop extends BTDecorator_Blackboard {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ConditionalLoop;
        static Load(InName: string): BTDecorator_ConditionalLoop;
    }
    
    class BTDecorator_ConeCheck extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConeHalfAngle: number;
        ConeOrigin: BlackboardKeySelector;
        ConeDirection: BlackboardKeySelector;
        Observed: BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ConeCheck;
        static Load(InName: string): BTDecorator_ConeCheck;
    }
    
    class BTDecorator_Cooldown extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CoolDownTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_Cooldown;
        static Load(InName: string): BTDecorator_Cooldown;
    }
    
    class BTDecorator_DoesPathExist extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKeyA: BlackboardKeySelector;
        BlackboardKeyB: BlackboardKeySelector;
        bUseSelf: boolean;
        PathQueryType: number;
        FilterClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_DoesPathExist;
        static Load(InName: string): BTDecorator_DoesPathExist;
    }
    
    class BTDecorator_ForceSuccess extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ForceSuccess;
        static Load(InName: string): BTDecorator_ForceSuccess;
    }
    
    enum FAIDistanceType { Distance3D, Distance2D, DistanceZ, MAX}
    class BTDecorator_IsAtLocation extends BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AcceptableRadius: number;
        ParametrizedAcceptableRadius: AIDataProviderFloatValue;
        GeometricDistanceType: FAIDistanceType;
        bUseParametrizedRadius: boolean;
        bUseNavAgentGoalLocation: boolean;
        bPathFindingBasedTest: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_IsAtLocation;
        static Load(InName: string): BTDecorator_IsAtLocation;
    }
    
    class BTDecorator_IsBBEntryOfClass extends BTDecorator_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_IsBBEntryOfClass;
        static Load(InName: string): BTDecorator_IsBBEntryOfClass;
    }
    
    class BTDecorator_KeepInCone extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConeHalfAngle: number;
        ConeOrigin: BlackboardKeySelector;
        Observed: BlackboardKeySelector;
        bUseSelfAsOrigin: boolean;
        bUseSelfAsObserved: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_KeepInCone;
        static Load(InName: string): BTDecorator_KeepInCone;
    }
    
    class BTDecorator_Loop extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumLoops: number;
        bInfiniteLoop: boolean;
        InfiniteLoopTimeoutTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_Loop;
        static Load(InName: string): BTDecorator_Loop;
    }
    
    class BTDecorator_ReachedMoveGoal extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_ReachedMoveGoal;
        static Load(InName: string): BTDecorator_ReachedMoveGoal;
    }
    
    class BTDecorator_SetTagCooldown extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CooldownTag: GameplayTag;
        CooldownDuration: number;
        bAddToExistingDuration: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_SetTagCooldown;
        static Load(InName: string): BTDecorator_SetTagCooldown;
    }
    
    class BTDecorator_TagCooldown extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CooldownTag: GameplayTag;
        CooldownDuration: number;
        bAddToExistingDuration: boolean;
        bActivatesCooldown: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_TagCooldown;
        static Load(InName: string): BTDecorator_TagCooldown;
    }
    
    class BTDecorator_TimeLimit extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeLimit: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTDecorator_TimeLimit;
        static Load(InName: string): BTDecorator_TimeLimit;
    }
    
    class BTFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StopUsingExternalEvent(NodeOwner: BTNode): void;
        static StartUsingExternalEvent(NodeOwner: BTNode, OwningActor: Actor): void;
        static SetBlackboardValueAsVector(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: Vector): void;
        static SetBlackboardValueAsString(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: string): void;
        static SetBlackboardValueAsRotator(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: Rotator): void;
        static SetBlackboardValueAsObject(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: Object): void;
        static SetBlackboardValueAsName(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: string): void;
        static SetBlackboardValueAsInt(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: number): void;
        static SetBlackboardValueAsFloat(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: number): void;
        static SetBlackboardValueAsEnum(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: number): void;
        static SetBlackboardValueAsClass(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: Class): void;
        static SetBlackboardValueAsBool(NodeOwner: BTNode, Key: BlackboardKeySelector, Value: boolean): void;
        static GetOwnersBlackboard(NodeOwner: BTNode): BlackboardComponent;
        static GetOwnerComponent(NodeOwner: BTNode): BehaviorTreeComponent;
        static GetBlackboardValueAsVector(NodeOwner: BTNode, Key: BlackboardKeySelector): Vector;
        static GetBlackboardValueAsString(NodeOwner: BTNode, Key: BlackboardKeySelector): string;
        static GetBlackboardValueAsRotator(NodeOwner: BTNode, Key: BlackboardKeySelector): Rotator;
        static GetBlackboardValueAsObject(NodeOwner: BTNode, Key: BlackboardKeySelector): Object;
        static GetBlackboardValueAsName(NodeOwner: BTNode, Key: BlackboardKeySelector): string;
        static GetBlackboardValueAsInt(NodeOwner: BTNode, Key: BlackboardKeySelector): number;
        static GetBlackboardValueAsFloat(NodeOwner: BTNode, Key: BlackboardKeySelector): number;
        static GetBlackboardValueAsEnum(NodeOwner: BTNode, Key: BlackboardKeySelector): number;
        static GetBlackboardValueAsClass(NodeOwner: BTNode, Key: BlackboardKeySelector): Class;
        static GetBlackboardValueAsBool(NodeOwner: BTNode, Key: BlackboardKeySelector): boolean;
        static GetBlackboardValueAsActor(NodeOwner: BTNode, Key: BlackboardKeySelector): Actor;
        static ClearBlackboardValueAsVector(NodeOwner: BTNode, Key: BlackboardKeySelector): void;
        static ClearBlackboardValue(NodeOwner: BTNode, Key: BlackboardKeySelector): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTFunctionLibrary;
        static Load(InName: string): BTFunctionLibrary;
    }
    
    class BTService_BlackboardBase extends BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_BlackboardBase;
        static Load(InName: string): BTService_BlackboardBase;
    }
    
    class BTService_BlueprintBase extends BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AIOwner: AIController;
        ActorOwner: Actor;
        bShowPropertyDetails: boolean;
        bShowEventDetails: boolean;
        ReceiveTickAI(OwnerController: AIController, ControlledPawn: Pawn, DeltaSeconds: number): void;
        ReceiveTick(OwnerActor: Actor, DeltaSeconds: number): void;
        ReceiveSearchStartAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveSearchStart(OwnerActor: Actor): void;
        ReceiveDeactivationAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveDeactivation(OwnerActor: Actor): void;
        ReceiveActivationAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveActivation(OwnerActor: Actor): void;
        IsServiceActive(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_BlueprintBase;
        static Load(InName: string): BTService_BlueprintBase;
    }
    
    class BTService_DefaultFocus extends BTService_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FocusPriority: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_DefaultFocus;
        static Load(InName: string): BTService_DefaultFocus;
    }
    
    enum EAIParamType { Float, Int, Bool, MAX}
    class AIDynamicParam {
        constructor(ParamName: string, ParamType: EAIParamType, Value: number, BBKey: BlackboardKeySelector);
        ParamName: string;
        ParamType: EAIParamType;
        Value: number;
        BBKey: BlackboardKeySelector;
    }
    
    class EQSParametrizedQueryExecutionRequest {
        constructor(QueryTemplate: EnvQuery, QueryConfig: TArray<AIDynamicParam>, EQSQueryBlackboardKey: BlackboardKeySelector, RunMode: number, bUseBBKeyForQueryTemplate: boolean);
        QueryTemplate: EnvQuery;
        QueryConfig: TArray<AIDynamicParam>;
        EQSQueryBlackboardKey: BlackboardKeySelector;
        RunMode: number;
        bUseBBKeyForQueryTemplate: boolean;
    }
    
    class BTService_RunEQS extends BTService_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EQSRequest: EQSParametrizedQueryExecutionRequest;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTService_RunEQS;
        static Load(InName: string): BTService_RunEQS;
    }
    
    class BTTask_BlackboardBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_BlackboardBase;
        static Load(InName: string): BTTask_BlackboardBase;
    }
    
    class IntervalCountdown {
        constructor(Interval: number);
        Interval: number;
    }
    
    class BTTask_BlueprintBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AIOwner: AIController;
        ActorOwner: Actor;
        TickInterval: IntervalCountdown;
        bShowPropertyDetails: boolean;
        SetFinishOnMessageWithId(MessageName: string, RequestID: number): void;
        SetFinishOnMessage(MessageName: string): void;
        ReceiveTickAI(OwnerController: AIController, ControlledPawn: Pawn, DeltaSeconds: number): void;
        ReceiveTick(OwnerActor: Actor, DeltaSeconds: number): void;
        ReceiveExecuteAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveExecute(OwnerActor: Actor): void;
        ReceiveAbortAI(OwnerController: AIController, ControlledPawn: Pawn): void;
        ReceiveAbort(OwnerActor: Actor): void;
        IsTaskExecuting(): boolean;
        IsTaskAborting(): boolean;
        FinishExecute(bSuccess: boolean): void;
        FinishAbort(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_BlueprintBase;
        static Load(InName: string): BTTask_BlueprintBase;
    }
    
    class BTTask_FinishWithResult extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Result: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_FinishWithResult;
        static Load(InName: string): BTTask_FinishWithResult;
    }
    
    class BTTask_GameplayTaskBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bWaitForGameplayTask: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_GameplayTaskBase;
        static Load(InName: string): BTTask_GameplayTaskBase;
    }
    
    class BTTask_MakeNoise extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Loudnes: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_MakeNoise;
        static Load(InName: string): BTTask_MakeNoise;
    }
    
    class BTTask_MoveTo extends BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AcceptableRadius: number;
        FilterClass: Class;
        ObservedBlackboardValueTolerance: number;
        bObserveBlackboardValue: boolean;
        bAllowStrafe: boolean;
        bAllowPartialPath: boolean;
        bTrackMovingGoal: boolean;
        bProjectGoalLocation: boolean;
        bReachTestIncludesAgentRadius: boolean;
        bReachTestIncludesGoalRadius: boolean;
        bStopOnOverlap: boolean;
        bStopOnOverlapNeedsUpdate: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_MoveTo;
        static Load(InName: string): BTTask_MoveTo;
    }
    
    class BTTask_MoveDirectlyToward extends BTTask_MoveTo {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisablePathUpdateOnGoalLocationChange: boolean;
        bProjectVectorGoalToNavigation: boolean;
        bUpdatedDeprecatedProperties: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_MoveDirectlyToward;
        static Load(InName: string): BTTask_MoveDirectlyToward;
    }
    
    class BTTask_PawnActionBase extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PawnActionBase;
        static Load(InName: string): BTTask_PawnActionBase;
    }
    
    class BTTask_PlayAnimation extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationToPlay: AnimationAsset;
        bLooping: boolean;
        bNonBlocking: boolean;
        MyOwnerComp: BehaviorTreeComponent;
        CachedSkelMesh: SkeletalMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PlayAnimation;
        static Load(InName: string): BTTask_PlayAnimation;
    }
    
    class BTTask_PlaySound extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SoundToPlay: SoundCue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PlaySound;
        static Load(InName: string): BTTask_PlaySound;
    }
    
    class BTTask_PushPawnAction extends BTTask_PawnActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: PawnAction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_PushPawnAction;
        static Load(InName: string): BTTask_PushPawnAction;
    }
    
    class BTTask_RotateToFaceBBEntry extends BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Precision: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RotateToFaceBBEntry;
        static Load(InName: string): BTTask_RotateToFaceBBEntry;
    }
    
    class BTTask_RunBehavior extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BehaviorAsset: BehaviorTree;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RunBehavior;
        static Load(InName: string): BTTask_RunBehavior;
    }
    
    class BTTask_RunBehaviorDynamic extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InjectionTag: GameplayTag;
        DefaultBehaviorAsset: BehaviorTree;
        BehaviorAsset: BehaviorTree;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RunBehaviorDynamic;
        static Load(InName: string): BTTask_RunBehaviorDynamic;
    }
    
    class EnvNamedValue {
        constructor(ParamName: string, ParamType: EAIParamType, Value: number);
        ParamName: string;
        ParamType: EAIParamType;
        Value: number;
    }
    
    class BTTask_RunEQSQuery extends BTTask_BlackboardBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryTemplate: EnvQuery;
        QueryParams: TArray<EnvNamedValue>;
        QueryConfig: TArray<AIDynamicParam>;
        RunMode: number;
        EQSQueryBlackboardKey: BlackboardKeySelector;
        bUseBBKey: boolean;
        EQSRequest: EQSParametrizedQueryExecutionRequest;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_RunEQSQuery;
        static Load(InName: string): BTTask_RunEQSQuery;
    }
    
    class BTTask_SetTagCooldown extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CooldownTag: GameplayTag;
        bAddToExistingDuration: boolean;
        CooldownDuration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_SetTagCooldown;
        static Load(InName: string): BTTask_SetTagCooldown;
    }
    
    class BTTask_Wait extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WaitTime: number;
        RandomDeviation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_Wait;
        static Load(InName: string): BTTask_Wait;
    }
    
    class BTTask_WaitBlackboardTime extends BTTask_Wait {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardKey: BlackboardKeySelector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BTTask_WaitBlackboardTime;
        static Load(InName: string): BTTask_WaitBlackboardTime;
    }
    
    class CrowdAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdAgentInterface;
        static Load(InName: string): CrowdAgentInterface;
    }
    
    class CrowdFollowingComponent extends PathFollowingComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CharacterMovement: CharacterMovementComponent;
        CrowdAgentMoveDirection: Vector;
        AvoidanceGroup: NavAvoidanceMask;
        GroupsToAvoid: NavAvoidanceMask;
        GroupsToIgnore: NavAvoidanceMask;
        SuspendCrowdSteering(bSuspend: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdFollowingComponent;
        static Load(InName: string): CrowdFollowingComponent;
    }
    
    class CrowdAvoidanceConfig {
        constructor(VelocityBias: number, DesiredVelocityWeight: number, CurrentVelocityWeight: number, SideBiasWeight: number, ImpactTimeWeight: number, ImpactTimeRange: number, CustomPatternIdx: number, AdaptiveDivisions: number, AdaptiveRings: number, AdaptiveDepth: number);
        VelocityBias: number;
        DesiredVelocityWeight: number;
        CurrentVelocityWeight: number;
        SideBiasWeight: number;
        ImpactTimeWeight: number;
        ImpactTimeRange: number;
        CustomPatternIdx: number;
        AdaptiveDivisions: number;
        AdaptiveRings: number;
        AdaptiveDepth: number;
    }
    
    class CrowdAvoidanceSamplingPattern {
        constructor(Angles: TArray<number>, Radii: TArray<number>);
        Angles: TArray<number>;
        Radii: TArray<number>;
    }
    
    class CrowdManager extends CrowdManagerBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyNavData: NavigationData;
        AvoidanceConfig: TArray<CrowdAvoidanceConfig>;
        SamplingPatterns: TArray<CrowdAvoidanceSamplingPattern>;
        MaxAgents: number;
        MaxAgentRadius: number;
        MaxAvoidedAgents: number;
        MaxAvoidedWalls: number;
        NavmeshCheckInterval: number;
        PathOptimizationInterval: number;
        SeparationDirClamp: number;
        PathOffsetRadiusMultiplier: number;
        bResolveCollisions: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CrowdManager;
        static Load(InName: string): CrowdManager;
    }
    
    class DetourCrowdAIController extends AIController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DetourCrowdAIController;
        static Load(InName: string): DetourCrowdAIController;
    }
    
    class EnvQueryContext_BlueprintBase extends EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProvideSingleLocation(QuerierObject: Object, QuerierActor: Actor, ResultingLocation: $Ref<Vector>): void;
        ProvideSingleActor(QuerierObject: Object, QuerierActor: Actor, ResultingActor: $Ref<Actor>): void;
        ProvideLocationsSet(QuerierObject: Object, QuerierActor: Actor, ResultingLocationSet: $Ref<TArray<Vector>>): void;
        ProvideActorsSet(QuerierObject: Object, QuerierActor: Actor, ResultingActorsSet: $Ref<TArray<Actor>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_BlueprintBase;
        static Load(InName: string): EnvQueryContext_BlueprintBase;
    }
    
    class EnvQueryContext_Item extends EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_Item;
        static Load(InName: string): EnvQueryContext_Item;
    }
    
    class EnvQueryContext_Querier extends EnvQueryContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryContext_Querier;
        static Load(InName: string): EnvQueryContext_Querier;
    }
    
    class EnvQueryDebugHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryDebugHelpers;
        static Load(InName: string): EnvQueryDebugHelpers;
    }
    
    class EnvQueryGenerator_ActorsOfClass extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SearchedActorClass: Class;
        GenerateOnlyActorsInRadius: AIDataProviderBoolValue;
        SearchRadius: AIDataProviderFloatValue;
        SearchCenter: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_ActorsOfClass;
        static Load(InName: string): EnvQueryGenerator_ActorsOfClass;
    }
    
    class EnvQueryGenerator_BlueprintBase extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeneratorsActionDescription: string;
        Context: Class;
        GeneratedItemType: Class;
        GetQuerier(): Object;
        DoItemGeneration(ContextLocations: TArray<Vector>): void;
        AddGeneratedVector(GeneratedVector: Vector): void;
        AddGeneratedActor(GeneratedActor: Actor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_BlueprintBase;
        static Load(InName: string): EnvQueryGenerator_BlueprintBase;
    }
    
    class EnvQueryGenerator_Composite extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Generators: TArray<EnvQueryGenerator>;
        bAllowDifferentItemTypes: boolean;
        bHasMatchingItemType: boolean;
        ForcedItemType: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Composite;
        static Load(InName: string): EnvQueryGenerator_Composite;
    }
    
    class EnvTraceData {
        constructor(VersionNum: number, NavigationFilter: Class, ProjectDown: number, ProjectUp: number, ExtentX: number, ExtentY: number, ExtentZ: number, PostProjectionVerticalOffset: number, TraceChannel: number, SerializedChannel: number, TraceShape: number, TraceMode: number, bTraceComplex: boolean, bOnlyBlockingHits: boolean, bCanTraceOnNavMesh: boolean, bCanTraceOnGeometry: boolean, bCanDisableTrace: boolean, bCanProjectDown: boolean);
        VersionNum: number;
        NavigationFilter: Class;
        ProjectDown: number;
        ProjectUp: number;
        ExtentX: number;
        ExtentY: number;
        ExtentZ: number;
        PostProjectionVerticalOffset: number;
        TraceChannel: number;
        SerializedChannel: number;
        TraceShape: number;
        TraceMode: number;
        bTraceComplex: boolean;
        bOnlyBlockingHits: boolean;
        bCanTraceOnNavMesh: boolean;
        bCanTraceOnGeometry: boolean;
        bCanDisableTrace: boolean;
        bCanProjectDown: boolean;
    }
    
    class EnvQueryGenerator_ProjectedPoints extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProjectionData: EnvTraceData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_ProjectedPoints;
        static Load(InName: string): EnvQueryGenerator_ProjectedPoints;
    }
    
    class EnvQueryGenerator_Cone extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AlignedPointsDistance: AIDataProviderFloatValue;
        ConeDegrees: AIDataProviderFloatValue;
        AngleStep: AIDataProviderFloatValue;
        Range: AIDataProviderFloatValue;
        CenterActor: Class;
        bIncludeContextLocation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Cone;
        static Load(InName: string): EnvQueryGenerator_Cone;
    }
    
    class EnvQueryGenerator_CurrentLocation extends EnvQueryGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryContext: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_CurrentLocation;
        static Load(InName: string): EnvQueryGenerator_CurrentLocation;
    }
    
    class AIDataProviderIntValue extends AIDataProviderTypedValue {
        constructor(DefaultValue: number);
        DefaultValue: number;
    }
    
    class EnvDirection {
        constructor(LineFrom: Class, LineTo: Class, Rotation: Class, DirMode: number);
        LineFrom: Class;
        LineTo: Class;
        Rotation: Class;
        DirMode: number;
    }
    
    class EnvQueryGenerator_Donut extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerRadius: AIDataProviderFloatValue;
        OuterRadius: AIDataProviderFloatValue;
        NumberOfRings: AIDataProviderIntValue;
        PointsPerRing: AIDataProviderIntValue;
        ArcDirection: EnvDirection;
        ArcAngle: AIDataProviderFloatValue;
        bUseSpiralPattern: boolean;
        Center: Class;
        bDefineArc: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_Donut;
        static Load(InName: string): EnvQueryGenerator_Donut;
    }
    
    enum EPointOnCircleSpacingMethod { BySpaceBetween, ByNumberOfPoints, EPointOnCircleSpacingMethod_MAX}
    class EnvQueryGenerator_OnCircle extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CircleRadius: AIDataProviderFloatValue;
        SpaceBetween: AIDataProviderFloatValue;
        NumberOfPoints: AIDataProviderIntValue;
        PointOnCircleSpacingMethod: EPointOnCircleSpacingMethod;
        ArcDirection: EnvDirection;
        ArcAngle: AIDataProviderFloatValue;
        AngleRadians: number;
        CircleCenter: Class;
        bIgnoreAnyContextActorsWhenGeneratingCircle: boolean;
        CircleCenterZOffset: AIDataProviderFloatValue;
        TraceData: EnvTraceData;
        bDefineArc: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_OnCircle;
        static Load(InName: string): EnvQueryGenerator_OnCircle;
    }
    
    class EnvQueryGenerator_SimpleGrid extends EnvQueryGenerator_ProjectedPoints {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GridSize: AIDataProviderFloatValue;
        SpaceBetween: AIDataProviderFloatValue;
        GenerateAround: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_SimpleGrid;
        static Load(InName: string): EnvQueryGenerator_SimpleGrid;
    }
    
    class EnvQueryGenerator_PathingGrid extends EnvQueryGenerator_SimpleGrid {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PathToItem: AIDataProviderBoolValue;
        NavigationFilter: Class;
        ScanRangeMultiplier: AIDataProviderFloatValue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryGenerator_PathingGrid;
        static Load(InName: string): EnvQueryGenerator_PathingGrid;
    }
    
    class EnvQueryItemType extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType;
        static Load(InName: string): EnvQueryItemType;
    }
    
    class EnvQueryItemType_VectorBase extends EnvQueryItemType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_VectorBase;
        static Load(InName: string): EnvQueryItemType_VectorBase;
    }
    
    class EnvQueryItemType_ActorBase extends EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_ActorBase;
        static Load(InName: string): EnvQueryItemType_ActorBase;
    }
    
    class EnvQueryItemType_Actor extends EnvQueryItemType_ActorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Actor;
        static Load(InName: string): EnvQueryItemType_Actor;
    }
    
    class EnvQueryItemType_Direction extends EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Direction;
        static Load(InName: string): EnvQueryItemType_Direction;
    }
    
    class EnvQueryItemType_Point extends EnvQueryItemType_VectorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryItemType_Point;
        static Load(InName: string): EnvQueryItemType_Point;
    }
    
    class EnvQueryTest_Distance extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestMode: number;
        DistanceTo: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Distance;
        static Load(InName: string): EnvQueryTest_Distance;
    }
    
    enum EEnvTestDot { Dot3D, Dot2D, EEnvTestDot_MAX}
    class EnvQueryTest_Dot extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LineA: EnvDirection;
        LineB: EnvDirection;
        TestMode: EEnvTestDot;
        bAbsoluteValue: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Dot;
        static Load(InName: string): EnvQueryTest_Dot;
    }
    
    class EnvQueryTest_GameplayTags extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TagQueryToMatch: GameplayTagQuery;
        bUpdatedToUseQuery: boolean;
        TagsToMatch: EGameplayContainerMatchType;
        GameplayTags: GameplayTagContainer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_GameplayTags;
        static Load(InName: string): EnvQueryTest_GameplayTags;
    }
    
    class EnvOverlapData {
        constructor(ExtentX: number, ExtentY: number, ExtentZ: number, ShapeOffset: Vector, OverlapChannel: number, OverlapShape: number, bOnlyBlockingHits: boolean, bOverlapComplex: boolean, bSkipOverlapQuerier: boolean);
        ExtentX: number;
        ExtentY: number;
        ExtentZ: number;
        ShapeOffset: Vector;
        OverlapChannel: number;
        OverlapShape: number;
        bOnlyBlockingHits: boolean;
        bOverlapComplex: boolean;
        bSkipOverlapQuerier: boolean;
    }
    
    class EnvQueryTest_Overlap extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OverlapData: EnvOverlapData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Overlap;
        static Load(InName: string): EnvQueryTest_Overlap;
    }
    
    class EnvQueryTest_Pathfinding extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestMode: number;
        Context: Class;
        PathFromContext: AIDataProviderBoolValue;
        SkipUnreachable: AIDataProviderBoolValue;
        FilterClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Pathfinding;
        static Load(InName: string): EnvQueryTest_Pathfinding;
    }
    
    class EnvQueryTest_PathfindingBatch extends EnvQueryTest_Pathfinding {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScanRangeMultiplier: AIDataProviderFloatValue;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_PathfindingBatch;
        static Load(InName: string): EnvQueryTest_PathfindingBatch;
    }
    
    class EnvQueryTest_Project extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProjectionData: EnvTraceData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Project;
        static Load(InName: string): EnvQueryTest_Project;
    }
    
    class EnvQueryTest_Random extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Random;
        static Load(InName: string): EnvQueryTest_Random;
    }
    
    class EnvQueryTest_Trace extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TraceData: EnvTraceData;
        TraceFromContext: AIDataProviderBoolValue;
        ItemHeightOffset: AIDataProviderFloatValue;
        ContextHeightOffset: AIDataProviderFloatValue;
        Context: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Trace;
        static Load(InName: string): EnvQueryTest_Trace;
    }
    
    class EnvQueryTest_Volume extends EnvQueryTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VolumeContext: Class;
        VolumeClass: Class;
        bDoComplexVolumeTest: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTest_Volume;
        static Load(InName: string): EnvQueryTest_Volume;
    }
    
    class EnvQueryTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EnvQueryTypes;
        static Load(InName: string): EnvQueryTypes;
    }
    
    class EQSQueryResultSourceInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EQSQueryResultSourceInterface;
        static Load(InName: string): EQSQueryResultSourceInterface;
    }
    
    class EQSRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EQSRenderingComponent;
        static Load(InName: string): EQSRenderingComponent;
    }
    
    enum EEnvQueryHightlightMode { All, Best5Pct, Best25Pct, EEnvQueryHightlightMode_MAX}
    class EQSTestingPawn extends Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryTemplate: EnvQuery;
        QueryParams: TArray<EnvNamedValue>;
        QueryConfig: TArray<AIDynamicParam>;
        TimeLimitPerStep: number;
        StepToDebugDraw: number;
        HighlightMode: EEnvQueryHightlightMode;
        bDrawLabels: boolean;
        bDrawFailedItems: boolean;
        bReRunQueryOnlyOnFinishedMove: boolean;
        bShouldBeVisibleInGame: boolean;
        bTickDuringGame: boolean;
        QueryingMode: number;
        NavAgentProperties: NavAgentProperties;
        EdRenderComp: EQSRenderingComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EQSTestingPawn;
        static Load(InName: string): EQSTestingPawn;
    }
    
    class GenericTeamAgentInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GenericTeamAgentInterface;
        static Load(InName: string): GenericTeamAgentInterface;
    }
    
    class GridPathAIController extends AIController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridPathAIController;
        static Load(InName: string): GridPathAIController;
    }
    
    class GridPathFollowingComponent extends PathFollowingComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GridManager: NavLocalGridManager;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GridPathFollowingComponent;
        static Load(InName: string): GridPathFollowingComponent;
    }
    
    class NavFilter_AIControllerDefault extends NavigationQueryFilter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavFilter_AIControllerDefault;
        static Load(InName: string): NavFilter_AIControllerDefault;
    }
    
    class NavLinkProxy extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PointLinks: TArray<NavigationLink>;
        SegmentLinks: TArray<NavigationSegmentLink>;
        SmartLinkComp: NavLinkCustomComponent;
        bSmartLinkIsRelevant: boolean;
        EdRenderComp: NavLinkRenderingComponent;
        SpriteComponent: BillboardComponent;
        OnSmartLinkReached: $MulticastDelegate<(MovingActor: Actor, DestinationPoint: Vector) => void>;
        SetSmartLinkEnabled(bEnabled: boolean): void;
        ResumePathFollowing(Agent: Actor): void;
        ReceiveSmartLinkReached(Agent: Actor, Destination: Vector): void;
        IsSmartLinkEnabled(): boolean;
        HasMovingAgents(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NavLinkProxy;
        static Load(InName: string): NavLinkProxy;
    }
    
    class PathFollowingManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PathFollowingManager;
        static Load(InName: string): PathFollowingManager;
    }
    
    class PawnAction_BlueprintBase extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActionTick(ControlledPawn: Pawn, DeltaSeconds: number): void;
        ActionStart(ControlledPawn: Pawn): void;
        ActionResume(ControlledPawn: Pawn): void;
        ActionPause(ControlledPawn: Pawn): void;
        ActionFinished(ControlledPawn: Pawn, WithResult: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_BlueprintBase;
        static Load(InName: string): PawnAction_BlueprintBase;
    }
    
    class PawnAction_Move extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GoalActor: Actor;
        GoalLocation: Vector;
        AcceptableRadius: number;
        FilterClass: Class;
        bAllowStrafe: boolean;
        bFinishOnOverlap: boolean;
        bUsePathfinding: boolean;
        bAllowPartialPath: boolean;
        bProjectGoalToNavigation: boolean;
        bUpdatePathToGoal: boolean;
        bAbortChildActionOnPathChange: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Move;
        static Load(InName: string): PawnAction_Move;
    }
    
    class PawnAction_Repeat extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActionToRepeat: PawnAction;
        RecentActionCopy: PawnAction;
        ChildFailureHandlingMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Repeat;
        static Load(InName: string): PawnAction_Repeat;
    }
    
    class PawnAction_Sequence extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActionSequence: TArray<PawnAction>;
        ChildFailureHandlingMode: number;
        RecentActionCopy: PawnAction;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Sequence;
        static Load(InName: string): PawnAction_Sequence;
    }
    
    class PawnAction_Wait extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeToWait: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnAction_Wait;
        static Load(InName: string): PawnAction_Wait;
    }
    
    class PawnSensingComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HearingThreshold: number;
        LOSHearingThreshold: number;
        SightRadius: number;
        SensingInterval: number;
        HearingMaxSoundAge: number;
        bEnableSensingUpdates: boolean;
        bOnlySensePlayers: boolean;
        bSeePawns: boolean;
        bHearNoises: boolean;
        OnSeePawn: $MulticastDelegate<(Pawn: Pawn) => void>;
        OnHearNoise: $MulticastDelegate<(Instigator: Pawn, Location: Vector, Volume: number) => void>;
        PeripheralVisionAngle: number;
        PeripheralVisionCosine: number;
        SetSensingUpdatesEnabled(bEnabled: boolean): void;
        SetSensingInterval(NewSensingInterval: number): void;
        SetPeripheralVisionAngle(NewPeripheralVisionAngle: number): void;
        SeePawnDelegate__DelegateSignature(Pawn: Pawn): void;
        HearNoiseDelegate__DelegateSignature(Instigator: Pawn, Location: Vector, Volume: number): void;
        GetPeripheralVisionCosine(): number;
        GetPeripheralVisionAngle(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PawnSensingComponent;
        static Load(InName: string): PawnSensingComponent;
    }
    
    class VisualLoggerExtension extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerExtension;
        static Load(InName: string): VisualLoggerExtension;
    }
    
    class CapturedPropSegment {
        constructor(PropertyName: string, PropertyIndex: number, ComponentName: string);
        PropertyName: string;
        PropertyIndex: number;
        ComponentName: string;
    }
    
    enum EPropertyValueCategory { Undefined, Generic, RelativeLocation, RelativeRotation, RelativeScale3D, Visibility, Material, Color, Option, EPropertyValueCategory_MAX}
    class PropertyValue extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Properties: TArray<Property>;
        PropertyIndices: TArray<number>;
        CapturedPropSegments: TArray<CapturedPropSegment>;
        FullDisplayString: string;
        PropertySetterName: string;
        PropertySetterParameterDefaults: TMap<string, string>;
        bHasRecordedData: boolean;
        LeafPropertyClass: Class;
        ValueBytes: TArray<number>;
        PropCategory: EPropertyValueCategory;
        HasRecordedData(): boolean;
        GetPropertyTooltip(): string;
        GetFullDisplayString(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValue;
        static Load(InName: string): PropertyValue;
    }
    
    class FunctionCaller {
        constructor(FunctionName: string, FunctionEntry: TWeakObjectPtr<Object>);
        FunctionName: string;
        FunctionEntry: TWeakObjectPtr<Object>;
    }
    
    class VariantObjectBinding extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectPtr: SoftObjectPath;
        LazyObjectPtr: TLazyObjectPtr<Object>;
        CapturedProperties: TArray<PropertyValue>;
        FunctionCallers: TArray<FunctionCaller>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantObjectBinding;
        static Load(InName: string): VariantObjectBinding;
    }
    
    class Variant extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayText: string;
        ObjectBindings: TArray<VariantObjectBinding>;
        SwitchOn(): void;
        SetDisplayText(NewDisplayText: string): void;
        GetNumActors(): number;
        GetDisplayText(): string;
        GetActor(ActorIndex: number): Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Variant;
        static Load(InName: string): Variant;
    }
    
    class VariantSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayText: string;
        bExpanded: boolean;
        Variants: TArray<Variant>;
        SetDisplayText(NewDisplayText: string): void;
        GetVariantByName(VariantName: string): Variant;
        GetVariant(VariantIndex: number): Variant;
        GetNumVariants(): number;
        GetDisplayText(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantSet;
        static Load(InName: string): VariantSet;
    }
    
    class LevelVariantSets extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DirectorBlueprint: Object;
        DirectorClass: BlueprintGeneratedClass;
        VariantSets: TArray<VariantSet>;
        GetVariantSetByName(VariantSetName: string): VariantSet;
        GetVariantSet(VariantSetIndex: number): VariantSet;
        GetNumVariantSets(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSets;
        static Load(InName: string): LevelVariantSets;
    }
    
    class LevelVariantSetsActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LevelVariantSets: SoftObjectPath;
        SwitchOnVariantByName(VariantSetName: string, VariantName: string): boolean;
        SwitchOnVariantByIndex(VariantSetIndex: number, VariantIndex: number): boolean;
        SetLevelVariantSets(InVariantSets: LevelVariantSets): void;
        GetLevelVariantSets(bLoad: boolean): LevelVariantSets;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSetsActor;
        static Load(InName: string): LevelVariantSetsActor;
    }
    
    class LevelVariantSetsFunctionDirector extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSetsFunctionDirector;
        static Load(InName: string): LevelVariantSetsFunctionDirector;
    }
    
    class PropertyValueTransform extends PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueTransform;
        static Load(InName: string): PropertyValueTransform;
    }
    
    class PropertyValueVisibility extends PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueVisibility;
        static Load(InName: string): PropertyValueVisibility;
    }
    
    class PropertyValueColor extends PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueColor;
        static Load(InName: string): PropertyValueColor;
    }
    
    class PropertyValueMaterial extends PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueMaterial;
        static Load(InName: string): PropertyValueMaterial;
    }
    
    class PropertyValueOption extends PropertyValue {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyValueOption;
        static Load(InName: string): PropertyValueOption;
    }
    
    class SwitchActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SceneComponent: SceneComponent;
        SelectOption(OptionIndex: number): void;
        GetSelectedOption(): number;
        GetOptions(): TArray<Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SwitchActor;
        static Load(InName: string): SwitchActor;
    }
    
    class DatasmithObjectTemplate extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithObjectTemplate;
        static Load(InName: string): DatasmithObjectTemplate;
    }
    
    class DatasmithActorTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Layers: TSet<string>;
        Tags: TSet<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithActorTemplate;
        static Load(InName: string): DatasmithActorTemplate;
    }
    
    class DatasmithAdditionalData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAdditionalData;
        static Load(InName: string): DatasmithAdditionalData;
    }
    
    enum EDatasmithAreaLightActorType { Point, Spot, Rect, EDatasmithAreaLightActorType_MAX}
    enum EDatasmithAreaLightActorShape { Rectangle, Disc, Sphere, Cylinder, None, EDatasmithAreaLightActorShape_MAX}
    class DatasmithAreaLightActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightType: EDatasmithAreaLightActorType;
        LightShape: EDatasmithAreaLightActorShape;
        Dimensions: Vector2D;
        Intensity: number;
        IntensityUnits: ELightUnits;
        Color: LinearColor;
        Temperature: number;
        IESTexture: TextureLightProfile;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        Rotation: Rotator;
        SourceRadius: number;
        SourceLength: number;
        AttenuationRadius: number;
        SpotlightInnerAngle: number;
        SpotlightOuterAngle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAreaLightActor;
        static Load(InName: string): DatasmithAreaLightActor;
    }
    
    class DatasmithAreaLightActorTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LightType: EDatasmithAreaLightActorType;
        LightShape: EDatasmithAreaLightActorShape;
        Dimensions: Vector2D;
        Color: LinearColor;
        Intensity: number;
        IntensityUnits: ELightUnits;
        Temperature: number;
        IESTexture: TSoftObjectPtr<TextureLightProfile>;
        bUseIESBrightness: boolean;
        IESBrightnessScale: number;
        Rotation: Rotator;
        SourceRadius: number;
        SourceLength: number;
        AttenuationRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAreaLightActorTemplate;
        static Load(InName: string): DatasmithAreaLightActorTemplate;
    }
    
    class DatasmithAssetImportOptions {
        constructor(PackagePath: string);
        PackagePath: string;
    }
    
    class DatasmithAssetImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportOptions: DatasmithAssetImportOptions;
        AdditionalData: TArray<DatasmithAdditionalData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAssetImportData;
        static Load(InName: string): DatasmithAssetImportData;
    }
    
    enum EDatasmithImportLightmapMin { LIGHTMAP_16, LIGHTMAP_32, LIGHTMAP_64, LIGHTMAP_128, LIGHTMAP_256, LIGHTMAP_512, LIGHTMAP_MAX}
    enum EDatasmithImportLightmapMax { LIGHTMAP_64, LIGHTMAP_128, LIGHTMAP_256, LIGHTMAP_512, LIGHTMAP_1024, LIGHTMAP_2048, LIGHTMAP_4096, LIGHTMAP_MAX}
    class DatasmithStaticMeshImportOptions {
        constructor(MinLightmapResolution: EDatasmithImportLightmapMin, MaxLightmapResolution: EDatasmithImportLightmapMax, bGenerateLightmapUVs: boolean, bRemoveDegenerates: boolean);
        MinLightmapResolution: EDatasmithImportLightmapMin;
        MaxLightmapResolution: EDatasmithImportLightmapMax;
        bGenerateLightmapUVs: boolean;
        bRemoveDegenerates: boolean;
    }
    
    class DatasmithStaticMeshImportData extends DatasmithAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportOptions: DatasmithStaticMeshImportOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshImportData;
        static Load(InName: string): DatasmithStaticMeshImportData;
    }
    
    enum EDatasmithCADStitchingTechnique { StitchingNone, StitchingHeal, StitchingSew, EDatasmithCADStitchingTechnique_MAX}
    class DatasmithTessellationOptions {
        constructor(ChordTolerance: number, MaxEdgeLength: number, NormalTolerance: number, StitchingTechnique: EDatasmithCADStitchingTechnique);
        ChordTolerance: number;
        MaxEdgeLength: number;
        NormalTolerance: number;
        StitchingTechnique: EDatasmithCADStitchingTechnique;
    }
    
    class DatasmithStaticMeshCADImportData extends DatasmithStaticMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TessellationOptions: DatasmithTessellationOptions;
        ModelUnit: number;
        ModelTolerance: number;
        ResourcePath: string;
        ResourceFilename: string;
        AuxiliaryFilenames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshCADImportData;
        static Load(InName: string): DatasmithStaticMeshCADImportData;
    }
    
    enum EDatasmithImportScene { NewLevel, CurrentLevel, AssetsOnly, EDatasmithImportScene_MAX}
    class DatasmithImportBaseOptions {
        constructor(SceneHandling: EDatasmithImportScene, bIncludeGeometry: boolean, bIncludeMaterial: boolean, bIncludeLight: boolean, bIncludeCamera: boolean, bIncludeAnimation: boolean, AssetOptions: DatasmithAssetImportOptions, StaticMeshOptions: DatasmithStaticMeshImportOptions);
        SceneHandling: EDatasmithImportScene;
        bIncludeGeometry: boolean;
        bIncludeMaterial: boolean;
        bIncludeLight: boolean;
        bIncludeCamera: boolean;
        bIncludeAnimation: boolean;
        AssetOptions: DatasmithAssetImportOptions;
        StaticMeshOptions: DatasmithStaticMeshImportOptions;
    }
    
    class DatasmithSceneImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseOptions: DatasmithImportBaseOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSceneImportData;
        static Load(InName: string): DatasmithSceneImportData;
    }
    
    class DatasmithTranslatedSceneImportData extends DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OriginFactory: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithTranslatedSceneImportData;
        static Load(InName: string): DatasmithTranslatedSceneImportData;
    }
    
    class DatasmithCADImportSceneData extends DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TessellationOptions: DatasmithTessellationOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCADImportSceneData;
        static Load(InName: string): DatasmithCADImportSceneData;
    }
    
    class DatasmithMDLSceneImportData extends DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithMDLSceneImportData;
        static Load(InName: string): DatasmithMDLSceneImportData;
    }
    
    class DatasmithGLTFSceneImportData extends DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Generator: string;
        Version: number;
        Author: string;
        License: string;
        Source: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithGLTFSceneImportData;
        static Load(InName: string): DatasmithGLTFSceneImportData;
    }
    
    class DatasmithStaticMeshGLTFImportData extends DatasmithStaticMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceMeshName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshGLTFImportData;
        static Load(InName: string): DatasmithStaticMeshGLTFImportData;
    }
    
    class DatasmithFBXSceneImportData extends DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bGenerateLightmapUVs: boolean;
        TexturesDir: string;
        IntermediateSerialization: number;
        bColorizeMaterials: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithFBXSceneImportData;
        static Load(InName: string): DatasmithFBXSceneImportData;
    }
    
    class DatasmithDeltaGenAssetImportData extends DatasmithAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithDeltaGenAssetImportData;
        static Load(InName: string): DatasmithDeltaGenAssetImportData;
    }
    
    class DatasmithDeltaGenSceneImportData extends DatasmithFBXSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMergeNodes: boolean;
        bOptimizeDuplicatedNodes: boolean;
        bRemoveInvisibleNodes: boolean;
        bSimplifyNodeHierarchy: boolean;
        bImportVar: boolean;
        VarPath: string;
        bImportPos: boolean;
        PosPath: string;
        bImportTml: boolean;
        TmlPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithDeltaGenSceneImportData;
        static Load(InName: string): DatasmithDeltaGenSceneImportData;
    }
    
    class DatasmithVREDAssetImportData extends DatasmithAssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithVREDAssetImportData;
        static Load(InName: string): DatasmithVREDAssetImportData;
    }
    
    class DatasmithVREDSceneImportData extends DatasmithFBXSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMergeNodes: boolean;
        bOptimizeDuplicatedNodes: boolean;
        bImportMats: boolean;
        MatsPath: string;
        bImportVar: boolean;
        bCleanVar: boolean;
        VarPath: string;
        bImportLightInfo: boolean;
        LightInfoPath: string;
        bImportClipInfo: boolean;
        ClipInfoPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithVREDSceneImportData;
        static Load(InName: string): DatasmithVREDSceneImportData;
    }
    
    class DatasmithIFCSceneImportData extends DatasmithSceneImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithIFCSceneImportData;
        static Load(InName: string): DatasmithIFCSceneImportData;
    }
    
    class DatasmithStaticMeshIFCImportData extends DatasmithStaticMeshImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceGlobalId: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshIFCImportData;
        static Load(InName: string): DatasmithStaticMeshIFCImportData;
    }
    
    class DatasmithAssetUserData extends AssetUserData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MetaData: TMap<string, string>;
        ObjectTemplates: TMap<Class, DatasmithObjectTemplate>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithAssetUserData;
        static Load(InName: string): DatasmithAssetUserData;
    }
    
    class DatasmithCameraLookatTrackingSettingsTemplate {
        constructor(bEnableLookAtTracking: boolean, bAllowRoll: boolean, ActorToTrack: TSoftObjectPtr<Actor>);
        bEnableLookAtTracking: boolean;
        bAllowRoll: boolean;
        ActorToTrack: TSoftObjectPtr<Actor>;
    }
    
    class DatasmithCineCameraActorTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookatTrackingSettings: DatasmithCameraLookatTrackingSettingsTemplate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCineCameraActorTemplate;
        static Load(InName: string): DatasmithCineCameraActorTemplate;
    }
    
    class DatasmithCameraFilmbackSettingsTemplate {
        constructor(SensorWidth: number, SensorHeight: number);
        SensorWidth: number;
        SensorHeight: number;
    }
    
    class DatasmithCameraLensSettingsTemplate {
        constructor(MaxFStop: number);
        MaxFStop: number;
    }
    
    class DatasmithCameraFocusSettingsTemplate {
        constructor(FocusMethod: ECameraFocusMethod, ManualFocusDistance: number);
        FocusMethod: ECameraFocusMethod;
        ManualFocusDistance: number;
    }
    
    class DatasmithPostProcessSettingsTemplate {
        constructor(bOverride_WhiteTemp: boolean, bOverride_ColorSaturation: boolean, bOverride_VignetteIntensity: boolean, bOverride_FilmWhitePoint: boolean, bOverride_AutoExposureMethod: boolean, bOverride_CameraISO: boolean, bOverride_CameraShutterSpeed: boolean, bOverride_DepthOfFieldFstop: boolean, WhiteTemp: number, VignetteIntensity: number, FilmWhitePoint: LinearColor, ColorSaturation: Vector4, AutoExposureMethod: number, CameraISO: number, CameraShutterSpeed: number, DepthOfFieldFstop: number);
        bOverride_WhiteTemp: boolean;
        bOverride_ColorSaturation: boolean;
        bOverride_VignetteIntensity: boolean;
        bOverride_FilmWhitePoint: boolean;
        bOverride_AutoExposureMethod: boolean;
        bOverride_CameraISO: boolean;
        bOverride_CameraShutterSpeed: boolean;
        bOverride_DepthOfFieldFstop: boolean;
        WhiteTemp: number;
        VignetteIntensity: number;
        FilmWhitePoint: LinearColor;
        ColorSaturation: Vector4;
        AutoExposureMethod: number;
        CameraISO: number;
        CameraShutterSpeed: number;
        DepthOfFieldFstop: number;
    }
    
    class DatasmithCineCameraComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FilmbackSettings: DatasmithCameraFilmbackSettingsTemplate;
        LensSettings: DatasmithCameraLensSettingsTemplate;
        FocusSettings: DatasmithCameraFocusSettingsTemplate;
        CurrentFocalLength: number;
        CurrentAperture: number;
        PostProcessSettings: DatasmithPostProcessSettingsTemplate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCineCameraComponentTemplate;
        static Load(InName: string): DatasmithCineCameraComponentTemplate;
    }
    
    class DatasmithContentBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetDatasmithUserDataValueForKey(Object: Object, Key: string): string;
        static GetDatasmithUserDataKeysAndValuesForValue(Object: Object, StringToMatch: string, OutKeys: $Ref<TArray<string>>, OutValues: $Ref<TArray<string>>): void;
        static GetDatasmithUserData(Object: Object): DatasmithAssetUserData;
        static GetAllObjectsAndValuesForKey(Key: string, ObjectClass: Class, OutObjects: $Ref<TArray<Object>>, OutValues: $Ref<TArray<string>>): void;
        static GetAllDatasmithUserData(ObjectClass: Class, OutUserData: $Ref<TArray<DatasmithAssetUserData>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithContentBlueprintLibrary;
        static Load(InName: string): DatasmithContentBlueprintLibrary;
    }
    
    class DatasmithCustomActionBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCustomActionBase;
        static Load(InName: string): DatasmithCustomActionBase;
    }
    
    class DatasmithImportedSequencesActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportedSequences: TArray<LevelSequence>;
        PlayLevelSequence(SequenceToPlay: LevelSequence): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithImportedSequencesActor;
        static Load(InName: string): DatasmithImportedSequencesActor;
    }
    
    class DatasmithCommonTessellationOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Options: DatasmithTessellationOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithCommonTessellationOptions;
        static Load(InName: string): DatasmithCommonTessellationOptions;
    }
    
    enum EDatasmithImportSearchPackagePolicy { Current, All, EDatasmithImportSearchPackagePolicy_MAX}
    enum EDatasmithImportAssetConflictPolicy { Replace, Update, Use, Ignore, EDatasmithImportAssetConflictPolicy_MAX}
    enum EDatasmithImportActorPolicy { Update, Full, Ignore, EDatasmithImportActorPolicy_MAX}
    enum EDatasmithImportMaterialQuality { UseNoFresnelCurves, UseSimplifierFresnelCurves, UseRealFresnelCurves, EDatasmithImportMaterialQuality_MAX}
    class DatasmithReimportOptions {
        constructor(bUpdateActors: boolean, bRespawnDeletedActors: boolean);
        bUpdateActors: boolean;
        bRespawnDeletedActors: boolean;
    }
    
    class DatasmithImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SearchPackagePolicy: EDatasmithImportSearchPackagePolicy;
        MaterialConflictPolicy: EDatasmithImportAssetConflictPolicy;
        TextureConflictPolicy: EDatasmithImportAssetConflictPolicy;
        StaticMeshActorImportPolicy: EDatasmithImportActorPolicy;
        LightImportPolicy: EDatasmithImportActorPolicy;
        CameraImportPolicy: EDatasmithImportActorPolicy;
        OtherActorImportPolicy: EDatasmithImportActorPolicy;
        MaterialQuality: EDatasmithImportMaterialQuality;
        BaseOptions: DatasmithImportBaseOptions;
        ReimportOptions: DatasmithReimportOptions;
        FileName: string;
        FilePath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithImportOptions;
        static Load(InName: string): DatasmithImportOptions;
    }
    
    class DatasmithLandscapeTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LandscapeMaterial: MaterialInterface;
        StaticLightingLOD: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithLandscapeTemplate;
        static Load(InName: string): DatasmithLandscapeTemplate;
    }
    
    class DatasmithLightComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bVisible: boolean;
        CastShadows: boolean;
        bUseTemperature: boolean;
        bUseIESBrightness: boolean;
        Intensity: number;
        Temperature: number;
        IESBrightnessScale: number;
        LightColor: LinearColor;
        LightFunctionMaterial: MaterialInterface;
        IESTexture: TextureLightProfile;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithLightComponentTemplate;
        static Load(InName: string): DatasmithLightComponentTemplate;
    }
    
    class DatasmithStaticParameterSetTemplate {
        constructor(StaticSwitchParameters: TMap<string, boolean>);
        StaticSwitchParameters: TMap<string, boolean>;
    }
    
    class DatasmithMaterialInstanceTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ScalarParameterValues: TMap<string, number>;
        VectorParameterValues: TMap<string, LinearColor>;
        TextureParameterValues: TMap<string, TSoftObjectPtr<Texture>>;
        StaticParameters: DatasmithStaticParameterSetTemplate;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithMaterialInstanceTemplate;
        static Load(InName: string): DatasmithMaterialInstanceTemplate;
    }
    
    class DatasmithPointLightComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntensityUnits: ELightUnits;
        SourceRadius: number;
        SourceLength: number;
        AttenuationRadius: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithPointLightComponentTemplate;
        static Load(InName: string): DatasmithPointLightComponentTemplate;
    }
    
    class DatasmithPostProcessVolumeTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: DatasmithPostProcessSettingsTemplate;
        bEnabled: boolean;
        bUnbound: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithPostProcessVolumeTemplate;
        static Load(InName: string): DatasmithPostProcessVolumeTemplate;
    }
    
    class DatasmithScene extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: DatasmithSceneImportData;
        BulkDataVersion: number;
        StaticMeshes: TMap<string, TSoftObjectPtr<StaticMesh>>;
        Textures: TMap<string, TSoftObjectPtr<Texture>>;
        MaterialFunctions: TMap<string, TSoftObjectPtr<MaterialFunction>>;
        Materials: TMap<string, TSoftObjectPtr<MaterialInterface>>;
        LevelSequences: TMap<string, TSoftObjectPtr<LevelSequence>>;
        LevelVariantSets: TMap<string, TSoftObjectPtr<LevelVariantSets>>;
        AssetUserData: TArray<AssetUserData>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithScene;
        static Load(InName: string): DatasmithScene;
    }
    
    class DatasmithSceneActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Scene: DatasmithScene;
        RelatedActors: TMap<string, TSoftObjectPtr<Actor>>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSceneActor;
        static Load(InName: string): DatasmithSceneActor;
    }
    
    class DatasmithSceneComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RelativeTransform: Transform;
        Mobility: number;
        AttachParent: TSoftObjectPtr<SceneComponent>;
        Tags: TSet<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSceneComponentTemplate;
        static Load(InName: string): DatasmithSceneComponentTemplate;
    }
    
    class DatasmithSkyLightComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceType: number;
        CubemapResolution: number;
        Cubemap: TextureCube;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSkyLightComponentTemplate;
        static Load(InName: string): DatasmithSkyLightComponentTemplate;
    }
    
    class DatasmithSpotLightComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InnerConeAngle: number;
        OuterConeAngle: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithSpotLightComponentTemplate;
        static Load(InName: string): DatasmithSpotLightComponentTemplate;
    }
    
    class DatasmithStaticMeshComponentTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMesh: StaticMesh;
        OverrideMaterials: TArray<MaterialInterface>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshComponentTemplate;
        static Load(InName: string): DatasmithStaticMeshComponentTemplate;
    }
    
    class DatasmithMeshSectionInfoTemplate {
        constructor(MaterialIndex: number);
        MaterialIndex: number;
    }
    
    class DatasmithMeshSectionInfoMapTemplate {
        constructor(Map: TMap<number, DatasmithMeshSectionInfoTemplate>);
        Map: TMap<number, DatasmithMeshSectionInfoTemplate>;
    }
    
    class DatasmithMeshBuildSettingsTemplate {
        constructor(bUseMikkTSpace: boolean, bRecomputeNormals: boolean, bRecomputeTangents: boolean, bRemoveDegenerates: boolean, bBuildAdjacencyBuffer: boolean, bUseHighPrecisionTangentBasis: boolean, bUseFullPrecisionUVs: boolean, bGenerateLightmapUVs: boolean, MinLightmapResolution: number, SrcLightmapIndex: number, DstLightmapIndex: number);
        bUseMikkTSpace: boolean;
        bRecomputeNormals: boolean;
        bRecomputeTangents: boolean;
        bRemoveDegenerates: boolean;
        bBuildAdjacencyBuffer: boolean;
        bUseHighPrecisionTangentBasis: boolean;
        bUseFullPrecisionUVs: boolean;
        bGenerateLightmapUVs: boolean;
        MinLightmapResolution: number;
        SrcLightmapIndex: number;
        DstLightmapIndex: number;
    }
    
    class DatasmithStaticMaterialTemplate {
        constructor(MaterialSlotName: string, MaterialInterface: MaterialInterface);
        MaterialSlotName: string;
        MaterialInterface: MaterialInterface;
    }
    
    class DatasmithStaticMeshTemplate extends DatasmithObjectTemplate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SectionInfoMap: DatasmithMeshSectionInfoMapTemplate;
        LightMapCoordinateIndex: number;
        LightMapResolution: number;
        BuildSettings: TArray<DatasmithMeshBuildSettingsTemplate>;
        StaticMaterials: TArray<DatasmithStaticMaterialTemplate>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DatasmithStaticMeshTemplate;
        static Load(InName: string): DatasmithStaticMeshTemplate;
    }
    
    enum EMagicLeapPrivilege { Invalid, BatteryInfo, CameraCapture, WorldReconstruction, InAppPurchase, AudioCaptureMic, DrmCertificates, Occlusion, LowLatencyLightwear, Internet, IdentityRead, BackgroundDownload, BackgroundUpload, MediaDrm, Media, MediaMetadata, PowerInfo, LocalAreaNetwork, VoiceInput, Documents, ConnectBackgroundMusicService, RegisterBackgroundMusicService, PwFoundObjRead, NormalNotificationsUsage, MusicService, ControllerPose, ScreensProvider, GesturesSubscribe, GesturesConfig, AddressBookRead, AddressBookWrite, CoarseLocation, HandMesh, WifiStatusRead, EMagicLeapPrivilege_MAX}
    class MagicLeapPrivilegesFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RequestPrivilegeAsync(Privilege: EMagicLeapPrivilege, ResultDelegate: $Delegate<(RequestedPrivilege: EMagicLeapPrivilege, WasGranted: boolean) => void>): boolean;
        static RequestPrivilege(Privilege: EMagicLeapPrivilege): boolean;
        static CheckPrivilege(Privilege: EMagicLeapPrivilege): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapPrivilegesFunctionLibrary;
        static Load(InName: string): MagicLeapPrivilegesFunctionLibrary;
    }
    
    enum PurchaseType { Consumable, Nonconsumable, Undefined, PurchaseType_MAX}
    class PurchaseItemDetails {
        constructor(Price: string, Name: string, Type: PurchaseType);
        Price: string;
        Name: string;
        Type: PurchaseType;
    }
    
    class PurchaseConfirmation {
        constructor(PackageName: string, Type: PurchaseType);
        PackageName: string;
        Type: PurchaseType;
    }
    
    class InAppPurchaseComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InAppPurchaseLogMessage: $MulticastDelegate<(LogMessage: string) => void>;
        GetItemsDetailsSuccess: $MulticastDelegate<(ItemsDetails: TArray<PurchaseItemDetails>) => void>;
        GetItemsDetailsFailure: $MulticastDelegate<() => void>;
        PurchaseConfirmationSuccess: $MulticastDelegate<(PurchaseConfirmations: PurchaseConfirmation) => void>;
        PurchaseConfirmationFailure: $MulticastDelegate<() => void>;
        GetPurchaseHistorySuccess: $MulticastDelegate<(PurchaseHistory: TArray<PurchaseConfirmation>) => void>;
        GetPurchaseHistoryFailure: $MulticastDelegate<() => void>;
        TryPurchaseItemAsync(ItemDetails: PurchaseItemDetails): boolean;
        TryGetPurchaseHistoryAsync(InNumPages: number): boolean;
        TryGetItemsDetailsAsync(ItemIDs: TArray<string>): boolean;
        PurchaseConfirmationSuccess__DelegateSignature(PurchaseConfirmations: PurchaseConfirmation): void;
        PurchaseConfirmationFailure__DelegateSignature(): void;
        InAppPurchaseLogMessage__DelegateSignature(LogMessage: string): void;
        GetPurchaseHistorySuccess__DelegateSignature(PurchaseHistory: TArray<PurchaseConfirmation>): void;
        GetPurchaseHistoryFailure__DelegateSignature(): void;
        GetItemsDetailsSuccess__DelegateSignature(ItemsDetails: TArray<PurchaseItemDetails>): void;
        GetItemsDetailsFailure__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseComponent;
        static Load(InName: string): InAppPurchaseComponent;
    }
    
    class LuminApplicationLifecycleComponent extends ApplicationLifecycleComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DeviceHasReactivatedDelegate: $MulticastDelegate<() => void>;
        DeviceWillEnterRealityModeDelegate: $MulticastDelegate<() => void>;
        DeviceWillGoInStandbyDelegate: $MulticastDelegate<() => void>;
        LuminApplicationLifetimeDelegate__DelegateSignature(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminApplicationLifecycleComponent;
        static Load(InName: string): LuminApplicationLifecycleComponent;
    }
    
    class MagicLeapHeadTrackingNotificationsComponent extends VRNotificationsComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnHeadTrackingLost: $MulticastDelegate<() => void>;
        OnHeadTrackingRecovered: $MulticastDelegate<() => void>;
        OnHeadTrackingRecoveryFailed: $MulticastDelegate<() => void>;
        OnHeadTrackingNewSessionStarted: $MulticastDelegate<() => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHeadTrackingNotificationsComponent;
        static Load(InName: string): MagicLeapHeadTrackingNotificationsComponent;
    }
    
    enum EMagicLeapHeadTrackingMode { PositionAndOrientation, Unavailable, Unknown, EMagicLeapHeadTrackingMode_MAX}
    enum EMagicLeapHeadTrackingError { None, NotEnoughFeatures, LowLight, Unknown, EMagicLeapHeadTrackingError_MAX}
    class MagicLeapHeadTrackingState {
        constructor(Mode: EMagicLeapHeadTrackingMode, Error: EMagicLeapHeadTrackingError, Confidence: number);
        Mode: EMagicLeapHeadTrackingMode;
        Error: EMagicLeapHeadTrackingError;
        Confidence: number;
    }
    
    enum EMagicLeapHeadTrackingMapEvent { Lost, Recovered, RecoveryFailed, NewSession, EMagicLeapHeadTrackingMapEvent_MAX}
    class MagicLeapHMDFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetStabilizationDepthActor(InStabilizationDepthActor: Actor, bSetFocusActor: boolean): void;
        static SetFocusActor(InFocusActor: Actor, bSetStabilizationActor: boolean): void;
        static SetBaseRotation(InBaseRotation: Rotator): void;
        static SetBasePosition(InBasePosition: Vector): void;
        static SetBaseOrientation(InBaseOrientation: Quat): void;
        static SetAppReady(): boolean;
        static IsRunningOnMagicLeapHMD(): boolean;
        static GetMLSDKVersionRevision(): number;
        static GetMLSDKVersionMinor(): number;
        static GetMLSDKVersionMajor(): number;
        static GetMLSDKVersion(): string;
        static GetHeadTrackingState(State: $Ref<MagicLeapHeadTrackingState>): boolean;
        static GetHeadTrackingMapEvents(MapEvents: $Ref<TSet<EMagicLeapHeadTrackingMapEvent>>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHMDFunctionLibrary;
        static Load(InName: string): MagicLeapHMDFunctionLibrary;
    }
    
    class MagicLeapSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableZI: boolean;
        bUseVulkanForZI: boolean;
        bUseMLAudioForZI: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapSettings;
        static Load(InName: string): MagicLeapSettings;
    }
    
    enum EMagicLeapMeshState { New, Updated, Deleted, Unchanged, EMagicLeapMeshState_MAX}
    class MagicLeapMeshBlockInfo {
        constructor(BlockID: Guid, BlockPosition: Vector, BlockOrientation: Rotator, BlockDimensions: Vector, Timestamp: Timespan, BlockState: EMagicLeapMeshState);
        BlockID: Guid;
        BlockPosition: Vector;
        BlockOrientation: Rotator;
        BlockDimensions: Vector;
        Timestamp: Timespan;
        BlockState: EMagicLeapMeshState;
    }
    
    class MagicLeapTrackingMeshInfo {
        constructor(Timestamp: Timespan, BlockData: TArray<MagicLeapMeshBlockInfo>);
        Timestamp: Timespan;
        BlockData: TArray<MagicLeapMeshBlockInfo>;
    }
    
    enum EMagicLeapMeshLOD { Minimum, Medium, Maximum, EMagicLeapMeshLOD_MAX}
    class MagicLeapMeshBlockRequest {
        constructor(BlockID: Guid, LevelOfDetail: EMagicLeapMeshLOD);
        BlockID: Guid;
        LevelOfDetail: EMagicLeapMeshLOD;
    }
    
    class MagicLeapMeshBlockSelectorInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectMeshBlocks(NewMeshInfo: MagicLeapTrackingMeshInfo, RequestedMesh: $Ref<TArray<MagicLeapMeshBlockRequest>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapMeshBlockSelectorInterface;
        static Load(InName: string): MagicLeapMeshBlockSelectorInterface;
    }
    
    enum EMagicLeapMeshType { Triangles, PointCloud, EMagicLeapMeshType_MAX}
    enum EMagicLeapMeshVertexColorMode { None, Confidence, Block, LOD, EMagicLeapMeshVertexColorMode_MAX}
    class MeshTrackerComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnMeshTrackerUpdated: $MulticastDelegate<(ID: Guid, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, Confidence: TArray<number>) => void>;
        ScanWorld: boolean;
        MeshType: EMagicLeapMeshType;
        BoundingVolume: BoxComponent;
        LevelOfDetail: EMagicLeapMeshLOD;
        PerimeterOfGapsToFill: number;
        Planarize: boolean;
        DisconnectedSectionArea: number;
        RequestNormals: boolean;
        RequestVertexConfidence: boolean;
        VertexColorMode: EMagicLeapMeshVertexColorMode;
        BlockVertexColors: TArray<Color>;
        VertexColorFromConfidenceZero: LinearColor;
        VertexColorFromConfidenceOne: LinearColor;
        RemoveOverlappingTriangles: boolean;
        MRMesh: MRMeshComponent;
        BricksPerFrame: number;
        SelectMeshBlocks(NewMeshInfo: MagicLeapTrackingMeshInfo, RequestedMesh: $Ref<TArray<MagicLeapMeshBlockRequest>>): void;
        OnMeshTrackerUpdated__DelegateSignature(ID: Guid, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, Confidence: TArray<number>): void;
        GetNumQueuedBlockUpdates(): number;
        DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
        DisconnectBlockSelector(): void;
        ConnectMRMesh(InMRMeshPtr: MRMeshComponent): void;
        ConnectBlockSelector(Selector: MagicLeapMeshBlockSelectorInterface): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshTrackerComponent;
        static Load(InName: string): MeshTrackerComponent;
    }
    
    enum EMagicLeapRaycastResultState { RequestFailed, NoCollision, HitUnobserved, HitObserved, EMagicLeapRaycastResultState_MAX}
    class MagicLeapRaycastHitResult {
        constructor(HitState: EMagicLeapRaycastResultState, HitPoint: Vector, Normal: Vector, Confidence: number, UserData: number);
        HitState: EMagicLeapRaycastResultState;
        HitPoint: Vector;
        Normal: Vector;
        Confidence: number;
        UserData: number;
    }
    
    class MagicLeapRaycastQueryParams {
        constructor(Position: Vector, Direction: Vector, UpVector: Vector, Width: number, Height: number, HorizontalFovDegrees: number, CollideWithUnobserved: boolean, UserData: number);
        Position: Vector;
        Direction: Vector;
        UpVector: Vector;
        Width: number;
        Height: number;
        HorizontalFovDegrees: number;
        CollideWithUnobserved: boolean;
        UserData: number;
    }
    
    class MagicLeapRaycastComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RequestRaycast(RequestParams: MagicLeapRaycastQueryParams, ResultDelegate: $Delegate<(HitResult: MagicLeapRaycastHitResult) => void>): boolean;
        RaycastResultDelegate__DelegateSignature(HitResult: MagicLeapRaycastHitResult): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapRaycastComponent;
        static Load(InName: string): MagicLeapRaycastComponent;
    }
    
    class MagicLeapRaycastFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeRaycastQueryParams(Position: Vector, Direction: Vector, UpVector: Vector, Width: number, Height: number, HorizontalFovDegrees: number, CollideWithUnobserved: boolean, UserData: number): MagicLeapRaycastQueryParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapRaycastFunctionLibrary;
        static Load(InName: string): MagicLeapRaycastFunctionLibrary;
    }
    
    class WmfMediaSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllowNonStandardCodecs: boolean;
        LowLatency: boolean;
        NativeAudioOut: boolean;
        HardwareAcceleratedVideoDecoding: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WmfMediaSettings;
        static Load(InName: string): WmfMediaSettings;
    }
    
    class NamedInterface {
        constructor(InterfaceName: string, InterfaceObject: Object);
        InterfaceName: string;
        InterfaceObject: Object;
    }
    
    class NamedInterfaceDef {
        constructor(InterfaceName: string, InterfaceClassName: string);
        InterfaceName: string;
        InterfaceClassName: string;
    }
    
    class NamedInterfaces extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NamedInterfaces: TArray<NamedInterface>;
        NamedInterfaceDefs: TArray<NamedInterfaceDef>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NamedInterfaces;
        static Load(InName: string): NamedInterfaces;
    }
    
    class TurnBasedMatchInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnMatchReceivedTurn(Match: string, bDidBecomeActive: boolean): void;
        OnMatchEnded(Match: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TurnBasedMatchInterface;
        static Load(InName: string): TurnBasedMatchInterface;
    }
    
    class AchievementBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetCachedAchievementProgress(WorldContextObject: Object, PlayerController: PlayerController, AchievementID: string, bFoundID: $Ref<boolean>, Progress: $Ref<number>): void;
        static GetCachedAchievementDescription(WorldContextObject: Object, PlayerController: PlayerController, AchievementID: string, bFoundID: $Ref<boolean>, Title: $Ref<string>, LockedDescription: $Ref<string>, UnlockedDescription: $Ref<string>, bHidden: $Ref<boolean>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AchievementBlueprintLibrary;
        static Load(InName: string): AchievementBlueprintLibrary;
    }
    
    class AchievementQueryCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static CacheAchievements(WorldContextObject: Object, PlayerController: PlayerController): AchievementQueryCallbackProxy;
        static CacheAchievementDescriptions(WorldContextObject: Object, PlayerController: PlayerController): AchievementQueryCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AchievementQueryCallbackProxy;
        static Load(InName: string): AchievementQueryCallbackProxy;
    }
    
    class AchievementWriteCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
        OnFailure: $MulticastDelegate<(WrittenAchievementName: string, WrittenProgress: number, WrittenUserTag: number) => void>;
        static WriteAchievementProgress(WorldContextObject: Object, PlayerController: PlayerController, AchievementName: string, Progress: number, UserTag: number): AchievementWriteCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AchievementWriteCallbackProxy;
        static Load(InName: string): AchievementWriteCallbackProxy;
    }
    
    class ConnectionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(ErrorCode: number) => void>;
        OnFailure: $MulticastDelegate<(ErrorCode: number) => void>;
        static ConnectToService(WorldContextObject: Object, PlayerController: PlayerController): ConnectionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConnectionCallbackProxy;
        static Load(InName: string): ConnectionCallbackProxy;
    }
    
    class CreateSessionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static CreateSession(WorldContextObject: Object, PlayerController: PlayerController, PublicConnections: number, bUseLAN: boolean): CreateSessionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CreateSessionCallbackProxy;
        static Load(InName: string): CreateSessionCallbackProxy;
    }
    
    class DestroySessionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static DestroySession(WorldContextObject: Object, PlayerController: PlayerController): DestroySessionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DestroySessionCallbackProxy;
        static Load(InName: string): DestroySessionCallbackProxy;
    }
    
    class EndMatchCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static EndMatch(WorldContextObject: Object, PlayerController: PlayerController, MatchActor: TurnBasedMatchInterface, MatchID: string, LocalPlayerOutcome: number, OtherPlayersOutcome: number): EndMatchCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EndMatchCallbackProxy;
        static Load(InName: string): EndMatchCallbackProxy;
    }
    
    class EndTurnCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static EndTurn(WorldContextObject: Object, PlayerController: PlayerController, MatchID: string, TurnBasedMatchInterface: TurnBasedMatchInterface): EndTurnCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EndTurnCallbackProxy;
        static Load(InName: string): EndTurnCallbackProxy;
    }
    
    class BlueprintSessionResult {
        constructor();
    }
    
    class FindSessionsCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(Results: TArray<BlueprintSessionResult>) => void>;
        OnFailure: $MulticastDelegate<(Results: TArray<BlueprintSessionResult>) => void>;
        static GetServerName(Result: BlueprintSessionResult): string;
        static GetPingInMs(Result: BlueprintSessionResult): number;
        static GetMaxPlayers(Result: BlueprintSessionResult): number;
        static GetCurrentPlayers(Result: BlueprintSessionResult): number;
        static FindSessions(WorldContextObject: Object, PlayerController: PlayerController, MaxResults: number, bUseLAN: boolean): FindSessionsCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FindSessionsCallbackProxy;
        static Load(InName: string): FindSessionsCallbackProxy;
    }
    
    class FindTurnBasedMatchCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(MatchID: string) => void>;
        OnFailure: $MulticastDelegate<(MatchID: string) => void>;
        static FindTurnBasedMatch(WorldContextObject: Object, PlayerController: PlayerController, MatchActor: TurnBasedMatchInterface, MinPlayers: number, MaxPlayers: number, PlayerGroup: number, ShowExistingMatches: boolean): FindTurnBasedMatchCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FindTurnBasedMatchCallbackProxy;
        static Load(InName: string): FindTurnBasedMatchCallbackProxy;
    }
    
    class InAppPurchaseProductInfo {
        constructor(Identifier: string, TransactionIdentifier: string, DisplayName: string, DisplayDescription: string, DisplayPrice: string, RawPrice: number, CurrencyCode: string, CurrencySymbol: string, DecimalSeparator: string, GroupingSeparator: string, ReceiptData: string);
        Identifier: string;
        TransactionIdentifier: string;
        DisplayName: string;
        DisplayDescription: string;
        DisplayPrice: string;
        RawPrice: number;
        CurrencyCode: string;
        CurrencySymbol: string;
        DecimalSeparator: string;
        GroupingSeparator: string;
        ReceiptData: string;
    }
    
    class InAppPurchaseProductRequest {
        constructor(ProductIdentifier: string, bIsConsumable: boolean);
        ProductIdentifier: string;
        bIsConsumable: boolean;
    }
    
    class InAppPurchaseCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(CompletionStatus: number, InAppPurchaseInformation: InAppPurchaseProductInfo) => void>;
        OnFailure: $MulticastDelegate<(CompletionStatus: number, InAppPurchaseInformation: InAppPurchaseProductInfo) => void>;
        static CreateProxyObjectForInAppPurchase(PlayerController: PlayerController, ProductRequest: InAppPurchaseProductRequest): InAppPurchaseCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseCallbackProxy;
        static Load(InName: string): InAppPurchaseCallbackProxy;
    }
    
    class InAppPurchaseQueryCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(InAppPurchaseInformation: TArray<InAppPurchaseProductInfo>) => void>;
        OnFailure: $MulticastDelegate<(InAppPurchaseInformation: TArray<InAppPurchaseProductInfo>) => void>;
        static CreateProxyObjectForInAppPurchaseQuery(PlayerController: PlayerController, ProductIdentifiers: TArray<string>): InAppPurchaseQueryCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseQueryCallbackProxy;
        static Load(InName: string): InAppPurchaseQueryCallbackProxy;
    }
    
    class InAppPurchaseRestoreInfo {
        constructor(Identifier: string, ReceiptData: string, TransactionIdentifier: string);
        Identifier: string;
        ReceiptData: string;
        TransactionIdentifier: string;
    }
    
    class InAppPurchaseRestoreCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(CompletionStatus: number, InAppRestorePurchaseInformation: TArray<InAppPurchaseRestoreInfo>) => void>;
        OnFailure: $MulticastDelegate<(CompletionStatus: number, InAppRestorePurchaseInformation: TArray<InAppPurchaseRestoreInfo>) => void>;
        static CreateProxyObjectForInAppPurchaseRestore(ConsumableProductFlags: TArray<InAppPurchaseProductRequest>, PlayerController: PlayerController): InAppPurchaseRestoreCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InAppPurchaseRestoreCallbackProxy;
        static Load(InName: string): InAppPurchaseRestoreCallbackProxy;
    }
    
    class IpConnection extends NetConnection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SocketErrorDisconnectDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IpConnection;
        static Load(InName: string): IpConnection;
    }
    
    class IpNetDriver extends NetDriver {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogPortUnreach: boolean;
        AllowPlayerPortUnreach: boolean;
        MaxPortCountToTry: number;
        ServerDesiredSocketReceiveBufferBytes: number;
        ServerDesiredSocketSendBufferBytes: number;
        ClientDesiredSocketReceiveBufferBytes: number;
        ClientDesiredSocketSendBufferBytes: number;
        MaxSecondsInReceive: number;
        NbPacketsBetweenReceiveTimeTest: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IpNetDriver;
        static Load(InName: string): IpNetDriver;
    }
    
    class JoinSessionCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static JoinSession(WorldContextObject: Object, PlayerController: PlayerController, SearchResult: BlueprintSessionResult): JoinSessionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JoinSessionCallbackProxy;
        static Load(InName: string): JoinSessionCallbackProxy;
    }
    
    class LeaderboardBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static WriteLeaderboardInteger(PlayerController: PlayerController, StatName: string, StatValue: number): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LeaderboardBlueprintLibrary;
        static Load(InName: string): LeaderboardBlueprintLibrary;
    }
    
    class LeaderboardFlushCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(SessionName: string) => void>;
        OnFailure: $MulticastDelegate<(SessionName: string) => void>;
        static CreateProxyObjectForFlush(PlayerController: PlayerController, SessionName: string): LeaderboardFlushCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LeaderboardFlushCallbackProxy;
        static Load(InName: string): LeaderboardFlushCallbackProxy;
    }
    
    class LeaderboardQueryCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(LeaderboardValue: number) => void>;
        OnFailure: $MulticastDelegate<(LeaderboardValue: number) => void>;
        static CreateProxyObjectForIntQuery(PlayerController: PlayerController, StatName: string): LeaderboardQueryCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LeaderboardQueryCallbackProxy;
        static Load(InName: string): LeaderboardQueryCallbackProxy;
    }
    
    class LogoutCallbackProxy extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(PlayerController: PlayerController) => void>;
        OnFailure: $MulticastDelegate<(PlayerController: PlayerController) => void>;
        static Logout(WorldContextObject: Object, PlayerController: PlayerController): LogoutCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LogoutCallbackProxy;
        static Load(InName: string): LogoutCallbackProxy;
    }
    
    class OnlineBeacon extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeaconConnectionInitialTimeout: number;
        BeaconConnectionTimeout: number;
        NetDriver: NetDriver;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeacon;
        static Load(InName: string): OnlineBeacon;
    }
    
    class OnlineBeaconHostObject extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeaconTypeName: string;
        ClientBeaconActorClass: Class;
        ClientActors: TArray<OnlineBeaconClient>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeaconHostObject;
        static Load(InName: string): OnlineBeaconHostObject;
    }
    
    enum EBeaconConnectionState { Invalid, Closed, Pending, Open, EBeaconConnectionState_MAX}
    class OnlineBeaconClient extends OnlineBeacon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BeaconOwner: OnlineBeaconHostObject;
        BeaconConnection: NetConnection;
        ConnectionState: EBeaconConnectionState;
        ClientOnConnected(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeaconClient;
        static Load(InName: string): OnlineBeaconClient;
    }
    
    class OnlineBeaconHost extends OnlineBeacon {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ListenPort: number;
        ClientActors: TArray<OnlineBeaconClient>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineBeaconHost;
        static Load(InName: string): OnlineBeaconHost;
    }
    
    class OnlineEngineInterfaceImpl extends OnlineEngineInterface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VoiceSubsystemNameOverride: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineEngineInterfaceImpl;
        static Load(InName: string): OnlineEngineInterfaceImpl;
    }
    
    class PIELoginSettingsInternal {
        constructor(Id: string, Token: string, Type: string, TokenBytes: TArray<number>);
        Id: string;
        Token: string;
        Type: string;
        TokenBytes: TArray<number>;
    }
    
    class OnlinePIESettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bOnlinePIEEnabled: boolean;
        Logins: TArray<PIELoginSettingsInternal>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlinePIESettings;
        static Load(InName: string): OnlinePIESettings;
    }
    
    class OnlineSessionClient extends OnlineSession {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsFromInvite: boolean;
        bHandlingDisconnect: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OnlineSessionClient;
        static Load(InName: string): OnlineSessionClient;
    }
    
    class PlayerReservation {
        constructor(UniqueId: UniqueNetIdRepl, ValidationStr: string, Platform: string, bAllowCrossplay: boolean, ElapsedTime: number);
        UniqueId: UniqueNetIdRepl;
        ValidationStr: string;
        Platform: string;
        bAllowCrossplay: boolean;
        ElapsedTime: number;
    }
    
    class PartyReservation {
        constructor(TeamNum: number, PartyLeader: UniqueNetIdRepl, PartyMembers: TArray<PlayerReservation>, RemovedPartyMembers: TArray<PlayerReservation>);
        TeamNum: number;
        PartyLeader: UniqueNetIdRepl;
        PartyMembers: TArray<PlayerReservation>;
        RemovedPartyMembers: TArray<PlayerReservation>;
    }
    
    enum EClientRequestType { NonePending, ExistingSessionReservation, ReservationUpdate, EmptyServerReservation, Reconnect, Abandon, ReservationRemoveMembers, EClientRequestType_MAX}
    class PartyBeaconClient extends OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DestSessionId: string;
        PendingReservation: PartyReservation;
        RequestType: EClientRequestType;
        bPendingReservationSent: boolean;
        bCancelReservation: boolean;
        ServerUpdateReservationRequest(SessionId: string, ReservationUpdate: PartyReservation): void;
        ServerReservationRequest(SessionId: string, Reservation: PartyReservation): void;
        ServerRemoveMemberFromReservationRequest(SessionId: string, ReservationUpdate: PartyReservation): void;
        ServerCancelReservationRequest(PartyLeader: UniqueNetIdRepl): void;
        ClientSendReservationUpdates(NumRemainingReservations: number): void;
        ClientSendReservationFull(): void;
        ClientReservationResponse(ReservationResponse: number): void;
        ClientCancelReservationResponse(ReservationResponse: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PartyBeaconClient;
        static Load(InName: string): PartyBeaconClient;
    }
    
    class PartyBeaconState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SessionName: string;
        NumConsumedReservations: number;
        MaxReservations: number;
        NumTeams: number;
        NumPlayersPerTeam: number;
        TeamAssignmentMethod: string;
        ReservedHostTeamNum: number;
        ForceTeamNum: number;
        bRestrictCrossConsole: boolean;
        bEnableRemovalRequests: boolean;
        Reservations: TArray<PartyReservation>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PartyBeaconState;
        static Load(InName: string): PartyBeaconState;
    }
    
    class PartyBeaconHost extends OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        State: PartyBeaconState;
        bLogoutOnSessionTimeout: boolean;
        SessionTimeoutSecs: number;
        TravelSessionTimeoutSecs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PartyBeaconHost;
        static Load(InName: string): PartyBeaconHost;
    }
    
    class QuitMatchCallbackProxy extends OnlineBlueprintCallProxyBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<() => void>;
        OnFailure: $MulticastDelegate<() => void>;
        static QuitMatch(WorldContextObject: Object, PlayerController: PlayerController, MatchID: string, Outcome: number, TurnTimeoutInSeconds: number): QuitMatchCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): QuitMatchCallbackProxy;
        static Load(InName: string): QuitMatchCallbackProxy;
    }
    
    class ShowLoginUICallbackProxy extends BlueprintAsyncActionBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(PlayerController: PlayerController) => void>;
        OnFailure: $MulticastDelegate<(PlayerController: PlayerController) => void>;
        static ShowExternalLoginUI(WorldContextObject: Object, InPlayerController: PlayerController): ShowLoginUICallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ShowLoginUICallbackProxy;
        static Load(InName: string): ShowLoginUICallbackProxy;
    }
    
    class SpectatorReservation {
        constructor(SpectatorId: UniqueNetIdRepl, Spectator: PlayerReservation);
        SpectatorId: UniqueNetIdRepl;
        Spectator: PlayerReservation;
    }
    
    enum ESpectatorClientRequestType { NonePending, ExistingSessionReservation, ReservationUpdate, EmptyServerReservation, Reconnect, Abandon, ESpectatorClientRequestType_MAX}
    class SpectatorBeaconClient extends OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DestSessionId: string;
        PendingReservation: SpectatorReservation;
        RequestType: ESpectatorClientRequestType;
        bPendingReservationSent: boolean;
        bCancelReservation: boolean;
        ServerReservationRequest(SessionId: string, Reservation: SpectatorReservation): void;
        ServerCancelReservationRequest(Spectator: UniqueNetIdRepl): void;
        ClientSendReservationUpdates(NumRemainingReservations: number): void;
        ClientSendReservationFull(): void;
        ClientReservationResponse(ReservationResponse: number): void;
        ClientCancelReservationResponse(ReservationResponse: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconClient;
        static Load(InName: string): SpectatorBeaconClient;
    }
    
    class SpectatorBeaconState extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SessionName: string;
        NumConsumedReservations: number;
        MaxReservations: number;
        bRestrictCrossConsole: boolean;
        Reservations: TArray<SpectatorReservation>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconState;
        static Load(InName: string): SpectatorBeaconState;
    }
    
    class SpectatorBeaconHost extends OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        State: SpectatorBeaconState;
        bLogoutOnSessionTimeout: boolean;
        SessionTimeoutSecs: number;
        TravelSessionTimeoutSecs: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpectatorBeaconHost;
        static Load(InName: string): SpectatorBeaconHost;
    }
    
    class TestBeaconClient extends OnlineBeaconClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ServerPong(): void;
        ClientPing(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBeaconClient;
        static Load(InName: string): TestBeaconClient;
    }
    
    class TestBeaconHost extends OnlineBeaconHostObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBeaconHost;
        static Load(InName: string): TestBeaconHost;
    }
    
    class TurnBasedBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RegisterTurnBasedMatchInterfaceObject(WorldContextObject: Object, PlayerController: PlayerController, Object: Object): void;
        static GetPlayerDisplayName(WorldContextObject: Object, PlayerController: PlayerController, MatchID: string, PlayerIndex: number, PlayerDisplayName: $Ref<string>): void;
        static GetMyPlayerIndex(WorldContextObject: Object, PlayerController: PlayerController, MatchID: string, PlayerIndex: $Ref<number>): void;
        static GetIsMyTurn(WorldContextObject: Object, PlayerController: PlayerController, MatchID: string, bIsMyTurn: $Ref<boolean>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TurnBasedBlueprintLibrary;
        static Load(InName: string): TurnBasedBlueprintLibrary;
    }
    
    class VoipListenerSynthComponent extends SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IsIdling(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VoipListenerSynthComponent;
        static Load(InName: string): VoipListenerSynthComponent;
    }
    
    class K2Node_InAppPurchase extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchase;
        static Load(InName: string): K2Node_InAppPurchase;
    }
    
    class K2Node_InAppPurchaseQuery extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseQuery;
        static Load(InName: string): K2Node_InAppPurchaseQuery;
    }
    
    class K2Node_InAppPurchaseRestore extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_InAppPurchaseRestore;
        static Load(InName: string): K2Node_InAppPurchaseRestore;
    }
    
    class K2Node_LatentOnlineCall extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LatentOnlineCall;
        static Load(InName: string): K2Node_LatentOnlineCall;
    }
    
    class K2Node_LeaderboardFlush extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LeaderboardFlush;
        static Load(InName: string): K2Node_LeaderboardFlush;
    }
    
    class K2Node_LeaderboardQuery extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LeaderboardQuery;
        static Load(InName: string): K2Node_LeaderboardQuery;
    }
    
    enum EFixedFoveatedRenderingLevel { FFR_Off, FFR_Low, FFR_Medium, FFR_High, FFR_HighTop, FFR_MAX}
    enum ETrackedDeviceType { None, HMD, LTouch, RTouch, Touch, DeviceObjectZero, All, ETrackedDeviceType_MAX}
    class HmdUserProfileField {
        constructor(FieldName: string, FieldValue: string);
        FieldName: string;
        FieldValue: string;
    }
    
    class HmdUserProfile {
        constructor(Name: string, Gender: string, PlayerHeight: number, EyeHeight: number, IPD: number, NeckToEyeDistance: Vector2D, ExtraFields: TArray<HmdUserProfileField>);
        Name: string;
        Gender: string;
        PlayerHeight: number;
        EyeHeight: number;
        IPD: number;
        NeckToEyeDistance: Vector2D;
        ExtraFields: TArray<HmdUserProfileField>;
    }
    
    enum EBoundaryType { Boundary_Outer, Boundary_PlayArea, Boundary_MAX}
    class GuardianTestResult {
        constructor(IsTriggering: boolean, DeviceType: ETrackedDeviceType, ClosestDistance: number, ClosestPoint: Vector, ClosestPointNormal: Vector);
        IsTriggering: boolean;
        DeviceType: ETrackedDeviceType;
        ClosestDistance: number;
        ClosestPoint: Vector;
        ClosestPointNormal: Vector;
    }
    
    class OculusFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ShowLoadingSplashScreen(): void;
        static ShowLoadingIcon(Texture: Texture2D): void;
        static SetReorientHMDOnControllerRecenter(recenterMode: boolean): void;
        static SetPositionScale3D(PosScale3D: Vector): void;
        static SetLoadingSplashParams(TexturePath: string, DistanceInMeters: Vector, SizeInMeters: Vector2D, RotationAxis: Vector, RotationDeltaInDeg: number): void;
        static SetGuardianVisibility(GuardianVisible: boolean): void;
        static SetFixedFoveatedRenderingLevel(level: EFixedFoveatedRenderingLevel): void;
        static SetDisplayFrequency(RequestedFrequency: number): void;
        static SetCPUAndGPULevels(CPULevel: number, GPULevel: number): void;
        static SetColorScaleAndOffset(ColorScale: LinearColor, ColorOffset: LinearColor, bApplyToAllLayers: boolean): void;
        static SetBaseRotationAndPositionOffset(BaseRot: Rotator, PosOffset: Vector, Options: number): void;
        static SetBaseRotationAndBaseOffsetInMeters(Rotation: Rotator, BaseOffsetInMeters: Vector, Options: number): void;
        static IsLoadingIconEnabled(): boolean;
        static IsGuardianDisplayed(): boolean;
        static IsGuardianConfigured(): boolean;
        static IsDeviceTracked(DeviceType: ETrackedDeviceType): boolean;
        static IsAutoLoadingSplashScreenEnabled(): boolean;
        static HideLoadingSplashScreen(bClear: boolean): void;
        static HideLoadingIcon(): void;
        static HasSystemOverlayPresent(): boolean;
        static HasInputFocus(): boolean;
        static GetUserProfile(Profile: $Ref<HmdUserProfile>): boolean;
        static GetRawSensorData(AngularAcceleration: $Ref<Vector>, LinearAcceleration: $Ref<Vector>, AngularVelocity: $Ref<Vector>, LinearVelocity: $Ref<Vector>, TimeInSeconds: $Ref<number>, DeviceType: ETrackedDeviceType): void;
        static GetPose(DeviceRotation: $Ref<Rotator>, DevicePosition: $Ref<Vector>, NeckPosition: $Ref<Vector>, bUseOrienationForPlayerCamera: boolean, bUsePositionForPlayerCamera: boolean, PositionScale: Vector): void;
        static GetPointGuardianIntersection(Point: Vector, BoundaryType: EBoundaryType): GuardianTestResult;
        static GetPlayAreaTransform(): Transform;
        static GetNodeGuardianIntersection(DeviceType: ETrackedDeviceType, BoundaryType: EBoundaryType): GuardianTestResult;
        static GetLoadingSplashParams(TexturePath: $Ref<string>, DistanceInMeters: $Ref<Vector>, SizeInMeters: $Ref<Vector2D>, RotationAxis: $Ref<Vector>, RotationDeltaInDeg: $Ref<number>): void;
        static GetGuardianPoints(BoundaryType: EBoundaryType, UsePawnSpace: boolean): TArray<Vector>;
        static GetGuardianDimensions(BoundaryType: EBoundaryType): Vector;
        static GetGPUUtilization(IsGPUAvailable: $Ref<boolean>, GPUUtilization: $Ref<number>): void;
        static GetGPUFrameTime(): number;
        static GetFixedFoveatedRenderingLevel(): EFixedFoveatedRenderingLevel;
        static GetDeviceName(): string;
        static GetCurrentDisplayFrequency(): number;
        static GetBaseRotationAndPositionOffset(OutRot: $Ref<Rotator>, OutPosOffset: $Ref<Vector>): void;
        static GetBaseRotationAndBaseOffsetInMeters(OutRotation: $Ref<Rotator>, OutBaseOffsetInMeters: $Ref<Vector>): void;
        static GetAvailableDisplayFrequencies(): TArray<number>;
        static EnablePositionTracking(bPositionTracking: boolean): void;
        static EnableOrientationTracking(bOrientationTracking: boolean): void;
        static EnableAutoLoadingSplashScreen(bAutoShowEnabled: boolean): void;
        static ClearLoadingSplashScreens(): void;
        static AddLoadingSplashScreen(Texture: Texture2D, TranslationInMeters: Vector, Rotation: Rotator, SizeInMeters: Vector2D, DeltaRotation: Rotator, bClearBeforeAdd: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusFunctionLibrary;
        static Load(InName: string): OculusFunctionLibrary;
    }
    
    class OculusSplashDesc {
        constructor(TexturePath: SoftObjectPath, TransformInMeters: Transform, QuadSizeInMeters: Vector2D, DeltaRotation: Quat, TextureOffset: Vector2D, TextureScale: Vector2D, bNoAlphaChannel: boolean);
        TexturePath: SoftObjectPath;
        TransformInMeters: Transform;
        QuadSizeInMeters: Vector2D;
        DeltaRotation: Quat;
        TextureOffset: Vector2D;
        TextureScale: Vector2D;
        bNoAlphaChannel: boolean;
    }
    
    class OculusHMDRuntimeSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoEnabled: boolean;
        SplashDescs: TArray<OculusSplashDesc>;
        bSupportsDash: boolean;
        bCompositesDepth: boolean;
        bHQDistortion: boolean;
        PixelDensityMin: number;
        PixelDensityMax: number;
        CPULevel: number;
        GPULevel: number;
        FFRLevel: EFixedFoveatedRenderingLevel;
        bChromaCorrection: boolean;
        bRecenterHMDWithController: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusHMDRuntimeSettings;
        static Load(InName: string): OculusHMDRuntimeSettings;
    }
    
    class OculusSceneCaptureCubemap extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CaptureComponents: TArray<SceneCaptureComponent2D>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusSceneCaptureCubemap;
        static Load(InName: string): OculusSceneCaptureCubemap;
    }
    
    class ProcMeshTangent {
        constructor(TangentX: Vector, bFlipTangentY: boolean);
        TangentX: Vector;
        bFlipTangentY: boolean;
    }
    
    class ProcMeshVertex {
        constructor(Position: Vector, Normal: Vector, Tangent: ProcMeshTangent, Color: Color, UV0: Vector2D, UV1: Vector2D, UV2: Vector2D, UV3: Vector2D);
        Position: Vector;
        Normal: Vector;
        Tangent: ProcMeshTangent;
        Color: Color;
        UV0: Vector2D;
        UV1: Vector2D;
        UV2: Vector2D;
        UV3: Vector2D;
    }
    
    class ProcMeshSection {
        constructor(ProcVertexBuffer: TArray<ProcMeshVertex>, ProcIndexBuffer: TArray<number>, SectionLocalBox: Box, bEnableCollision: boolean, bSectionVisible: boolean);
        ProcVertexBuffer: TArray<ProcMeshVertex>;
        ProcIndexBuffer: TArray<number>;
        SectionLocalBox: Box;
        bEnableCollision: boolean;
        bSectionVisible: boolean;
    }
    
    class ProceduralMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseComplexAsSimpleCollision: boolean;
        bUseAsyncCooking: boolean;
        ProcMeshBodySetup: BodySetup;
        ProcMeshSections: TArray<ProcMeshSection>;
        CollisionConvexElems: TArray<KConvexElem>;
        LocalBounds: BoxSphereBounds;
        AsyncBodySetupQueue: TArray<BodySetup>;
        UpdateMeshSection_LinearColor(SectionIndex: number, Vertices: TArray<Vector>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, UV1: TArray<Vector2D>, UV2: TArray<Vector2D>, UV3: TArray<Vector2D>, VertexColors: TArray<LinearColor>, Tangents: TArray<ProcMeshTangent>): void;
        UpdateMeshSection(SectionIndex: number, Vertices: TArray<Vector>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, VertexColors: TArray<Color>, Tangents: TArray<ProcMeshTangent>): void;
        SetMeshSectionVisible(SectionIndex: number, bNewVisibility: boolean): void;
        IsMeshSectionVisible(SectionIndex: number): boolean;
        GetNumSections(): number;
        CreateMeshSection_LinearColor(SectionIndex: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, UV1: TArray<Vector2D>, UV2: TArray<Vector2D>, UV3: TArray<Vector2D>, VertexColors: TArray<LinearColor>, Tangents: TArray<ProcMeshTangent>, bCreateCollision: boolean): void;
        CreateMeshSection(SectionIndex: number, Vertices: TArray<Vector>, Triangles: TArray<number>, Normals: TArray<Vector>, UV0: TArray<Vector2D>, VertexColors: TArray<Color>, Tangents: TArray<ProcMeshTangent>, bCreateCollision: boolean): void;
        ClearMeshSection(SectionIndex: number): void;
        ClearCollisionConvexMeshes(): void;
        ClearAllMeshSections(): void;
        AddCollisionConvexMesh(ConvexVerts: TArray<Vector>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralMeshComponent;
        static Load(InName: string): ProceduralMeshComponent;
    }
    
    enum EProcMeshSliceCapOption { NoCap, CreateNewSectionForCap, UseLastSectionForCap, EProcMeshSliceCapOption_MAX}
    class KismetProceduralMeshLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SliceProceduralMesh(InProcMesh: ProceduralMeshComponent, PlanePosition: Vector, PlaneNormal: Vector, bCreateOtherHalf: boolean, OutOtherHalfProcMesh: $Ref<ProceduralMeshComponent>, CapOption: EProcMeshSliceCapOption, CapMaterial: MaterialInterface): void;
        static GetSectionFromStaticMesh(InMesh: StaticMesh, LODIndex: number, SectionIndex: number, Vertices: $Ref<TArray<Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;
        static GetSectionFromProceduralMesh(InProcMesh: ProceduralMeshComponent, SectionIndex: number, Vertices: $Ref<TArray<Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;
        static GenerateBoxMesh(BoxRadius: Vector, Vertices: $Ref<TArray<Vector>>, Triangles: $Ref<TArray<number>>, Normals: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;
        static CreateGridMeshWelded(NumX: number, NumY: number, Triangles: $Ref<TArray<number>>, Vertices: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, GridSpacing: number): void;
        static CreateGridMeshTriangles(NumX: number, NumY: number, bWinding: boolean, Triangles: $Ref<TArray<number>>): void;
        static CreateGridMeshSplit(NumX: number, NumY: number, Triangles: $Ref<TArray<number>>, Vertices: $Ref<TArray<Vector>>, UVs: $Ref<TArray<Vector2D>>, UV1s: $Ref<TArray<Vector2D>>, GridSpacing: number): void;
        static CopyProceduralMeshFromStaticMeshComponent(StaticMeshComponent: StaticMeshComponent, LODIndex: number, ProcMeshComponent: ProceduralMeshComponent, bCreateCollision: boolean): void;
        static ConvertQuadToTriangles(Triangles: $Ref<TArray<number>>, Vert0: number, Vert1: number, Vert2: number, Vert3: number): void;
        static CalculateTangentsForMesh(Vertices: TArray<Vector>, Triangles: TArray<number>, UVs: TArray<Vector2D>, Normals: $Ref<TArray<Vector>>, Tangents: $Ref<TArray<ProcMeshTangent>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): KismetProceduralMeshLibrary;
        static Load(InName: string): KismetProceduralMeshLibrary;
    }
    
    class SteamVRChaperoneComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnLeaveBounds: $MulticastDelegate<() => void>;
        OnReturnToBounds: $MulticastDelegate<() => void>;
        SteamVRChaperoneEvent__DelegateSignature(): void;
        GetBounds(): TArray<Vector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRChaperoneComponent;
        static Load(InName: string): SteamVRChaperoneComponent;
    }
    
    enum ESteamVRTrackedDeviceType { Controller, TrackingReference, Other, Invalid, ESteamVRTrackedDeviceType_MAX}
    class SteamVRFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetValidTrackedDeviceIds(DeviceType: ESteamVRTrackedDeviceType, OutTrackedDeviceIds: $Ref<TArray<number>>): void;
        static GetTrackedDevicePositionAndOrientation(DeviceId: number, OutPosition: $Ref<Vector>, OutOrientation: $Ref<Rotator>): boolean;
        static GetHandPositionAndOrientation(ControllerIndex: number, Hand: EControllerHand, OutPosition: $Ref<Vector>, OutOrientation: $Ref<Rotator>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRFunctionLibrary;
        static Load(InName: string): SteamVRFunctionLibrary;
    }
    
    class SteamVRAction {
        constructor(Name: string, Path: string);
        Name: string;
        Path: string;
    }
    
    class SteamVRActionSet {
        constructor(Path: string);
        Path: string;
    }
    
    enum ESteamVRHand { VR_Left, VR_Right, VR_MAX}
    class SteamVRInputOriginInfo {
        constructor(TrackedDeviceIndex: number, RenderModelComponentName: string, TrackedDeviceModel: string);
        TrackedDeviceIndex: number;
        RenderModelComponentName: string;
        TrackedDeviceModel: string;
    }
    
    enum ESteamVRInputStringBits { VR_InputString_Hand, VR_InputString_ControllerType, VR_InputString_InputSource, VR_InputString_All, VR_InputString_MAX}
    class SteamVRInputBindingInfo {
        constructor(DevicePathName: string, InputPathName: string, ModeName: string, SlotName: string);
        DevicePathName: string;
        InputPathName: string;
        ModeName: string;
        SlotName: string;
    }
    
    class SteamVRSkeletonTransform {
        constructor(Root: Transform, Wrist: Transform, Thumb_0: Transform, Thumb_1: Transform, Thumb_2: Transform, Thumb_3: Transform, Index_0: Transform, Index_1: Transform, Index_2: Transform, Index_3: Transform, Index_4: Transform, Middle_0: Transform, Middle_1: Transform, Middle_2: Transform, Middle_3: Transform, Middle_4: Transform, Ring_0: Transform, Ring_1: Transform, Ring_2: Transform, Ring_3: Transform, Ring_4: Transform, Pinky_0: Transform, Pinky_1: Transform, Pinky_2: Transform, Pinky_3: Transform, Pinky_4: Transform, Aux_Thumb: Transform, Aux_Index: Transform, Aux_Middle: Transform, Aux_Ring: Transform, Aux_Pinky: Transform);
        Root: Transform;
        Wrist: Transform;
        Thumb_0: Transform;
        Thumb_1: Transform;
        Thumb_2: Transform;
        Thumb_3: Transform;
        Index_0: Transform;
        Index_1: Transform;
        Index_2: Transform;
        Index_3: Transform;
        Index_4: Transform;
        Middle_0: Transform;
        Middle_1: Transform;
        Middle_2: Transform;
        Middle_3: Transform;
        Middle_4: Transform;
        Ring_0: Transform;
        Ring_1: Transform;
        Ring_2: Transform;
        Ring_3: Transform;
        Ring_4: Transform;
        Pinky_0: Transform;
        Pinky_1: Transform;
        Pinky_2: Transform;
        Pinky_3: Transform;
        Pinky_4: Transform;
        Aux_Thumb: Transform;
        Aux_Index: Transform;
        Aux_Middle: Transform;
        Aux_Ring: Transform;
        Aux_Pinky: Transform;
    }
    
    enum EHand { VR_LeftHand, VR_RightHand, VR_MAX}
    class SteamVRFingerCurls {
        constructor(Thumb: number, Index: number, Middle: number, Ring: number, Pinky: number);
        Thumb: number;
        Index: number;
        Middle: number;
        Ring: number;
        Pinky: number;
    }
    
    class SteamVRFingerSplays {
        constructor(Thumb_Index: number, Index_Middle: number, Middle_Ring: number, Ring_Pinky: number);
        Thumb_Index: number;
        Index_Middle: number;
        Middle_Ring: number;
        Ring_Pinky: number;
    }
    
    enum ESkeletalSummaryDataType { VR_SummaryType_FromAnimation, VR_SummaryType_FromDevice, VR_SummaryType_MAX}
    enum EControllerFidelity { VR_ControllerFidelity_Estimated, VR_ControllerFidelity_Full, VR_ControllerFidelity_Partial, VR_ControllerFidelity_MAX}
    class SteamVRInputDeviceFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ShowSteamVR_ActionOrigin(SteamVRAction: SteamVRAction, SteamVRActionSet: SteamVRActionSet): void;
        static ShowAllSteamVR_ActionOrigins(): void;
        static SetSteamVR_GlobalPredictedSecondsFromNow(NewValue: number): number;
        static SetPoseSource(bUseSkeletonPose: boolean): void;
        static SetCurlsAndSplaysState(NewLeftHandState: boolean, NewRightHandState: boolean): void;
        static ResetSeatedPosition(): boolean;
        static PlaySteamVR_HapticFeedback(Hand: ESteamVRHand, StartSecondsFromNow: number, DurationSeconds: number, Frequency: number, Amplitude: number): void;
        static GetUserIPD(): number;
        static GetSteamVR_OriginTrackedDeviceInfo(SteamVRAction: SteamVRAction, InputOriginInfo: $Ref<SteamVRInputOriginInfo>): boolean;
        static GetSteamVR_OriginLocalizedName(SteamVRAction: SteamVRAction, LocalizedParts: TArray<ESteamVRInputStringBits>, OriginLocalizedName: $Ref<string>): void;
        static GetSteamVR_InputBindingInfo(SteamVRActionHandle: SteamVRAction): TArray<SteamVRInputBindingInfo>;
        static GetSteamVR_HandPoseRelativeToNow(Position: $Ref<Vector>, Orientation: $Ref<Rotator>, Hand: ESteamVRHand, PredictedSecondsFromNow: number): boolean;
        static GetSteamVR_GlobalPredictedSecondsFromNow(): number;
        static GetSteamVR_ActionSetArray(SteamVRActionSets: $Ref<TArray<SteamVRActionSet>>): void;
        static GetSteamVR_ActionArray(SteamVRActions: $Ref<TArray<SteamVRAction>>): void;
        static GetSkeletalTransform(LeftHand: $Ref<SteamVRSkeletonTransform>, RightHand: $Ref<SteamVRSkeletonTransform>, bWithController: boolean): void;
        static GetSkeletalState(LeftHandState: $Ref<boolean>, RightHandState: $Ref<boolean>): void;
        static GetRightHandPoseData(Position: $Ref<Vector>, Orientation: $Ref<Rotator>, AngularVelocity: $Ref<Vector>, Velocity: $Ref<Vector>): void;
        static GetPoseSource(bUsingSkeletonPose: $Ref<boolean>): void;
        static GetLeftHandPoseData(Position: $Ref<Vector>, Orientation: $Ref<Rotator>, AngularVelocity: $Ref<Vector>, Velocity: $Ref<Vector>): void;
        static GetFingerCurlsAndSplays(Hand: EHand, FingerCurls: $Ref<SteamVRFingerCurls>, FingerSplays: $Ref<SteamVRFingerSplays>, SummaryDataType: ESkeletalSummaryDataType): void;
        static GetCurlsAndSplaysState(LeftHandState: $Ref<boolean>, RightHandState: $Ref<boolean>): void;
        static GetControllerFidelity(LeftControllerFidelity: $Ref<EControllerFidelity>, RightControllerFidelity: $Ref<EControllerFidelity>): void;
        static FindSteamVR_OriginTrackedDeviceInfo(ActionName: string, bResult: $Ref<boolean>, InputOriginInfo: $Ref<SteamVRInputOriginInfo>, ActionSet: string): void;
        static FindSteamVR_InputBindingInfo(ActionName: string, ActionSet: string): TArray<SteamVRInputBindingInfo>;
        static FindSteamVR_ActionOrigin(ActionName: string, ActionSet: string): boolean;
        static FindSteamVR_Action(ActionName: string, bResult: $Ref<boolean>, FoundAction: $Ref<SteamVRAction>, FoundActionSet: $Ref<SteamVRActionSet>, ActionSet: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRInputDeviceFunctionLibrary;
        static Load(InName: string): SteamVRInputDeviceFunctionLibrary;
    }
    
    class SteamVRTrackingReferences extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnTrackedDeviceActivated: $MulticastDelegate<(DeviceID: number, DeviceClass: string, DeviceModel: string) => void>;
        OnTrackedDeviceDeactivated: $MulticastDelegate<(DeviceID: number, DeviceClass: string, DeviceModel: string) => void>;
        ActiveDevicePollFrequency: number;
        TrackingReferenceScale: Vector;
        TrackingReferences: TArray<StaticMeshComponent>;
        ShowTrackingReferences(TrackingReferenceMesh: StaticMesh): boolean;
        HideTrackingReferences(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamVRTrackingReferences;
        static Load(InName: string): SteamVRTrackingReferences;
    }
    
    class ChaosDebugDrawComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosDebugDrawComponent;
        static Load(InName: string): ChaosDebugDrawComponent;
    }
    
    class ChaosEventListenerComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosEventListenerComponent;
        static Load(InName: string): ChaosEventListenerComponent;
    }
    
    class ChaosHandlerSet {
        constructor(ChaosHandlers: TSet<Object>);
        ChaosHandlers: TSet<Object>;
    }
    
    class BreakEventCallbackWrapper {
        constructor();
    }
    
    class ChaosGameplayEventDispatcher extends ChaosEventListenerComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CollisionEventRegistrations: TMap<PrimitiveComponent, ChaosHandlerSet>;
        BreakEventRegistrations: TMap<PrimitiveComponent, BreakEventCallbackWrapper>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosGameplayEventDispatcher;
        static Load(InName: string): ChaosGameplayEventDispatcher;
    }
    
    class ChaosNotifyHandlerInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosNotifyHandlerInterface;
        static Load(InName: string): ChaosNotifyHandlerInterface;
    }
    
    class ChaosPhysicsCollisionInfo {
        constructor(Component: PrimitiveComponent, OtherComponent: PrimitiveComponent, Location: Vector, Normal: Vector, AccumulatedImpulse: Vector, Velocity: Vector, OtherVelocity: Vector, AngularVelocity: Vector, OtherAngularVelocity: Vector, Mass: number, OtherMass: number);
        Component: PrimitiveComponent;
        OtherComponent: PrimitiveComponent;
        Location: Vector;
        Normal: Vector;
        AccumulatedImpulse: Vector;
        Velocity: Vector;
        OtherVelocity: Vector;
        AngularVelocity: Vector;
        OtherAngularVelocity: Vector;
        Mass: number;
        OtherMass: number;
    }
    
    class ChaosSolverEngineBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ConvertPhysicsCollisionToHitResult(PhysicsCollision: ChaosPhysicsCollisionInfo): HitResult;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolverEngineBlueprintLibrary;
        static Load(InName: string): ChaosSolverEngineBlueprintLibrary;
    }
    
    class ChaosSolver extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolver;
        static Load(InName: string): ChaosSolver;
    }
    
    enum EClusterConnectionTypeEnum { Chaos_PointImplicit, Chaos_DelaunayTriangulation, Chaos_MinimalSpanningSubsetDelaunayTriangulation, Chaos_PointImplicitAugmentedWithMinimalDelaunay, Chaos_None, Chaos_EClsuterCreationParameters_Max, Chaos_MAX}
    class SolverCollisionFilterSettings {
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinImpulse: number);
        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinImpulse: number;
    }
    
    class SolverBreakingFilterSettings {
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinVolume: number);
        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinVolume: number;
    }
    
    class SolverTrailingFilterSettings {
        constructor(FilterEnabled: boolean, MinMass: number, MinSpeed: number, MinVolume: number);
        FilterEnabled: boolean;
        MinMass: number;
        MinSpeed: number;
        MinVolume: number;
    }
    
    class ChaosDebugSubstepControl {
        constructor(bPause: boolean, bSubstep: boolean, bStep: boolean);
        bPause: boolean;
        bSubstep: boolean;
        bStep: boolean;
    }
    
    class ChaosSolverActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TimeStepMultiplier: number;
        CollisionIterations: number;
        PushOutIterations: number;
        PushOutPairIterations: number;
        ClusterConnectionFactor: number;
        ClusterUnionConnectionType: EClusterConnectionTypeEnum;
        DoGenerateCollisionData: boolean;
        CollisionFilterSettings: SolverCollisionFilterSettings;
        DoGenerateBreakingData: boolean;
        BreakingFilterSettings: SolverBreakingFilterSettings;
        DoGenerateTrailingData: boolean;
        TrailingFilterSettings: SolverTrailingFilterSettings;
        bHasFloor: boolean;
        FloorHeight: number;
        MassScale: number;
        ChaosDebugSubstepControl: ChaosDebugSubstepControl;
        SpriteComponent: BillboardComponent;
        GameplayEventDispatcherComponent: ChaosGameplayEventDispatcher;
        SetSolverActive(bActive: boolean): void;
        SetAsCurrentWorldSolver(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolverActor;
        static Load(InName: string): ChaosSolverActor;
    }
    
    class ChaosSolverSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultChaosSolverActorClass: SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosSolverSettings;
        static Load(InName: string): ChaosSolverSettings;
    }
    
    class FieldSystem extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystem;
        static Load(InName: string): FieldSystem;
    }
    
    class FieldSystemMetaData extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaData;
        static Load(InName: string): FieldSystemMetaData;
    }
    
    class FieldNodeBase extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeBase;
        static Load(InName: string): FieldNodeBase;
    }
    
    class FieldSystemComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FieldSystem: FieldSystem;
        SupportedSolvers: TArray<TSoftObjectPtr<ChaosSolverActor>>;
        ResetFieldSystem(): void;
        ApplyUniformVectorFalloffForce(Enabled: boolean, Position: Vector, Direction: Vector, Radius: number, Magnitude: number): void;
        ApplyStrainField(Enabled: boolean, Position: Vector, Radius: number, Magnitude: number, Iterations: number): void;
        ApplyStayDynamicField(Enabled: boolean, Position: Vector, Radius: number): void;
        ApplyRadialVectorFalloffForce(Enabled: boolean, Position: Vector, Radius: number, Magnitude: number): void;
        ApplyRadialForce(Enabled: boolean, Position: Vector, Magnitude: number): void;
        ApplyPhysicsField(Enabled: boolean, Target: number, MetaData: FieldSystemMetaData, Field: FieldNodeBase): void;
        ApplyLinearForce(Enabled: boolean, Direction: Vector, Magnitude: number): void;
        AddFieldCommand(Enabled: boolean, Target: number, MetaData: FieldSystemMetaData, Field: FieldNodeBase): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemComponent;
        static Load(InName: string): FieldSystemComponent;
    }
    
    class FieldSystemActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FieldSystemComponent: FieldSystemComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemActor;
        static Load(InName: string): FieldSystemActor;
    }
    
    class FieldSystemMetaDataIteration extends FieldSystemMetaData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Iterations: number;
        SetMetaDataIteration(Iterations: number): FieldSystemMetaDataIteration;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaDataIteration;
        static Load(InName: string): FieldSystemMetaDataIteration;
    }
    
    class FieldSystemMetaDataProcessingResolution extends FieldSystemMetaData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ResolutionType: number;
        SetMetaDataaProcessingResolutionType(ResolutionType: number): FieldSystemMetaDataProcessingResolution;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldSystemMetaDataProcessingResolution;
        static Load(InName: string): FieldSystemMetaDataProcessingResolution;
    }
    
    class FieldNodeInt extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeInt;
        static Load(InName: string): FieldNodeInt;
    }
    
    class FieldNodeFloat extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeFloat;
        static Load(InName: string): FieldNodeFloat;
    }
    
    class FieldNodeVector extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FieldNodeVector;
        static Load(InName: string): FieldNodeVector;
    }
    
    class UniformInteger extends FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        SetUniformInteger(Magnitude: number): UniformInteger;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformInteger;
        static Load(InName: string): UniformInteger;
    }
    
    class RadialIntMask extends FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Radius: number;
        Position: Vector;
        InteriorValue: number;
        ExteriorValue: number;
        SetMaskCondition: number;
        SetRadialIntMask(Radius: number, Position: Vector, InteriorValue: number, ExteriorValue: number, SetMaskConditionIn: number): RadialIntMask;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialIntMask;
        static Load(InName: string): RadialIntMask;
    }
    
    class UniformScalar extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        SetUniformScalar(Magnitude: number): UniformScalar;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformScalar;
        static Load(InName: string): UniformScalar;
    }
    
    class RadialFalloff extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Radius: number;
        Position: Vector;
        Falloff: number;
        SetRadialFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Radius: number, Position: Vector, Falloff: number): RadialFalloff;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialFalloff;
        static Load(InName: string): RadialFalloff;
    }
    
    class PlaneFalloff extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Distance: number;
        Position: Vector;
        Normal: Vector;
        Falloff: number;
        SetPlaneFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Distance: number, Position: Vector, Normal: Vector, Falloff: number): PlaneFalloff;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlaneFalloff;
        static Load(InName: string): PlaneFalloff;
    }
    
    class BoxFalloff extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        MinRange: number;
        MaxRange: number;
        Default: number;
        Transform: Transform;
        Falloff: number;
        SetBoxFalloff(Magnitude: number, MinRange: number, MaxRange: number, Default: number, Transform: Transform, Falloff: number): BoxFalloff;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BoxFalloff;
        static Load(InName: string): BoxFalloff;
    }
    
    class NoiseField extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinRange: number;
        MaxRange: number;
        Transform: Transform;
        SetNoiseField(MinRange: number, MaxRange: number, Transform: Transform): NoiseField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NoiseField;
        static Load(InName: string): NoiseField;
    }
    
    class UniformVector extends FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        Direction: Vector;
        SetUniformVector(Magnitude: number, Direction: Vector): UniformVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UniformVector;
        static Load(InName: string): UniformVector;
    }
    
    class RadialVector extends FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        Position: Vector;
        SetRadialVector(Magnitude: number, Position: Vector): RadialVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RadialVector;
        static Load(InName: string): RadialVector;
    }
    
    class RandomVector extends FieldNodeVector {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        SetRandomVector(Magnitude: number): RandomVector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RandomVector;
        static Load(InName: string): RandomVector;
    }
    
    class OperatorField extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Magnitude: number;
        RightField: FieldNodeBase;
        LeftField: FieldNodeBase;
        Operation: number;
        SetOperatorField(Magnitude: number, RightField: FieldNodeBase, LeftField: FieldNodeBase, Operation: number): OperatorField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OperatorField;
        static Load(InName: string): OperatorField;
    }
    
    class ToIntegerField extends FieldNodeInt {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FloatField: FieldNodeFloat;
        SetToIntegerField(FloatField: FieldNodeFloat): ToIntegerField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToIntegerField;
        static Load(InName: string): ToIntegerField;
    }
    
    class ToFloatField extends FieldNodeFloat {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IntField: FieldNodeInt;
        SetToFloatField(IntegerField: FieldNodeInt): ToFloatField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ToFloatField;
        static Load(InName: string): ToFloatField;
    }
    
    class CullingField extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Culling: FieldNodeBase;
        Field: FieldNodeBase;
        Operation: number;
        SetCullingField(Culling: FieldNodeBase, Field: FieldNodeBase, Operation: number): CullingField;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CullingField;
        static Load(InName: string): CullingField;
    }
    
    class ReturnResultsTerminal extends FieldNodeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetReturnResultsTerminal(): ReturnResultsTerminal;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReturnResultsTerminal;
        static Load(InName: string): ReturnResultsTerminal;
    }
    
    enum ECompilerVersion { Default, VisualStudio2015, VisualStudio2017, VisualStudio2019, ECompilerVersion_MAX}
    enum EDefaultGraphicsRHI { DefaultGraphicsRHI_Default, DefaultGraphicsRHI_DX11, DefaultGraphicsRHI_DX12, DefaultGraphicsRHI_Vulkan, DefaultGraphicsRHI_MAX}
    enum EMinimumSupportedOS { MSOS_Vista, MSOS_MAX}
    class PlatformRuntimeAudioCompressionOverrides {
        constructor(bOverrideCompressionTimes: boolean, DurationThreshold: number, MaxNumRandomBranches: number, SoundCueQualityIndex: number);
        bOverrideCompressionTimes: boolean;
        DurationThreshold: number;
        MaxNumRandomBranches: number;
        SoundCueQualityIndex: number;
    }
    
    class WindowsTargetSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Compiler: ECompilerVersion;
        TargetedRHIs: TArray<string>;
        DefaultGraphicsRHI: EDefaultGraphicsRHI;
        MinimumOSVersion: EMinimumSupportedOS;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: PlatformRuntimeAudioCompressionOverrides;
        ChunkSizeKB: number;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        bResampleForDevice: boolean;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        SoundCueCookQualityIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WindowsTargetSettings;
        static Load(InName: string): WindowsTargetSettings;
    }
    
    class SourceCodeAccessSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreferredAccessor: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SourceCodeAccessSettings;
        static Load(InName: string): SourceCodeAccessSettings;
    }
    
    class LandscapeBlueprintBrush extends LandscapeBlueprintBrushBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeBlueprintBrush;
        static Load(InName: string): LandscapeBlueprintBrush;
    }
    
    enum ETimezoneSetting { InternationalDateLineWest, CoordinatedUniversalTimeNeg11, Samoa, Hawaii, Alaska, PacificTime_USCAN, BajaCalifornia, MountainTime_USCAN, Chihuahua_LaPaz_Mazatlan, Arizona, Saskatchewan, CentralAmerica, CentralTime_USCAN, Guadalajara_MexicoCity_Monterrey, EasternTime_USCAN, Bogota_Lima_Quito, Indiana_US, Caracas, AtlanticTime_Canada, Cuiaba, Santiago, Georgetown_LaPaz_Manaus_SanJuan, Asuncion, Newfoundland, Brasilia, Greenland, Montevideo, Cayenne_Fortaleza, BuenosAires, MidAtlantic, CoordinatedUniversalTimeNeg02, Azores, CaboVerdeIs, Dublin_Edinburgh_Lisbon_London, Monrovia_Reykjavik, Casablanca, UTC, Belgrade_Bratislava_Budapest_Ljubljana_Prague, Sarajevo_Skopje_Warsaw_Zagreb, Brussels_Copenhagen_Madrid_Paris, WestCentralAfrica, Amsterdam_Berlin_Bern_Rome_Stockholm_Vienna, Windhoek, Minsk, Cairo, Helsinki_Kyiv_Riga_Sofia_Tallinn_Vilnius, Athens_Bucharest, Jerusalem, Amman, Beirut, Harare_Pretoria, Damascus, Istanbul, Kuwait_Riyadh, Baghdad, Nairobi, Kaliningrad, Tehran, Moscow_StPetersburg_Volgograd, AbuDhabi_Muscat, Baku, Yerevan, Tbilisi, PortLouis, Kabul, Tashkent, Islamabad_Karachi, Chennai_Kolkata_Mumbai_NewDelhi, SriJayawardenepura, Kathmandu, Ekaterinburg, Astana, Dhaka, Yangon_Rangoon, Novosibirsk, Bangkok_Hanoi_Jakarta, Krasnoyarsk, Beijing_Chongqing_HongKong_Urumqi, KualaLumpur_Singapore, Taipei, Perth, Ulaanbaatar, Irkutsk, Seoul, Osaka_Sapporo_Tokyo, Darwin, Adelaide, Yakutsk, Canberra_Melbourne_Sydney, Brisbane, Hobart, Guam_PortMoresby, Vladivostok, SolomonIs_NewCaledonia, Magadan, Fiji, Auckland_Wellington, CoordinatedUniversalTime12, Nukualofa, LocalTime, ETimezoneSetting_MAX}
    class InternationalizationSettingsModel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisplayTimezone: ETimezoneSetting;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationSettingsModel;
        static Load(InName: string): InternationalizationSettingsModel;
    }
    
    class PropertyConfigFileDisplayRow extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ConfigFileName: string;
        ExternalProperty: Property;
        bIsFileWritable: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyConfigFileDisplayRow;
        static Load(InName: string): PropertyConfigFileDisplayRow;
    }
    
    class ConfigHierarchyPropertyView extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EditProperty: TWeakObjectPtr<Property>;
        ConfigFilePropertyObjects: TArray<PropertyConfigFileDisplayRow>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ConfigHierarchyPropertyView;
        static Load(InName: string): ConfigHierarchyPropertyView;
    }
    
    enum EPinnedCommandListType { Command, CustomWidget, EPinnedCommandListType_MAX}
    class PinnedCommandListCommand {
        constructor(Name: string, Binding: string, Type: EPinnedCommandListType);
        Name: string;
        Binding: string;
        Type: EPinnedCommandListType;
    }
    
    class PinnedCommandListContext {
        constructor(Name: string, Commands: TArray<PinnedCommandListCommand>);
        Name: string;
        Commands: TArray<PinnedCommandListCommand>;
    }
    
    class PinnedCommandListSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Contexts: TArray<PinnedCommandListContext>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PinnedCommandListSettings;
        static Load(InName: string): PinnedCommandListSettings;
    }
    
    class AnimationEditorPreviewActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationEditorPreviewActor;
        static Load(InName: string): AnimationEditorPreviewActor;
    }
    
    class LODInfoUILayout extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LODInfo: SkeletalMeshLODInfo;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LODInfoUILayout;
        static Load(InName: string): LODInfoUILayout;
    }
    
    class PersonaPreviewSceneController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneController;
        static Load(InName: string): PersonaPreviewSceneController;
    }
    
    class PersonaPreviewSceneAnimationController extends PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Animation: TSoftObjectPtr<AnimationAsset>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneAnimationController;
        static Load(InName: string): PersonaPreviewSceneAnimationController;
    }
    
    class PersonaPreviewSceneDefaultController extends PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneDefaultController;
        static Load(InName: string): PersonaPreviewSceneDefaultController;
    }
    
    class PersonaPreviewSceneDescription extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreviewController: Class;
        PreviewControllerInstance: PersonaPreviewSceneController;
        PreviewControllerInstances: TArray<PersonaPreviewSceneController>;
        PreviewMesh: TSoftObjectPtr<SkeletalMesh>;
        PreviewAnimationBlueprint: TSoftObjectPtr<AnimBlueprint>;
        ApplicationMethod: EPreviewAnimationBlueprintApplicationMethod;
        LinkedAnimGraphTag: string;
        AdditionalMeshes: TSoftObjectPtr<DataAsset>;
        DefaultAdditionalMeshes: PreviewMeshCollection;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneDescription;
        static Load(InName: string): PersonaPreviewSceneDescription;
    }
    
    class PersonaPreviewSceneRefPoseController extends PersonaPreviewSceneController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bResetBoneTransforms: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PersonaPreviewSceneRefPoseController;
        static Load(InName: string): PersonaPreviewSceneRefPoseController;
    }
    
    class SkinWeightImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ProfileName: string;
        FilePath: string;
        LODIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkinWeightImportOptions;
        static Load(InName: string): SkinWeightImportOptions;
    }
    
    class Manipulator extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssociatedComponent: SceneComponent;
        StaticMeshComponent: StaticMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Manipulator;
        static Load(InName: string): Manipulator;
    }
    
    enum EShapeAddMode { AppendAfter, AppendBefore, InsertAfter, InsertBefore, EShapeAddMode_MAX}
    class SplineGeneratorBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ShapeAddMode: EShapeAddMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineGeneratorBase;
        static Load(InName: string): SplineGeneratorBase;
    }
    
    class CircleSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Radius: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CircleSplineGenerator;
        static Load(InName: string): CircleSplineGenerator;
    }
    
    class ArcSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Radius: number;
        Degrees: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArcSplineGenerator;
        static Load(InName: string): ArcSplineGenerator;
    }
    
    class SquareSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Length: number;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SquareSplineGenerator;
        static Load(InName: string): SquareSplineGenerator;
    }
    
    class EllipseSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Length: number;
        Width: number;
        bReverseDir: boolean;
        bKeepFirstKeyTangent: boolean;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EllipseSplineGenerator;
        static Load(InName: string): EllipseSplineGenerator;
    }
    
    class RectangleSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Length: number;
        Width: number;
        bBranchRight: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RectangleSplineGenerator;
        static Load(InName: string): RectangleSplineGenerator;
    }
    
    class LineSplineGenerator extends SplineGeneratorBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPoints: number;
        Length: number;
        bEnableUpToNextPoint: boolean;
        bUpToNextPoint: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LineSplineGenerator;
        static Load(InName: string): LineSplineGenerator;
    }
    
    class SplineMetadataDetailsFactoryBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SplineMetadataDetailsFactoryBase;
        static Load(InName: string): SplineMetadataDetailsFactoryBase;
    }
    
    class PropertyViewBase extends Widget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LazyObject: TLazyObjectPtr<Object>;
        SoftObjectPath: SoftObjectPath;
        bAutoLoadAsset: boolean;
        OnPropertyChanged: $MulticastDelegate<(PropertyName: string) => void>;
        SetObject(NewObject: Object): void;
        GetObject(): Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PropertyViewBase;
        static Load(InName: string): PropertyViewBase;
    }
    
    class DetailsView extends PropertyViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAllowFiltering: boolean;
        bAllowFavoriteSystem: boolean;
        bShowModifiedPropertiesOption: boolean;
        bShowKeyablePropertiesOption: boolean;
        bShowAnimatedPropertiesOption: boolean;
        ColumnWidth: number;
        bShowScrollBar: boolean;
        bForceHiddenPropertyVisibility: boolean;
        ViewIdentifier: string;
        CategoriesToShow: TArray<string>;
        PropertiesToShow: TArray<string>;
        bShowOnlyWhitelisted: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DetailsView;
        static Load(InName: string): DetailsView;
    }
    
    class K2Node_CreateDragDropOperation extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CreateDragDropOperation;
        static Load(InName: string): K2Node_CreateDragDropOperation;
    }
    
    class K2Node_CreateWidget extends K2Node_ConstructObjectFromClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_CreateWidget;
        static Load(InName: string): K2Node_CreateWidget;
    }
    
    class K2Node_PlayAnimation extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PlayAnimation;
        static Load(InName: string): K2Node_PlayAnimation;
    }
    
    class K2Node_PlayAnimationTimeRange extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_PlayAnimationTimeRange;
        static Load(InName: string): K2Node_PlayAnimationTimeRange;
    }
    
    class EditorPropertyPathSegment {
        constructor(Struct: Struct, MemberName: string, MemberGuid: Guid, IsProperty: boolean);
        Struct: Struct;
        MemberName: string;
        MemberGuid: Guid;
        IsProperty: boolean;
    }
    
    class EditorPropertyPath {
        constructor(Segments: TArray<EditorPropertyPathSegment>);
        Segments: TArray<EditorPropertyPathSegment>;
    }
    
    class DelegateEditorBinding {
        constructor(ObjectName: string, PropertyName: string, FunctionName: string, SourceProperty: string, SourcePath: EditorPropertyPath, MemberGuid: Guid, Kind: EBindingKind);
        ObjectName: string;
        PropertyName: string;
        FunctionName: string;
        SourceProperty: string;
        SourcePath: EditorPropertyPath;
        MemberGuid: Guid;
        Kind: EBindingKind;
    }
    
    class WidgetAnimation_DEPRECATED {
        constructor(MovieScene: MovieScene, AnimationBindings: TArray<WidgetAnimationBinding>);
        MovieScene: MovieScene;
        AnimationBindings: TArray<WidgetAnimationBinding>;
    }
    
    enum EWidgetSupportsDynamicCreation { Default, Yes, No, EWidgetSupportsDynamicCreation_MAX}
    enum EWidgetCompileTimeTickPrediction { WontTick, OnDemand, WillTick, EWidgetCompileTimeTickPrediction_MAX}
    class WidgetBlueprint extends BaseWidgetBlueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Bindings: TArray<DelegateEditorBinding>;
        AnimationData: TArray<WidgetAnimation_DEPRECATED>;
        Animations: TArray<WidgetAnimation>;
        PaletteCategory: string;
        bForceSlowConstructionPath: boolean;
        SupportDynamicCreation: EWidgetSupportsDynamicCreation;
        InclusiveWidgets: number;
        EstimatedTemplateSize: number;
        TickFrequency: EWidgetTickFrequency;
        TickPrediction: EWidgetCompileTimeTickPrediction;
        TickPredictionReason: string;
        PropertyBindings: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprint;
        static Load(InName: string): WidgetBlueprint;
    }
    
    class K2Node_WidgetAnimationEvent extends K2Node_Event {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Action: EWidgetAnimationEvent;
        AnimationPropertyName: string;
        UserTag: string;
        SourceWidgetBlueprint: WidgetBlueprint;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_WidgetAnimationEvent;
        static Load(InName: string): K2Node_WidgetAnimationEvent;
    }
    
    class SinglePropertyView extends PropertyViewBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PropertyName: string;
        NameOverride: string;
        SetPropertyName(NewPropertyName: string): void;
        GetPropertyName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SinglePropertyView;
        static Load(InName: string): SinglePropertyView;
    }
    
    class SlateVectorArtDataFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SlateVectorArtDataFactory;
        static Load(InName: string): SlateVectorArtDataFactory;
    }
    
    enum EPropertyBindingPermissionLevel { Allow, Prevent, PreventAndWarn, PreventAndError, EPropertyBindingPermissionLevel_MAX}
    class WidgetCompilerOptions {
        constructor(bCookSlowConstructionWidgetTree: boolean, bWidgetSupportsDynamicCreation: boolean, bAllowBlueprintTick: boolean, bAllowBlueprintPaint: boolean, PropertyBindingRule: EPropertyBindingPermissionLevel, Rules: TArray<TSoftObjectPtr<Class>>);
        bCookSlowConstructionWidgetTree: boolean;
        bWidgetSupportsDynamicCreation: boolean;
        bAllowBlueprintTick: boolean;
        bAllowBlueprintPaint: boolean;
        PropertyBindingRule: EPropertyBindingPermissionLevel;
        Rules: TArray<TSoftObjectPtr<Class>>;
    }
    
    class DirectoryWidgetCompilerOptions {
        constructor(Directory: DirectoryPath, IgnoredWidgets: TArray<TSoftObjectPtr<WidgetBlueprint>>, Options: WidgetCompilerOptions);
        Directory: DirectoryPath;
        IgnoredWidgets: TArray<TSoftObjectPtr<WidgetBlueprint>>;
        Options: WidgetCompilerOptions;
    }
    
    class DebugResolution {
        constructor(Width: number, Height: number, Description: string, Color: LinearColor);
        Width: number;
        Height: number;
        Description: string;
        Color: LinearColor;
    }
    
    class UMGEditorProjectSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultCompilerOptions: WidgetCompilerOptions;
        DirectoryCompilerOptions: TArray<DirectoryWidgetCompilerOptions>;
        bShowWidgetsFromEngineContent: boolean;
        bShowWidgetsFromDeveloperContent: boolean;
        CategoriesToHide: TArray<string>;
        WidgetClassesToHide: TArray<SoftClassPath>;
        bUseWidgetTemplateSelector: boolean;
        DefaultRootWidget: Class;
        DebugResolutions: TArray<DebugResolution>;
        Version: number;
        bCookSlowConstructionWidgetTree: boolean;
        bWidgetSupportsDynamicCreation: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UMGEditorProjectSettings;
        static Load(InName: string): UMGEditorProjectSettings;
    }
    
    class WidgetBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintType: number;
        ParentClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetBlueprintFactory;
        static Load(InName: string): WidgetBlueprintFactory;
    }
    
    class WidgetCompilerRule extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetCompilerRule;
        static Load(InName: string): WidgetCompilerRule;
    }
    
    class WidgetPaletteFavorites extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Favorites: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetPaletteFavorites;
        static Load(InName: string): WidgetPaletteFavorites;
    }
    
    class WidgetDesignerSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GridSnapEnabled: boolean;
        GridSnapSize: number;
        bLockToPanelOnDragByDefault: boolean;
        bShowOutlines: boolean;
        bExecutePreConstructEvent: boolean;
        bRespectLocks: boolean;
        Favorites: WidgetPaletteFavorites;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetDesignerSettings;
        static Load(InName: string): WidgetDesignerSettings;
    }
    
    class WidgetGraphSchema extends EdGraphSchema_K2 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetGraphSchema;
        static Load(InName: string): WidgetGraphSchema;
    }
    
    class WidgetSlotPair extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetName: string;
        SlotPropertyNames: TArray<string>;
        SlotPropertyValues: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WidgetSlotPair;
        static Load(InName: string): WidgetSlotPair;
    }
    
    class AdvancedCopyCustomization extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AdvancedCopyCustomization;
        static Load(InName: string): AdvancedCopyCustomization;
    }
    
    class AssetToolsImpl extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetToolsImpl;
        static Load(InName: string): AssetToolsImpl;
    }
    
    class AdvancedCopyMap {
        constructor(ClassToCopy: SoftClassPath, AdvancedCopyCustomization: SoftClassPath);
        ClassToCopy: SoftClassPath;
        AdvancedCopyCustomization: SoftClassPath;
    }
    
    class AssetToolsSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AdvancedCopyCustomizations: TArray<AdvancedCopyMap>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetToolsSettings;
        static Load(InName: string): AssetToolsSettings;
    }
    
    class AssetRenameData {
        constructor(Asset: TWeakObjectPtr<Object>, NewPackagePath: string, NewName: string, OldObjectPath: SoftObjectPath, NewObjectPath: SoftObjectPath, bOnlyFixSoftReferences: boolean);
        Asset: TWeakObjectPtr<Object>;
        NewPackagePath: string;
        NewName: string;
        OldObjectPath: SoftObjectPath;
        NewObjectPath: SoftObjectPath;
        bOnlyFixSoftReferences: boolean;
    }
    
    class AssetTools extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenameReferencingSoftObjectPaths(PackagesToCheck: TArray<Package>, AssetRedirectorMap: TMap<SoftObjectPath, SoftObjectPath>): void;
        RenameAssetsWithDialog(AssetsAndNames: TArray<AssetRenameData>, bAutoCheckout: boolean): void;
        RenameAssets(AssetsAndNames: TArray<AssetRenameData>): boolean;
        OpenEditorForAssets(Assets: TArray<Object>): void;
        ImportAssetTasks(ImportTasks: TArray<AssetImportTask>): void;
        ImportAssetsWithDialog(DestinationPath: string): TArray<Object>;
        ImportAssetsAutomated(ImportData: AutomatedAssetImportData): TArray<Object>;
        FindSoftReferencesToObject(TargetObject: SoftObjectPath, ReferencingObjects: $Ref<TArray<Object>>): void;
        ExportAssetsWithDialog(AssetsToExport: TArray<string>, bPromptForIndividualFilenames: boolean): void;
        ExportAssets(AssetsToExport: TArray<string>, ExportPath: string): void;
        DuplicateAssetWithDialog(AssetName: string, PackagePath: string, OriginalObject: Object): Object;
        DuplicateAsset(AssetName: string, PackagePath: string, OriginalObject: Object): Object;
        CreateUniqueAssetName(InBasePackageName: string, InSuffix: string, OutPackageName: $Ref<string>, OutAssetName: $Ref<string>): void;
        CreateAssetWithDialog(AssetName: string, PackagePath: string, AssetClass: Class, Factory: Factory, CallingContext: string): Object;
        CreateAsset(AssetName: string, PackagePath: string, AssetClass: Class, Factory: Factory, CallingContext: string): Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetTools;
        static Load(InName: string): AssetTools;
    }
    
    class AssetToolsHelpers extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetAssetTools(): AssetTools;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetToolsHelpers;
        static Load(InName: string): AssetToolsHelpers;
    }
    
    class AutomatedTestFilter {
        constructor(Contains: string, MatchFromStart: boolean);
        Contains: string;
        MatchFromStart: boolean;
    }
    
    class AutomatedTestGroup {
        constructor(Name: string, Filters: TArray<AutomatedTestFilter>);
        Name: string;
        Filters: TArray<AutomatedTestFilter>;
    }
    
    class AutomationControllerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Groups: TArray<AutomatedTestGroup>;
        bTreatLogErrorsAsTestErrors: boolean;
        bTreatLogWarningsAsTestErrors: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationControllerSettings;
        static Load(InName: string): AutomationControllerSettings;
    }
    
    class AutomationEditorTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IsValidTask(): boolean;
        IsTaskDone(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationEditorTask;
        static Load(InName: string): AutomationEditorTask;
    }
    
    enum EComparisonTolerance { Zero, Low, Medium, High, Custom, EComparisonTolerance_MAX}
    class AutomationViewSettings extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AntiAliasing: boolean;
        MotionBlur: boolean;
        TemporalAA: boolean;
        ScreenSpaceReflections: boolean;
        ScreenSpaceAO: boolean;
        DistanceFieldAO: boolean;
        ContactShadows: boolean;
        EyeAdaptation: boolean;
        Bloom: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationViewSettings;
        static Load(InName: string): AutomationViewSettings;
    }
    
    class ComparisonToleranceAmount {
        constructor(Red: number, Green: number, Blue: number, Alpha: number, MinBrightness: number, MaxBrightness: number);
        Red: number;
        Green: number;
        Blue: number;
        Alpha: number;
        MinBrightness: number;
        MaxBrightness: number;
    }
    
    class AutomationScreenshotOptions {
        constructor(Resolution: Vector2D, Delay: number, bOverride_OverrideTimeTo: boolean, OverrideTimeTo: number, bDisableNoisyRenderingFeatures: boolean, bDisableTonemapping: boolean, ViewSettings: AutomationViewSettings, VisualizeBuffer: string, Tolerance: EComparisonTolerance, ToleranceAmount: ComparisonToleranceAmount, MaximumLocalError: number, MaximumGlobalError: number, bIgnoreAntiAliasing: boolean, bIgnoreColors: boolean);
        Resolution: Vector2D;
        Delay: number;
        bOverride_OverrideTimeTo: boolean;
        OverrideTimeTo: number;
        bDisableNoisyRenderingFeatures: boolean;
        bDisableTonemapping: boolean;
        ViewSettings: AutomationViewSettings;
        VisualizeBuffer: string;
        Tolerance: EComparisonTolerance;
        ToleranceAmount: ComparisonToleranceAmount;
        MaximumLocalError: number;
        MaximumGlobalError: number;
        bIgnoreAntiAliasing: boolean;
        bIgnoreColors: boolean;
    }
    
    class AutomationBlueprintFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TakeHighResScreenshot(ResX: number, ResY: number, Filename: string, Camera: CameraActor, bMaskEnabled: boolean, bCaptureHDR: boolean, ComparisonTolerance: EComparisonTolerance, ComparisonNotes: string): AutomationEditorTask;
        static TakeAutomationScreenshotOfUI(WorldContextObject: Object, LatentInfo: LatentActionInfo, Name: string, Options: AutomationScreenshotOptions): void;
        static TakeAutomationScreenshotAtCamera(WorldContextObject: Object, LatentInfo: LatentActionInfo, Camera: CameraActor, NameOverride: string, Notes: string, Options: AutomationScreenshotOptions): void;
        static TakeAutomationScreenshot(WorldContextObject: Object, LatentInfo: LatentActionInfo, Name: string, Notes: string, Options: AutomationScreenshotOptions): void;
        static SetScalabilityQualityToLow(WorldContextObject: Object): void;
        static SetScalabilityQualityToEpic(WorldContextObject: Object): void;
        static SetScalabilityQualityLevelRelativeToMax(WorldContextObject: Object, Value: number): void;
        static GetStatIncMax(StatName: string): number;
        static GetStatIncAverage(StatName: string): number;
        static GetStatExcMax(StatName: string): number;
        static GetStatExcAverage(StatName: string): number;
        static GetStatCallCount(StatName: string): number;
        static GetDefaultScreenshotOptionsForRendering(Tolerance: EComparisonTolerance, Delay: number): AutomationScreenshotOptions;
        static GetDefaultScreenshotOptionsForGameplay(Tolerance: EComparisonTolerance, Delay: number): AutomationScreenshotOptions;
        static EnableStatGroup(WorldContextObject: Object, GroupName: string): void;
        static DisableStatGroup(WorldContextObject: Object, GroupName: string): void;
        static AutomationWaitForLoading(WorldContextObject: Object, LatentInfo: LatentActionInfo): void;
        static AreAutomatedTestsRunning(): boolean;
        static AddExpectedLogError(ExpectedPatternString: string, Occurrences: number, ExactMatch: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationBlueprintFunctionLibrary;
        static Load(InName: string): AutomationBlueprintFunctionLibrary;
    }
    
    class FuncTestRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FuncTestRenderingComponent;
        static Load(InName: string): FuncTestRenderingComponent;
    }
    
    enum EFunctionalTestLogHandling { ProjectDefault, OutputIsError, OutputIgnored, EFunctionalTestLogHandling_MAX}
    enum EFunctionalTestResult { Default, Invalid, Error, Running, Failed, Succeeded, EFunctionalTestResult_MAX}
    enum EComparisonMethod { Equal_To, Not_Equal_To, Greater_Than_Or_Equal_To, Less_Than_Or_Equal_To, Greater_Than, Less_Than, EComparisonMethod_MAX}
    class TraceQueryTestNames {
        constructor(ComponentName: string, PhysicalMaterialName: string, ActorName: string);
        ComponentName: string;
        PhysicalMaterialName: string;
        ActorName: string;
    }
    
    class TraceQueryTestResultsInnerMost {
        constructor(SingleHit: HitResult, SingleNames: TraceQueryTestNames, bSingleResult: boolean, MultiHits: TArray<HitResult>, MultiNames: TArray<TraceQueryTestNames>, bMultiResult: boolean);
        SingleHit: HitResult;
        SingleNames: TraceQueryTestNames;
        bSingleResult: boolean;
        MultiHits: TArray<HitResult>;
        MultiNames: TArray<TraceQueryTestNames>;
        bMultiResult: boolean;
    }
    
    class TraceQueryTestResultsInner {
        constructor(LineResults: TraceQueryTestResultsInnerMost, SphereResults: TraceQueryTestResultsInnerMost, CapsuleResults: TraceQueryTestResultsInnerMost, BoxResults: TraceQueryTestResultsInnerMost);
        LineResults: TraceQueryTestResultsInnerMost;
        SphereResults: TraceQueryTestResultsInnerMost;
        CapsuleResults: TraceQueryTestResultsInnerMost;
        BoxResults: TraceQueryTestResultsInnerMost;
    }
    
    class TraceChannelTestBatchOptions {
        constructor(bLineTrace: boolean, bSphereTrace: boolean, bCapsuleTrace: boolean, bBoxTrace: boolean, bChannelTrace: boolean, bObjectsTrace: boolean, bProfileTrace: boolean);
        bLineTrace: boolean;
        bSphereTrace: boolean;
        bCapsuleTrace: boolean;
        bBoxTrace: boolean;
        bChannelTrace: boolean;
        bObjectsTrace: boolean;
        bProfileTrace: boolean;
    }
    
    class TraceQueryTestResults extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChannelResults: TraceQueryTestResultsInner;
        ObjectResults: TraceQueryTestResultsInner;
        ProfileResults: TraceQueryTestResultsInner;
        BatchOptions: TraceChannelTestBatchOptions;
        ToString(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TraceQueryTestResults;
        static Load(InName: string): TraceQueryTestResults;
    }
    
    class FunctionalTest extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteComponent: BillboardComponent;
        bIsEnabled: boolean;
        LogErrorHandling: EFunctionalTestLogHandling;
        LogWarningHandling: EFunctionalTestLogHandling;
        Author: string;
        Description: string;
        ObservationPoint: Actor;
        RandomNumbersStream: RandomStream;
        Result: EFunctionalTestResult;
        PreparationTimeLimit: number;
        TimeLimit: number;
        TimesUpMessage: string;
        TimesUpResult: EFunctionalTestResult;
        OnTestPrepare: $MulticastDelegate<() => void>;
        OnTestStart: $MulticastDelegate<() => void>;
        OnTestFinished: $MulticastDelegate<() => void>;
        AutoDestroyActors: TArray<Actor>;
        RenderComp: FuncTestRenderingComponent;
        TestName: TextRenderComponent;
        bIsRunning: boolean;
        TotalTime: number;
        SetTimeLimit(NewTimeLimit: number, ResultWhenTimeRunsOut: EFunctionalTestResult): void;
        RegisterAutoDestroyActor(ActorToAutoDestroy: Actor): void;
        ReceiveStartTest(): void;
        ReceivePrepareTest(): void;
        OnWantsReRunCheck(): boolean;
        OnAdditionalTestFinishedMessageRequest(TestResult: EFunctionalTestResult): string;
        LogMessage(Message: string): void;
        IsRunning(): boolean;
        IsReady(): boolean;
        IsEnabled(): boolean;
        GetCurrentRerunReason(): string;
        FinishTest(TestResult: EFunctionalTestResult, Message: string): void;
        DebugGatherRelevantActors(): TArray<Actor>;
        AssertValue_Int(Actual: number, ShouldBe: EComparisonMethod, Expected: number, What: string, ContextObject: Object): boolean;
        AssertValue_Float(Actual: number, ShouldBe: EComparisonMethod, Expected: number, What: string, ContextObject: Object): boolean;
        AssertValue_DateTime(Actual: DateTime, ShouldBe: EComparisonMethod, Expected: DateTime, What: string, ContextObject: Object): boolean;
        AssertTrue(Condition: boolean, Message: string, ContextObject: Object): boolean;
        AssertNotEqual_Vector(Actual: Vector, NotExpected: Vector, What: string, ContextObject: Object): boolean;
        AssertNotEqual_Transform(Actual: Transform, NotExpected: Transform, What: string, ContextObject: Object): boolean;
        AssertNotEqual_String(Actual: string, NotExpected: string, What: string, ContextObject: Object): boolean;
        AssertNotEqual_Rotator(Actual: Rotator, NotExpected: Rotator, What: string, ContextObject: Object): boolean;
        AssertIsValid(Object: Object, Message: string, ContextObject: Object): boolean;
        AssertFalse(Condition: boolean, Message: string, ContextObject: Object): boolean;
        AssertEqual_Vector(Actual: Vector, Expected: Vector, What: string, Tolerance: number, ContextObject: Object): boolean;
        AssertEqual_Transform(Actual: Transform, Expected: Transform, What: string, Tolerance: number, ContextObject: Object): boolean;
        AssertEqual_TraceQueryResults(Actual: TraceQueryTestResults, Expected: TraceQueryTestResults, What: string, ContextObject: Object): boolean;
        AssertEqual_String(Actual: string, Expected: string, What: string, ContextObject: Object): boolean;
        AssertEqual_Rotator(Actual: Rotator, Expected: Rotator, What: string, Tolerance: number, ContextObject: Object): boolean;
        AssertEqual_Name(Actual: string, Expected: string, What: string, ContextObject: Object): boolean;
        AssertEqual_Int(Actual: number, Expected: number, What: string, ContextObject: Object): boolean;
        AssertEqual_Float(Actual: number, Expected: number, What: string, Tolerance: number, ContextObject: Object): boolean;
        AssertEqual_Bool(Actual: boolean, Expected: boolean, What: string, ContextObject: Object): boolean;
        AddWarning(Message: string): void;
        AddRerun(Reason: string): void;
        AddError(Message: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTest;
        static Load(InName: string): FunctionalTest;
    }
    
    class GenericTeamId {
        constructor(TeamID: number);
        TeamID: number;
    }
    
    class AITestSpawnInfo {
        constructor(PawnClass: Class, ControllerClass: Class, TeamID: GenericTeamId, BehaviorTree: BehaviorTree, SpawnLocation: Actor, NumberToSpawn: number, SpawnDelay: number, PreSpawnDelay: number);
        PawnClass: Class;
        ControllerClass: Class;
        TeamID: GenericTeamId;
        BehaviorTree: BehaviorTree;
        SpawnLocation: Actor;
        NumberToSpawn: number;
        SpawnDelay: number;
        PreSpawnDelay: number;
    }
    
    class AITestSpawnSet {
        constructor(SpawnInfoContainer: TArray<AITestSpawnInfo>, Name: string, bEnabled: boolean, FallbackSpawnLocation: Actor);
        SpawnInfoContainer: TArray<AITestSpawnInfo>;
        Name: string;
        bEnabled: boolean;
        FallbackSpawnLocation: Actor;
    }
    
    class PendingDelayedSpawn extends AITestSpawnInfo {
        constructor();
    }
    
    class FunctionalAITest extends FunctionalTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnSets: TArray<AITestSpawnSet>;
        SpawnLocationRandomizationRange: number;
        SpawnedPawns: TArray<Pawn>;
        PendingDelayedSpawns: TArray<PendingDelayedSpawn>;
        CurrentSpawnSetIndex: number;
        CurrentSpawnSetName: string;
        OnAISpawned: $MulticastDelegate<(Controller: AIController, Pawn: Pawn) => void>;
        OnAllAISPawned: $MulticastDelegate<() => void>;
        NavMeshDebugOrigin: Vector;
        NavMeshDebugExtent: Vector;
        bWaitForNavMesh: boolean;
        bDebugNavMeshOnTimeout: boolean;
        IsOneOfSpawnedPawns(Actor: Actor): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalAITest;
        static Load(InName: string): FunctionalAITest;
    }
    
    class AutomationPerformaceHelper extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WriteLogFile(CaptureDir: string, CaptureExtension: string): void;
        TriggerGPUTraceIfRecordFallsBelowBudget(): void;
        Tick(DeltaSeconds: number): void;
        StopCPUProfiling(): void;
        StartCPUProfiling(): void;
        Sample(DeltaSeconds: number): void;
        OnBeginTests(): void;
        OnAllTestsComplete(): void;
        IsRecording(): boolean;
        IsCurrentRecordWithinRenderThreadBudget(): boolean;
        IsCurrentRecordWithinGPUBudget(): boolean;
        IsCurrentRecordWithinGameThreadBudget(): boolean;
        EndStatsFile(): void;
        EndRecordingBaseline(): void;
        EndRecording(): void;
        BeginStatsFile(RecordName: string): void;
        BeginRecordingBaseline(RecordName: string): void;
        BeginRecording(RecordName: string, InGPUBudget: number, InRenderThreadBudget: number, InGameThreadBudget: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationPerformaceHelper;
        static Load(InName: string): AutomationPerformaceHelper;
    }
    
    class FunctionalTestGameMode extends GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestGameMode;
        static Load(InName: string): FunctionalTestGameMode;
    }
    
    class FunctionalTestingManager extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TestsLeft: TArray<FunctionalTest>;
        AllTests: TArray<FunctionalTest>;
        OnSetupTests: $MulticastDelegate<() => void>;
        OnTestsComplete: $MulticastDelegate<() => void>;
        OnTestsBegin: $MulticastDelegate<() => void>;
        static RunAllFunctionalTests(WorldContextObject: Object, bNewLog: boolean, bRunLooped: boolean, FailedTestsReproString: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestingManager;
        static Load(InName: string): FunctionalTestingManager;
    }
    
    class PhasedAutomationActorBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnFunctionalTestingComplete(): void;
        OnFunctionalTestingBegin(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PhasedAutomationActorBase;
        static Load(InName: string): PhasedAutomationActorBase;
    }
    
    class FunctionalTestLevelScript extends LevelScriptActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestLevelScript;
        static Load(InName: string): FunctionalTestLevelScript;
    }
    
    class FunctionalTestUtilityLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TraceChannelTestUtil(WorldContextObject: Object, BatchOptions: TraceChannelTestBatchOptions, Start: Vector, End: Vector, SphereCapsuleRadius: number, CapsuleHalfHeight: number, BoxHalfSize: Vector, Orientation: Rotator, TraceChannel: number, ObjectTypes: TArray<number>, ProfileName: string, bTraceComplex: boolean, ActorsToIgnore: TArray<Actor>, bIgnoreSelf: boolean, DrawDebugType: number, TraceColor: LinearColor, TraceHitColor: LinearColor, DrawTime: number): TraceQueryTestResults;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalTestUtilityLibrary;
        static Load(InName: string): FunctionalTestUtilityLibrary;
    }
    
    class ScreenshotFunctionalTestBase extends FunctionalTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Notes: string;
        ScreenshotCamera: CameraComponent;
        ScreenshotOptions: AutomationScreenshotOptions;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScreenshotFunctionalTestBase;
        static Load(InName: string): ScreenshotFunctionalTestBase;
    }
    
    enum EWidgetTestAppearLocation { Viewport, PlayerScreen, EWidgetTestAppearLocation_MAX}
    class FunctionalUIScreenshotTest extends ScreenshotFunctionalTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WidgetClass: Class;
        SpawnedWidget: UserWidget;
        WidgetLocation: EWidgetTestAppearLocation;
        ScreenshotRT: TextureRenderTarget2D;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FunctionalUIScreenshotTest;
        static Load(InName: string): FunctionalUIScreenshotTest;
    }
    
    class GroundTruthData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bResetGroundTruth: boolean;
        ObjectData: Object;
        SaveObject(GroundTruth: Object): void;
        LoadObject(): Object;
        CanModify(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GroundTruthData;
        static Load(InName: string): GroundTruthData;
    }
    
    class ScreenshotFunctionalTest extends ScreenshotFunctionalTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCameraCutOnScreenshotPrep: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScreenshotFunctionalTest;
        static Load(InName: string): ScreenshotFunctionalTest;
    }
    
    class TestPhaseComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestPhaseComponent;
        static Load(InName: string): TestPhaseComponent;
    }
    
    class AIGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GraphVersion: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIGraph;
        static Load(InName: string): AIGraph;
    }
    
    class GraphNodeClassData {
        constructor(AssetName: string, GeneratedClassPackage: string, ClassName: string, Category: string);
        AssetName: string;
        GeneratedClassPackage: string;
        ClassName: string;
        Category: string;
    }
    
    class AIGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClassData: GraphNodeClassData;
        NodeInstance: Object;
        ParentNode: AIGraphNode;
        SubNodes: TArray<AIGraphNode>;
        CopySubNodeIndex: number;
        bIsReadOnly: boolean;
        bIsSubNode: boolean;
        ErrorMessage: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIGraphNode;
        static Load(InName: string): AIGraphNode;
    }
    
    class AIGraphSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AIGraphSchema;
        static Load(InName: string): AIGraphSchema;
    }
    
    class K2Node_AIMoveTo extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_AIMoveTo;
        static Load(InName: string): K2Node_AIMoveTo;
    }
    
    class BehaviorTreeDecoratorGraph extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraph;
        static Load(InName: string): BehaviorTreeDecoratorGraph;
    }
    
    class BehaviorTreeDecoratorGraphNode extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode;
        static Load(InName: string): BehaviorTreeDecoratorGraphNode;
    }
    
    class BehaviorTreeDecoratorGraphNode_Decorator extends BehaviorTreeDecoratorGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NodeInstance: Object;
        ClassData: GraphNodeClassData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode_Decorator;
        static Load(InName: string): BehaviorTreeDecoratorGraphNode_Decorator;
    }
    
    class BehaviorTreeDecoratorGraphNode_Logic extends BehaviorTreeDecoratorGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogicMode: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeDecoratorGraphNode_Logic;
        static Load(InName: string): BehaviorTreeDecoratorGraphNode_Logic;
    }
    
    class BehaviorTreeEditorTypes extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeEditorTypes;
        static Load(InName: string): BehaviorTreeEditorTypes;
    }
    
    class BehaviorTreeFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeFactory;
        static Load(InName: string): BehaviorTreeFactory;
    }
    
    class BehaviorTreeGraph extends AIGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ModCounter: number;
        bIsUsingModCounter: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraph;
        static Load(InName: string): BehaviorTreeGraph;
    }
    
    class BehaviorTreeGraphNode extends AIGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Decorators: TArray<BehaviorTreeGraphNode>;
        Services: TArray<BehaviorTreeGraphNode>;
        bInjectedNode: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode;
        static Load(InName: string): BehaviorTreeGraphNode;
    }
    
    class BehaviorTreeGraphNode_Composite extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Composite;
        static Load(InName: string): BehaviorTreeGraphNode_Composite;
    }
    
    class BehaviorTreeGraphNode_CompositeDecorator extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundGraph: EdGraph;
        CompositeName: string;
        bShowOperations: boolean;
        bCanAbortFlow: boolean;
        ParentNodeInstance: BTCompositeNode;
        CachedDescription: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_CompositeDecorator;
        static Load(InName: string): BehaviorTreeGraphNode_CompositeDecorator;
    }
    
    class BehaviorTreeGraphNode_Decorator extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Decorator;
        static Load(InName: string): BehaviorTreeGraphNode_Decorator;
    }
    
    class BehaviorTreeGraphNode_Root extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlackboardAsset: BlackboardData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Root;
        static Load(InName: string): BehaviorTreeGraphNode_Root;
    }
    
    class BehaviorTreeGraphNode_Service extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Service;
        static Load(InName: string): BehaviorTreeGraphNode_Service;
    }
    
    class BehaviorTreeGraphNode_SimpleParallel extends BehaviorTreeGraphNode_Composite {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_SimpleParallel;
        static Load(InName: string): BehaviorTreeGraphNode_SimpleParallel;
    }
    
    class BehaviorTreeGraphNode_Task extends BehaviorTreeGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_Task;
        static Load(InName: string): BehaviorTreeGraphNode_Task;
    }
    
    class BehaviorTreeGraphNode_SubtreeTask extends BehaviorTreeGraphNode_Task {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BehaviorTreeGraphNode_SubtreeTask;
        static Load(InName: string): BehaviorTreeGraphNode_SubtreeTask;
    }
    
    class BlackboardDataFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BlackboardDataFactory;
        static Load(InName: string): BlackboardDataFactory;
    }
    
    class EdGraphSchema_BehaviorTree extends AIGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_BehaviorTree;
        static Load(InName: string): EdGraphSchema_BehaviorTree;
    }
    
    class EdGraphSchema_BehaviorTreeDecorator extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PC_Boolean: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphSchema_BehaviorTreeDecorator;
        static Load(InName: string): EdGraphSchema_BehaviorTreeDecorator;
    }
    
    class K2Node_LatentGameplayTaskCall extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpawnParamPins: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_LatentGameplayTaskCall;
        static Load(InName: string): K2Node_LatentGameplayTaskCall;
    }
    
    class Overlays extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): Overlays;
        static Load(InName: string): Overlays;
    }
    
    class OverlayItem {
        constructor(StartTime: Timespan, EndTime: Timespan, Text: string, Position: Vector2D);
        StartTime: Timespan;
        EndTime: Timespan;
        Text: string;
        Position: Vector2D;
    }
    
    class BasicOverlays extends Overlays {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Overlays: TArray<OverlayItem>;
        AssetImportData: AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BasicOverlays;
        static Load(InName: string): BasicOverlays;
    }
    
    class LocalizedOverlays extends Overlays {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultOverlays: BasicOverlays;
        LocaleToOverlaysMap: TMap<string, BasicOverlays>;
        AssetImportData: AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizedOverlays;
        static Load(InName: string): LocalizedOverlays;
    }
    
    class BasicOverlaysFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BasicOverlaysFactory;
        static Load(InName: string): BasicOverlaysFactory;
    }
    
    class BasicOverlaysFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BasicOverlaysFactoryNew;
        static Load(InName: string): BasicOverlaysFactoryNew;
    }
    
    class LocalizedOverlaysFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizedOverlaysFactoryNew;
        static Load(InName: string): LocalizedOverlaysFactoryNew;
    }
    
    class ReimportBasicOverlaysFactory extends BasicOverlaysFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportBasicOverlaysFactory;
        static Load(InName: string): ReimportBasicOverlaysFactory;
    }
    
    class MediaSource extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Validate(): boolean;
        SetMediaOptionString(Key: string, Value: string): void;
        SetMediaOptionInt64(Key: string, Value: bigint): void;
        SetMediaOptionFloat(Key: string, Value: number): void;
        SetMediaOptionBool(Key: string, Value: boolean): void;
        GetUrl(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaSource;
        static Load(InName: string): MediaSource;
    }
    
    class BaseMediaSource extends MediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlatformPlayerNames: TMap<string, string>;
        PlayerName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BaseMediaSource;
        static Load(InName: string): BaseMediaSource;
    }
    
    class FileMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FilePath: string;
        PrecacheFile: boolean;
        SetFilePath(Path: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileMediaSource;
        static Load(InName: string): FileMediaSource;
    }
    
    class MediaCaptureDevice {
        constructor(DisplayName: string, Url: string);
        DisplayName: string;
        Url: string;
    }
    
    class MediaBlueprintFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static EnumerateWebcamCaptureDevices(OutDevices: $Ref<TArray<MediaCaptureDevice>>, Filter: number): void;
        static EnumerateVideoCaptureDevices(OutDevices: $Ref<TArray<MediaCaptureDevice>>, Filter: number): void;
        static EnumerateAudioCaptureDevices(OutDevices: $Ref<TArray<MediaCaptureDevice>>, Filter: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaBlueprintFunctionLibrary;
        static Load(InName: string): MediaBlueprintFunctionLibrary;
    }
    
    class MediaPlaylist extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Items: TArray<MediaSource>;
        Replace(Index: number, Replacement: MediaSource): boolean;
        RemoveAt(Index: number): boolean;
        Remove(MediaSource: MediaSource): boolean;
        Num(): number;
        Insert(MediaSource: MediaSource, Index: number): void;
        GetRandom(OutIndex: $Ref<number>): MediaSource;
        GetPrevious(InOutIndex: $Ref<number>): MediaSource;
        GetNext(InOutIndex: $Ref<number>): MediaSource;
        Get(Index: number): MediaSource;
        AddUrl(Url: string): boolean;
        AddFile(FilePath: string): boolean;
        Add(MediaSource: MediaSource): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlaylist;
        static Load(InName: string): MediaPlaylist;
    }
    
    enum EMediaPlayerTrack { Audio, Caption, Metadata, Script, Subtitle, Text, Video, EMediaPlayerTrack_MAX}
    class MediaPlayerTrackOptions {
        constructor(Audio: number, Caption: number, Metadata: number, Script: number, Subtitle: number, Text: number, Video: number);
        Audio: number;
        Caption: number;
        Metadata: number;
        Script: number;
        Subtitle: number;
        Text: number;
        Video: number;
    }
    
    enum EMediaPlayerOptionBooleanOverride { UseMediaPlayerSetting, Enabled, Disabled, EMediaPlayerOptionBooleanOverride_MAX}
    class MediaPlayerOptions {
        constructor(Tracks: MediaPlayerTrackOptions, SeekTime: Timespan, PlayOnOpen: EMediaPlayerOptionBooleanOverride, Loop: EMediaPlayerOptionBooleanOverride);
        Tracks: MediaPlayerTrackOptions;
        SeekTime: Timespan;
        PlayOnOpen: EMediaPlayerOptionBooleanOverride;
        Loop: EMediaPlayerOptionBooleanOverride;
    }
    
    class MediaPlayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnEndReached: $MulticastDelegate<() => void>;
        OnMediaClosed: $MulticastDelegate<() => void>;
        OnMediaOpened: $MulticastDelegate<(OpenedUrl: string) => void>;
        OnMediaOpenFailed: $MulticastDelegate<(FailedUrl: string) => void>;
        OnPlaybackResumed: $MulticastDelegate<() => void>;
        OnPlaybackSuspended: $MulticastDelegate<() => void>;
        OnSeekCompleted: $MulticastDelegate<() => void>;
        OnTracksChanged: $MulticastDelegate<() => void>;
        CacheAhead: Timespan;
        CacheBehind: Timespan;
        CacheBehindGame: Timespan;
        NativeAudioOut: boolean;
        PlayOnOpen: boolean;
        Shuffle: boolean;
        Loop: boolean;
        Playlist: MediaPlaylist;
        PlaylistIndex: number;
        TimeDelay: Timespan;
        HorizontalFieldOfView: number;
        VerticalFieldOfView: number;
        ViewRotation: Rotator;
        PlayerGuid: Guid;
        AffectedByPIEHandling: boolean;
        SupportsSeeking(): boolean;
        SupportsScrubbing(): boolean;
        SupportsRate(Rate: number, Unthinned: boolean): boolean;
        SetViewRotation(Rotation: Rotator, Absolute: boolean): boolean;
        SetViewField(Horizontal: number, Vertical: number, Absolute: boolean): boolean;
        SetVideoTrackFrameRate(TrackIndex: number, FormatIndex: number, FrameRate: number): boolean;
        SetTrackFormat(TrackType: EMediaPlayerTrack, TrackIndex: number, FormatIndex: number): boolean;
        SetTimeDelay(TimeDelay: Timespan): void;
        SetRate(Rate: number): boolean;
        SetNativeVolume(Volume: number): boolean;
        SetMediaOptions(Options: MediaSource): void;
        SetLooping(Looping: boolean): boolean;
        SetDesiredPlayerName(PlayerName: string): void;
        SetBlockOnTime(Time: Timespan): void;
        SelectTrack(TrackType: EMediaPlayerTrack, TrackIndex: number): boolean;
        Seek(Time: Timespan): boolean;
        Rewind(): boolean;
        Reopen(): boolean;
        Previous(): boolean;
        Play(): boolean;
        Pause(): boolean;
        OpenUrl(Url: string): boolean;
        OpenSourceWithOptions(MediaSource: MediaSource, Options: MediaPlayerOptions): boolean;
        OpenSourceLatent(WorldContextObject: Object, LatentInfo: LatentActionInfo, MediaSource: MediaSource, Options: MediaPlayerOptions, bSuccess: $Ref<boolean>): void;
        OpenSource(MediaSource: MediaSource): boolean;
        OpenPlaylistIndex(InPlaylist: MediaPlaylist, Index: number): boolean;
        OpenPlaylist(InPlaylist: MediaPlaylist): boolean;
        OpenFile(FilePath: string): boolean;
        Next(): boolean;
        IsReady(): boolean;
        IsPreparing(): boolean;
        IsPlaying(): boolean;
        IsPaused(): boolean;
        IsLooping(): boolean;
        IsConnecting(): boolean;
        IsClosed(): boolean;
        IsBuffering(): boolean;
        HasError(): boolean;
        GetViewRotation(): Rotator;
        GetVideoTrackType(TrackIndex: number, FormatIndex: number): string;
        GetVideoTrackFrameRates(TrackIndex: number, FormatIndex: number): FloatRange;
        GetVideoTrackFrameRate(TrackIndex: number, FormatIndex: number): number;
        GetVideoTrackDimensions(TrackIndex: number, FormatIndex: number): IntPoint;
        GetVideoTrackAspectRatio(TrackIndex: number, FormatIndex: number): number;
        GetVerticalFieldOfView(): number;
        GetUrl(): string;
        GetTrackLanguage(TrackType: EMediaPlayerTrack, TrackIndex: number): string;
        GetTrackFormat(TrackType: EMediaPlayerTrack, TrackIndex: number): number;
        GetTrackDisplayName(TrackType: EMediaPlayerTrack, TrackIndex: number): string;
        GetTimeDelay(): Timespan;
        GetTime(): Timespan;
        GetSupportedRates(OutRates: $Ref<TArray<FloatRange>>, Unthinned: boolean): void;
        GetSelectedTrack(TrackType: EMediaPlayerTrack): number;
        GetRate(): number;
        GetPlaylistIndex(): number;
        GetPlaylist(): MediaPlaylist;
        GetPlayerName(): string;
        GetNumTracks(TrackType: EMediaPlayerTrack): number;
        GetNumTrackFormats(TrackType: EMediaPlayerTrack, TrackIndex: number): number;
        GetMediaName(): string;
        GetLastVideoSampleProcessedTime(): Timespan;
        GetLastAudioSampleProcessedTime(): Timespan;
        GetHorizontalFieldOfView(): number;
        GetDuration(): Timespan;
        GetDesiredPlayerName(): string;
        GetAudioTrackType(TrackIndex: number, FormatIndex: number): string;
        GetAudioTrackSampleRate(TrackIndex: number, FormatIndex: number): number;
        GetAudioTrackChannels(TrackIndex: number, FormatIndex: number): number;
        Close(): void;
        CanPlayUrl(Url: string): boolean;
        CanPlaySource(MediaSource: MediaSource): boolean;
        CanPause(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayer;
        static Load(InName: string): MediaPlayer;
    }
    
    enum EMediaSoundChannels { Mono, Stereo, Surround, EMediaSoundChannels_MAX}
    enum EMediaSoundComponentFFTSize { Min_64, Small_256, Medium_512, Large_1024, EMediaSoundComponentFFTSize_MAX}
    class MediaSoundComponentSpectralData {
        constructor(FrequencyHz: number, Magnitude: number);
        FrequencyHz: number;
        Magnitude: number;
    }
    
    class MediaSoundComponent extends SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Channels: EMediaSoundChannels;
        DynamicRateAdjustment: boolean;
        RateAdjustmentFactor: number;
        RateAdjustmentRange: FloatRange;
        MediaPlayer: MediaPlayer;
        SetSpectralAnalysisSettings(InFrequenciesToAnalyze: TArray<number>, InFFTSize: EMediaSoundComponentFFTSize): void;
        SetMediaPlayer(NewMediaPlayer: MediaPlayer): void;
        SetEnvelopeFollowingsettings(AttackTimeMsec: number, ReleaseTimeMsec: number): void;
        SetEnableSpectralAnalysis(bInSpectralAnalysisEnabled: boolean): void;
        SetEnableEnvelopeFollowing(bInEnvelopeFollowing: boolean): void;
        GetSpectralData(): TArray<MediaSoundComponentSpectralData>;
        GetMediaPlayer(): MediaPlayer;
        GetEnvelopeValue(): number;
        BP_GetAttenuationSettingsToApply(OutAttenuationSettings: $Ref<SoundAttenuationSettings>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaSoundComponent;
        static Load(InName: string): MediaSoundComponent;
    }
    
    class MediaTexture extends Texture {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AddressX: number;
        AddressY: number;
        AutoClear: boolean;
        ClearColor: LinearColor;
        MediaPlayer: MediaPlayer;
        SetMediaPlayer(NewMediaPlayer: MediaPlayer): void;
        GetWidth(): number;
        GetMediaPlayer(): MediaPlayer;
        GetHeight(): number;
        GetAspectRatio(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaTexture;
        static Load(InName: string): MediaTexture;
    }
    
    class PlatformMediaSource extends MediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlatformMediaSources: TMap<string, MediaSource>;
        MediaSource: MediaSource;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformMediaSource;
        static Load(InName: string): PlatformMediaSource;
    }
    
    class StreamMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StreamUrl: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamMediaSource;
        static Load(InName: string): StreamMediaSource;
    }
    
    class TimeSynchronizableMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bUseTimeSynchronization: boolean;
        FrameDelay: number;
        TimeDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TimeSynchronizableMediaSource;
        static Load(InName: string): TimeSynchronizableMediaSource;
    }
    
    class MaterialExpressionSpriteTextureSampler extends MaterialExpressionTextureSampleParameter2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSampleAdditionalTextures: boolean;
        AdditionalSlotIndex: number;
        SlotDisplayName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MaterialExpressionSpriteTextureSampler;
        static Load(InName: string): MaterialExpressionSpriteTextureSampler;
    }
    
    class PaperSpriteSocket {
        constructor(LocalTransform: Transform, SocketName: string);
        LocalTransform: Transform;
        SocketName: string;
    }
    
    enum ESpriteShapeType { Box, Circle, Polygon, ESpriteShapeType_MAX}
    class SpriteGeometryShape {
        constructor(ShapeType: ESpriteShapeType, Vertices: TArray<Vector2D>, BoxSize: Vector2D, BoxPosition: Vector2D, Rotation: number, bNegativeWinding: boolean);
        ShapeType: ESpriteShapeType;
        Vertices: TArray<Vector2D>;
        BoxSize: Vector2D;
        BoxPosition: Vector2D;
        Rotation: number;
        bNegativeWinding: boolean;
    }
    
    class SpriteGeometryCollection {
        constructor(Shapes: TArray<SpriteGeometryShape>, GeometryType: number, PixelsPerSubdivisionX: number, PixelsPerSubdivisionY: number, bAvoidVertexMerging: boolean, AlphaThreshold: number, DetailAmount: number, SimplifyEpsilon: number);
        Shapes: TArray<SpriteGeometryShape>;
        GeometryType: number;
        PixelsPerSubdivisionX: number;
        PixelsPerSubdivisionY: number;
        bAvoidVertexMerging: boolean;
        AlphaThreshold: number;
        DetailAmount: number;
        SimplifyEpsilon: number;
    }
    
    enum EPaperSpriteAtlasPadding { DilateBorder, PadWithZero, EPaperSpriteAtlasPadding_MAX}
    class PaperSpriteAtlasSlot {
        constructor(SpriteRef: TSoftObjectPtr<PaperSprite>, AtlasIndex: number, X: number, Y: number, Width: number, Height: number);
        SpriteRef: TSoftObjectPtr<PaperSprite>;
        AtlasIndex: number;
        X: number;
        Y: number;
        Width: number;
        Height: number;
    }
    
    class PaperSpriteAtlas extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AtlasDescription: string;
        MaxWidth: number;
        MaxHeight: number;
        MipCount: number;
        PaddingType: EPaperSpriteAtlasPadding;
        Padding: number;
        CompressionSettings: number;
        Filter: number;
        GeneratedTextures: TArray<Texture>;
        AtlasGUID: Guid;
        bRebuildAtlas: boolean;
        AtlasSlots: TArray<PaperSpriteAtlasSlot>;
        NumIncrementalBuilds: number;
        BuiltWidth: number;
        BuiltHeight: number;
        BuiltPadding: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteAtlas;
        static Load(InName: string): PaperSpriteAtlas;
    }
    
    class PaperSprite extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OriginInSourceImageBeforeTrimming: Vector2D;
        SourceImageDimensionBeforeTrimming: Vector2D;
        bTrimmedInSourceImage: boolean;
        bRotatedInSourceImage: boolean;
        SourceTextureDimension: Vector2D;
        SourceUV: Vector2D;
        SourceDimension: Vector2D;
        SourceTexture: TSoftObjectPtr<Texture2D>;
        SourceTextureCacheNeverSerialized: Texture2D;
        AdditionalSourceTextures: TArray<Texture>;
        BakedSourceUV: Vector2D;
        BakedSourceDimension: Vector2D;
        BakedSourceTexture: Texture2D;
        DefaultMaterial: MaterialInterface;
        AlternateMaterial: MaterialInterface;
        Sockets: TArray<PaperSpriteSocket>;
        SpriteCollisionDomain: number;
        PixelsPerUnrealUnit: number;
        BodySetup: BodySetup;
        PivotMode: number;
        CustomPivotPoint: Vector2D;
        bSnapPivotToPixelGrid: boolean;
        CollisionGeometry: SpriteGeometryCollection;
        CollisionThickness: number;
        RenderGeometry: SpriteGeometryCollection;
        AtlasGroup: PaperSpriteAtlas;
        AlternateMaterialSplitIndex: number;
        BakedRenderData: TArray<Vector4>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSprite;
        static Load(InName: string): PaperSprite;
    }
    
    class PaperFlipbookKeyFrame {
        constructor(Sprite: PaperSprite, FrameRun: number);
        Sprite: PaperSprite;
        FrameRun: number;
    }
    
    class PaperFlipbook extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FramesPerSecond: number;
        KeyFrames: TArray<PaperFlipbookKeyFrame>;
        DefaultMaterial: MaterialInterface;
        CollisionSource: number;
        IsValidKeyFrameIndex(Index: number): boolean;
        GetTotalDuration(): number;
        GetSpriteAtTime(Time: number, bClampToEnds: boolean): PaperSprite;
        GetSpriteAtFrame(FrameIndex: number): PaperSprite;
        GetNumKeyFrames(): number;
        GetNumFrames(): number;
        GetKeyFrameIndexAtTime(Time: number, bClampToEnds: boolean): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbook;
        static Load(InName: string): PaperFlipbook;
    }
    
    class PaperFlipbookComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceFlipbook: PaperFlipbook;
        Material: MaterialInterface;
        PlayRate: number;
        bLooping: boolean;
        bReversePlayback: boolean;
        bPlaying: boolean;
        AccumulatedTime: number;
        CachedFrameIndex: number;
        SpriteColor: LinearColor;
        CachedBodySetup: BodySetup;
        OnFinishedPlaying: $MulticastDelegate<() => void>;
        Stop(): void;
        SetSpriteColor(NewColor: LinearColor): void;
        SetPlayRate(NewRate: number): void;
        SetPlaybackPositionInFrames(NewFramePosition: number, bFireEvents: boolean): void;
        SetPlaybackPosition(NewPosition: number, bFireEvents: boolean): void;
        SetNewTime(NewTime: number): void;
        SetLooping(bNewLooping: boolean): void;
        SetFlipbook(NewFlipbook: PaperFlipbook): boolean;
        ReverseFromEnd(): void;
        Reverse(): void;
        PlayFromStart(): void;
        Play(): void;
        OnRep_SourceFlipbook(OldFlipbook: PaperFlipbook): void;
        IsReversing(): boolean;
        IsPlaying(): boolean;
        IsLooping(): boolean;
        GetPlayRate(): number;
        GetPlaybackPositionInFrames(): number;
        GetPlaybackPosition(): number;
        GetFlipbookLengthInFrames(): number;
        GetFlipbookLength(): number;
        GetFlipbookFramerate(): number;
        GetFlipbook(): PaperFlipbook;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookComponent;
        static Load(InName: string): PaperFlipbookComponent;
    }
    
    class PaperCharacter extends Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Sprite: PaperFlipbookComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperCharacter;
        static Load(InName: string): PaperCharacter;
    }
    
    class PaperFlipbookActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: PaperFlipbookComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookActor;
        static Load(InName: string): PaperFlipbookActor;
    }
    
    class SpriteInstanceData {
        constructor(Transform: Matrix, SourceSprite: PaperSprite, VertexColor: Color, MaterialIndex: number);
        Transform: Matrix;
        SourceSprite: PaperSprite;
        VertexColor: Color;
        MaterialIndex: number;
    }
    
    class PaperGroupedSpriteComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InstanceMaterials: TArray<MaterialInterface>;
        PerInstanceSpriteData: TArray<SpriteInstanceData>;
        UpdateInstanceTransform(InstanceIndex: number, NewInstanceTransform: Transform, bWorldSpace: boolean, bMarkRenderStateDirty: boolean, bTeleport: boolean): boolean;
        UpdateInstanceColor(InstanceIndex: number, NewInstanceColor: LinearColor, bMarkRenderStateDirty: boolean): boolean;
        SortInstancesAlongAxis(WorldSpaceSortAxis: Vector): void;
        RemoveInstance(InstanceIndex: number): boolean;
        GetInstanceTransform(InstanceIndex: number, OutInstanceTransform: $Ref<Transform>, bWorldSpace: boolean): boolean;
        GetInstanceCount(): number;
        ClearInstances(): void;
        AddInstance(Transform: Transform, Sprite: PaperSprite, bWorldSpace: boolean, Color: LinearColor): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperGroupedSpriteComponent;
        static Load(InName: string): PaperGroupedSpriteComponent;
    }
    
    class PaperGroupedSpriteActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: PaperGroupedSpriteComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperGroupedSpriteActor;
        static Load(InName: string): PaperGroupedSpriteActor;
    }
    
    class PaperRuntimeSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableSpriteAtlasGroups: boolean;
        bEnableTerrainSplineEditing: boolean;
        bResizeSpriteDataToMatchTextures: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperRuntimeSettings;
        static Load(InName: string): PaperRuntimeSettings;
    }
    
    class PaperSpriteComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceSprite: PaperSprite;
        MaterialOverride: MaterialInterface;
        SpriteColor: LinearColor;
        SetSpriteColor(NewColor: LinearColor): void;
        SetSprite(NewSprite: PaperSprite): boolean;
        GetSprite(): PaperSprite;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteComponent;
        static Load(InName: string): PaperSpriteComponent;
    }
    
    class PaperSpriteActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: PaperSpriteComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteActor;
        static Load(InName: string): PaperSpriteActor;
    }
    
    class PaperSpriteBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeBrushFromSprite(Sprite: PaperSprite, Width: number, Height: number): SlateBrush;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteBlueprintLibrary;
        static Load(InName: string): PaperSpriteBlueprintLibrary;
    }
    
    class PaperTerrainSplineComponent extends SplineComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainSplineComponent;
        static Load(InName: string): PaperTerrainSplineComponent;
    }
    
    class PaperTerrainMaterialRule {
        constructor(StartCap: PaperSprite, Body: TArray<PaperSprite>, EndCap: PaperSprite, MinimumAngle: number, MaximumAngle: number, bEnableCollision: boolean, CollisionOffset: number, DrawOrder: number, Description: string);
        StartCap: PaperSprite;
        Body: TArray<PaperSprite>;
        EndCap: PaperSprite;
        MinimumAngle: number;
        MaximumAngle: number;
        bEnableCollision: boolean;
        CollisionOffset: number;
        DrawOrder: number;
        Description: string;
    }
    
    class PaperTerrainMaterial extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Rules: TArray<PaperTerrainMaterialRule>;
        InteriorFill: PaperSprite;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainMaterial;
        static Load(InName: string): PaperTerrainMaterial;
    }
    
    class PaperTerrainComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TerrainMaterial: PaperTerrainMaterial;
        bClosedSpline: boolean;
        bFilledSpline: boolean;
        AssociatedSpline: PaperTerrainSplineComponent;
        RandomSeed: number;
        SegmentOverlapAmount: number;
        TerrainColor: LinearColor;
        ReparamStepsPerSegment: number;
        SpriteCollisionDomain: number;
        CollisionThickness: number;
        CachedBodySetup: BodySetup;
        SetTerrainColor(NewColor: LinearColor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainComponent;
        static Load(InName: string): PaperTerrainComponent;
    }
    
    class PaperTerrainActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DummyRoot: SceneComponent;
        SplineComponent: PaperTerrainSplineComponent;
        RenderComponent: PaperTerrainComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTerrainActor;
        static Load(InName: string): PaperTerrainActor;
    }
    
    class IntMargin {
        constructor(Left: number, Top: number, Right: number, Bottom: number);
        Left: number;
        Top: number;
        Right: number;
        Bottom: number;
    }
    
    class PaperTileMetadata {
        constructor(UserDataName: string, CollisionData: SpriteGeometryCollection, TerrainMembership: FixSizeArray<number>);
        UserDataName: string;
        CollisionData: SpriteGeometryCollection;
        TerrainMembership: FixSizeArray<number>;
    }
    
    class PaperTileSetTerrain {
        constructor(TerrainName: string, CenterTileIndex: number);
        TerrainName: string;
        CenterTileIndex: number;
    }
    
    class PaperTileSet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TileSize: IntPoint;
        TileSheet: Texture2D;
        AdditionalSourceTextures: TArray<Texture>;
        BorderMargin: IntMargin;
        PerTileSpacing: IntPoint;
        DrawingOffset: IntPoint;
        BackgroundColor: LinearColor;
        WidthInTiles: number;
        HeightInTiles: number;
        AllocatedWidth: number;
        AllocatedHeight: number;
        PerTileData: TArray<PaperTileMetadata>;
        Terrains: TArray<PaperTileSetTerrain>;
        TileWidth: number;
        TileHeight: number;
        Margin: number;
        Spacing: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileSet;
        static Load(InName: string): PaperTileSet;
    }
    
    class PaperTileInfo {
        constructor(TileSet: PaperTileSet, PackedTileIndex: number);
        TileSet: PaperTileSet;
        PackedTileIndex: number;
    }
    
    class PaperTileLayer extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LayerName: string;
        LayerWidth: number;
        LayerHeight: number;
        bHiddenInEditor: boolean;
        bHiddenInGame: boolean;
        bLayerCollides: boolean;
        bOverrideCollisionThickness: boolean;
        bOverrideCollisionOffset: boolean;
        CollisionThicknessOverride: number;
        CollisionOffsetOverride: number;
        LayerColor: LinearColor;
        AllocatedWidth: number;
        AllocatedHeight: number;
        AllocatedCells: TArray<PaperTileInfo>;
        TileSet: PaperTileSet;
        AllocatedGrid: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileLayer;
        static Load(InName: string): PaperTileLayer;
    }
    
    class PaperTileMap extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MapWidth: number;
        MapHeight: number;
        TileWidth: number;
        TileHeight: number;
        PixelsPerUnrealUnit: number;
        SeparationPerTileX: number;
        SeparationPerTileY: number;
        SeparationPerLayer: number;
        SelectedTileSet: TSoftObjectPtr<PaperTileSet>;
        Material: MaterialInterface;
        TileLayers: TArray<PaperTileLayer>;
        CollisionThickness: number;
        SpriteCollisionDomain: number;
        ProjectionMode: number;
        HexSideLength: number;
        BodySetup: BodySetup;
        AssetImportData: AssetImportData;
        SelectedLayerIndex: number;
        BackgroundColor: LinearColor;
        TileGridColor: LinearColor;
        MultiTileGridColor: LinearColor;
        MultiTileGridWidth: number;
        MultiTileGridHeight: number;
        MultiTileGridOffsetX: number;
        MultiTileGridOffsetY: number;
        LayerGridColor: LinearColor;
        LayerNameIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMap;
        static Load(InName: string): PaperTileMap;
    }
    
    class PaperTileMapComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MapWidth: number;
        MapHeight: number;
        TileWidth: number;
        TileHeight: number;
        DefaultLayerTileSet: PaperTileSet;
        Material: MaterialInterface;
        TileLayers: TArray<PaperTileLayer>;
        TileMapColor: LinearColor;
        UseSingleLayerIndex: number;
        bUseSingleLayer: boolean;
        TileMap: PaperTileMap;
        bShowPerTileGridWhenSelected: boolean;
        bShowPerLayerGridWhenSelected: boolean;
        bShowOutlineWhenUnselected: boolean;
        bShowPerTileGridWhenUnselected: boolean;
        bShowPerLayerGridWhenUnselected: boolean;
        SetTileMapColor(NewColor: LinearColor): void;
        SetTileMap(NewTileMap: PaperTileMap): boolean;
        SetTile(X: number, Y: number, Layer: number, NewValue: PaperTileInfo): void;
        SetLayerColor(NewColor: LinearColor, Layer: number): void;
        SetLayerCollision(Layer: number, bHasCollision: boolean, bOverrideThickness: boolean, CustomThickness: number, bOverrideOffset: boolean, CustomOffset: number, bRebuildCollision: boolean): void;
        SetDefaultCollisionThickness(Thickness: number, bRebuildCollision: boolean): void;
        ResizeMap(NewWidthInTiles: number, NewHeightInTiles: number): void;
        RebuildCollision(): void;
        OwnsTileMap(): boolean;
        MakeTileMapEditable(): void;
        GetTilePolygon(TileX: number, TileY: number, Points: $Ref<TArray<Vector>>, LayerIndex: number, bWorldSpace: boolean): void;
        GetTileMapColor(): LinearColor;
        GetTileCornerPosition(TileX: number, TileY: number, LayerIndex: number, bWorldSpace: boolean): Vector;
        GetTileCenterPosition(TileX: number, TileY: number, LayerIndex: number, bWorldSpace: boolean): Vector;
        GetTile(X: number, Y: number, Layer: number): PaperTileInfo;
        GetMapSize(MapWidth: $Ref<number>, MapHeight: $Ref<number>, NumLayers: $Ref<number>): void;
        GetLayerColor(Layer: number): LinearColor;
        CreateNewTileMap(MapWidth: number, MapHeight: number, TileWidth: number, TileHeight: number, PixelsPerUnrealUnit: number, bCreateLayer: boolean): void;
        AddNewLayer(): PaperTileLayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapComponent;
        static Load(InName: string): PaperTileMapComponent;
    }
    
    class PaperTileMapActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RenderComponent: PaperTileMapComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapActor;
        static Load(InName: string): PaperTileMapActor;
    }
    
    class TileMapBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeTile(TileIndex: number, TileSet: PaperTileSet, bFlipH: boolean, bFlipV: boolean, bFlipD: boolean): PaperTileInfo;
        static GetTileUserData(Tile: PaperTileInfo): string;
        static GetTileTransform(Tile: PaperTileInfo): Transform;
        static BreakTile(Tile: PaperTileInfo, TileIndex: $Ref<number>, TileSet: $Ref<PaperTileSet>, bFlipH: $Ref<boolean>, bFlipV: $Ref<boolean>, bFlipD: $Ref<boolean>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapBlueprintLibrary;
        static Load(InName: string): TileMapBlueprintLibrary;
    }
    
    class LightPropagationVolumeSettings {
        constructor(bOverride_LPVIntensity: boolean, bOverride_LPVDirectionalOcclusionIntensity: boolean, bOverride_LPVDirectionalOcclusionRadius: boolean, bOverride_LPVDiffuseOcclusionExponent: boolean, bOverride_LPVSpecularOcclusionExponent: boolean, bOverride_LPVDiffuseOcclusionIntensity: boolean, bOverride_LPVSpecularOcclusionIntensity: boolean, bOverride_LPVSize: boolean, bOverride_LPVSecondaryOcclusionIntensity: boolean, bOverride_LPVSecondaryBounceIntensity: boolean, bOverride_LPVGeometryVolumeBias: boolean, bOverride_LPVVplInjectionBias: boolean, bOverride_LPVEmissiveInjectionIntensity: boolean, LPVIntensity: number, LPVVplInjectionBias: number, LPVSize: number, LPVSecondaryOcclusionIntensity: number, LPVSecondaryBounceIntensity: number, LPVGeometryVolumeBias: number, LPVEmissiveInjectionIntensity: number, LPVDirectionalOcclusionIntensity: number, LPVDirectionalOcclusionRadius: number, LPVDiffuseOcclusionExponent: number, LPVSpecularOcclusionExponent: number, LPVDiffuseOcclusionIntensity: number, LPVSpecularOcclusionIntensity: number, LPVFadeRange: number, LPVDirectionalOcclusionFadeRange: number);
        bOverride_LPVIntensity: boolean;
        bOverride_LPVDirectionalOcclusionIntensity: boolean;
        bOverride_LPVDirectionalOcclusionRadius: boolean;
        bOverride_LPVDiffuseOcclusionExponent: boolean;
        bOverride_LPVSpecularOcclusionExponent: boolean;
        bOverride_LPVDiffuseOcclusionIntensity: boolean;
        bOverride_LPVSpecularOcclusionIntensity: boolean;
        bOverride_LPVSize: boolean;
        bOverride_LPVSecondaryOcclusionIntensity: boolean;
        bOverride_LPVSecondaryBounceIntensity: boolean;
        bOverride_LPVGeometryVolumeBias: boolean;
        bOverride_LPVVplInjectionBias: boolean;
        bOverride_LPVEmissiveInjectionIntensity: boolean;
        LPVIntensity: number;
        LPVVplInjectionBias: number;
        LPVSize: number;
        LPVSecondaryOcclusionIntensity: number;
        LPVSecondaryBounceIntensity: number;
        LPVGeometryVolumeBias: number;
        LPVEmissiveInjectionIntensity: number;
        LPVDirectionalOcclusionIntensity: number;
        LPVDirectionalOcclusionRadius: number;
        LPVDiffuseOcclusionExponent: number;
        LPVSpecularOcclusionExponent: number;
        LPVDiffuseOcclusionIntensity: number;
        LPVSpecularOcclusionIntensity: number;
        LPVFadeRange: number;
        LPVDirectionalOcclusionFadeRange: number;
    }
    
    class LightPropagationVolumeBlendable extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: LightPropagationVolumeSettings;
        BlendWeight: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightPropagationVolumeBlendable;
        static Load(InName: string): LightPropagationVolumeBlendable;
    }
    
    class SignificanceManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SignificanceManagerClassName: SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SignificanceManager;
        static Load(InName: string): SignificanceManager;
    }
    
    class AnimationSharingStateProcessor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationStateEnum: TSoftObjectPtr<Enum>;
        ProcessActorState(OutState: $Ref<number>, InActor: Actor, CurrentState: number, OnDemandState: number, bShouldProcess: $Ref<boolean>): void;
        GetAnimationStateEnum(): Enum;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingStateProcessor;
        static Load(InName: string): AnimationSharingStateProcessor;
    }
    
    class AnimSharingInstance extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RegisteredActors: TArray<Actor>;
        StateProcessor: AnimationSharingStateProcessor;
        UsedAnimationSequences: TArray<AnimSequence>;
        StateEnum: Enum;
        SharingActor: Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingInstance;
        static Load(InName: string): AnimSharingInstance;
    }
    
    class AnimSharingStateInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationToPlay: AnimSequence;
        PermutationTimeOffset: number;
        PlayRate: number;
        bStateBool: boolean;
        Instance: AnimSharingInstance;
        GetInstancedActors(Actors: $Ref<TArray<Actor>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingStateInstance;
        static Load(InName: string): AnimSharingStateInstance;
    }
    
    class AnimSharingTransitionInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FromComponent: TWeakObjectPtr<SkeletalMeshComponent>;
        ToComponent: TWeakObjectPtr<SkeletalMeshComponent>;
        BlendTime: number;
        bBlendBool: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingTransitionInstance;
        static Load(InName: string): AnimSharingTransitionInstance;
    }
    
    class AnimSharingAdditiveInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BaseComponent: TWeakObjectPtr<SkeletalMeshComponent>;
        AdditiveAnimation: TWeakObjectPtr<AnimSequence>;
        Alpha: number;
        bStateBool: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimSharingAdditiveInstance;
        static Load(InName: string): AnimSharingAdditiveInstance;
    }
    
    class AnimationSetup {
        constructor(AnimSequence: AnimSequence, AnimBlueprint: Class, NumRandomizedInstances: PerPlatformInt, Enabled: PerPlatformBool);
        AnimSequence: AnimSequence;
        AnimBlueprint: Class;
        NumRandomizedInstances: PerPlatformInt;
        Enabled: PerPlatformBool;
    }
    
    class AnimationStateEntry {
        constructor(State: number, AnimationSetups: TArray<AnimationSetup>, bOnDemand: boolean, bAdditive: boolean, BlendTime: number, bReturnToPreviousState: boolean, bSetNextState: boolean, NextState: number, MaximumNumberOfConcurrentInstances: PerPlatformInt, WiggleTimePercentage: number, bRequiresCurves: boolean);
        State: number;
        AnimationSetups: TArray<AnimationSetup>;
        bOnDemand: boolean;
        bAdditive: boolean;
        BlendTime: number;
        bReturnToPreviousState: boolean;
        bSetNextState: boolean;
        NextState: number;
        MaximumNumberOfConcurrentInstances: PerPlatformInt;
        WiggleTimePercentage: number;
        bRequiresCurves: boolean;
    }
    
    class PerSkeletonAnimationSharingSetup {
        constructor(Skeleton: Skeleton, SkeletalMesh: SkeletalMesh, BlendAnimBlueprint: Class, AdditiveAnimBlueprint: Class, StateProcessorClass: Class, AnimationStates: TArray<AnimationStateEntry>);
        Skeleton: Skeleton;
        SkeletalMesh: SkeletalMesh;
        BlendAnimBlueprint: Class;
        AdditiveAnimBlueprint: Class;
        StateProcessorClass: Class;
        AnimationStates: TArray<AnimationStateEntry>;
    }
    
    class AnimationSharingScalability {
        constructor(UseBlendTransitions: PerPlatformBool, BlendSignificanceValue: PerPlatformFloat, MaximumNumberConcurrentBlends: PerPlatformInt, TickSignificanceValue: PerPlatformFloat);
        UseBlendTransitions: PerPlatformBool;
        BlendSignificanceValue: PerPlatformFloat;
        MaximumNumberConcurrentBlends: PerPlatformInt;
        TickSignificanceValue: PerPlatformFloat;
    }
    
    class AnimationSharingSetup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkeletonSetups: TArray<PerSkeletonAnimationSharingSetup>;
        ScalabilitySettings: AnimationSharingScalability;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingSetup;
        static Load(InName: string): AnimationSharingSetup;
    }
    
    class AnimationSharingManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Skeletons: TArray<Skeleton>;
        PerSkeletonData: TArray<AnimSharingInstance>;
        RegisterActorWithSkeletonBP(InActor: Actor, SharingSkeleton: Skeleton): void;
        static GetAnimationSharingManager(WorldContextObject: Object): AnimationSharingManager;
        static CreateAnimationSharingManager(WorldContextObject: Object, Setup: AnimationSharingSetup): boolean;
        static AnimationSharingEnabled(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingManager;
        static Load(InName: string): AnimationSharingManager;
    }
    
    class EdGraph_ReferenceViewer extends EdGraph {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraph_ReferenceViewer;
        static Load(InName: string): EdGraph_ReferenceViewer;
    }
    
    class EdGraphNode_Reference extends EdGraphNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdGraphNode_Reference;
        static Load(InName: string): EdGraphNode_Reference;
    }
    
    class ReferenceViewerSchema extends EdGraphSchema {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReferenceViewerSchema;
        static Load(InName: string): ReferenceViewerSchema;
    }
    
    class InternationalizationExportSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CulturesToGenerate: TArray<string>;
        CommandletClass: string;
        SourcePath: string;
        DestinationPath: string;
        PortableObjectName: string;
        ManifestName: string;
        ArchiveName: string;
        bExportLoc: boolean;
        bImportLoc: boolean;
        bUseCultureDirectory: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): InternationalizationExportSettings;
        static Load(InName: string): InternationalizationExportSettings;
    }
    
    class TranslationPickerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bSubmitTranslationPickerChangesToLocalizationService: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TranslationPickerSettings;
        static Load(InName: string): TranslationPickerSettings;
    }
    
    class TranslationChange {
        constructor(Version: string, DateAndTime: DateTime, Source: string, Translation: string);
        Version: string;
        DateAndTime: DateTime;
        Source: string;
        Translation: string;
    }
    
    class TranslationContextInfo {
        constructor(Key: string, Context: string, Changes: TArray<TranslationChange>);
        Key: string;
        Context: string;
        Changes: TArray<TranslationChange>;
    }
    
    class TranslationUnit extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Namespace: string;
        Key: string;
        Source: string;
        Translation: string;
        Contexts: TArray<TranslationContextInfo>;
        HasBeenReviewed: boolean;
        TranslationBeforeImport: string;
        LocresPath: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TranslationUnit;
        static Load(InName: string): TranslationUnit;
    }
    
    class PixelInspectorView extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FinalColor: LinearColor;
        SceneColor: LinearColor;
        PreExposure: number;
        Luminance: number;
        HdrColor: LinearColor;
        Normal: Vector;
        PerObjectGBufferData: number;
        Metallic: number;
        Specular: number;
        Roughness: number;
        MaterialShadingModel: number;
        SelectiveOutputMask: number;
        BaseColor: LinearColor;
        IndirectIrradiance: number;
        AmbientOcclusion: number;
        SubSurfaceColor: LinearColor;
        SubsurfaceProfile: Vector;
        Opacity: number;
        ClearCoat: number;
        ClearCoatRoughness: number;
        WorldNormal: Vector;
        BackLit: number;
        Cloth: number;
        EyeTangent: Vector;
        IrisMask: number;
        IrisDistance: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PixelInspectorView;
        static Load(InName: string): PixelInspectorView;
    }
    
    class EditorUtilityObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Run(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityObject;
        static Load(InName: string): EditorUtilityObject;
    }
    
    class ActorActionUtility extends EditorUtilityObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GetSupportedClass(): Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorActionUtility;
        static Load(InName: string): ActorActionUtility;
    }
    
    class AssetActionUtility extends EditorUtilityObject {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        IsActionForBlueprints(): boolean;
        GetSupportedClass(): Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetActionUtility;
        static Load(InName: string): AssetActionUtility;
    }
    
    class EditorUtilityExtension extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityExtension;
        static Load(InName: string): EditorUtilityExtension;
    }
    
    class EditorUtilityActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Run(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityActor;
        static Load(InName: string): EditorUtilityActor;
    }
    
    class EditorUtilityActorComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityActorComponent;
        static Load(InName: string): EditorUtilityActorComponent;
    }
    
    class EditorUtilityBlueprint extends Blueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityBlueprint;
        static Load(InName: string): EditorUtilityBlueprint;
    }
    
    class EditorUtilityBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ParentClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityBlueprintFactory;
        static Load(InName: string): EditorUtilityBlueprintFactory;
    }
    
    class EditorUtilityCamera extends CameraActor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityCamera;
        static Load(InName: string): EditorUtilityCamera;
    }
    
    class EditorUtilityLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RenameAsset(Asset: Object, NewName: string): void;
        static GetSelectionSet(): TArray<Actor>;
        static GetSelectionBounds(Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, SphereRadius: $Ref<number>): void;
        static GetSelectedBlueprintClasses(): TArray<Class>;
        static GetSelectedAssets(): TArray<Object>;
        static GetSelectedAssetData(): TArray<AssetData>;
        GetActorReference(PathToActor: string): Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityLibrary;
        static Load(InName: string): EditorUtilityLibrary;
    }
    
    class EditorUtilityWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpText: string;
        bAlwaysReregisterWithWindowsMenu: boolean;
        bAutoRunDefaultAction: boolean;
        Run(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidget;
        static Load(InName: string): EditorUtilityWidget;
    }
    
    class EditorUtilityWidgetBlueprint extends WidgetBlueprint {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreatedUMGWidget: EditorUtilityWidget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidgetBlueprint;
        static Load(InName: string): EditorUtilityWidgetBlueprint;
    }
    
    class EditorUtilitySubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LoadedUIs: TArray<SoftObjectPath>;
        StartupObjects: TArray<SoftObjectPath>;
        ObjectInstances: TMap<Object, Object>;
        TryRun(Asset: Object): boolean;
        SpawnAndRegisterTab(InBlueprint: EditorUtilityWidgetBlueprint): EditorUtilityWidget;
        ReleaseInstanceOfAsset(Asset: Object): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilitySubsystem;
        static Load(InName: string): EditorUtilitySubsystem;
    }
    
    class EditorUtilityWidgetBlueprintFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BlueprintType: number;
        ParentClass: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorUtilityWidgetBlueprintFactory;
        static Load(InName: string): EditorUtilityWidgetBlueprintFactory;
    }
    
    class GlobalEditorUtilityBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpText: string;
        bDirtiedSelectionSet: boolean;
        bAutoRunDefaultAction: boolean;
        OnEachSelectedActor: $MulticastDelegate<(Actor: Actor, Index: number) => void>;
        OnEachSelectedAsset: $MulticastDelegate<(Asset: Object, Index: number) => void>;
        SetActorSelectionState(Actor: Actor, bShouldBeSelected: boolean): void;
        SelectNothing(): void;
        RenameAsset(Asset: Object, NewName: string): void;
        OnDefaultActionClicked(): void;
        GetSelectionSet(): TArray<Actor>;
        GetSelectionBounds(Origin: $Ref<Vector>, BoxExtent: $Ref<Vector>, SphereRadius: $Ref<number>): void;
        GetSelectedAssets(): TArray<Object>;
        GetEditorUserSettings(): EditorPerProjectUserSettings;
        GetActorReference(PathToActor: string): Actor;
        ForEachSelectedAsset(): void;
        ForEachSelectedActor(): void;
        ClearActorSelectionSet(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GlobalEditorUtilityBase;
        static Load(InName: string): GlobalEditorUtilityBase;
    }
    
    class PlacedEditorUtilityBase extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        HelpText: string;
        SetLevelViewportCameraInfo(CameraLocation: Vector, CameraRotation: Rotator): void;
        SetActorSelectionState(Actor: Actor, bShouldBeSelected: boolean): void;
        SelectNothing(): void;
        GetSelectionSet(): TArray<Actor>;
        GetLevelViewportCameraInfo(CameraLocation: $Ref<Vector>, CameraRotation: $Ref<Rotator>): boolean;
        GetActorReference(PathToActor: string): Actor;
        ClearActorSelectionSet(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlacedEditorUtilityBase;
        static Load(InName: string): PlacedEditorUtilityBase;
    }
    
    class DataValidationCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataValidationCommandlet;
        static Load(InName: string): DataValidationCommandlet;
    }
    
    class DataValidationManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExcludedDirectories: TArray<DirectoryPath>;
        bValidateOnSave: boolean;
        DataValidationManagerClassName: SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DataValidationManager;
        static Load(InName: string): DataValidationManager;
    }
    
    enum EDataValidationResult { Invalid, Valid, NotValidated, EDataValidationResult_MAX}
    class EditorValidatorBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsEnabled: boolean;
        ValidateLoadedAsset(InAsset: Object, ValidationErrors: $Ref<TArray<string>>): EDataValidationResult;
        GetValidationResult(): EDataValidationResult;
        CanValidateAsset(InAsset: Object): boolean;
        AssetPasses(InAsset: Object): void;
        AssetFails(InAsset: Object, InMessage: string, ValidationErrors: $Ref<TArray<string>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorValidatorBase;
        static Load(InName: string): EditorValidatorBase;
    }
    
    class EditorValidatorSubsystem extends EditorSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ExcludedDirectories: TArray<DirectoryPath>;
        bValidateOnSave: boolean;
        Validators: TMap<Class, EditorValidatorBase>;
        bValidateAssetsWhileSavingForCook: boolean;
        bAllowBlueprintValidators: boolean;
        ValidateAssets(AssetDataList: TArray<AssetData>, bSkipExcludedDirectories: boolean, bShowIfNoFailures: boolean): number;
        IsObjectValid(InObject: Object, ValidationErrors: $Ref<TArray<string>>): EDataValidationResult;
        IsAssetValid(AssetData: $Ref<AssetData>, ValidationErrors: $Ref<TArray<string>>): EDataValidationResult;
        AddValidator(InValidator: EditorValidatorBase): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorValidatorSubsystem;
        static Load(InName: string): EditorValidatorSubsystem;
    }
    
    class AudioCurveSourceComponent extends AudioComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveSourceBindingName: string;
        CurveSyncOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCurveSourceComponent;
        static Load(InName: string): AudioCurveSourceComponent;
    }
    
    class FacialAnimationBulkImporterSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceImportPath: DirectoryPath;
        TargetImportPath: DirectoryPath;
        CurveNodeName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FacialAnimationBulkImporterSettings;
        static Load(InName: string): FacialAnimationBulkImporterSettings;
    }
    
    class GameplayTagSearchFilter extends ContentBrowserFrontEndFilterExtension {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagSearchFilter;
        static Load(InName: string): GameplayTagSearchFilter;
    }
    
    class GameplayTagsK2Node_LiteralGameplayTag extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_LiteralGameplayTag;
        static Load(InName: string): GameplayTagsK2Node_LiteralGameplayTag;
    }
    
    class GameplayTagsK2Node_MultiCompareBase extends K2Node {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumberOfPins: number;
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareBase;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareBase;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterface;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagAssetInterfaceSingleTags;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagContainer extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainer;
    }
    
    class GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags extends GameplayTagsK2Node_MultiCompareBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
        static Load(InName: string): GameplayTagsK2Node_MultiCompareGameplayTagContainerSingleTags;
    }
    
    class GameplayTagsK2Node_SwitchGameplayTag extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinTags: TArray<GameplayTag>;
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_SwitchGameplayTag;
        static Load(InName: string): GameplayTagsK2Node_SwitchGameplayTag;
    }
    
    class GameplayTagsK2Node_SwitchGameplayTagContainer extends K2Node_Switch {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinContainers: TArray<GameplayTagContainer>;
        PinNames: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GameplayTagsK2Node_SwitchGameplayTagContainer;
        static Load(InName: string): GameplayTagsK2Node_SwitchGameplayTagContainer;
    }
    
    enum EMagicLeapPlaneQueryFlags { Vertical, Horizontal, Arbitrary, OrientToGravity, PreferInner, Ceiling, Floor, Wall, Polygons, EMagicLeapPlaneQueryFlags_MAX}
    class MagicLeapPlaneResult {
        constructor(PlanePosition: Vector, PlaneOrientation: Rotator, ContentOrientation: Rotator, PlaneDimensions: Vector2D, PlaneFlags: TArray<EMagicLeapPlaneQueryFlags>, ID: Guid);
        PlanePosition: Vector;
        PlaneOrientation: Rotator;
        ContentOrientation: Rotator;
        PlaneDimensions: Vector2D;
        PlaneFlags: TArray<EMagicLeapPlaneQueryFlags>;
        ID: Guid;
    }
    
    class MagicLeapPolygon {
        constructor(Vertices: TArray<Vector>);
        Vertices: TArray<Vector>;
    }
    
    class MagicLeapPlaneBoundary {
        constructor(Polygon: MagicLeapPolygon, Holes: TArray<MagicLeapPolygon>);
        Polygon: MagicLeapPolygon;
        Holes: TArray<MagicLeapPolygon>;
    }
    
    class MagicLeapPlaneBoundaries {
        constructor(ID: Guid, Boundaries: TArray<MagicLeapPlaneBoundary>);
        ID: Guid;
        Boundaries: TArray<MagicLeapPlaneBoundary>;
    }
    
    class MagicLeapPlanesComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        QueryFlags: TArray<EMagicLeapPlaneQueryFlags>;
        SearchVolume: BoxComponent;
        MaxResults: number;
        MinHolePerimeter: number;
        MinPlaneArea: number;
        OnPlanesQueryResult: $MulticastDelegate<(bSuccess: boolean, Planes: TArray<MagicLeapPlaneResult>, Polygons: TArray<MagicLeapPlaneBoundaries>) => void>;
        RequestPlanesAsync(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapPlanesComponent;
        static Load(InName: string): MagicLeapPlanesComponent;
    }
    
    class MagicLeapPlanesQuery {
        constructor(Flags: TArray<EMagicLeapPlaneQueryFlags>, SearchVolume: BoxComponent, MaxResults: number, MinHoleLength: number, MinPlaneArea: number, SearchVolumePosition: Vector, SearchVolumeOrientation: Quat, SearchVolumeExtents: Vector);
        Flags: TArray<EMagicLeapPlaneQueryFlags>;
        SearchVolume: BoxComponent;
        MaxResults: number;
        MinHoleLength: number;
        MinPlaneArea: number;
        SearchVolumePosition: Vector;
        SearchVolumeOrientation: Quat;
        SearchVolumeExtents: Vector;
    }
    
    class MagicLeapPlanesFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ReorderPlaneFlags(InPriority: TArray<EMagicLeapPlaneQueryFlags>, InFlagsToReorder: TArray<EMagicLeapPlaneQueryFlags>, OutReorderedFlags: $Ref<TArray<EMagicLeapPlaneQueryFlags>>): void;
        static RemoveFlagsNotInQuery(InQueryFlags: TArray<EMagicLeapPlaneQueryFlags>, InResultFlags: TArray<EMagicLeapPlaneQueryFlags>, OutFlags: $Ref<TArray<EMagicLeapPlaneQueryFlags>>): void;
        static PlanesQueryBeginAsync(Query: MagicLeapPlanesQuery, ResultDelegate: $Delegate<(bSuccess: boolean, Planes: TArray<MagicLeapPlaneResult>, Polygons: TArray<MagicLeapPlaneBoundaries>) => void>): boolean;
        static IsTrackerValid(): boolean;
        static GetContentScale(ContentActor: Actor, PlaneResult: MagicLeapPlaneResult): Transform;
        static DestroyTracker(): boolean;
        static CreateTracker(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapPlanesFunctionLibrary;
        static Load(InName: string): MagicLeapPlanesFunctionLibrary;
    }
    
    class LuminARUObjectManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AllAnchors: TArray<ARPin>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARUObjectManager;
        static Load(InName: string): LuminARUObjectManager;
    }
    
    class LuminARSessionConfig extends ARSessionConfig {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MaxPlaneQueryResults: number;
        MinPlaneArea: number;
        bArbitraryOrientationPlaneDetection: boolean;
        PlaneSearchExtents: Vector;
        PlaneQueryFlags: TArray<EMagicLeapPlaneQueryFlags>;
        bDiscardZeroExtentPlanes: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARSessionConfig;
        static Load(InName: string): LuminARSessionConfig;
    }
    
    class LuminARSessionFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StartLuminARSession(WorldContextObject: Object, LatentInfo: LatentActionInfo, Configuration: LuminARSessionConfig): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARSessionFunctionLibrary;
        static Load(InName: string): LuminARSessionFunctionLibrary;
    }
    
    enum ELuminARLineTraceChannel { None, FeaturePoint, InfinitePlane, PlaneUsingExtent, PlaneUsingBoundaryPolygon, FeaturePointWithSurfaceNormal, ELuminARLineTraceChannel_MAX}
    enum ELuminARTrackingState { Tracking, NotTracking, StoppedTracking, ELuminARTrackingState_MAX}
    class LuminARLightEstimate {
        constructor(bIsValid: boolean, PixelIntensity: number, RGBScaleFactor: Vector);
        bIsValid: boolean;
        PixelIntensity: number;
        RGBScaleFactor: Vector;
    }
    
    class LuminARFrameFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static LuminARLineTrace(WorldContextObject: Object, ScreenPosition: Vector2D, TraceChannels: TSet<ELuminARLineTraceChannel>, OutHitResults: $Ref<TArray<ARTraceResult>>): boolean;
        static GetTrackingState(): ELuminARTrackingState;
        static GetLightEstimation(OutLightEstimate: $Ref<LuminARLightEstimate>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminARFrameFunctionLibrary;
        static Load(InName: string): LuminARFrameFunctionLibrary;
    }
    
    enum EMagicLeapAutoPinType { OnlyOnDataRestoration, Always, Never, EMagicLeapAutoPinType_MAX}
    class MagicLeapARPinSaveGame extends SaveGame {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PinnedID: Guid;
        ComponentWorldTransform: Transform;
        PinTransform: Transform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapARPinSaveGame;
        static Load(InName: string): MagicLeapARPinSaveGame;
    }
    
    class MagicLeapARPinComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ObjectUID: string;
        UserIndex: number;
        AutoPinType: EMagicLeapAutoPinType;
        bShouldPinActor: boolean;
        PinDataClass: Class;
        OnPersistentEntityPinned: $MulticastDelegate<(bRestoredOrSynced: boolean) => void>;
        OnPersistentEntityPinLost: $MulticastDelegate<() => void>;
        PinnedCFUID: Guid;
        PinnedSceneComponent: SceneComponent;
        PinData: MagicLeapARPinSaveGame;
        UnPin(): void;
        PinSceneComponent(ComponentToPin: SceneComponent): boolean;
        PinRestoredOrSynced(): boolean;
        PinActor(ActorToPin: Actor): boolean;
        PersistentEntityPinned__DelegateSignature(bRestoredOrSynced: boolean): void;
        PersistentEntityPinLost__DelegateSignature(): void;
        IsPinned(): boolean;
        GetPinnedPinID(PinID: $Ref<Guid>): boolean;
        GetPinData(PinDataClass: Class): MagicLeapARPinSaveGame;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapARPinComponent;
        static Load(InName: string): MagicLeapARPinComponent;
    }
    
    enum EMagicLeapPassableWorldError { None, LowMapQuality, UnableToLocalize, Unavailable, PrivilegeDenied, InvalidParam, UnspecifiedFailure, PrivilegeRequestPending, EMagicLeapPassableWorldError_MAX}
    class MagicLeapARPinFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static IsTrackerValid(): boolean;
        static GetNumAvailableARPins(Count: $Ref<number>): EMagicLeapPassableWorldError;
        static GetClosestARPin(SearchPoint: Vector, PinID: $Ref<Guid>): EMagicLeapPassableWorldError;
        static GetAvailableARPins(NumRequested: number, Pins: $Ref<TArray<Guid>>): EMagicLeapPassableWorldError;
        static GetARPinPositionAndOrientation(PinID: Guid, Position: $Ref<Vector>, Orientation: $Ref<Rotator>, PinFoundInEnvironment: $Ref<boolean>): boolean;
        static DestroyTracker(): EMagicLeapPassableWorldError;
        static CreateTracker(): EMagicLeapPassableWorldError;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapARPinFunctionLibrary;
        static Load(InName: string): MagicLeapARPinFunctionLibrary;
    }
    
    enum EMagicLeapControllerTrackingMode { InputService, CoordinateFrameUID, EMagicLeapControllerTrackingMode_MAX}
    enum EMagicLeapControllerLEDPattern { None, Clock01, Clock02, Clock03, Clock04, Clock05, Clock06, Clock07, Clock08, Clock09, Clock10, Clock11, Clock12, Clock01_07, Clock02_08, Clock03_09, Clock04_10, Clock05_11, Clock06_12, EMagicLeapControllerLEDPattern_MAX}
    enum EMagicLeapControllerLEDColor { BrightMissionRed, PastelMissionRed, BrightFloridaOrange, PastelFloridaOrange, BrightLunaYellow, PastelLunaYellow, BrightNebulaPink, PastelNebulaPink, BrightCosmicPurple, PastelCosmicPurple, BrightMysticBlue, PastelMysticBlue, BrightCelestialBlue, PastelCelestialBlue, BrightShaggleGreen, PastelShaggleGreen, EMagicLeapControllerLEDColor_MAX}
    enum EMagicLeapControllerLEDEffect { RotateCW, RotateCCW, Pulse, PaintCW, PaintCCW, Blink, EMagicLeapControllerLEDEffect_MAX}
    enum EMagicLeapControllerLEDSpeed { Slow, Medium, Fast, EMagicLeapControllerLEDSpeed_MAX}
    enum EMagicLeapControllerHapticPattern { None, Click, Bump, DoubleClick, Buzz, Tick, ForceDown, ForceUp, ForceDwell, SecondForceDown, EMagicLeapControllerHapticPattern_MAX}
    enum EMagicLeapControllerHapticIntensity { Low, Medium, High, EMagicLeapControllerHapticIntensity_MAX}
    enum EMagicLeapControllerType { None, Device, MobileApp, EMagicLeapControllerType_MAX}
    class MagicLeapControllerFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetMotionSourceForHand(Hand: EControllerHand, MotionSource: string): boolean;
        static SetControllerTrackingMode(TrackingMode: EMagicLeapControllerTrackingMode): boolean;
        static PlayLEDPattern(MotionSource: string, LEDPattern: EMagicLeapControllerLEDPattern, LEDColor: EMagicLeapControllerLEDColor, DurationInSec: number): boolean;
        static PlayLEDEffect(MotionSource: string, LEDEffect: EMagicLeapControllerLEDEffect, LEDSpeed: EMagicLeapControllerLEDSpeed, LEDPattern: EMagicLeapControllerLEDPattern, LEDColor: EMagicLeapControllerLEDColor, DurationInSec: number): boolean;
        static PlayHapticPattern(MotionSource: string, HapticPattern: EMagicLeapControllerHapticPattern, Intensity: EMagicLeapControllerHapticIntensity): boolean;
        static PlayControllerLEDEffect(Hand: EControllerHand, LEDEffect: EMagicLeapControllerLEDEffect, LEDSpeed: EMagicLeapControllerLEDSpeed, LEDPattern: EMagicLeapControllerLEDPattern, LEDColor: EMagicLeapControllerLEDColor, DurationInSec: number): boolean;
        static PlayControllerLED(Hand: EControllerHand, LEDPattern: EMagicLeapControllerLEDPattern, LEDColor: EMagicLeapControllerLEDColor, DurationInSec: number): boolean;
        static PlayControllerHapticFeedback(Hand: EControllerHand, HapticPattern: EMagicLeapControllerHapticPattern, Intensity: EMagicLeapControllerHapticIntensity): boolean;
        static MaxSupportedMagicLeapControllers(): number;
        static IsMLControllerConnected(MotionSource: string): boolean;
        static InvertControllerMapping(): void;
        static GetMotionSourceForHand(Hand: EControllerHand): string;
        static GetMLControllerType(Hand: EControllerHand): EMagicLeapControllerType;
        static GetHandForMotionSource(MotionSource: string): EControllerHand;
        static GetControllerType(MotionSource: string): EMagicLeapControllerType;
        static GetControllerTrackingMode(): EMagicLeapControllerTrackingMode;
        static GetControllerMapping(ControllerIndex: number, Hand: $Ref<EControllerHand>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapControllerFunctionLibrary;
        static Load(InName: string): MagicLeapControllerFunctionLibrary;
    }
    
    enum EMagicLeapTouchpadGestureType { None, Tap, ForceTapDown, ForceTapUp, ForceDwell, SecondForceDown, LongHold, RadialScroll, Swipe, Scroll, Pinch, EMagicLeapTouchpadGestureType_MAX}
    enum EMagicLeapTouchpadGestureDirection { None, Up, Down, Left, Right, In, Out, Clockwise, CounterClockwise, EMagicLeapTouchpadGestureDirection_MAX}
    class MagicLeapTouchpadGesture {
        constructor(Hand: EControllerHand, MotionSource: string, Type: EMagicLeapTouchpadGestureType, Direction: EMagicLeapTouchpadGestureDirection, PositionAndForce: Vector, Speed: number, Distance: number, FingerGap: number, Radius: number, Angle: number);
        Hand: EControllerHand;
        MotionSource: string;
        Type: EMagicLeapTouchpadGestureType;
        Direction: EMagicLeapTouchpadGestureDirection;
        PositionAndForce: Vector;
        Speed: number;
        Distance: number;
        FingerGap: number;
        Radius: number;
        Angle: number;
    }
    
    class MagicLeapTouchpadGesturesComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnTouchpadGestureStart: $MulticastDelegate<(GestureData: MagicLeapTouchpadGesture) => void>;
        OnTouchpadGestureContinue: $MulticastDelegate<(GestureData: MagicLeapTouchpadGesture) => void>;
        OnTouchpadGestureEnd: $MulticastDelegate<(GestureData: MagicLeapTouchpadGesture) => void>;
        TouchpadGestureEvent__DelegateSignature(GestureData: MagicLeapTouchpadGesture): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapTouchpadGesturesComponent;
        static Load(InName: string): MagicLeapTouchpadGesturesComponent;
    }
    
    class EyeTrackerStereoGazeData {
        constructor(LeftEyeOrigin: Vector, LeftEyeDirection: Vector, RightEyeOrigin: Vector, RightEyeDirection: Vector, FixationPoint: Vector, ConfidenceValue: number);
        LeftEyeOrigin: Vector;
        LeftEyeDirection: Vector;
        RightEyeOrigin: Vector;
        RightEyeDirection: Vector;
        FixationPoint: Vector;
        ConfidenceValue: number;
    }
    
    class EyeTrackerGazeData {
        constructor(GazeOrigin: Vector, GazeDirection: Vector, FixationPoint: Vector, ConfidenceValue: number);
        GazeOrigin: Vector;
        GazeDirection: Vector;
        FixationPoint: Vector;
        ConfidenceValue: number;
    }
    
    class EyeTrackerFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetEyeTrackedPlayer(PlayerController: PlayerController): void;
        static IsStereoGazeDataAvailable(): boolean;
        static IsEyeTrackerConnected(): boolean;
        static GetStereoGazeData(OutGazeData: $Ref<EyeTrackerStereoGazeData>): boolean;
        static GetGazeData(OutGazeData: $Ref<EyeTrackerGazeData>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EyeTrackerFunctionLibrary;
        static Load(InName: string): EyeTrackerFunctionLibrary;
    }
    
    class MagicLeapFixationComfort {
        constructor(FixationDepthIsUncomfortable: boolean, FixationDepthViolationHasOccurred: boolean, RemainingTimeAtUncomfortableDepth: number);
        FixationDepthIsUncomfortable: boolean;
        FixationDepthViolationHasOccurred: boolean;
        RemainingTimeAtUncomfortableDepth: number;
    }
    
    class MagicLeapEyeBlinkState {
        constructor(LeftEyeBlinked: boolean, RightEyeBlinked: boolean);
        LeftEyeBlinked: boolean;
        RightEyeBlinked: boolean;
    }
    
    enum EMagicLeapEyeTrackingCalibrationStatus { None, Bad, Good, EMagicLeapEyeTrackingCalibrationStatus_MAX}
    class MagicLeapEyeTrackerFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static GetFixationComfort(FixationComfort: $Ref<MagicLeapFixationComfort>): boolean;
        static GetEyeBlinkState(BlinkState: $Ref<MagicLeapEyeBlinkState>): boolean;
        static GetCalibrationStatus(): EMagicLeapEyeTrackingCalibrationStatus;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapEyeTrackerFunctionLibrary;
        static Load(InName: string): MagicLeapEyeTrackerFunctionLibrary;
    }
    
    class MagicLeapHandMeshingComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): boolean;
        ConnectMRMesh(InMRMeshPtr: MRMeshComponent): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHandMeshingComponent;
        static Load(InName: string): MagicLeapHandMeshingComponent;
    }
    
    class MagicLeapHandMeshingFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static DisconnectMRMesh(InMRMeshPtr: MRMeshComponent): boolean;
        static DestroyClient(): boolean;
        static CreateClient(): boolean;
        static ConnectMRMesh(InMRMeshPtr: MRMeshComponent): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHandMeshingFunctionLibrary;
        static Load(InName: string): MagicLeapHandMeshingFunctionLibrary;
    }
    
    class LiveLinkRole extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkRole;
        static Load(InName: string): LiveLinkRole;
    }
    
    class LiveLinkBasicRole extends LiveLinkRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkBasicRole;
        static Load(InName: string): LiveLinkBasicRole;
    }
    
    class LiveLinkAnimationRole extends LiveLinkBasicRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkAnimationRole;
        static Load(InName: string): LiveLinkAnimationRole;
    }
    
    class LiveLinkTransformRole extends LiveLinkBasicRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkTransformRole;
        static Load(InName: string): LiveLinkTransformRole;
    }
    
    class LiveLinkCameraRole extends LiveLinkTransformRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkCameraRole;
        static Load(InName: string): LiveLinkCameraRole;
    }
    
    class LiveLinkController extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkController;
        static Load(InName: string): LiveLinkController;
    }
    
    enum ELiveLinkSourceMode { Latest, EngineTime, Timecode, ELiveLinkSourceMode_MAX}
    class LiveLinkSourceBufferManagementSettings {
        constructor(ValidEngineTime: number, EngineTimeOffset: number, TimecodeFrameRate: FrameRate, bGenerateSubFrame: boolean, SourceTimecodeFrameRate: FrameRate, ValidTimecodeFrame: number, TimecodeFrameOffset: number, LatestOffset: number, MaxNumberOfFrameToBuffered: number, bKeepAtLeastOneFrame: boolean);
        ValidEngineTime: number;
        EngineTimeOffset: number;
        TimecodeFrameRate: FrameRate;
        bGenerateSubFrame: boolean;
        SourceTimecodeFrameRate: FrameRate;
        ValidTimecodeFrame: number;
        TimecodeFrameOffset: number;
        LatestOffset: number;
        MaxNumberOfFrameToBuffered: number;
        bKeepAtLeastOneFrame: boolean;
    }
    
    class LiveLinkSubjectName {
        constructor(Name: string);
        Name: string;
    }
    
    class LiveLinkSourceDebugInfo {
        constructor(SubjectName: LiveLinkSubjectName, SnapshotIndex: number, NumberOfBufferAtSnapshot: number);
        SubjectName: LiveLinkSubjectName;
        SnapshotIndex: number;
        NumberOfBufferAtSnapshot: number;
    }
    
    class LiveLinkSourceSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mode: ELiveLinkSourceMode;
        BufferSettings: LiveLinkSourceBufferManagementSettings;
        ConnectionString: string;
        Factory: Class;
        SourceDebugInfos: TArray<LiveLinkSourceDebugInfo>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkSourceSettings;
        static Load(InName: string): LiveLinkSourceSettings;
    }
    
    class LiveLinkCurveConversionSettings {
        constructor(CurveConversionAssetMap: TMap<string, SoftObjectPath>);
        CurveConversionAssetMap: TMap<string, SoftObjectPath>;
    }
    
    class LiveLinkCurveRemapSettings extends LiveLinkSourceSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CurveConversionSettings: LiveLinkCurveConversionSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkCurveRemapSettings;
        static Load(InName: string): LiveLinkCurveRemapSettings;
    }
    
    class LiveLinkFrameInterpolationProcessor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkFrameInterpolationProcessor;
        static Load(InName: string): LiveLinkFrameInterpolationProcessor;
    }
    
    class LiveLinkFramePreProcessor extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkFramePreProcessor;
        static Load(InName: string): LiveLinkFramePreProcessor;
    }
    
    class LiveLinkFrameTranslator extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkFrameTranslator;
        static Load(InName: string): LiveLinkFrameTranslator;
    }
    
    class LiveLinkLightRole extends LiveLinkTransformRole {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkLightRole;
        static Load(InName: string): LiveLinkLightRole;
    }
    
    class LiveLinkSourceFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkSourceFactory;
        static Load(InName: string): LiveLinkSourceFactory;
    }
    
    class LiveLinkSubjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PreProcessors: TArray<LiveLinkFramePreProcessor>;
        InterpolationProcessor: LiveLinkFrameInterpolationProcessor;
        Translators: TArray<LiveLinkFrameTranslator>;
        Role: Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkSubjectSettings;
        static Load(InName: string): LiveLinkSubjectSettings;
    }
    
    class LiveLinkVirtualSubject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Role: Class;
        Subjects: TArray<LiveLinkSubjectName>;
        FrameTranslators: TArray<LiveLinkFrameTranslator>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkVirtualSubject;
        static Load(InName: string): LiveLinkVirtualSubject;
    }
    
    class LiveLinkMagicLeapHandTrackingSourceFactory extends LiveLinkSourceFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveLinkMagicLeapHandTrackingSourceFactory;
        static Load(InName: string): LiveLinkMagicLeapHandTrackingSourceFactory;
    }
    
    enum EMagicLeapHandTrackingGesture { Finger, Fist, Pinch, Thumb, L, OpenHand, OpenHandBack, Ok, C, NoPose, NoHand, EMagicLeapHandTrackingGesture_MAX}
    enum EMagicLeapHandTrackingKeypointFilterLevel { NoFilter, SimpleSmoothing, PredictiveSmoothing, EMagicLeapHandTrackingKeypointFilterLevel_MAX}
    enum EMagicLeapHandTrackingGestureFilterLevel { NoFilter, SlightRobustnessToFlicker, MoreRobustnessToFlicker, EMagicLeapHandTrackingGestureFilterLevel_MAX}
    class LiveLinkSourceHandle {
        constructor();
    }
    
    enum EMagicLeapGestureTransformSpace { World, Hand, Tracking, EMagicLeapGestureTransformSpace_MAX}
    enum EMagicLeapHandTrackingKeypoint { Thumb_Tip, Thumb_IP, Thumb_MCP, Thumb_CMC, Index_Tip, Index_DIP, Index_PIP, Index_MCP, Middle_Tip, Middle_DIP, Middle_PIP, Middle_MCP, Ring_Tip, Ring_DIP, Ring_PIP, Ring_MCP, Pinky_Tip, Pinky_DIP, Pinky_PIP, Pinky_MCP, Wrist_Center, Wrist_Ulnar, Wrist_Radial, Hand_Center, EMagicLeapHandTrackingKeypoint_MAX}
    class MagicLeapHandTrackingFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetStaticGestureConfidenceThreshold(Gesture: EMagicLeapHandTrackingGesture, Confidence: number): void;
        static SetConfiguration(StaticGesturesToActivate: TArray<EMagicLeapHandTrackingGesture>, KeypointsFilterLevel: EMagicLeapHandTrackingKeypointFilterLevel, GestureFilterLevel: EMagicLeapHandTrackingGestureFilterLevel, bTrackingEnabled: boolean): boolean;
        static GetStaticGestureConfidenceThreshold(Gesture: EMagicLeapHandTrackingGesture): number;
        static GetMagicLeapHandTrackingLiveLinkSource(SourceHandle: $Ref<LiveLinkSourceHandle>): boolean;
        static GetHandThumbTip(Hand: EControllerHand, TransformSpace: EMagicLeapGestureTransformSpace, Secondary: $Ref<Transform>): boolean;
        static GetHandIndexFingerTip(Hand: EControllerHand, TransformSpace: EMagicLeapGestureTransformSpace, Pointer: $Ref<Transform>): boolean;
        static GetHandCenterNormalized(Hand: EControllerHand, HandCenterNormalized: $Ref<Vector>): boolean;
        static GetHandCenter(Hand: EControllerHand, HandCenter: $Ref<Transform>): boolean;
        static GetGestureKeypointTransform(Hand: EControllerHand, Keypoint: EMagicLeapHandTrackingKeypoint, TransformSpace: EMagicLeapGestureTransformSpace, Transform: $Ref<Transform>): boolean;
        static GetGestureKeypoints(Hand: EControllerHand, Keypoints: $Ref<TArray<Transform>>): boolean;
        static GetCurrentGestureConfidence(Hand: EControllerHand, Confidence: $Ref<number>): boolean;
        static GetCurrentGesture(Hand: EControllerHand, Gesture: $Ref<EMagicLeapHandTrackingGesture>): boolean;
        static GetConfiguration(ActiveStaticGestures: $Ref<TArray<EMagicLeapHandTrackingGesture>>, KeypointsFilterLevel: $Ref<EMagicLeapHandTrackingKeypointFilterLevel>, GestureFilterLevel: $Ref<EMagicLeapHandTrackingGestureFilterLevel>, bTrackingEnabled: $Ref<boolean>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapHandTrackingFunctionLibrary;
        static Load(InName: string): MagicLeapHandTrackingFunctionLibrary;
    }
    
    class MagicLeapImageTrackerComponent extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetImageTexture: Texture2D;
        Name: string;
        LongerDimension: number;
        bIsStationary: boolean;
        bUseUnreliablePose: boolean;
        OnSetImageTargetSucceeded: $MulticastDelegate<() => void>;
        OnSetImageTargetFailed: $MulticastDelegate<() => void>;
        OnImageTargetFound: $MulticastDelegate<() => void>;
        OnImageTargetLost: $MulticastDelegate<() => void>;
        OnImageTargetUnreliableTracking: $MulticastDelegate<(LastTrackedLocation: Vector, LastTrackedRotation: Rotator, NewUnreliableLocation: Vector, NewUnreliableRotation: Rotator) => void>;
        SetTargetAsync(ImageTarget: Texture2D): boolean;
        RemoveTargetAsync(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapImageTrackerComponent;
        static Load(InName: string): MagicLeapImageTrackerComponent;
    }
    
    class MagicLeapImageTrackerFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetMaxSimultaneousTargets(MaxSimultaneousTargets: number): void;
        static IsImageTrackingEnabled(): boolean;
        static GetMaxSimultaneousTargets(): number;
        static EnableImageTracking(bEnable: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapImageTrackerFunctionLibrary;
        static Load(InName: string): MagicLeapImageTrackerFunctionLibrary;
    }
    
    class MagicLeapSecureStorage extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static PutSecureVector(Key: string, DataToStore: Vector): boolean;
        static PutSecureTransform(Key: string, DataToStore: Transform): boolean;
        static PutSecureString(Key: string, DataToStore: string): boolean;
        static PutSecureSaveGame(Key: string, ObjectToStore: SaveGame): boolean;
        static PutSecureRotator(Key: string, DataToStore: Rotator): boolean;
        static PutSecureInt64(Key: string, DataToStore: bigint): boolean;
        static PutSecureInt(Key: string, DataToStore: number): boolean;
        static PutSecureFloat(Key: string, DataToStore: number): boolean;
        static PutSecureByte(Key: string, DataToStore: number): boolean;
        static PutSecureBool(Key: string, DataToStore: boolean): boolean;
        static PutSecureArray(Key: string, DataToStore: TArray<number>): boolean;
        static GetSecureVector(Key: string, DataToRetrieve: $Ref<Vector>): boolean;
        static GetSecureTransform(Key: string, DataToRetrieve: $Ref<Transform>): boolean;
        static GetSecureString(Key: string, DataToRetrieve: $Ref<string>): boolean;
        static GetSecureSaveGame(Key: string, ObjectToRetrieve: $Ref<SaveGame>): boolean;
        static GetSecureRotator(Key: string, DataToRetrieve: $Ref<Rotator>): boolean;
        static GetSecureInt64(Key: string, DataToRetrieve: $Ref<bigint>): boolean;
        static GetSecureInt(Key: string, DataToRetrieve: $Ref<number>): boolean;
        static GetSecureFloat(Key: string, DataToRetrieve: $Ref<number>): boolean;
        static GetSecureByte(Key: string, DataToRetrieve: $Ref<number>): boolean;
        static GetSecureBool(Key: string, DataToRetrieve: $Ref<boolean>): boolean;
        static GetSecureArray(Key: string, DataToRetrieve: $Ref<TArray<number>>): boolean;
        static DeleteSecureData(Key: string): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapSecureStorage;
        static Load(InName: string): MagicLeapSecureStorage;
    }
    
    enum EMagicLeapIdentityError { Ok, InvalidParam, AllocFailed, PrivilegeDenied, FailedToConnectToLocalService, FailedToConnectToCloudService, CloudAuthentication, InvalidInformationFromCloud, NotLoggedIn, ExpiredCredentials, FailedToGetUserProfile, Unauthorized, CertificateError, RejectedByCloud, AlreadyLoggedIn, ModifyIsNotSupported, NetworkError, UnspecifiedFailure, EMagicLeapIdentityError_MAX}
    enum EMagicLeapIdentityKey { GivenName, FamilyName, Email, Bio, PhoneNumber, Avatar2D, Avatar3D, Unknown, EMagicLeapIdentityKey_MAX}
    class MagicLeapIdentityAttribute {
        constructor(Attribute: EMagicLeapIdentityKey, Value: string);
        Attribute: EMagicLeapIdentityKey;
        Value: string;
    }
    
    class MagicLeapIdentity extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RequestIdentityAttributeValueDelegate__DelegateSignature(ResultCode: EMagicLeapIdentityError, AttributeValue: TArray<MagicLeapIdentityAttribute>): void;
        RequestAttributeValueAsync(RequestedAttributeList: TArray<EMagicLeapIdentityKey>, ResultDelegate: $Delegate<(ResultCode: EMagicLeapIdentityError, AttributeValue: TArray<MagicLeapIdentityAttribute>) => void>): EMagicLeapIdentityError;
        RequestAttributeValue(RequestedAttributeList: TArray<EMagicLeapIdentityKey>, RequestedAttributeValues: $Ref<TArray<MagicLeapIdentityAttribute>>): EMagicLeapIdentityError;
        ModifyIdentityAttributeValueDelegate__DelegateSignature(ResultCode: EMagicLeapIdentityError, AttributesUpdatedSuccessfully: TArray<EMagicLeapIdentityKey>): void;
        GetAllAvailableAttributesAsync(ResultDelegate: $Delegate<(ResultCode: EMagicLeapIdentityError, AvailableAttributes: TArray<EMagicLeapIdentityKey>) => void>): void;
        GetAllAvailableAttributes(AvailableAttributes: $Ref<TArray<EMagicLeapIdentityKey>>): EMagicLeapIdentityError;
        AvailableIdentityAttributesDelegate__DelegateSignature(ResultCode: EMagicLeapIdentityError, AvailableAttributes: TArray<EMagicLeapIdentityKey>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapIdentity;
        static Load(InName: string): MagicLeapIdentity;
    }
    
    class TcpMessagingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnableTransport: boolean;
        ListenEndpoint: string;
        ConnectToEndpoints: TArray<string>;
        ConnectionRetryDelay: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TcpMessagingSettings;
        static Load(InName: string): TcpMessagingSettings;
    }
    
    class UdpMessagingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnableTransport: boolean;
        bAutoRepair: boolean;
        UnicastEndpoint: string;
        MulticastEndpoint: string;
        MulticastTimeToLive: number;
        StaticEndpoints: TArray<string>;
        EnableTunnel: boolean;
        TunnelUnicastEndpoint: string;
        TunnelMulticastEndpoint: string;
        RemoteTunnelEndpoints: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UdpMessagingSettings;
        static Load(InName: string): UdpMessagingSettings;
    }
    
    enum EActorSequenceObjectReferenceType { ContextActor, ExternalActor, Component, EActorSequenceObjectReferenceType_MAX}
    class ActorSequenceObjectReference {
        constructor(Type: EActorSequenceObjectReferenceType, ActorId: Guid, PathToComponent: string);
        Type: EActorSequenceObjectReferenceType;
        ActorId: Guid;
        PathToComponent: string;
    }
    
    class ActorSequenceObjectReferences {
        constructor(Array: TArray<ActorSequenceObjectReference>);
        Array: TArray<ActorSequenceObjectReference>;
    }
    
    class ActorSequenceObjectReferenceMap {
        constructor(BindingIds: TArray<Guid>, References: TArray<ActorSequenceObjectReferences>);
        BindingIds: TArray<Guid>;
        References: TArray<ActorSequenceObjectReferences>;
    }
    
    class ActorSequence extends MovieSceneSequence {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MovieScene: MovieScene;
        ObjectReferences: ActorSequenceObjectReferenceMap;
        bHasBeenInitialized: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorSequence;
        static Load(InName: string): ActorSequence;
    }
    
    class ActorSequencePlayer extends MovieSceneSequencePlayer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorSequencePlayer;
        static Load(InName: string): ActorSequencePlayer;
    }
    
    class ActorSequenceComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PlaybackSettings: MovieSceneSequencePlaybackSettings;
        Sequence: ActorSequence;
        SequencePlayer: ActorSequencePlayer;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorSequenceComponent;
        static Load(InName: string): ActorSequenceComponent;
    }
    
    enum ELocationAccuracy { LA_ThreeKilometers, LA_OneKilometer, LA_HundredMeters, LA_TenMeters, LA_Best, LA_Navigation, LA_MAX}
    class LocationServicesData {
        constructor(Timestamp: number, Longitude: number, Latitude: number, HorizontalAccuracy: number, VerticalAccuracy: number, Altitude: number);
        Timestamp: number;
        Longitude: number;
        Latitude: number;
        HorizontalAccuracy: number;
        VerticalAccuracy: number;
        Altitude: number;
    }
    
    class LocationServicesImpl extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnLocationChanged: $MulticastDelegate<(LocationData: LocationServicesData) => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocationServicesImpl;
        static Load(InName: string): LocationServicesImpl;
    }
    
    class LocationServices extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StopLocationServices(): boolean;
        static StartLocationServices(): boolean;
        static IsLocationAccuracyAvailable(Accuracy: ELocationAccuracy): boolean;
        static InitLocationServices(Accuracy: ELocationAccuracy, UpdateFrequency: number, MinDistanceFilter: number): boolean;
        static GetLocationServicesImpl(): LocationServicesImpl;
        static GetLastKnownLocation(): LocationServicesData;
        static AreLocationServicesEnabled(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocationServices;
        static Load(InName: string): LocationServices;
    }
    
    class WheelSetup {
        constructor(WheelClass: Class, BoneName: string, AdditionalOffset: Vector, bDisableSteering: boolean);
        WheelClass: Class;
        BoneName: string;
        AdditionalOffset: Vector;
        bDisableSteering: boolean;
    }
    
    class TireConfigMaterialFriction {
        constructor(PhysicalMaterial: PhysicalMaterial, FrictionScale: number);
        PhysicalMaterial: PhysicalMaterial;
        FrictionScale: number;
    }
    
    class TireConfig extends DataAsset {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrictionScale: number;
        TireFrictionScales: TArray<TireConfigMaterialFriction>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TireConfig;
        static Load(InName: string): TireConfig;
    }
    
    class VehicleWheel extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CollisionMesh: StaticMesh;
        bDontCreateShape: boolean;
        bAutoAdjustCollisionSize: boolean;
        Offset: Vector;
        ShapeRadius: number;
        ShapeWidth: number;
        Mass: number;
        DampingRate: number;
        SteerAngle: number;
        bAffectedByHandbrake: boolean;
        TireType: TireType;
        TireConfig: TireConfig;
        LatStiffMaxLoad: number;
        LatStiffValue: number;
        LongStiffValue: number;
        SuspensionForceOffset: number;
        SuspensionMaxRaise: number;
        SuspensionMaxDrop: number;
        SuspensionNaturalFrequency: number;
        SuspensionDampingRatio: number;
        SweepType: number;
        MaxBrakeTorque: number;
        MaxHandBrakeTorque: number;
        VehicleSim: WheeledVehicleMovementComponent;
        WheelIndex: number;
        DebugLongSlip: number;
        DebugLatSlip: number;
        DebugNormalizedTireLoad: number;
        DebugWheelTorque: number;
        DebugLongForce: number;
        DebugLatForce: number;
        Location: Vector;
        OldLocation: Vector;
        Velocity: Vector;
        IsInAir(): boolean;
        GetSuspensionOffset(): number;
        GetSteerAngle(): number;
        GetRotationAngle(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VehicleWheel;
        static Load(InName: string): VehicleWheel;
    }
    
    class ReplicatedVehicleState {
        constructor(SteeringInput: number, ThrottleInput: number, BrakeInput: number, HandbrakeInput: number, CurrentGear: number);
        SteeringInput: number;
        ThrottleInput: number;
        BrakeInput: number;
        HandbrakeInput: number;
        CurrentGear: number;
    }
    
    class VehicleInputRate {
        constructor(RiseRate: number, FallRate: number);
        RiseRate: number;
        FallRate: number;
    }
    
    class WheeledVehicleMovementComponent extends PawnMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDeprecatedSpringOffsetMode: boolean;
        bReverseAsBrake: boolean;
        bUseRVOAvoidance: boolean;
        bRawHandbrakeInput: boolean;
        bRawGearUpInput: boolean;
        bRawGearDownInput: boolean;
        bWasAvoidanceUpdated: boolean;
        Mass: number;
        WheelSetups: TArray<WheelSetup>;
        DragCoefficient: number;
        ChassisWidth: number;
        ChassisHeight: number;
        DragArea: number;
        EstimatedMaxEngineSpeed: number;
        MaxEngineRPM: number;
        DebugDragMagnitude: number;
        InertiaTensorScale: Vector;
        MinNormalizedTireLoad: number;
        MinNormalizedTireLoadFiltered: number;
        MaxNormalizedTireLoad: number;
        MaxNormalizedTireLoadFiltered: number;
        ThresholdLongitudinalSpeed: number;
        LowForwardSpeedSubStepCount: number;
        HighForwardSpeedSubStepCount: number;
        Wheels: TArray<VehicleWheel>;
        RVOAvoidanceRadius: number;
        RVOAvoidanceHeight: number;
        AvoidanceConsiderationRadius: number;
        RVOSteeringStep: number;
        RVOThrottleStep: number;
        AvoidanceUID: number;
        AvoidanceGroup: NavAvoidanceMask;
        GroupsToAvoid: NavAvoidanceMask;
        GroupsToIgnore: NavAvoidanceMask;
        AvoidanceWeight: number;
        PendingLaunchVelocity: Vector;
        ReplicatedState: ReplicatedVehicleState;
        RawSteeringInput: number;
        RawThrottleInput: number;
        RawBrakeInput: number;
        SteeringInput: number;
        ThrottleInput: number;
        BrakeInput: number;
        HandbrakeInput: number;
        IdleBrakeInput: number;
        StopThreshold: number;
        WrongDirectionThreshold: number;
        ThrottleInputRate: VehicleInputRate;
        BrakeInputRate: VehicleInputRate;
        HandbrakeInputRate: VehicleInputRate;
        SteeringInputRate: VehicleInputRate;
        OverrideController: Controller;
        SetUseAutoGears(bUseAuto: boolean): void;
        SetThrottleInput(Throttle: number): void;
        SetTargetGear(GearNum: number, bImmediate: boolean): void;
        SetSteeringInput(Steering: number): void;
        SetHandbrakeInput(bNewHandbrake: boolean): void;
        SetGroupsToIgnoreMask(GroupMask: NavAvoidanceMask): void;
        SetGroupsToIgnore(GroupFlags: number): void;
        SetGroupsToAvoidMask(GroupMask: NavAvoidanceMask): void;
        SetGroupsToAvoid(GroupFlags: number): void;
        SetGearUp(bNewGearUp: boolean): void;
        SetGearDown(bNewGearDown: boolean): void;
        SetBrakeInput(Brake: number): void;
        SetAvoidanceGroupMask(GroupMask: NavAvoidanceMask): void;
        SetAvoidanceGroup(GroupFlags: number): void;
        SetAvoidanceEnabled(bEnable: boolean): void;
        ServerUpdateState(InSteeringInput: number, InThrottleInput: number, InBrakeInput: number, InHandbrakeInput: number, CurrentGear: number): void;
        GetUseAutoGears(): boolean;
        GetTargetGear(): number;
        GetForwardSpeed(): number;
        GetEngineRotationSpeed(): number;
        GetEngineMaxRotationSpeed(): number;
        GetCurrentGear(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WheeledVehicleMovementComponent;
        static Load(InName: string): WheeledVehicleMovementComponent;
    }
    
    class SimpleWheeledVehicleMovementComponent extends WheeledVehicleMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetSteerAngle(SteerAngle: number, WheelIndex: number): void;
        SetDriveTorque(DriveTorque: number, WheelIndex: number): void;
        SetBrakeTorque(BrakeTorque: number, WheelIndex: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SimpleWheeledVehicleMovementComponent;
        static Load(InName: string): SimpleWheeledVehicleMovementComponent;
    }
    
    class WheeledVehicle extends Pawn {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mesh: SkeletalMeshComponent;
        VehicleMovement: WheeledVehicleMovementComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WheeledVehicle;
        static Load(InName: string): WheeledVehicle;
    }
    
    class VehicleAnimInstance extends AnimInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WheeledVehicleMovementComponent: WheeledVehicleMovementComponent;
        GetVehicle(): WheeledVehicle;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VehicleAnimInstance;
        static Load(InName: string): VehicleAnimInstance;
    }
    
    class VehicleEngineData {
        constructor(TorqueCurve: RuntimeFloatCurve, MaxRPM: number, MOI: number, DampingRateFullThrottle: number, DampingRateZeroThrottleClutchEngaged: number, DampingRateZeroThrottleClutchDisengaged: number);
        TorqueCurve: RuntimeFloatCurve;
        MaxRPM: number;
        MOI: number;
        DampingRateFullThrottle: number;
        DampingRateZeroThrottleClutchEngaged: number;
        DampingRateZeroThrottleClutchDisengaged: number;
    }
    
    class VehicleDifferential4WData {
        constructor(DifferentialType: number, FrontRearSplit: number, FrontLeftRightSplit: number, RearLeftRightSplit: number, CentreBias: number, FrontBias: number, RearBias: number);
        DifferentialType: number;
        FrontRearSplit: number;
        FrontLeftRightSplit: number;
        RearLeftRightSplit: number;
        CentreBias: number;
        FrontBias: number;
        RearBias: number;
    }
    
    class VehicleGearData {
        constructor(Ratio: number, DownRatio: number, UpRatio: number);
        Ratio: number;
        DownRatio: number;
        UpRatio: number;
    }
    
    class VehicleTransmissionData {
        constructor(bUseGearAutoBox: boolean, GearSwitchTime: number, GearAutoBoxLatency: number, FinalRatio: number, ForwardGears: TArray<VehicleGearData>, ReverseGearRatio: number, NeutralGearUpRatio: number, ClutchStrength: number);
        bUseGearAutoBox: boolean;
        GearSwitchTime: number;
        GearAutoBoxLatency: number;
        FinalRatio: number;
        ForwardGears: TArray<VehicleGearData>;
        ReverseGearRatio: number;
        NeutralGearUpRatio: number;
        ClutchStrength: number;
    }
    
    class WheeledVehicleMovementComponent4W extends WheeledVehicleMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EngineSetup: VehicleEngineData;
        DifferentialSetup: VehicleDifferential4WData;
        AckermannAccuracy: number;
        TransmissionSetup: VehicleTransmissionData;
        SteeringCurve: RuntimeFloatCurve;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WheeledVehicleMovementComponent4W;
        static Load(InName: string): WheeledVehicleMovementComponent4W;
    }
    
    class AnimNode_WheelHandler extends AnimNode_SkeletalControlBase {
        constructor();
    }
    
    class AnimGraphNode_WheelHandler extends AnimGraphNode_SkeletalControlBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_WheelHandler;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_WheelHandler;
        static Load(InName: string): AnimGraphNode_WheelHandler;
    }
    
    class DynamicDelegateProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Fire(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DynamicDelegateProxy;
        static Load(InName: string): DynamicDelegateProxy;
    }
    
    class ExtensionMethods extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ExtensionMethods;
        static Load(InName: string): ExtensionMethods;
    }
    
    class JSAnimGeneratedClass extends AnimBlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSAnimGeneratedClass;
        static Load(InName: string): JSAnimGeneratedClass;
    }
    
    class JSGeneratedClass extends BlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSGeneratedClass;
        static Load(InName: string): JSGeneratedClass;
    }
    
    class JSGeneratedFunction extends Function {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSGeneratedFunction;
        static Load(InName: string): JSGeneratedFunction;
    }
    
    class JSWidgetGeneratedClass extends WidgetBlueprintGeneratedClass {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSWidgetGeneratedClass;
        static Load(InName: string): JSWidgetGeneratedClass;
    }
    
    class ReactWidget extends UserWidget {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RemoveChild(Content: Widget): boolean;
        AddChild(Content: Widget): PanelSlot;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReactWidget;
        static Load(InName: string): ReactWidget;
    }
    
    class UMGManager extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SynchronizeWidgetProperties(Widget: Widget): void;
        static SynchronizeSlotProperties(Slot: PanelSlot): void;
        static CreateWidget(World: World, Class: Class): UserWidget;
        static CreateReactWidget(World: World): ReactWidget;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UMGManager;
        static Load(InName: string): UMGManager;
    }
    
    enum EnumInt32 { VM1, V0, V1, V2, V3, EnumInt32_MAX}
    enum EnumInt8Min { VINT8_MIN, VINT8_MAX}
    enum EnumInt8Max { VINT8_MAX}
    class ContainersTest extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Int32Array: TArray<number>;
        Int32ArrayWithInit: TArray<number>;
        UInt32Array: TArray<number>;
        Int64Array: TArray<bigint>;
        UInt64Array: TArray<bigint>;
        FloatArray: TArray<number>;
        DoubleArray: TArray<number>;
        BoolArray: TArray<boolean>;
        EnumInt32Array: TArray<EnumInt32>;
        EnumInt8MinArray: TArray<EnumInt8Min>;
        EnumInt8MaxArray: TArray<EnumInt8Max>;
        FStringArray: TArray<string>;
        FNameArray: TArray<string>;
        FTextArray: TArray<string>;
        Int32FixSizeArray: FixSizeArray<number>;
        Int32Set: TSet<number>;
        FStringSet: TSet<string>;
        Int32ToStrMap: TMap<number, string>;
        StrToStrMap: TMap<string, string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ContainersTest;
        static Load(InName: string): ContainersTest;
    }
    
    class JSBlueprintFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static Info(To: Class): void;
        static Hello(To: string): string;
        static GetName(): string;
        static Concat(First: string, Second: string): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): JSBlueprintFunctionLibrary;
        static Load(InName: string): JSBlueprintFunctionLibrary;
    }
    
    class MainActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NotifyWithInt: $MulticastDelegate<(A: number) => void>;
        NotifyWithString: $Delegate<(A: string) => void>;
        NotifyWithRefString: $Delegate<(A: $Ref<string>) => void>;
        NotifyWithStringRet: $Delegate<(A: string) => string>;
        NotifyWithNothing: $MulticastDelegate<() => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MainActor;
        static Load(InName: string): MainActor;
    }
    
    class SomeData {
        constructor(Alignment: Vector2D, WillSerialize: number);
        Alignment: Vector2D;
        WillSerialize: number;
    }
    
    enum EToTest { V0, V1, V13, EToTest_MAX}
    class MainObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SomeData: SomeData;
        V: Vector;
        MyFixSizeArray: FixSizeArray<number>;
        MyArray: TArray<number>;
        MySet: TSet<string>;
        MyMap: TMap<string, number>;
        MyString: string;
        ArrayBuffer: ArrayBuffer;
        PrintState(): void;
        GetStrings(): TArray<string>;
        GetInts(): TArray<number>;
        GetData(): TArray<number>;
        Foo(): string;
        EnumTest(E: EToTest): void;
        Bar3(V: $Ref<Vector>): Vector;
        Bar2(V: $Ref<Vector>): string;
        Bar(V: Vector): string;
        ArrayBufferTest(Ab: ArrayBuffer): ArrayBuffer;
        Add(a: number, b: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MainObject;
        static Load(InName: string): MainObject;
    }
    
    class ObjectExtensionMethods extends ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static IsValid(Object: Object): boolean;
        static GetWorld(Object: Object): World;
        static GetOuter(Object: Object): Object;
        static GetName(Object: Object): string;
        static GetClass(Object: Object): Class;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ObjectExtensionMethods;
        static Load(InName: string): ObjectExtensionMethods;
    }
    
    class puerts_unreal_demoGameModeBase extends GameModeBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): puerts_unreal_demoGameModeBase;
        static Load(InName: string): puerts_unreal_demoGameModeBase;
    }
    
    class TextureImage extends Image {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bMatchSize: boolean;
        TextureName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TextureImage;
        static Load(InName: string): TextureImage;
    }
    
    class TGUnitTestCallee extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StrArgIntRet(Str: string): number;
        RetInt(): number;
        NoArgNoRet(): void;
        IntArgIntRet(Arg: number): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TGUnitTestCallee;
        static Load(InName: string): TGUnitTestCallee;
    }
    
    class TsGameInstance extends GameInstance {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TsGameInstance;
        static Load(InName: string): TsGameInstance;
    }
    
    class VectorExtensionMethods extends ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static ToString(This: $Ref<Vector>): string;
        static Set(This: $Ref<Vector>, InX: number, InY: number, InZ: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VectorExtensionMethods;
        static Load(InName: string): VectorExtensionMethods;
    }
    
    class WorldExtensionMethods extends ExtensionMethods {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SpawnActor(World: World, Class: Class, Transform: Transform, SpawnCollisionHandlingOverride: ESpawnActorCollisionHandlingMethod, Owner: Actor, Instigator: Pawn): Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WorldExtensionMethods;
        static Load(InName: string): WorldExtensionMethods;
    }
    
    enum EMeshPaintColorViewMode { Normal, RGB, Alpha, Red, Green, Blue, EMeshPaintColorViewMode_MAX}
    class PaintBrushSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BrushRadius: number;
        BrushStrength: number;
        BrushFalloffAmount: number;
        bEnableFlow: boolean;
        bOnlyFrontFacingTriangles: boolean;
        ColorViewMode: EMeshPaintColorViewMode;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaintBrushSettings;
        static Load(InName: string): PaintBrushSettings;
    }
    
    class MeshPaintSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VertexPreviewSize: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshPaintSettings;
        static Load(InName: string): MeshPaintSettings;
    }
    
    class VertexColorImportOptions extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UVIndex: number;
        LODIndex: number;
        bRed: boolean;
        bBlue: boolean;
        bGreen: boolean;
        bAlpha: boolean;
        bImportToInstance: boolean;
        bCanImportToInstance: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VertexColorImportOptions;
        static Load(InName: string): VertexColorImportOptions;
    }
    
    class FlipbookEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BackgroundColor: Color;
        bShowGridByDefault: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FlipbookEditorSettings;
        static Load(InName: string): FlipbookEditorSettings;
    }
    
    enum ESpriteExtractMode { Auto, Grid, ESpriteExtractMode_MAX}
    class PaperExtractSpritesSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteExtractMode: ESpriteExtractMode;
        OutlineColor: LinearColor;
        ViewportTextureTint: LinearColor;
        BackgroundColor: LinearColor;
        NamingTemplate: string;
        NamingStartIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperExtractSpritesSettings;
        static Load(InName: string): PaperExtractSpritesSettings;
    }
    
    class PaperExtractSpriteGridSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CellWidth: number;
        CellHeight: number;
        NumCellsX: number;
        NumCellsY: number;
        MarginX: number;
        MarginY: number;
        SpacingX: number;
        SpacingY: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperExtractSpriteGridSettings;
        static Load(InName: string): PaperExtractSpriteGridSettings;
    }
    
    class PaperFlipbookActorFactory extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookActorFactory;
        static Load(InName: string): PaperFlipbookActorFactory;
    }
    
    class PaperFlipbookFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookFactory;
        static Load(InName: string): PaperFlipbookFactory;
    }
    
    class PaperSpriteThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteThumbnailRenderer;
        static Load(InName: string): PaperSpriteThumbnailRenderer;
    }
    
    class PaperFlipbookThumbnailRenderer extends PaperSpriteThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperFlipbookThumbnailRenderer;
        static Load(InName: string): PaperFlipbookThumbnailRenderer;
    }
    
    class PaperImporterSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bPickBestMaterialWhenCreatingSprites: boolean;
        bPickBestMaterialWhenCreatingTileMaps: boolean;
        bAnalysisCanUseOpaque: boolean;
        DefaultPixelsPerUnrealUnit: number;
        NormalMapTextureSuffixes: TArray<string>;
        BaseMapTextureSuffixes: TArray<string>;
        DefaultSpriteTextureGroup: number;
        bOverrideTextureCompression: boolean;
        DefaultSpriteTextureCompression: number;
        UnlitDefaultMaskedMaterialName: SoftObjectPath;
        UnlitDefaultTranslucentMaterialName: SoftObjectPath;
        UnlitDefaultOpaqueMaterialName: SoftObjectPath;
        LitDefaultMaskedMaterialName: SoftObjectPath;
        LitDefaultTranslucentMaterialName: SoftObjectPath;
        LitDefaultOpaqueMaterialName: SoftObjectPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperImporterSettings;
        static Load(InName: string): PaperImporterSettings;
    }
    
    class PaperSpriteActorFactory extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteActorFactory;
        static Load(InName: string): PaperSpriteActorFactory;
    }
    
    class PaperSpriteAtlasFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteAtlasFactory;
        static Load(InName: string): PaperSpriteAtlasFactory;
    }
    
    class PaperSpriteFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteFactory;
        static Load(InName: string): PaperSpriteFactory;
    }
    
    class PaperTileMapFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapFactory;
        static Load(InName: string): PaperTileMapFactory;
    }
    
    class PaperTileMapPromotionFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetToRename: PaperTileMap;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileMapPromotionFactory;
        static Load(InName: string): PaperTileMapPromotionFactory;
    }
    
    class PaperTileSetFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileSetFactory;
        static Load(InName: string): PaperTileSetFactory;
    }
    
    class PaperTileSetThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTileSetThumbnailRenderer;
        static Load(InName: string): PaperTileSetThumbnailRenderer;
    }
    
    class SpriteEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BackgroundColor: Color;
        bShowGridByDefault: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpriteEditorSettings;
        static Load(InName: string): SpriteEditorSettings;
    }
    
    class TerrainSplineActorFactory extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TerrainSplineActorFactory;
        static Load(InName: string): TerrainSplineActorFactory;
    }
    
    class TileMapActorFactory extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapActorFactory;
        static Load(InName: string): TileMapActorFactory;
    }
    
    class TileSetImportMapping {
        constructor(SourceName: string, ImportedTileSet: TWeakObjectPtr<PaperTileSet>, ImportedTexture: TWeakObjectPtr<Texture>);
        SourceName: string;
        ImportedTileSet: TWeakObjectPtr<PaperTileSet>;
        ImportedTexture: TWeakObjectPtr<Texture>;
    }
    
    class TileMapAssetImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TileSetMap: TArray<TileSetImportMapping>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapAssetImportData;
        static Load(InName: string): TileMapAssetImportData;
    }
    
    class TileMapEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultBackgroundColor: Color;
        bShowGridByDefault: boolean;
        DefaultTileGridColor: Color;
        DefaultMultiTileGridColor: Color;
        DefaultMultiTileGridWidth: number;
        DefaultMultiTileGridHeight: number;
        DefaultMultiTileGridOffsetX: number;
        DefaultMultiTileGridOffsetY: number;
        DefaultLayerGridColor: Color;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileMapEditorSettings;
        static Load(InName: string): TileMapEditorSettings;
    }
    
    class TileSetEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultBackgroundColor: Color;
        bShowGridByDefault: boolean;
        ExtrusionAmount: number;
        bPadToPowerOf2: boolean;
        bFillWithTransparentBlack: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileSetEditorSettings;
        static Load(InName: string): TileSetEditorSettings;
    }
    
    class TileSheetPaddingFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SourceTileSet: PaperTileSet;
        ExtrusionAmount: number;
        bPadToPowerOf2: boolean;
        bFillWithTransparentBlack: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TileSheetPaddingFactory;
        static Load(InName: string): TileSheetPaddingFactory;
    }
    
    class PaperSpriteSheet extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SpriteNames: TArray<string>;
        Sprites: TArray<TSoftObjectPtr<PaperSprite>>;
        TextureName: string;
        Texture: Texture2D;
        NormalMapTextureName: string;
        NormalMapTexture: Texture2D;
        AssetImportData: AssetImportData;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteSheet;
        static Load(InName: string): PaperSpriteSheet;
    }
    
    class PaperSpriteSheetImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteSheetImportFactory;
        static Load(InName: string): PaperSpriteSheetImportFactory;
    }
    
    class PaperSpriteSheetReimportFactory extends PaperSpriteSheetImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperSpriteSheetReimportFactory;
        static Load(InName: string): PaperSpriteSheetReimportFactory;
    }
    
    class PaperTiledImporterFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaperTiledImporterFactory;
        static Load(InName: string): PaperTiledImporterFactory;
    }
    
    class LightPropagationVolumeBlendableFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LightPropagationVolumeBlendableFactory;
        static Load(InName: string): LightPropagationVolumeBlendableFactory;
    }
    
    class ActorLayer {
        constructor(Name: string);
        Name: string;
    }
    
    class LayersBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RemoveActorFromLayer(InActor: Actor, Layer: ActorLayer): void;
        static GetActors(WorldContextObject: Object, ActorLayer: ActorLayer): TArray<Actor>;
        static AddActorToLayer(InActor: Actor, Layer: ActorLayer): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LayersBlueprintLibrary;
        static Load(InName: string): LayersBlueprintLibrary;
    }
    
    class AnimationSharingSetupFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimationSharingSetupFactory;
        static Load(InName: string): AnimationSharingSetupFactory;
    }
    
    class MyPluginStruct {
        constructor(TestString: string);
        TestString: string;
    }
    
    class MyPluginObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MyStruct: MyPluginStruct;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MyPluginObject;
        static Load(InName: string): MyPluginObject;
    }
    
    class CryptoKeysCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CryptoKeysCommandlet;
        static Load(InName: string): CryptoKeysCommandlet;
    }
    
    class CryptoEncryptionKey {
        constructor(Guid: Guid, Name: string, Key: string);
        Guid: Guid;
        Name: string;
        Key: string;
    }
    
    class CryptoKeysSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EncryptionKey: string;
        SecondaryEncryptionKeys: TArray<CryptoEncryptionKey>;
        bEncryptPakIniFiles: boolean;
        bEncryptPakIndex: boolean;
        bEncryptUAssetFiles: boolean;
        bEncryptAllAssetFiles: boolean;
        SigningPublicExponent: string;
        SigningModulus: string;
        SigningPrivateExponent: string;
        bEnablePakSigning: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CryptoKeysSettings;
        static Load(InName: string): CryptoKeysSettings;
    }
    
    enum ECurveEditorFFTFilterType { Lowpass, Highpass, ECurveEditorFFTFilterType_MAX}
    enum ECurveEditorFFTFilterClass { Butterworth, Chebyshev, ECurveEditorFFTFilterClass_MAX}
    class CurveEditorFFTFilter extends CurveEditorFilterBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CutoffFrequency: number;
        Type: ECurveEditorFFTFilterType;
        Response: ECurveEditorFFTFilterClass;
        Order: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorFFTFilter;
        static Load(InName: string): CurveEditorFFTFilter;
    }
    
    class CurveEditorRetimeAnchor {
        constructor(ValueInSeconds: number, bIsSelected: boolean);
        ValueInSeconds: number;
        bIsSelected: boolean;
    }
    
    class CurveEditorRetimeToolData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RetimingAnchors: TArray<CurveEditorRetimeAnchor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CurveEditorRetimeToolData;
        static Load(InName: string): CurveEditorRetimeToolData;
    }
    
    class NewPluginDescriptorData extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CreatedBy: string;
        CreatedByURL: string;
        Description: string;
        bIsBetaVersion: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NewPluginDescriptorData;
        static Load(InName: string): NewPluginDescriptorData;
    }
    
    class PluginMetadataObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Version: number;
        VersionName: string;
        FriendlyName: string;
        Description: string;
        Category: string;
        CreatedBy: string;
        CreatedByURL: string;
        DocsURL: string;
        MarketplaceURL: string;
        SupportURL: string;
        bCanContainContent: boolean;
        bIsBetaVersion: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PluginMetadataObject;
        static Load(InName: string): PluginMetadataObject;
    }
    
    class SpeedTreeImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpeedTreeImportFactory;
        static Load(InName: string): SpeedTreeImportFactory;
    }
    
    class ReimportSpeedTreeFactory extends SpeedTreeImportFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ReimportSpeedTreeFactory;
        static Load(InName: string): ReimportSpeedTreeFactory;
    }
    
    class SpeedTreeImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TreeScale: number;
        ImportGeometryType: number;
        LODType: number;
        IncludeCollision: boolean;
        MakeMaterialsCheck: boolean;
        IncludeNormalMapCheck: boolean;
        IncludeDetailMapCheck: boolean;
        IncludeSpecularMapCheck: boolean;
        IncludeBranchSeamSmoothing: boolean;
        IncludeSpeedTreeAO: boolean;
        IncludeColorAdjustment: boolean;
        IncludeSubsurface: boolean;
        IncludeVertexProcessingCheck: boolean;
        IncludeWindCheck: boolean;
        IncludeSmoothLODCheck: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SpeedTreeImportData;
        static Load(InName: string): SpeedTreeImportData;
    }
    
    class LevelVariantSetsActorFactory extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelVariantSetsActorFactory;
        static Load(InName: string): LevelVariantSetsActorFactory;
    }
    
    class VariantManagerFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantManagerFactoryNew;
        static Load(InName: string): VariantManagerFactoryNew;
    }
    
    enum EVariantManagerTestEnum { None, FirstOption, SecondOption, ThirdOption, EVariantManagerTestEnum_MAX}
    class VariantManagerTestActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EnumWithNoDefault: EVariantManagerTestEnum;
        EnumWithSecondDefault: EVariantManagerTestEnum;
        CapturedByteProperty: number;
        CapturedIntProperty: number;
        CapturedFloatProperty: number;
        bCapturedBoolProperty: boolean;
        CapturedObjectProperty: Object;
        CapturedInterfaceProperty: Interface;
        CapturedNameProperty: string;
        CapturedStrProperty: string;
        CapturedTextProperty: string;
        CapturedRotatorProperty: Rotator;
        CapturedColorProperty: Color;
        CapturedLinearColorProperty: LinearColor;
        CapturedVectorProperty: Vector;
        CapturedQuatProperty: Quat;
        CapturedVector4Property: Vector4;
        CapturedVector2DProperty: Vector2D;
        CapturedIntPointProperty: IntPoint;
        CapturedUObjectArrayProperty: TArray<Object>;
        CapturedVectorArrayProperty: TArray<Vector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VariantManagerTestActor;
        static Load(InName: string): VariantManagerTestActor;
    }
    
    class GeometryCacheTrack extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Duration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack;
        static Load(InName: string): GeometryCacheTrack;
    }
    
    class GeometryCache extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AssetImportData: AssetImportData;
        ThumbnailInfo: ThumbnailInfo;
        Materials: TArray<MaterialInterface>;
        Tracks: TArray<GeometryCacheTrack>;
        StartFrame: number;
        EndFrame: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCache;
        static Load(InName: string): GeometryCache;
    }
    
    class GeometryCacheComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCache: GeometryCache;
        bRunning: boolean;
        bLooping: boolean;
        StartTimeOffset: number;
        PlaybackSpeed: number;
        NumTracks: number;
        ElapsedTime: number;
        Duration: number;
        bManualTick: boolean;
        TickAtThisTime(Time: number, bInIsRunning: boolean, bInBackwards: boolean, bInIsLooping: boolean): void;
        Stop(): void;
        SetStartTimeOffset(NewStartTimeOffset: number): void;
        SetPlaybackSpeed(NewPlaybackSpeed: number): void;
        SetLooping(bNewLooping: boolean): void;
        SetGeometryCache(NewGeomCache: GeometryCache): boolean;
        PlayReversedFromEnd(): void;
        PlayReversed(): void;
        PlayFromStart(): void;
        Play(): void;
        Pause(): void;
        IsPlayingReversed(): boolean;
        IsPlaying(): boolean;
        IsLooping(): boolean;
        GetStartTimeOffset(): number;
        GetPlaybackSpeed(): number;
        GetPlaybackDirection(): number;
        GetNumberOfFrames(): number;
        GetDuration(): number;
        GetAnimationTime(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheComponent;
        static Load(InName: string): GeometryCacheComponent;
    }
    
    class GeometryCacheActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCacheComponent: GeometryCacheComponent;
        GetGeometryCacheComponent(): GeometryCacheComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheActor;
        static Load(InName: string): GeometryCacheActor;
    }
    
    class GeometryCacheCodecBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TopologyRanges: TArray<number>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheCodecBase;
        static Load(InName: string): GeometryCacheCodecBase;
    }
    
    class GeometryCacheCodecRaw extends GeometryCacheCodecBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DummyProperty: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheCodecRaw;
        static Load(InName: string): GeometryCacheCodecRaw;
    }
    
    class GeometryCacheCodecV1 extends GeometryCacheCodecBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheCodecV1;
        static Load(InName: string): GeometryCacheCodecV1;
    }
    
    class GeometryCacheMeshData {
        constructor();
    }
    
    class GeometryCacheTrack_FlipbookAnimation extends GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NumMeshSamples: number;
        AddMeshSample(MeshData: GeometryCacheMeshData, SampleTime: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack_FlipbookAnimation;
        static Load(InName: string): GeometryCacheTrack_FlipbookAnimation;
    }
    
    class GeometryCacheTrackStreamable extends GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Codec: GeometryCacheCodecBase;
        StartSampleTime: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrackStreamable;
        static Load(InName: string): GeometryCacheTrackStreamable;
    }
    
    class GeometryCacheTrack_TransformAnimation extends GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetMesh(NewMeshData: GeometryCacheMeshData): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack_TransformAnimation;
        static Load(InName: string): GeometryCacheTrack_TransformAnimation;
    }
    
    class GeometryCacheTrack_TransformGroupAnimation extends GeometryCacheTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetMesh(NewMeshData: GeometryCacheMeshData): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheTrack_TransformGroupAnimation;
        static Load(InName: string): GeometryCacheTrack_TransformGroupAnimation;
    }
    
    enum EAlembicSamplingType { PerFrame, PerXFrames, PerTimeStep, EAlembicSamplingType_MAX}
    class AbcSamplingSettings {
        constructor(SamplingType: EAlembicSamplingType, FrameSteps: number, TimeSteps: number, FrameStart: number, FrameEnd: number, bSkipEmpty: boolean);
        SamplingType: EAlembicSamplingType;
        FrameSteps: number;
        TimeSteps: number;
        FrameStart: number;
        FrameEnd: number;
        bSkipEmpty: boolean;
    }
    
    class AbcAssetImportData extends AssetImportData {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackNames: TArray<string>;
        SamplingSettings: AbcSamplingSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AbcAssetImportData;
        static Load(InName: string): AbcAssetImportData;
    }
    
    enum EAlembicImportType { StaticMesh, GeometryCache, Skeletal, EAlembicImportType_MAX}
    class AbcNormalGenerationSettings {
        constructor(bForceOneSmoothingGroupPerObject: boolean, HardEdgeAngleThreshold: number, bRecomputeNormals: boolean, bIgnoreDegenerateTriangles: boolean);
        bForceOneSmoothingGroupPerObject: boolean;
        HardEdgeAngleThreshold: number;
        bRecomputeNormals: boolean;
        bIgnoreDegenerateTriangles: boolean;
    }
    
    class AbcMaterialSettings {
        constructor(bCreateMaterials: boolean, bFindMaterials: boolean);
        bCreateMaterials: boolean;
        bFindMaterials: boolean;
    }
    
    enum EBaseCalculationType { None, PercentageBased, FixedNumber, EBaseCalculationType_MAX}
    class AbcCompressionSettings {
        constructor(bMergeMeshes: boolean, bBakeMatrixAnimation: boolean, BaseCalculationType: EBaseCalculationType, PercentageOfTotalBases: number, MaxNumberOfBases: number, MinimumNumberOfVertexInfluencePercentage: number);
        bMergeMeshes: boolean;
        bBakeMatrixAnimation: boolean;
        BaseCalculationType: EBaseCalculationType;
        PercentageOfTotalBases: number;
        MaxNumberOfBases: number;
        MinimumNumberOfVertexInfluencePercentage: number;
    }
    
    class AbcStaticMeshSettings {
        constructor(bMergeMeshes: boolean, bPropagateMatrixTransformations: boolean, bGenerateLightmapUVs: boolean);
        bMergeMeshes: boolean;
        bPropagateMatrixTransformations: boolean;
        bGenerateLightmapUVs: boolean;
    }
    
    class AbcGeometryCacheSettings {
        constructor(bFlattenTracks: boolean, bApplyConstantTopologyOptimizations: boolean, bCalculateMotionVectorsDuringImport: boolean, bOptimizeIndexBuffers: boolean, CompressedPositionPrecision: number, CompressedTextureCoordinatesNumberOfBits: number);
        bFlattenTracks: boolean;
        bApplyConstantTopologyOptimizations: boolean;
        bCalculateMotionVectorsDuringImport: boolean;
        bOptimizeIndexBuffers: boolean;
        CompressedPositionPrecision: number;
        CompressedTextureCoordinatesNumberOfBits: number;
    }
    
    enum EAbcConversionPreset { Maya, Max, Custom, EAbcConversionPreset_MAX}
    class AbcConversionSettings {
        constructor(Preset: EAbcConversionPreset, bFlipU: boolean, bFlipV: boolean, Scale: Vector, Rotation: Vector);
        Preset: EAbcConversionPreset;
        bFlipU: boolean;
        bFlipV: boolean;
        Scale: Vector;
        Rotation: Vector;
    }
    
    class AbcImportSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportType: EAlembicImportType;
        SamplingSettings: AbcSamplingSettings;
        NormalGenerationSettings: AbcNormalGenerationSettings;
        MaterialSettings: AbcMaterialSettings;
        CompressionSettings: AbcCompressionSettings;
        StaticMeshSettings: AbcStaticMeshSettings;
        GeometryCacheSettings: AbcGeometryCacheSettings;
        ConversionSettings: AbcConversionSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AbcImportSettings;
        static Load(InName: string): AbcImportSettings;
    }
    
    class AlembicTestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AlembicTestCommandlet;
        static Load(InName: string): AlembicTestCommandlet;
    }
    
    class AlembicImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ImportSettings: AbcImportSettings;
        bShowOption: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AlembicImportFactory;
        static Load(InName: string): AlembicImportFactory;
    }
    
    class ActorFactoryGeometryCache extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryGeometryCache;
        static Load(InName: string): ActorFactoryGeometryCache;
    }
    
    class GeometryCacheThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCacheThumbnailRenderer;
        static Load(InName: string): GeometryCacheThumbnailRenderer;
    }
    
    class AutomationUtilsBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static TakeGameplayAutomationScreenshot(ScreenshotName: string, MaxGlobalError: number, MaxLocalError: number, MapNameOverride: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AutomationUtilsBlueprintLibrary;
        static Load(InName: string): AutomationUtilsBlueprintLibrary;
    }
    
    class ScreenshotComparisonCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ScreenshotComparisonCommandlet;
        static Load(InName: string): ScreenshotComparisonCommandlet;
    }
    
    class MovieSceneGeometryCacheParams {
        constructor(GeometryCacheAsset: GeometryCache, FirstLoopStartFrameOffset: FrameNumber, StartFrameOffset: FrameNumber, EndFrameOffset: FrameNumber, PlayRate: number, bReverse: boolean, StartOffset: number, EndOffset: number, GeometryCache: SoftObjectPath);
        GeometryCacheAsset: GeometryCache;
        FirstLoopStartFrameOffset: FrameNumber;
        StartFrameOffset: FrameNumber;
        EndFrameOffset: FrameNumber;
        PlayRate: number;
        bReverse: boolean;
        StartOffset: number;
        EndOffset: number;
        GeometryCache: SoftObjectPath;
    }
    
    class MovieSceneGeometryCacheSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Params: MovieSceneGeometryCacheParams;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneGeometryCacheSection;
        static Load(InName: string): MovieSceneGeometryCacheSection;
    }
    
    class MovieSceneGeometryCacheTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AnimationSections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneGeometryCacheTrack;
        static Load(InName: string): MovieSceneGeometryCacheTrack;
    }
    
    class MagicLeapAudioFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetOnAudioJackUnpluggedDelegate(ResultDelegate: $Delegate<() => void>): boolean;
        static SetOnAudioJackPluggedDelegate(ResultDelegate: $Delegate<() => void>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapAudioFunctionLibrary;
        static Load(InName: string): MagicLeapAudioFunctionLibrary;
    }
    
    class ImgMediaSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DefaultFrameRate: FrameRate;
        CacheBehindPercentage: number;
        CacheSizeGB: number;
        CacheThreads: number;
        CacheThreadStackSizeKB: number;
        GlobalCacheSizeGB: number;
        UseGlobalCache: boolean;
        ExrDecoderThreads: number;
        DefaultProxy: string;
        UseDefaultProxy: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSettings;
        static Load(InName: string): ImgMediaSettings;
    }
    
    class ImgMediaSource extends BaseMediaSource {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        FrameRateOverride: FrameRate;
        ProxyOverride: string;
        SequencePath: DirectoryPath;
        SetSequencePath(Path: string): void;
        GetSequencePath(): string;
        GetProxies(OutProxies: $Ref<TArray<string>>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSource;
        static Load(InName: string): ImgMediaSource;
    }
    
    class MovieSceneMediaSection extends MovieSceneSection {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MediaSource: MediaSource;
        bLooping: boolean;
        StartFrameOffset: FrameNumber;
        MediaTexture: MediaTexture;
        MediaSoundComponent: MediaSoundComponent;
        bUseExternalMediaPlayer: boolean;
        ExternalMediaPlayer: MediaPlayer;
        ThumbnailReferenceOffset: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMediaSection;
        static Load(InName: string): MovieSceneMediaSection;
    }
    
    class MovieSceneMediaTrack extends MovieSceneNameableTrack {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MediaSections: TArray<MovieSceneSection>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneMediaTrack;
        static Load(InName: string): MovieSceneMediaTrack;
    }
    
    class NetPropertyHook extends Property {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetPropertyHook;
        static Load(InName: string): NetPropertyHook;
    }
    
    class UnitTestBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestBase;
        static Load(InName: string): UnitTestBase;
    }
    
    class UnitTask extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTask;
        static Load(InName: string): UnitTask;
    }
    
    enum EUnitTestVerification { Unverified, VerifiedNotFixed, VerifiedFixed, VerifiedNeedsUpdate, VerifiedUnreliable, EUnitTestVerification_MAX}
    class UnitTest extends UnitTestBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PeakMemoryUsage: bigint;
        TimeToPeakMem: number;
        LastExecutionTime: number;
        UnitTasks: TArray<UnitTask>;
        VerificationState: EUnitTestVerification;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTest;
        static Load(InName: string): UnitTest;
    }
    
    class ProcessUnitTest extends UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProcessUnitTest;
        static Load(InName: string): ProcessUnitTest;
    }
    
    class MinimalClient extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MinimalClient;
        static Load(InName: string): MinimalClient;
    }
    
    class ClientUnitTest extends ProcessUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MinClient: MinimalClient;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClientUnitTest;
        static Load(InName: string): ClientUnitTest;
    }
    
    class IPClient extends ClientUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IPClient;
        static Load(InName: string): IPClient;
    }
    
    class NUTActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TempDelegate: $Delegate<(InNUTActor: NUTActor) => void>;
        Wait(Seconds: number): void;
        UnitTravel(Dest: string): void;
        UnitSeamlessTravel(Dest: string): void;
        ServerReceiveText(InText: string): void;
        ServerExecute(InDelegate: string): void;
        ServerClientStillAlive(): void;
        ServerClientPing(): void;
        ServerAdmin(Command: string): void;
        NetMulticastPing(): void;
        NetFlush(): void;
        Admin(Command: string): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NUTActor;
        static Load(InName: string): NUTActor;
    }
    
    class NUTGlobals extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        EventWatcher: NetConnection;
        ServerPortOffset: number;
        UnitTestNetDriverCount: number;
        DumpRPCMatches: TArray<string>;
        UnitTestModules: TArray<string>;
        UnloadedModules: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NUTGlobals;
        static Load(InName: string): NUTGlobals;
    }
    
    class PackedVectorTest extends UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PackedVectorTest;
        static Load(InName: string): PackedVectorTest;
    }
    
    class SteamClient extends IPClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SteamClient;
        static Load(InName: string): SteamClient;
    }
    
    class UnitTestActorChannel extends ActorChannel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestActorChannel;
        static Load(InName: string): UnitTestActorChannel;
    }
    
    class UnitTestChannel extends Channel {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestChannel;
        static Load(InName: string): UnitTestChannel;
    }
    
    class UnitTestCommandlet extends Commandlet {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestCommandlet;
        static Load(InName: string): UnitTestCommandlet;
    }
    
    class UnitTestManager extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCapUnitTestCount: boolean;
        MaxUnitTestCount: number;
        bCapUnitTestMemory: boolean;
        MaxMemoryPercent: number;
        AutoCloseMemoryPercent: number;
        MaxAutoCloseCount: number;
        UnitTestSessionCount: number;
        PendingUnitTests: TArray<Class>;
        ActiveUnitTests: TArray<UnitTest>;
        FinishedUnitTests: TArray<UnitTest>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestManager;
        static Load(InName: string): UnitTestManager;
    }
    
    class UnitTestPackageMap extends PackageMapClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UnitTestPackageMap;
        static Load(InName: string): UnitTestPackageMap;
    }
    
    class VMReflection extends UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VMReflection;
        static Load(InName: string): VMReflection;
    }
    
    class VMTestClassA extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        AObjectRef: Object;
        ByteProp: number;
        UInt16Prop: number;
        UInt32Prop: number;
        UInt64Prop: bigint;
        Int8Prop: number;
        Int16Prop: number;
        Int32Prop: number;
        Int64Prop: bigint;
        FloatProp: number;
        DoubleProp: number;
        bBoolPropA: boolean;
        bBoolPropB: boolean;
        bBoolPropC: boolean;
        bBoolPropD: boolean;
        bBoolPropE: boolean;
        NameProp: string;
        StringProp: string;
        TextProp: string;
        BytePropArray: FixSizeArray<number>;
        ObjectPropArray: FixSizeArray<Object>;
        DynBytePropArray: TArray<number>;
        DynBoolPropArray: TArray<boolean>;
        DynObjectPropArray: TArray<Object>;
        DynNamePropArray: TArray<string>;
        DynDoublePropArray: TArray<number>;
        DynFloatPropArray: TArray<number>;
        DynInt16PropArray: TArray<number>;
        DynInt64PropArray: TArray<bigint>;
        DynInt8PropArray: TArray<number>;
        DynIntPropArray: TArray<number>;
        DynUInt16PropArray: TArray<number>;
        DynUIntPropArray: TArray<number>;
        DynUInt64PropArray: TArray<bigint>;
        DynStringPropArray: TArray<string>;
        DynTextPropArray: TArray<string>;
        DynClassPropArray: TArray<Class>;
        DynPawnPropArray: TArray<Pawn>;
        StructProp: Vector;
        StructPropArray: FixSizeArray<Vector>;
        DynStructPropArray: TArray<Vector>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VMTestClassA;
        static Load(InName: string): VMTestClassA;
    }
    
    class VMTestClassB extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BObjectRef: Object;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VMTestClassB;
        static Load(InName: string): VMTestClassB;
    }
    
    class WebSocketClient extends IPClient {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WebSocketClient;
        static Load(InName: string): WebSocketClient;
    }
    
    class FTextCrash extends ClientUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FTextCrash;
        static Load(InName: string): FTextCrash;
    }
    
    class NetBitsTest extends UnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): NetBitsTest;
        static Load(InName: string): NetBitsTest;
    }
    
    class UTT61_DebugReplicateData extends ClientUnitTest {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UTT61_DebugReplicateData;
        static Load(InName: string): UTT61_DebugReplicateData;
    }
    
    class AndroidPermissionCallbackProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnPermissionsGrantedDynamicDelegate: $MulticastDelegate<(Permissions: TArray<string>, GrantResults: TArray<boolean>) => void>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidPermissionCallbackProxy;
        static Load(InName: string): AndroidPermissionCallbackProxy;
    }
    
    class AndroidPermissionFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CheckPermission(permission: string): boolean;
        static AcquirePermissions(permissions: TArray<string>): AndroidPermissionCallbackProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidPermissionFunctionLibrary;
        static Load(InName: string): AndroidPermissionFunctionLibrary;
    }
    
    class AppleImageUtilsImageConversionResult {
        constructor(Error: string, ImageData: TArray<number>);
        Error: string;
        ImageData: TArray<number>;
    }
    
    enum ETextureRotationDirection { None, Left, Right, Down, ETextureRotationDirection_MAX}
    class AppleImageUtilsBaseAsyncTaskBlueprintProxy extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnSuccess: $MulticastDelegate<(ConversionResult: AppleImageUtilsImageConversionResult) => void>;
        OnFailure: $MulticastDelegate<(ConversionResult: AppleImageUtilsImageConversionResult) => void>;
        ConversionResult: AppleImageUtilsImageConversionResult;
        static CreateProxyObjectForConvertToTIFF(SourceImage: Texture, bWantColor: boolean, bUseGpu: boolean, Scale: number, Rotate: ETextureRotationDirection): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static CreateProxyObjectForConvertToPNG(SourceImage: Texture, bWantColor: boolean, bUseGpu: boolean, Scale: number, Rotate: ETextureRotationDirection): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static CreateProxyObjectForConvertToJPEG(SourceImage: Texture, Quality: number, bWantColor: boolean, bUseGpu: boolean, Scale: number, Rotate: ETextureRotationDirection): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static CreateProxyObjectForConvertToHEIF(SourceImage: Texture, Quality: number, bWantColor: boolean, bUseGpu: boolean, Scale: number, Rotate: ETextureRotationDirection): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
        static Load(InName: string): AppleImageUtilsBaseAsyncTaskBlueprintProxy;
    }
    
    class AppleImageInterface extends Interface {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AppleImageInterface;
        static Load(InName: string): AppleImageInterface;
    }
    
    class K2Node_ConvertToJPEG extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToJPEG;
        static Load(InName: string): K2Node_ConvertToJPEG;
    }
    
    class K2Node_ConvertToHEIF extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToHEIF;
        static Load(InName: string): K2Node_ConvertToHEIF;
    }
    
    class K2Node_ConvertToTIFF extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToTIFF;
        static Load(InName: string): K2Node_ConvertToTIFF;
    }
    
    class K2Node_ConvertToPNG extends K2Node_BaseAsyncTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): K2Node_ConvertToPNG;
        static Load(InName: string): K2Node_ConvertToPNG;
    }
    
    class ArchVisCharacter extends Character {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LookUpAxisName: string;
        LookUpAtRateAxisName: string;
        TurnAxisName: string;
        TurnAtRateAxisName: string;
        MoveForwardAxisName: string;
        MoveRightAxisName: string;
        MouseSensitivityScale_Pitch: number;
        MouseSensitivityScale_Yaw: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArchVisCharacter;
        static Load(InName: string): ArchVisCharacter;
    }
    
    class ArchVisCharMovementComponent extends CharacterMovementComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RotationalAcceleration: Rotator;
        RotationalDeceleration: Rotator;
        MaxRotationalVelocity: Rotator;
        MinPitch: number;
        MaxPitch: number;
        WalkingFriction: number;
        WalkingSpeed: number;
        WalkingAcceleration: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ArchVisCharMovementComponent;
        static Load(InName: string): ArchVisCharMovementComponent;
    }
    
    enum ECollectionScriptingShareType { Local, Private, Shared, ECollectionScriptingShareType_MAX}
    class AssetTagsSubsystem extends EngineSubsystem {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ReparentCollection(Name: string, NewParentName: string): boolean;
        RenameCollection(Name: string, NewName: string): boolean;
        RemoveAssetsFromCollection(Name: string, AssetPathNames: TArray<string>): boolean;
        RemoveAssetPtrsFromCollection(Name: string, AssetPtrs: TArray<Object>): boolean;
        RemoveAssetPtrFromCollection(Name: string, AssetPtr: Object): boolean;
        RemoveAssetFromCollection(Name: string, AssetPathName: string): boolean;
        RemoveAssetDatasFromCollection(Name: string, AssetDatas: TArray<AssetData>): boolean;
        RemoveAssetDataFromCollection(Name: string, AssetData: AssetData): boolean;
        GetCollectionsContainingAssetPtr(AssetPtr: Object): TArray<string>;
        GetCollectionsContainingAssetData(AssetData: AssetData): TArray<string>;
        GetCollectionsContainingAsset(AssetPathName: string): TArray<string>;
        GetCollections(): TArray<string>;
        GetAssetsInCollection(Name: string): TArray<AssetData>;
        EmptyCollection(Name: string): boolean;
        DestroyCollection(Name: string): boolean;
        CreateCollection(Name: string, ShareType: ECollectionScriptingShareType): boolean;
        CollectionExists(Name: string): boolean;
        AddAssetToCollection(Name: string, AssetPathName: string): boolean;
        AddAssetsToCollection(Name: string, AssetPathNames: TArray<string>): boolean;
        AddAssetPtrToCollection(Name: string, AssetPtr: Object): boolean;
        AddAssetPtrsToCollection(Name: string, AssetPtrs: TArray<Object>): boolean;
        AddAssetDataToCollection(Name: string, AssetData: AssetData): boolean;
        AddAssetDatasToCollection(Name: string, AssetDatas: TArray<AssetData>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AssetTagsSubsystem;
        static Load(InName: string): AssetTagsSubsystem;
    }
    
    class AudioCaptureDeviceInfo {
        constructor(DeviceName: string, NumInputChannels: number, SampleRate: number);
        DeviceName: string;
        NumInputChannels: number;
        SampleRate: number;
    }
    
    class AudioCapture extends AudioGenerator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StopCapturingAudio(): void;
        StartCapturingAudio(): void;
        IsCapturingAudio(): boolean;
        GetAudioCaptureDeviceInfo(OutInfo: $Ref<AudioCaptureDeviceInfo>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCapture;
        static Load(InName: string): AudioCapture;
    }
    
    class AudioCaptureFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static CreateAudioCapture(): AudioCapture;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCaptureFunctionLibrary;
        static Load(InName: string): AudioCaptureFunctionLibrary;
    }
    
    class AudioCaptureComponent extends SynthComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        JitterLatencyFrames: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AudioCaptureComponent;
        static Load(InName: string): AudioCaptureComponent;
    }
    
    class ComponentReference {
        constructor(OtherActor: Actor, ComponentProperty: string, PathToComponent: string);
        OtherActor: Actor;
        ComponentProperty: string;
        PathToComponent: string;
    }
    
    class CableComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAttachStart: boolean;
        bAttachEnd: boolean;
        AttachEndTo: ComponentReference;
        AttachEndToSocketName: string;
        EndLocation: Vector;
        CableLength: number;
        NumSegments: number;
        SubstepTime: number;
        SolverIterations: number;
        bEnableStiffness: boolean;
        bEnableCollision: boolean;
        CollisionFriction: number;
        CableForce: Vector;
        CableGravityScale: number;
        CableWidth: number;
        NumSides: number;
        TileMaterial: number;
        SetAttachEndToComponent(Component: SceneComponent, SocketName: string): void;
        SetAttachEndTo(Actor: Actor, ComponentProperty: string, SocketName: string): void;
        GetCableParticleLocations(Locations: $Ref<TArray<Vector>>): void;
        GetAttachedComponent(): SceneComponent;
        GetAttachedActor(): Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CableComponent;
        static Load(InName: string): CableComponent;
    }
    
    class CableActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CableComponent: CableComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CableActor;
        static Load(InName: string): CableActor;
    }
    
    class CustomMeshTriangle {
        constructor(Vertex0: Vector, Vertex1: Vector, Vertex2: Vector);
        Vertex0: Vector;
        Vertex1: Vector;
        Vertex2: Vector;
    }
    
    class CustomMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetCustomMeshTriangles(Triangles: TArray<CustomMeshTriangle>): boolean;
        ClearCustomMeshTriangles(): void;
        AddCustomMeshTriangles(Triangles: TArray<CustomMeshTriangle>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): CustomMeshComponent;
        static Load(InName: string): CustomMeshComponent;
    }
    
    enum EChaosCollisionSortMethod { SortNone, SortByHighestMass, SortByHighestSpeed, SortByHighestImpulse, SortByNearestFirst, Count, EChaosCollisionSortMethod_MAX}
    class ChaosCollisionEventRequestSettings {
        constructor(MaxNumberResults: number, MinMass: number, MinSpeed: number, MinImpulse: number, MaxDistance: number, SortMethod: EChaosCollisionSortMethod);
        MaxNumberResults: number;
        MinMass: number;
        MinSpeed: number;
        MinImpulse: number;
        MaxDistance: number;
        SortMethod: EChaosCollisionSortMethod;
    }
    
    enum EChaosBreakingSortMethod { SortNone, SortByHighestMass, SortByHighestSpeed, SortByNearestFirst, Count, EChaosBreakingSortMethod_MAX}
    class ChaosBreakingEventRequestSettings {
        constructor(MaxNumberOfResults: number, MinRadius: number, MinSpeed: number, MinMass: number, MaxDistance: number, SortMethod: EChaosBreakingSortMethod);
        MaxNumberOfResults: number;
        MinRadius: number;
        MinSpeed: number;
        MinMass: number;
        MaxDistance: number;
        SortMethod: EChaosBreakingSortMethod;
    }
    
    enum EChaosTrailingSortMethod { SortNone, SortByHighestMass, SortByHighestSpeed, SortByNearestFirst, Count, EChaosTrailingSortMethod_MAX}
    class ChaosTrailingEventRequestSettings {
        constructor(MaxNumberOfResults: number, MinMass: number, MinSpeed: number, MinAngularSpeed: number, MaxDistance: number, SortMethod: EChaosTrailingSortMethod);
        MaxNumberOfResults: number;
        MinMass: number;
        MinSpeed: number;
        MinAngularSpeed: number;
        MaxDistance: number;
        SortMethod: EChaosTrailingSortMethod;
    }
    
    enum ECollisionTypeEnum { Chaos_Volumetric, Chaos_Surface_Volumetric, Chaos_Max, Chaos_MAX}
    enum EImplicitTypeEnum { Chaos_Implicit_Box, Chaos_Implicit_Sphere, Chaos_Implicit_Capsule, Chaos_Implicit_LevelSet, Chaos_Implicit_None, Chaos_Max, Chaos_MAX}
    class GeometryCollectionSizeSpecificData {
        constructor(MaxSize: number, CollisionType: ECollisionTypeEnum, ImplicitType: EImplicitTypeEnum, MinLevelSetResolution: number, MaxLevelSetResolution: number, MinClusterLevelSetResolution: number, MaxClusterLevelSetResolution: number, CollisionObjectReductionPercentage: number, CollisionParticlesFraction: number, MaximumCollisionParticles: number);
        MaxSize: number;
        CollisionType: ECollisionTypeEnum;
        ImplicitType: EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        MinClusterLevelSetResolution: number;
        MaxClusterLevelSetResolution: number;
        CollisionObjectReductionPercentage: number;
        CollisionParticlesFraction: number;
        MaximumCollisionParticles: number;
    }
    
    class GeometryCollection extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Materials: TArray<MaterialInterface>;
        CollisionType: ECollisionTypeEnum;
        ImplicitType: EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        MinClusterLevelSetResolution: number;
        MaxClusterLevelSetResolution: number;
        CollisionObjectReductionPercentage: number;
        bMassAsDensity: boolean;
        Mass: number;
        MinimumMassClamp: number;
        CollisionParticlesFraction: number;
        MaximumCollisionParticles: number;
        SizeSpecificData: TArray<GeometryCollectionSizeSpecificData>;
        EnableRemovePiecesOnFracture: boolean;
        RemoveOnFractureMaterials: TArray<MaterialInterface>;
        ThumbnailInfo: ThumbnailInfo;
        PersistentGuid: Guid;
        StateGuid: Guid;
        BoneSelectedMaterialIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollection;
        static Load(InName: string): GeometryCollection;
    }
    
    enum EObjectStateTypeEnum { Chaos_NONE, Chaos_Object_Sleeping, Chaos_Object_Kinematic, Chaos_Object_Static, Chaos_Object_Dynamic, Chaos_Object_UserDefined, Chaos_Max, Chaos_MAX}
    enum EInitialVelocityTypeEnum { Chaos_Initial_Velocity_User_Defined, Chaos_Initial_Velocity_None, Chaos_Max, Chaos_MAX}
    enum EGeometryCollectionCacheType { None, Record, Play, RecordAndPlay, EGeometryCollectionCacheType_MAX}
    class SolverCollisionData {
        constructor(Location: Vector, AccumulatedImpulse: Vector, Normal: Vector, Velocity1: Vector, Velocity2: Vector, AngularVelocity1: Vector, AngularVelocity2: Vector, Mass1: number, Mass2: number, ParticleIndex: number, LevelsetIndex: number, ParticleIndexMesh: number, LevelsetIndexMesh: number);
        Location: Vector;
        AccumulatedImpulse: Vector;
        Normal: Vector;
        Velocity1: Vector;
        Velocity2: Vector;
        AngularVelocity1: Vector;
        AngularVelocity2: Vector;
        Mass1: number;
        Mass2: number;
        ParticleIndex: number;
        LevelsetIndex: number;
        ParticleIndexMesh: number;
        LevelsetIndexMesh: number;
    }
    
    class SolverBreakingData {
        constructor(Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number, ParticleIndex: number, ParticleIndexMesh: number);
        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
        ParticleIndex: number;
        ParticleIndexMesh: number;
    }
    
    class SolverTrailingData {
        constructor(Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number, ParticleIndex: number, ParticleIndexMesh: number);
        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
        ParticleIndex: number;
        ParticleIndexMesh: number;
    }
    
    class RecordedFrame {
        constructor(Transforms: TArray<Transform>, TransformIndices: TArray<number>, PreviousTransformIndices: TArray<number>, DisabledFlags: TArray<boolean>, Collisions: TArray<SolverCollisionData>, Breakings: TArray<SolverBreakingData>, Trailings: TSet<SolverTrailingData>, Timestamp: number);
        Transforms: TArray<Transform>;
        TransformIndices: TArray<number>;
        PreviousTransformIndices: TArray<number>;
        DisabledFlags: TArray<boolean>;
        Collisions: TArray<SolverCollisionData>;
        Breakings: TArray<SolverBreakingData>;
        Trailings: TSet<SolverTrailingData>;
        Timestamp: number;
    }
    
    class RecordedTransformTrack {
        constructor(Records: TArray<RecordedFrame>);
        Records: TArray<RecordedFrame>;
    }
    
    class GeometryCollectionCache extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RecordedData: RecordedTransformTrack;
        SupportedCollection: GeometryCollection;
        CompatibleCollectionState: Guid;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionCache;
        static Load(InName: string): GeometryCollectionCache;
    }
    
    class GeomComponentCacheParameters {
        constructor(CacheMode: EGeometryCollectionCacheType, TargetCache: GeometryCollectionCache, ReverseCacheBeginTime: number, SaveCollisionData: boolean, DoGenerateCollisionData: boolean, CollisionDataSizeMax: number, DoCollisionDataSpatialHash: boolean, CollisionDataSpatialHashRadius: number, MaxCollisionPerCell: number, SaveBreakingData: boolean, DoGenerateBreakingData: boolean, BreakingDataSizeMax: number, DoBreakingDataSpatialHash: boolean, BreakingDataSpatialHashRadius: number, MaxBreakingPerCell: number, SaveTrailingData: boolean, DoGenerateTrailingData: boolean, TrailingDataSizeMax: number, TrailingMinSpeedThreshold: number, TrailingMinVolumeThreshold: number);
        CacheMode: EGeometryCollectionCacheType;
        TargetCache: GeometryCollectionCache;
        ReverseCacheBeginTime: number;
        SaveCollisionData: boolean;
        DoGenerateCollisionData: boolean;
        CollisionDataSizeMax: number;
        DoCollisionDataSpatialHash: boolean;
        CollisionDataSpatialHashRadius: number;
        MaxCollisionPerCell: number;
        SaveBreakingData: boolean;
        DoGenerateBreakingData: boolean;
        BreakingDataSizeMax: number;
        DoBreakingDataSpatialHash: boolean;
        BreakingDataSpatialHashRadius: number;
        MaxBreakingPerCell: number;
        SaveTrailingData: boolean;
        DoGenerateTrailingData: boolean;
        TrailingDataSizeMax: number;
        TrailingMinSpeedThreshold: number;
        TrailingMinVolumeThreshold: number;
    }
    
    class ChaosBreakEvent {
        constructor(Component: PrimitiveComponent, Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number);
        Component: PrimitiveComponent;
        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
    }
    
    enum EGeometryCollectionPhysicsTypeEnum { Chaos_AngularVelocity, Chaos_DynamicState, Chaos_LinearVelocity, Chaos_InitialAngularVelocity, Chaos_InitialLinearVelocity, Chaos_CollisionGroup, Chaos_LinearForce, Chaos_AngularTorque, Chaos_Max, Chaos_MAX}
    class GeometryCollectionComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ChaosSolverActor: ChaosSolverActor;
        RestCollection: GeometryCollection;
        InitializationFields: TArray<FieldSystemActor>;
        Simulating: boolean;
        ObjectType: EObjectStateTypeEnum;
        EnableClustering: boolean;
        ClusterGroupIndex: number;
        MaxClusterLevel: number;
        DamageThreshold: TArray<number>;
        ClusterConnectionType: EClusterConnectionTypeEnum;
        CollisionGroup: number;
        CollisionSampleFraction: number;
        PhysicalMaterial: ChaosPhysicalMaterial;
        InitialVelocityType: EInitialVelocityTypeEnum;
        InitialLinearVelocity: Vector;
        InitialAngularVelocity: Vector;
        CacheParameters: GeomComponentCacheParameters;
        NotifyGeometryCollectionPhysicsStateChange: $MulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
        NotifyGeometryCollectionPhysicsLoadingStateChange: $MulticastDelegate<(FracturedComponent: GeometryCollectionComponent) => void>;
        OnChaosBreakEvent: $MulticastDelegate<(BreakEvent: ChaosBreakEvent) => void>;
        DesiredCacheTime: number;
        CachePlayback: boolean;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
        bNotifyBreaks: boolean;
        bNotifyCollisions: boolean;
        SelectedBones: TArray<number>;
        HighlightedBones: TArray<number>;
        DummyBodySetup: BodySetup;
        EditorActor: Actor;
        SetNotifyBreaks(bNewNotifyBreaks: boolean): void;
        ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
        NotifyGeometryCollectionPhysicsStateChange__DelegateSignature(FracturedComponent: GeometryCollectionComponent): void;
        NotifyGeometryCollectionPhysicsLoadingStateChange__DelegateSignature(FracturedComponent: GeometryCollectionComponent): void;
        ApplyPhysicsField(Enabled: boolean, Target: EGeometryCollectionPhysicsTypeEnum, MetaData: FieldSystemMetaData, Field: FieldNodeBase): void;
        ApplyKinematicField(Radius: number, Position: Vector): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionComponent;
        static Load(InName: string): GeometryCollectionComponent;
    }
    
    class GeometryCollectionDebugDrawWarningMessage {
        constructor();
    }
    
    class GeometryCollectionDebugDrawActorSelectedRigidBody {
        constructor(Id: number, Solver: ChaosSolverActor, GeometryCollection: GeometryCollectionActor);
        Id: number;
        Solver: ChaosSolverActor;
        GeometryCollection: GeometryCollectionActor;
    }
    
    enum EGeometryCollectionDebugDrawActorHideGeometry { HideNone, HideWithCollision, HideSelected, HideWholeCollection, HideAll, EGeometryCollectionDebugDrawActorHideGeometry_MAX}
    class GeometryCollectionDebugDrawActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        WarningMessage: GeometryCollectionDebugDrawWarningMessage;
        SelectedRigidBody: GeometryCollectionDebugDrawActorSelectedRigidBody;
        bDebugDrawWholeCollection: boolean;
        bDebugDrawHierarchy: boolean;
        bDebugDrawClustering: boolean;
        HideGeometry: EGeometryCollectionDebugDrawActorHideGeometry;
        bShowRigidBodyId: boolean;
        bShowRigidBodyCollision: boolean;
        bCollisionAtOrigin: boolean;
        bShowRigidBodyTransform: boolean;
        bShowRigidBodyInertia: boolean;
        bShowRigidBodyVelocity: boolean;
        bShowRigidBodyForce: boolean;
        bShowRigidBodyInfos: boolean;
        bShowTransformIndex: boolean;
        bShowTransform: boolean;
        bShowParent: boolean;
        bShowLevel: boolean;
        bShowConnectivityEdges: boolean;
        bShowGeometryIndex: boolean;
        bShowGeometryTransform: boolean;
        bShowBoundingBox: boolean;
        bShowFaces: boolean;
        bShowFaceIndices: boolean;
        bShowFaceNormals: boolean;
        bShowSingleFace: boolean;
        SingleFaceIndex: number;
        bShowVertices: boolean;
        bShowVertexIndices: boolean;
        bShowVertexNormals: boolean;
        bUseActiveVisualization: boolean;
        PointThickness: number;
        LineThickness: number;
        bTextShadow: boolean;
        TextScale: number;
        NormalScale: number;
        AxisScale: number;
        ArrowScale: number;
        RigidBodyIdColor: Color;
        RigidBodyTransformScale: number;
        RigidBodyCollisionColor: Color;
        RigidBodyInertiaColor: Color;
        RigidBodyVelocityColor: Color;
        RigidBodyForceColor: Color;
        RigidBodyInfoColor: Color;
        TransformIndexColor: Color;
        TransformScale: number;
        LevelColor: Color;
        ParentColor: Color;
        ConnectivityEdgeThickness: number;
        GeometryIndexColor: Color;
        GeometryTransformScale: number;
        BoundingBoxColor: Color;
        FaceColor: Color;
        FaceIndexColor: Color;
        FaceNormalColor: Color;
        SingleFaceColor: Color;
        VertexColor: Color;
        VertexIndexColor: Color;
        VertexNormalColor: Color;
        SpriteComponent: BillboardComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionDebugDrawActor;
        static Load(InName: string): GeometryCollectionDebugDrawActor;
    }
    
    class GeometryCollectionRenderLevelSetActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TargetVolumeTexture: VolumeTexture;
        RayMarchMaterial: Material;
        SurfaceTolerance: number;
        Isovalue: number;
        Enabled: boolean;
        RenderVolumeBoundingBox: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionRenderLevelSetActor;
        static Load(InName: string): GeometryCollectionRenderLevelSetActor;
    }
    
    class GeometryCollectionDebugDrawComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCollectionDebugDrawActor: GeometryCollectionDebugDrawActor;
        GeometryCollectionRenderLevelSetActor: GeometryCollectionRenderLevelSetActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionDebugDrawComponent;
        static Load(InName: string): GeometryCollectionDebugDrawComponent;
    }
    
    class GeometryCollectionActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCollectionComponent: GeometryCollectionComponent;
        GeometryCollectionDebugDrawComponent: GeometryCollectionDebugDrawComponent;
        RaycastSingle(Start: Vector, End: Vector, OutHit: $Ref<HitResult>): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeometryCollectionActor;
        static Load(InName: string): GeometryCollectionActor;
    }
    
    class ChaosCollisionEventData {
        constructor(Location: Vector, Normal: Vector, Velocity1: Vector, Velocity2: Vector, Mass1: number, Mass2: number, Impulse: Vector);
        Location: Vector;
        Normal: Vector;
        Velocity1: Vector;
        Velocity2: Vector;
        Mass1: number;
        Mass2: number;
        Impulse: Vector;
    }
    
    class ChaosBreakingEventData {
        constructor(Location: Vector, Velocity: Vector, Mass: number, ParticleIndex: number);
        Location: Vector;
        Velocity: Vector;
        Mass: number;
        ParticleIndex: number;
    }
    
    class ChaosTrailingEventData {
        constructor(Location: Vector, Velocity: Vector, AngularVelocity: Vector, Mass: number, ParticleIndex: number);
        Location: Vector;
        Velocity: Vector;
        AngularVelocity: Vector;
        Mass: number;
        ParticleIndex: number;
    }
    
    class ChaosDestructionListener extends SceneComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIsCollisionEventListeningEnabled: boolean;
        bIsBreakingEventListeningEnabled: boolean;
        bIsTrailingEventListeningEnabled: boolean;
        CollisionEventRequestSettings: ChaosCollisionEventRequestSettings;
        BreakingEventRequestSettings: ChaosBreakingEventRequestSettings;
        TrailingEventRequestSettings: ChaosTrailingEventRequestSettings;
        ChaosSolverActors: TSet<ChaosSolverActor>;
        GeometryCollectionActors: TSet<GeometryCollectionActor>;
        OnCollisionEvents: $MulticastDelegate<(CollisionEvents: TArray<ChaosCollisionEventData>) => void>;
        OnBreakingEvents: $MulticastDelegate<(BreakingEvents: TArray<ChaosBreakingEventData>) => void>;
        OnTrailingEvents: $MulticastDelegate<(TrailingEvents: TArray<ChaosTrailingEventData>) => void>;
        SortTrailingEvents(TrailingEvents: $Ref<TArray<ChaosTrailingEventData>>, SortMethod: EChaosTrailingSortMethod): void;
        SortCollisionEvents(CollisionEvents: $Ref<TArray<ChaosCollisionEventData>>, SortMethod: EChaosCollisionSortMethod): void;
        SortBreakingEvents(BreakingEvents: $Ref<TArray<ChaosBreakingEventData>>, SortMethod: EChaosBreakingSortMethod): void;
        SetTrailingEventRequestSettings(InSettings: ChaosTrailingEventRequestSettings): void;
        SetTrailingEventEnabled(bIsEnabled: boolean): void;
        SetCollisionEventRequestSettings(InSettings: ChaosCollisionEventRequestSettings): void;
        SetCollisionEventEnabled(bIsEnabled: boolean): void;
        SetBreakingEventRequestSettings(InSettings: ChaosBreakingEventRequestSettings): void;
        SetBreakingEventEnabled(bIsEnabled: boolean): void;
        RemoveGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
        RemoveChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
        IsEventListening(): boolean;
        AddGeometryCollectionActor(GeometryCollectionActor: GeometryCollectionActor): void;
        AddChaosSolverActor(ChaosSolverActor: ChaosSolverActor): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ChaosDestructionListener;
        static Load(InName: string): ChaosDestructionListener;
    }
    
    class SkeletalMeshSimulationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PhysicalMaterial: ChaosPhysicalMaterial;
        ChaosSolverActor: ChaosSolverActor;
        OverridePhysicsAsset: PhysicsAsset;
        bSimulating: boolean;
        bNotifyCollisions: boolean;
        ObjectType: EObjectStateTypeEnum;
        Density: number;
        MinMass: number;
        MaxMass: number;
        CollisionType: ECollisionTypeEnum;
        ImplicitShapeParticlesPerUnitArea: number;
        ImplicitShapeMinNumParticles: number;
        ImplicitShapeMaxNumParticles: number;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        CollisionGroup: number;
        InitialVelocityType: EInitialVelocityTypeEnum;
        InitialLinearVelocity: Vector;
        InitialAngularVelocity: Vector;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
        ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SkeletalMeshSimulationComponent;
        static Load(InName: string): SkeletalMeshSimulationComponent;
    }
    
    class StaticMeshSimulationComponent extends ActorComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Simulating: boolean;
        bNotifyCollisions: boolean;
        ObjectType: EObjectStateTypeEnum;
        Mass: number;
        CollisionType: ECollisionTypeEnum;
        ImplicitType: EImplicitTypeEnum;
        MinLevelSetResolution: number;
        MaxLevelSetResolution: number;
        InitialVelocityType: EInitialVelocityTypeEnum;
        InitialLinearVelocity: Vector;
        InitialAngularVelocity: Vector;
        DamageThreshold: number;
        PhysicalMaterial: ChaosPhysicalMaterial;
        ChaosSolverActor: ChaosSolverActor;
        OnChaosPhysicsCollision: $MulticastDelegate<(CollisionInfo: ChaosPhysicsCollisionInfo) => void>;
        SimulatedComponents: TArray<PrimitiveComponent>;
        ReceivePhysicsCollision(CollisionInfo: ChaosPhysicsCollisionInfo): void;
        ForceRecreatePhysicsState(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StaticMeshSimulationComponent;
        static Load(InName: string): StaticMeshSimulationComponent;
    }
    
    class EditableMeshAdapter extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableMeshAdapter;
        static Load(InName: string): EditableMeshAdapter;
    }
    
    class EditableGeometryCollectionAdapter extends EditableMeshAdapter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GeometryCollection: GeometryCollection;
        OriginalGeometryCollection: GeometryCollection;
        GeometryCollectionLODIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableGeometryCollectionAdapter;
        static Load(InName: string): EditableGeometryCollectionAdapter;
    }
    
    enum ETriangleTessellationMode { ThreeTriangles, FourTriangles, ETriangleTessellationMode_MAX}
    enum EMeshModificationType { FirstInterim, Interim, Final, EMeshModificationType_MAX}
    enum EMeshTopologyChange { NoTopologyChange, TopologyChange, EMeshTopologyChange_MAX}
    class VertexPair {
        constructor(VertexID0: VertexID, VertexID1: VertexID);
        VertexID0: VertexID;
        VertexID1: VertexID;
    }
    
    class PolygonToSplit {
        constructor(PolygonID: PolygonID, VertexPairsToSplitAt: TArray<VertexPair>);
        PolygonID: PolygonID;
        VertexPairsToSplitAt: TArray<VertexPair>;
    }
    
    class MeshElementAttributeValue {
        constructor();
    }
    
    class MeshElementAttributeData {
        constructor(AttributeName: string, AttributeIndex: number, AttributeValue: MeshElementAttributeValue);
        AttributeName: string;
        AttributeIndex: number;
        AttributeValue: MeshElementAttributeValue;
    }
    
    class MeshElementAttributeList {
        constructor(Attributes: TArray<MeshElementAttributeData>);
        Attributes: TArray<MeshElementAttributeData>;
    }
    
    class AttributesForVertex {
        constructor(VertexID: VertexID, VertexAttributes: MeshElementAttributeList);
        VertexID: VertexID;
        VertexAttributes: MeshElementAttributeList;
    }
    
    class AttributesForVertexInstance {
        constructor(VertexInstanceID: VertexInstanceID, VertexInstanceAttributes: MeshElementAttributeList);
        VertexInstanceID: VertexInstanceID;
        VertexInstanceAttributes: MeshElementAttributeList;
    }
    
    class VertexAttributesForPolygonHole {
        constructor(VertexAttributeList: TArray<MeshElementAttributeList>);
        VertexAttributeList: TArray<MeshElementAttributeList>;
    }
    
    class VertexAttributesForPolygon {
        constructor(PolygonID: PolygonID, PerimeterVertexAttributeLists: TArray<MeshElementAttributeList>, VertexAttributeListsForEachHole: TArray<VertexAttributesForPolygonHole>);
        PolygonID: PolygonID;
        PerimeterVertexAttributeLists: TArray<MeshElementAttributeList>;
        VertexAttributeListsForEachHole: TArray<VertexAttributesForPolygonHole>;
    }
    
    class AttributesForEdge {
        constructor(EdgeID: EdgeID, EdgeAttributes: MeshElementAttributeList);
        EdgeID: EdgeID;
        EdgeAttributes: MeshElementAttributeList;
    }
    
    class VertexToMove {
        constructor(VertexID: VertexID, NewVertexPosition: Vector);
        VertexID: VertexID;
        NewVertexPosition: Vector;
    }
    
    enum EInsetPolygonsMode { All, CenterPolygonOnly, SidePolygonsOnly, EInsetPolygonsMode_MAX}
    class SubdividedQuadVertex {
        constructor(VertexPositionIndex: number, TextureCoordinate0: Vector2D, TextureCoordinate1: Vector2D, VertexColor: Color, VertexNormal: Vector, VertexTangent: Vector, VertexBinormalSign: number);
        VertexPositionIndex: number;
        TextureCoordinate0: Vector2D;
        TextureCoordinate1: Vector2D;
        VertexColor: Color;
        VertexNormal: Vector;
        VertexTangent: Vector;
        VertexBinormalSign: number;
    }
    
    class SubdividedQuad {
        constructor(QuadVertex0: SubdividedQuadVertex, QuadVertex1: SubdividedQuadVertex, QuadVertex2: SubdividedQuadVertex, QuadVertex3: SubdividedQuadVertex);
        QuadVertex0: SubdividedQuadVertex;
        QuadVertex1: SubdividedQuadVertex;
        QuadVertex2: SubdividedQuadVertex;
        QuadVertex3: SubdividedQuadVertex;
    }
    
    class SubdivisionLimitSection {
        constructor(SubdividedQuads: TArray<SubdividedQuad>);
        SubdividedQuads: TArray<SubdividedQuad>;
    }
    
    class SubdividedWireEdge {
        constructor(EdgeVertex0PositionIndex: number, EdgeVertex1PositionIndex: number);
        EdgeVertex0PositionIndex: number;
        EdgeVertex1PositionIndex: number;
    }
    
    class SubdivisionLimitData {
        constructor(VertexPositions: TArray<Vector>, Sections: TArray<SubdivisionLimitSection>, SubdividedWireEdges: TArray<SubdividedWireEdge>);
        VertexPositions: TArray<Vector>;
        Sections: TArray<SubdivisionLimitSection>;
        SubdividedWireEdges: TArray<SubdividedWireEdge>;
    }
    
    class VertexToCreate {
        constructor(VertexAttributes: MeshElementAttributeList, OriginalVertexID: VertexID);
        VertexAttributes: MeshElementAttributeList;
        OriginalVertexID: VertexID;
    }
    
    class VertexInstanceToCreate {
        constructor(VertexID: VertexID, VertexInstanceAttributes: MeshElementAttributeList, OriginalVertexInstanceID: VertexInstanceID);
        VertexID: VertexID;
        VertexInstanceAttributes: MeshElementAttributeList;
        OriginalVertexInstanceID: VertexInstanceID;
    }
    
    class VertexAndAttributes {
        constructor(VertexInstanceID: VertexInstanceID, VertexID: VertexID, PolygonVertexAttributes: MeshElementAttributeList);
        VertexInstanceID: VertexInstanceID;
        VertexID: VertexID;
        PolygonVertexAttributes: MeshElementAttributeList;
    }
    
    enum EPolygonEdgeHardness { NewEdgesSoft, NewEdgesHard, AllEdgesSoft, AllEdgesHard, EPolygonEdgeHardness_MAX}
    class PolygonToCreate {
        constructor(PolygonGroupID: PolygonGroupID, PerimeterVertices: TArray<VertexAndAttributes>, OriginalPolygonID: PolygonID, PolygonEdgeHardness: EPolygonEdgeHardness);
        PolygonGroupID: PolygonGroupID;
        PerimeterVertices: TArray<VertexAndAttributes>;
        OriginalPolygonID: PolygonID;
        PolygonEdgeHardness: EPolygonEdgeHardness;
    }
    
    class PolygonGroupToCreate {
        constructor(PolygonGroupAttributes: MeshElementAttributeList, OriginalPolygonGroupID: PolygonGroupID);
        PolygonGroupAttributes: MeshElementAttributeList;
        OriginalPolygonGroupID: PolygonGroupID;
    }
    
    class EdgeToCreate {
        constructor(VertexID0: VertexID, VertexID1: VertexID, EdgeAttributes: MeshElementAttributeList, OriginalEdgeID: EdgeID);
        VertexID0: VertexID;
        VertexID1: VertexID;
        EdgeAttributes: MeshElementAttributeList;
        OriginalEdgeID: EdgeID;
    }
    
    class VertexIndexAndInstanceID {
        constructor(ContourIndex: number, VertexInstanceID: VertexInstanceID);
        ContourIndex: number;
        VertexInstanceID: VertexInstanceID;
    }
    
    class VertexInstancesForPolygonHole {
        constructor(VertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>);
        VertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>;
    }
    
    class ChangeVertexInstancesForPolygon {
        constructor(PolygonID: PolygonID, PerimeterVertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>, VertexIndicesAndInstanceIDsForEachHole: TArray<VertexInstancesForPolygonHole>);
        PolygonID: PolygonID;
        PerimeterVertexIndicesAndInstanceIDs: TArray<VertexIndexAndInstanceID>;
        VertexIndicesAndInstanceIDsForEachHole: TArray<VertexInstancesForPolygonHole>;
    }
    
    class PolygonGroupForPolygon {
        constructor(PolygonID: PolygonID, PolygonGroupID: PolygonGroupID);
        PolygonID: PolygonID;
        PolygonGroupID: PolygonGroupID;
    }
    
    class EditableMesh extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Adapters: TArray<EditableMeshAdapter>;
        TextureCoordinateCount: number;
        PendingCompactCounter: number;
        SubdivisionCount: number;
        WeldVertices(VertexIDs: TArray<VertexID>, OutNewVertexID: $Ref<VertexID>): void;
        TryToRemoveVertex(VertexID: VertexID, bOutWasVertexRemoved: $Ref<boolean>, OutNewEdgeID: $Ref<EdgeID>): void;
        TryToRemovePolygonEdge(EdgeID: EdgeID, bOutWasEdgeRemoved: $Ref<boolean>, OutNewPolygonID: $Ref<PolygonID>): void;
        TriangulatePolygons(PolygonIDs: TArray<PolygonID>, OutNewTrianglePolygons: $Ref<TArray<PolygonID>>): void;
        TessellatePolygons(PolygonIDs: TArray<PolygonID>, TriangleTessellationMode: ETriangleTessellationMode, OutNewPolygonIDs: $Ref<TArray<PolygonID>>): void;
        StartModification(MeshModificationType: EMeshModificationType, MeshTopologyChange: EMeshTopologyChange): void;
        SplitPolygons(PolygonsToSplit: TArray<PolygonToSplit>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        SplitPolygonalMesh(InPlane: Plane, PolygonIDs1: $Ref<TArray<PolygonID>>, PolygonIDs2: $Ref<TArray<PolygonID>>, BoundaryIDs: $Ref<TArray<EdgeID>>): void;
        SplitEdge(EdgeID: EdgeID, Splits: TArray<number>, OutNewVertexIDs: $Ref<TArray<VertexID>>): void;
        SetVerticesCornerSharpness(VertexIDs: TArray<VertexID>, VerticesNewCornerSharpness: TArray<number>): void;
        SetVerticesAttributes(AttributesForVertices: TArray<AttributesForVertex>): void;
        SetVertexInstancesAttributes(AttributesForVertexInstances: TArray<AttributesForVertexInstance>): void;
        SetTextureCoordinateCount(NumTexCoords: number): void;
        SetSubdivisionCount(NewSubdivisionCount: number): void;
        SetPolygonsVertexAttributes(VertexAttributesForPolygons: TArray<VertexAttributesForPolygon>): void;
        SetEdgesHardnessAutomatically(EdgeIDs: TArray<EdgeID>, MaxDotProductForSoftEdge: number): void;
        SetEdgesHardness(EdgeIDs: TArray<EdgeID>, EdgesNewIsHard: TArray<boolean>): void;
        SetEdgesCreaseSharpness(EdgeIDs: TArray<EdgeID>, EdgesNewCreaseSharpness: TArray<number>): void;
        SetEdgesAttributes(AttributesForEdges: TArray<AttributesForEdge>): void;
        SetAllowUndo(bInAllowUndo: boolean): void;
        SetAllowSpatialDatabase(bInAllowSpatialDatabase: boolean): void;
        SetAllowCompact(bInAllowCompact: boolean): void;
        SearchSpatialDatabaseForPolygonsPotentiallyIntersectingPlane(InPlane: Plane, OutPolygons: $Ref<TArray<PolygonID>>): void;
        SearchSpatialDatabaseForPolygonsPotentiallyIntersectingLineSegment(LineSegmentStart: Vector, LineSegmentEnd: Vector, OutPolygons: $Ref<TArray<PolygonID>>): void;
        SearchSpatialDatabaseForPolygonsInVolume(Planes: TArray<Plane>, OutPolygons: $Ref<TArray<PolygonID>>): void;
        RevertInstance(): EditableMesh;
        Revert(): void;
        RebuildRenderMesh(): void;
        QuadrangulateMesh(OutNewPolygonIDs: $Ref<TArray<PolygonID>>): void;
        PropagateInstanceChanges(): void;
        MoveVertices(VerticesToMove: TArray<VertexToMove>): void;
        static MakeVertexID(VertexIndex: number): VertexID;
        static MakePolygonID(PolygonIndex: number): PolygonID;
        static MakePolygonGroupID(PolygonGroupIndex: number): PolygonGroupID;
        static MakeEdgeID(EdgeIndex: number): EdgeID;
        IsValidVertex(VertexID: VertexID): boolean;
        IsValidPolygonGroup(PolygonGroupID: PolygonGroupID): boolean;
        IsValidPolygon(PolygonID: PolygonID): boolean;
        IsValidEdge(EdgeID: EdgeID): boolean;
        IsUndoAllowed(): boolean;
        IsSpatialDatabaseAllowed(): boolean;
        IsPreviewingSubdivisions(): boolean;
        IsOrphanedVertex(VertexID: VertexID): boolean;
        IsCompactAllowed(): boolean;
        IsCommittedAsInstance(): boolean;
        IsCommitted(): boolean;
        IsBeingModified(): boolean;
        static InvalidVertexID(): VertexID;
        static InvalidPolygonID(): PolygonID;
        static InvalidPolygonGroupID(): PolygonGroupID;
        static InvalidEdgeID(): EdgeID;
        InsetPolygons(PolygonIDs: TArray<PolygonID>, InsetFixedDistance: number, InsetProgressTowardCenter: number, Mode: EInsetPolygonsMode, OutNewCenterPolygonIDs: $Ref<TArray<PolygonID>>, OutNewSidePolygonIDs: $Ref<TArray<PolygonID>>): void;
        InsertEdgeLoop(EdgeID: EdgeID, Splits: TArray<number>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        InitializeAdapters(): void;
        GetVertexPairEdge(VertexID: VertexID, NextVertexID: VertexID, bOutEdgeWindingIsReversed: $Ref<boolean>): EdgeID;
        GetVertexInstanceVertex(VertexInstanceID: VertexInstanceID): VertexID;
        GetVertexInstanceCount(): number;
        GetVertexInstanceConnectedPolygons(VertexInstanceID: VertexInstanceID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetVertexInstanceConnectedPolygonCount(VertexInstanceID: VertexInstanceID): number;
        GetVertexInstanceConnectedPolygon(VertexInstanceID: VertexInstanceID, ConnectedPolygonNumber: number): PolygonID;
        GetVertexCount(): number;
        GetVertexConnectedPolygons(VertexID: VertexID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetVertexConnectedEdges(VertexID: VertexID, OutConnectedEdgeIDs: $Ref<TArray<EdgeID>>): void;
        GetVertexConnectedEdgeCount(VertexID: VertexID): number;
        GetVertexConnectedEdge(VertexID: VertexID, ConnectedEdgeNumber: number): EdgeID;
        GetVertexAdjacentVertices(VertexID: VertexID, OutAdjacentVertexIDs: $Ref<TArray<VertexID>>): void;
        GetTextureCoordinateCount(): number;
        GetSubdivisionLimitData(): SubdivisionLimitData;
        GetSubdivisionCount(): number;
        GetPolygonTriangulatedTriangleCount(PolygonID: PolygonID): number;
        GetPolygonTriangulatedTriangle(PolygonID: PolygonID, PolygonTriangleNumber: number): TriangleID;
        GetPolygonPerimeterVertices(PolygonID: PolygonID, OutPolygonPerimeterVertexIDs: $Ref<TArray<VertexID>>): void;
        GetPolygonPerimeterVertexInstances(PolygonID: PolygonID, OutPolygonPerimeterVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;
        GetPolygonPerimeterVertexInstance(PolygonID: PolygonID, PolygonVertexNumber: number): VertexInstanceID;
        GetPolygonPerimeterVertexCount(PolygonID: PolygonID): number;
        GetPolygonPerimeterVertex(PolygonID: PolygonID, PolygonVertexNumber: number): VertexID;
        GetPolygonPerimeterEdges(PolygonID: PolygonID, OutPolygonPerimeterEdgeIDs: $Ref<TArray<EdgeID>>): void;
        GetPolygonPerimeterEdgeCount(PolygonID: PolygonID): number;
        GetPolygonPerimeterEdge(PolygonID: PolygonID, PerimeterEdgeNumber: number, bOutEdgeWindingIsReversedForPolygon: $Ref<boolean>): EdgeID;
        GetPolygonInGroup(PolygonGroupID: PolygonGroupID, PolygonNumber: number): PolygonID;
        GetPolygonGroupCount(): number;
        GetPolygonCountInGroup(PolygonGroupID: PolygonGroupID): number;
        GetPolygonCount(): number;
        GetPolygonAdjacentPolygons(PolygonID: PolygonID, OutAdjacentPolygons: $Ref<TArray<PolygonID>>): void;
        GetGroupForPolygon(PolygonID: PolygonID): PolygonGroupID;
        GetFirstValidPolygonGroup(): PolygonGroupID;
        GetEdgeVertices(EdgeID: EdgeID, OutEdgeVertexID0: $Ref<VertexID>, OutEdgeVertexID1: $Ref<VertexID>): void;
        GetEdgeVertex(EdgeID: EdgeID, EdgeVertexNumber: number): VertexID;
        GetEdgeThatConnectsVertices(VertexID0: VertexID, VertexID1: VertexID): EdgeID;
        GetEdgeLoopElements(EdgeID: EdgeID, EdgeLoopIDs: $Ref<TArray<EdgeID>>): void;
        GetEdgeCount(): number;
        GetEdgeConnectedPolygons(EdgeID: EdgeID, OutConnectedPolygonIDs: $Ref<TArray<PolygonID>>): void;
        GetEdgeConnectedPolygonCount(EdgeID: EdgeID): number;
        GetEdgeConnectedPolygon(EdgeID: EdgeID, ConnectedPolygonNumber: number): PolygonID;
        GeneratePolygonTangentsAndNormals(PolygonIDs: TArray<PolygonID>): void;
        FlipPolygons(PolygonIDs: TArray<PolygonID>): void;
        FindPolygonPerimeterVertexNumberForVertex(PolygonID: PolygonID, VertexID: VertexID): number;
        FindPolygonPerimeterEdgeNumberForVertices(PolygonID: PolygonID, EdgeVertexID0: VertexID, EdgeVertexID1: VertexID): number;
        FindPolygonLoop(EdgeID: EdgeID, OutEdgeLoopEdgeIDs: $Ref<TArray<EdgeID>>, OutFlippedEdgeIDs: $Ref<TArray<EdgeID>>, OutReversedEdgeIDPathToTake: $Ref<TArray<EdgeID>>, OutPolygonIDsToSplit: $Ref<TArray<PolygonID>>): void;
        ExtrudePolygons(Polygons: TArray<PolygonID>, ExtrudeDistance: number, bKeepNeighborsTogether: boolean, OutNewExtrudedFrontPolygons: $Ref<TArray<PolygonID>>): void;
        ExtendVertices(VertexIDs: TArray<VertexID>, bOnlyExtendClosestEdge: boolean, ReferencePosition: Vector, OutNewExtendedVertexIDs: $Ref<TArray<VertexID>>): void;
        ExtendEdges(EdgeIDs: TArray<EdgeID>, bWeldNeighbors: boolean, OutNewExtendedEdgeIDs: $Ref<TArray<EdgeID>>): void;
        EndModification(bFromUndo: boolean): void;
        DeleteVertexInstances(VertexInstanceIDsToDelete: TArray<VertexInstanceID>, bDeleteOrphanedVertices: boolean): void;
        DeleteVertexAndConnectedEdgesAndPolygons(VertexID: VertexID, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean): void;
        DeletePolygons(PolygonIDsToDelete: TArray<PolygonID>, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean): void;
        DeletePolygonGroups(PolygonGroupIDs: TArray<PolygonGroupID>): void;
        DeleteOrphanVertices(VertexIDsToDelete: TArray<VertexID>): void;
        DeleteEdges(EdgeIDsToDelete: TArray<EdgeID>, bDeleteOrphanedVertices: boolean): void;
        DeleteEdgeAndConnectedPolygons(EdgeID: EdgeID, bDeleteOrphanedEdges: boolean, bDeleteOrphanedVertices: boolean, bDeleteOrphanedVertexInstances: boolean, bDeleteEmptyPolygonGroups: boolean): void;
        CreateVertices(VerticesToCreate: TArray<VertexToCreate>, OutNewVertexIDs: $Ref<TArray<VertexID>>): void;
        CreateVertexInstances(VertexInstancesToCreate: TArray<VertexInstanceToCreate>, OutNewVertexInstanceIDs: $Ref<TArray<VertexInstanceID>>): void;
        CreatePolygons(PolygonsToCreate: TArray<PolygonToCreate>, OutNewPolygonIDs: $Ref<TArray<PolygonID>>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        CreatePolygonGroups(PolygonGroupsToCreate: TArray<PolygonGroupToCreate>, OutNewPolygonGroupIDs: $Ref<TArray<PolygonGroupID>>): void;
        CreateMissingPolygonPerimeterEdges(PolygonID: PolygonID, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        CreateEmptyVertexRange(NumVerticesToCreate: number, OutNewVertexIDs: $Ref<TArray<VertexID>>): void;
        CreateEdges(EdgesToCreate: TArray<EdgeToCreate>, OutNewEdgeIDs: $Ref<TArray<EdgeID>>): void;
        ComputePolygonsSharedEdges(PolygonIDs: TArray<PolygonID>, OutSharedEdgeIDs: $Ref<TArray<EdgeID>>): void;
        ComputePolygonPlane(PolygonID: PolygonID): Plane;
        ComputePolygonNormal(PolygonID: PolygonID): Vector;
        ComputePolygonCenter(PolygonID: PolygonID): Vector;
        ComputeBoundingBoxAndSphere(): BoxSphereBounds;
        ComputeBoundingBox(): Box;
        CommitInstance(ComponentToInstanceTo: PrimitiveComponent): EditableMesh;
        Commit(): void;
        ChangePolygonsVertexInstances(VertexInstancesForPolygons: TArray<ChangeVertexInstancesForPolygon>): void;
        BevelPolygons(PolygonIDs: TArray<PolygonID>, BevelFixedDistance: number, BevelProgressTowardCenter: number, OutNewCenterPolygonIDs: $Ref<TArray<PolygonID>>, OutNewSidePolygonIDs: $Ref<TArray<PolygonID>>): void;
        AssignPolygonsToPolygonGroups(PolygonGroupForPolygons: TArray<PolygonGroupForPolygon>, bDeleteOrphanedPolygonGroups: boolean): void;
        AnyChangesToUndo(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableMesh;
        static Load(InName: string): EditableMesh;
    }
    
    class EditableMeshFactory extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static MakeEditableMesh(PrimitiveComponent: PrimitiveComponent, LODIndex: number): EditableMesh;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableMeshFactory;
        static Load(InName: string): EditableMeshFactory;
    }
    
    class EditableStaticMeshAdapter extends EditableMeshAdapter {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StaticMesh: StaticMesh;
        OriginalStaticMesh: StaticMesh;
        StaticMeshLODIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditableStaticMeshAdapter;
        static Load(InName: string): EditableStaticMeshAdapter;
    }
    
    class MobileInstalledContent extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Mount(PakOrder: number, MountPoint: string): boolean;
        GetInstalledContentSize(): number;
        GetDiskFreeSpace(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MobileInstalledContent;
        static Load(InName: string): MobileInstalledContent;
    }
    
    class MobilePendingContent extends MobileInstalledContent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StartInstall(OnSucceeded: $Delegate<() => void>, OnFailed: $Delegate<(ErrorText: string, ErrorCode: number) => void>): void;
        GetTotalDownloadedSize(): number;
        GetRequiredDiskSpace(): number;
        GetInstallProgress(): number;
        GetDownloadStatusText(): string;
        GetDownloadSpeed(): number;
        GetDownloadSize(): number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MobilePendingContent;
        static Load(InName: string): MobilePendingContent;
    }
    
    class MobilePatchingLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static RequestContent(RemoteManifestURL: string, CloudURL: string, InstallDirectory: string, OnSucceeded: $Delegate<(MobilePendingContent: MobilePendingContent) => void>, OnFailed: $Delegate<(ErrorText: string, ErrorCode: number) => void>): void;
        static HasActiveWiFiConnection(): boolean;
        static GetSupportedPlatformNames(): TArray<string>;
        static GetInstalledContent(InstallDirectory: string): MobileInstalledContent;
        static GetActiveDeviceProfileName(): string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MobilePatchingLibrary;
        static Load(InName: string): MobilePatchingLibrary;
    }
    
    enum EOculusMR_BoundaryType { BT_OuterBoundary, BT_PlayArea, BT_MAX}
    class OculusMR_PlaneMeshTriangle {
        constructor(Vertex0: Vector, UV0: Vector2D, Vertex1: Vector, UV1: Vector2D, Vertex2: Vector, UV2: Vector2D);
        Vertex0: Vector;
        UV0: Vector2D;
        Vertex1: Vector;
        UV1: Vector2D;
        Vertex2: Vector;
        UV2: Vector2D;
    }
    
    class OculusMR_PlaneMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SetCustomMeshTriangles(Triangles: TArray<OculusMR_PlaneMeshTriangle>): boolean;
        ClearCustomMeshTriangles(): void;
        AddCustomMeshTriangles(Triangles: TArray<OculusMR_PlaneMeshTriangle>): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_PlaneMeshComponent;
        static Load(InName: string): OculusMR_PlaneMeshComponent;
    }
    
    enum EOculusMR_ClippingReference { CR_TrackingReference, CR_Head, CR_MAX}
    enum EOculusMR_VirtualGreenScreenType { VGS_Off, VGS_OuterBoundary, VGS_PlayArea, VGS_MAX}
    enum EOculusMR_PostProcessEffects { PPE_Off, PPE_On, PPE_MAX}
    enum EOculusMR_CompositionMethod { ExternalComposition, DirectComposition, EOculusMR_MAX}
    enum EOculusMR_CameraDeviceEnum { CD_None, CD_WebCamera0, CD_WebCamera1, CD_ZEDCamera, CD_MAX}
    enum EOculusMR_DepthQuality { DQ_Low, DQ_Medium, DQ_High, DQ_MAX}
    class OculusMR_Settings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ClippingReference: EOculusMR_ClippingReference;
        bUseTrackedCameraResolution: boolean;
        WidthPerView: number;
        HeightPerView: number;
        CastingLatency: number;
        BackdropColor: Color;
        HandPoseStateLatency: number;
        ChromaKeyColor: Color;
        ChromaKeySimilarity: number;
        ChromaKeySmoothRange: number;
        ChromaKeySpillRange: number;
        VirtualGreenScreenType: EOculusMR_VirtualGreenScreenType;
        DynamicLightingDepthSmoothFactor: number;
        DynamicLightingDepthVariationClampingValue: number;
        ExternalCompositionPostProcessEffects: EOculusMR_PostProcessEffects;
        bIsCasting: boolean;
        CompositionMethod: EOculusMR_CompositionMethod;
        CapturingCamera: EOculusMR_CameraDeviceEnum;
        bUseDynamicLighting: boolean;
        DepthQuality: EOculusMR_DepthQuality;
        SetUseDynamicLighting(val: boolean): void;
        SetIsCasting(val: boolean): void;
        SetDepthQuality(val: EOculusMR_DepthQuality): void;
        SetCompositionMethod(val: EOculusMR_CompositionMethod): void;
        SetCapturingCamera(val: EOculusMR_CameraDeviceEnum): void;
        SaveToIni(): void;
        LoadFromIni(): void;
        GetUseDynamicLighting(): boolean;
        GetIsCasting(): boolean;
        GetDepthQuality(): EOculusMR_DepthQuality;
        GetCompositionMethod(): EOculusMR_CompositionMethod;
        GetCapturingCamera(): EOculusMR_CameraDeviceEnum;
        GetBindToTrackedCameraIndex(): number;
        BindToTrackedCameraIndexIfAvailable(InTrackedCameraIndex: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_Settings;
        static Load(InName: string): OculusMR_Settings;
    }
    
    class TrackedCamera {
        constructor(Index: number, Name: string, FieldOfView: number, SizeX: number, SizeY: number, AttachedTrackedDevice: ETrackedDeviceType, CalibratedRotation: Rotator, CalibratedOffset: Vector, UserRotation: Rotator, UserOffset: Vector, RawRotation: Rotator, RawOffset: Vector);
        Index: number;
        Name: string;
        FieldOfView: number;
        SizeX: number;
        SizeY: number;
        AttachedTrackedDevice: ETrackedDeviceType;
        CalibratedRotation: Rotator;
        CalibratedOffset: Vector;
        UserRotation: Rotator;
        UserOffset: Vector;
        RawRotation: Rotator;
        RawOffset: Vector;
    }
    
    class OculusMR_State extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackedCamera: TrackedCamera;
        TrackingReferenceComponent: SceneComponent;
        ChangeCameraStateRequested: boolean;
        BindToTrackedCameraIndexRequested: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_State;
        static Load(InName: string): OculusMR_State;
    }
    
    class OculusMR_CastingCameraActor extends SceneCapture2D {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        VRNotificationComponent: VRNotificationsComponent;
        CameraColorTexture: Texture2D;
        CameraDepthTexture: Texture2D;
        PlaneMeshComponent: OculusMR_PlaneMeshComponent;
        ChromaKeyMaterial: Material;
        ChromaKeyLitMaterial: Material;
        OpaqueColoredMaterial: Material;
        ChromaKeyMaterialInstance: MaterialInstanceDynamic;
        ChromaKeyLitMaterialInstance: MaterialInstanceDynamic;
        CameraFrameMaterialInstance: MaterialInstanceDynamic;
        BackdropMaterialInstance: MaterialInstanceDynamic;
        BoundaryActor: OculusMR_BoundaryActor;
        BoundarySceneCaptureActor: SceneCapture2D;
        DefaultTexture_White: Texture2D;
        BackgroundRenderTargets: TArray<TextureRenderTarget2D>;
        ForegroundCaptureActor: SceneCapture2D;
        ForegroundRenderTargets: TArray<TextureRenderTarget2D>;
        MRSettings: OculusMR_Settings;
        MRState: OculusMR_State;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_CastingCameraActor;
        static Load(InName: string): OculusMR_CastingCameraActor;
    }
    
    class OculusMR_BoundaryMeshComponent extends MeshComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundaryType: EOculusMR_BoundaryType;
        BottomZ: number;
        TopZ: number;
        WhiteMaterial: Material;
        CastingCameraActor: OculusMR_CastingCameraActor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_BoundaryMeshComponent;
        static Load(InName: string): OculusMR_BoundaryMeshComponent;
    }
    
    class OculusMR_BoundaryActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BoundaryMeshComponent: OculusMR_BoundaryMeshComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMR_BoundaryActor;
        static Load(InName: string): OculusMR_BoundaryActor;
    }
    
    class OculusMRFunctionLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetTrackingReferenceComponent(Component: SceneComponent): void;
        static IsMrcEnabled(): boolean;
        static IsMrcActive(): boolean;
        static GetTrackingReferenceComponent(): SceneComponent;
        static GetOculusMRSettings(): OculusMR_Settings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusMRFunctionLibrary;
        static Load(InName: string): OculusMRFunctionLibrary;
    }
    
    class GooglePlayAchievementMapping {
        constructor(Name: string, AchievementID: string);
        Name: string;
        AchievementID: string;
    }
    
    class GooglePlayLeaderboardMapping {
        constructor(Name: string, LeaderboardID: string);
        Name: string;
        LeaderboardID: string;
    }
    
    class AndroidRuntimeSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PackageName: string;
        StoreVersion: number;
        StoreVersionOffsetArmV7: number;
        StoreVersionOffsetArm64: number;
        StoreVersionOffsetX8664: number;
        ApplicationDisplayName: string;
        VersionDisplayName: string;
        MinSDKVersion: number;
        TargetSDKVersion: number;
        InstallLocation: number;
        bEnableGradle: boolean;
        bEnableLint: boolean;
        bPackageDataInsideApk: boolean;
        bCreateAllPlatformsInstall: boolean;
        bDisableVerifyOBBOnStartUp: boolean;
        bAllowLargeOBBFiles: boolean;
        bAllowPatchOBBFile: boolean;
        bUseExternalFilesDir: boolean;
        bPublicLogFiles: boolean;
        Orientation: number;
        MaxAspectRatio: number;
        bUseDisplayCutout: boolean;
        bRestoreNotificationsOnReboot: boolean;
        bFullScreen: boolean;
        bEnableNewKeyboard: boolean;
        DepthBufferPreference: number;
        bValidateTextureFormats: boolean;
        ExtraManifestNodeTags: TArray<string>;
        ExtraApplicationNodeTags: TArray<string>;
        ExtraApplicationSettings: string;
        ExtraActivityNodeTags: TArray<string>;
        ExtraActivitySettings: string;
        ExtraPermissions: TArray<string>;
        bAndroidVoiceEnabled: boolean;
        PackageForOculusMobile: TArray<number>;
        bRemoveOSIG: boolean;
        GoogleVRCaps: TArray<number>;
        bGoogleVRSustainedPerformance: boolean;
        KeyStore: string;
        KeyAlias: string;
        KeyStorePassword: string;
        KeyPassword: string;
        bBuildForArmV7: boolean;
        bBuildForArm64: boolean;
        bBuildForX8664: boolean;
        bBuildForES2: boolean;
        bBuildForES31: boolean;
        bSupportsVulkan: boolean;
        bDetectVulkanByDefault: boolean;
        bBuildWithHiddenSymbolVisibility: boolean;
        bSaveSymbols: boolean;
        bEnableGooglePlaySupport: boolean;
        bUseGetAccounts: boolean;
        GamesAppID: string;
        AchievementMap: TArray<GooglePlayAchievementMapping>;
        LeaderboardMap: TArray<GooglePlayLeaderboardMapping>;
        bEnableSnapshots: boolean;
        bSupportAdMob: boolean;
        AdMobAdUnitID: string;
        AdMobAdUnitIDs: TArray<string>;
        GooglePlayLicenseKey: string;
        GCMClientSenderID: string;
        bShowLaunchImage: boolean;
        bAllowIMU: boolean;
        bAllowControllers: boolean;
        bBlockAndroidKeysOnControllers: boolean;
        AndroidAudio: number;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: PlatformRuntimeAudioCompressionOverrides;
        ChunkSizeKB: number;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        bResampleForDevice: boolean;
        SoundCueCookQualityIndex: number;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        AndroidGraphicsDebugger: number;
        MaliGraphicsDebuggerPath: DirectoryPath;
        bMultiTargetFormat_ETC1: boolean;
        bMultiTargetFormat_ETC1a: boolean;
        bMultiTargetFormat_ETC2: boolean;
        bMultiTargetFormat_DXT: boolean;
        bMultiTargetFormat_PVRTC: boolean;
        bMultiTargetFormat_ATC: boolean;
        bMultiTargetFormat_ASTC: boolean;
        TextureFormatPriority_ETC1: number;
        TextureFormatPriority_ETC1a: number;
        TextureFormatPriority_ETC2: number;
        TextureFormatPriority_DXT: number;
        TextureFormatPriority_PVRTC: number;
        TextureFormatPriority_ATC: number;
        TextureFormatPriority_ASTC: number;
        SDKAPILevelOverride: string;
        NDKAPILevelOverride: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidRuntimeSettings;
        static Load(InName: string): AndroidRuntimeSettings;
    }
    
    enum EOculusPlatform { PC, Mobile, Length, EOculusPlatform_MAX}
    class OculusEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PerfToolIgnoreList: TMap<string, boolean>;
        PerfToolTargetPlatform: EOculusPlatform;
        bAddMenuOption: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusEditorSettings;
        static Load(InName: string): OculusEditorSettings;
    }
    
    class RedistPackage {
        constructor(Included: boolean, Name: string, Id: string);
        Included: boolean;
        Name: string;
        Id: string;
    }
    
    enum EOculusPlatformTarget { Rift, Quest, Mobile, Length, EOculusPlatformTarget_MAX}
    enum EOculusGamepadEmulation { Off, Twinstick, RightDPad, LeftDPad, Length, EOculusGamepadEmulation_MAX}
    enum EOculusAssetType { Default, Store, Language_Pack, Length, EOculusAssetType_MAX}
    class AssetConfig {
        constructor(AssetType: EOculusAssetType, Required: boolean, Name: string, Sku: string);
        AssetType: EOculusAssetType;
        Required: boolean;
        Name: string;
        Sku: string;
    }
    
    class AssetConfigArray {
        constructor(ConfigArray: TArray<AssetConfig>);
        ConfigArray: TArray<AssetConfig>;
    }
    
    class OculusPlatformToolSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OculusRiftBuildDirectory: string;
        OculusRiftBuildVersion: string;
        OculusRiftLaunchParams: string;
        OculusRiftFireWallException: boolean;
        OculusRift2DLaunchPath: string;
        OculusRift2DLaunchParams: string;
        OculusRedistPackages: TArray<RedistPackage>;
        OculusTargetPlatform: EOculusPlatformTarget;
        OculusApplicationID: TArray<string>;
        OculusApplicationToken: TArray<string>;
        OculusReleaseChannel: TArray<string>;
        OculusReleaseNote: TArray<string>;
        OculusLaunchFilePath: TArray<string>;
        OculusRiftGamepadEmulation: EOculusGamepadEmulation;
        OculusLanguagePacksPath: TArray<string>;
        OculusExpansionFilesPath: TArray<string>;
        OculusAssetConfigs: TArray<AssetConfigArray>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): OculusPlatformToolSettings;
        static Load(InName: string): OculusPlatformToolSettings;
    }
    
    class MockAI extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BBComp: BlackboardComponent;
        BrainComp: BrainComponent;
        PerceptionComp: AIPerceptionComponent;
        PawnActionComp: PawnActionsComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockAI;
        static Load(InName: string): MockAI;
    }
    
    class MockAI_BT extends MockAI {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        BTComp: BehaviorTreeComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockAI_BT;
        static Load(InName: string): MockAI_BT;
    }
    
    class MockTask_Log extends GameplayTask {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockTask_Log;
        static Load(InName: string): MockTask_Log;
    }
    
    class MockGameplayTasksComponent extends GameplayTasksComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockGameplayTasksComponent;
        static Load(InName: string): MockGameplayTasksComponent;
    }
    
    class MockGameplayTaskOwner extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GTComponent: GameplayTasksComponent;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MockGameplayTaskOwner;
        static Load(InName: string): MockGameplayTaskOwner;
    }
    
    class TestBTDecorator_CantExecute extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_CantExecute;
        static Load(InName: string): TestBTDecorator_CantExecute;
    }
    
    class TestBTDecorator_DelayedAbort extends BTDecorator {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DelayTicks: number;
        bOnlyOnce: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTDecorator_DelayedAbort;
        static Load(InName: string): TestBTDecorator_DelayedAbort;
    }
    
    class TestBTService_Log extends BTService {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogActivation: number;
        LogDeactivation: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTService_Log;
        static Load(InName: string): TestBTService_Log;
    }
    
    class TestBTTask_LatentWithFlags extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogIndexExecuteStart: number;
        LogIndexExecuteFinish: number;
        LogIndexAbortStart: number;
        LogIndexAbortFinish: number;
        ExecuteTicks: number;
        AbortTicks: number;
        KeyNameExecute: string;
        KeyNameAbort: string;
        LogResult: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_LatentWithFlags;
        static Load(InName: string): TestBTTask_LatentWithFlags;
    }
    
    class TestBTTask_Log extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        LogIndex: number;
        LogFinished: number;
        ExecutionTicks: number;
        LogResult: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_Log;
        static Load(InName: string): TestBTTask_Log;
    }
    
    class TestBTTask_SetFlag extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyName: string;
        bValue: boolean;
        TaskResult: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_SetFlag;
        static Load(InName: string): TestBTTask_SetFlag;
    }
    
    class TestBTTask_SetValue extends BTTaskNode {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        KeyName: string;
        Value: number;
        TaskResult: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBTTask_SetValue;
        static Load(InName: string): TestBTTask_SetValue;
    }
    
    class TestPawnAction_Log extends PawnAction {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestPawnAction_Log;
        static Load(InName: string): TestPawnAction_Log;
    }
    
    class TestPawnAction_CallFunction extends TestPawnAction_Log {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestPawnAction_CallFunction;
        static Load(InName: string): TestPawnAction_CallFunction;
    }
    
    enum ELiveCodingStartupMode { Automatic, AutomaticButHidden, Manual, ELiveCodingStartupMode_MAX}
    class LiveCodingSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnabled: boolean;
        Startup: ELiveCodingStartupMode;
        bPreloadEngineModules: boolean;
        bPreloadEnginePluginModules: boolean;
        bPreloadProjectModules: boolean;
        bPreloadProjectPluginModules: boolean;
        PreloadNamedModules: TArray<string>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LiveCodingSettings;
        static Load(InName: string): LiveCodingSettings;
    }
    
    class StructViewerProjectSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        InternalOnlyPaths: TArray<DirectoryPath>;
        InternalOnlyStructs: TArray<TSoftObjectPtr<ScriptStruct>>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StructViewerProjectSettings;
        static Load(InName: string): StructViewerProjectSettings;
    }
    
    class UndoHistorySettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bShowTransactionDetails: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): UndoHistorySettings;
        static Load(InName: string): UndoHistorySettings;
    }
    
    class LocalizationDashboardSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LocalizationDashboardSettings;
        static Load(InName: string): LocalizationDashboardSettings;
    }
    
    enum EMeshInstancingReplacementMethod { RemoveOriginalActors, KeepOriginalActorsAsEditorOnly, EMeshInstancingReplacementMethod_MAX}
    class MeshInstancingSettings {
        constructor(ActorClassToUse: Class, InstanceReplacementThreshold: number, MeshReplacementMethod: EMeshInstancingReplacementMethod, bSkipMeshesWithVertexColors: boolean, bUseHLODVolumes: boolean, ISMComponentToUse: Class);
        ActorClassToUse: Class;
        InstanceReplacementThreshold: number;
        MeshReplacementMethod: EMeshInstancingReplacementMethod;
        bSkipMeshesWithVertexColors: boolean;
        bUseHLODVolumes: boolean;
        ISMComponentToUse: Class;
    }
    
    class MeshInstancingSettingsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: MeshInstancingSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshInstancingSettingsObject;
        static Load(InName: string): MeshInstancingSettingsObject;
    }
    
    class MeshMergingSettingsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: MeshMergingSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshMergingSettingsObject;
        static Load(InName: string): MeshMergingSettingsObject;
    }
    
    class MeshProxySettingsObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Settings: MeshProxySettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MeshProxySettingsObject;
        static Load(InName: string): MeshProxySettingsObject;
    }
    
    class EditorKeyboardShortcutSettings extends DeveloperSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorKeyboardShortcutSettings;
        static Load(InName: string): EditorKeyboardShortcutSettings;
    }
    
    class EdModeInteractiveToolsContext extends InteractiveToolsContext {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        StandardVertexColorMaterial: MaterialInterface;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EdModeInteractiveToolsContext;
        static Load(InName: string): EdModeInteractiveToolsContext;
    }
    
    enum EIOSCloudKitSyncStrategy { None, OnlyAtGameStart, Always, EIOSCloudKitSyncStrategy_MAX}
    class IOSBuildResourceDirectory {
        constructor(Path: string);
        Path: string;
    }
    
    class IOSBuildResourceFilePath {
        constructor(FilePath: string);
        FilePath: string;
    }
    
    enum EIOSLandscapeOrientation { LandscapeLeft, LandscapeRight, EIOSLandscapeOrientation_MAX}
    enum EPowerUsageFrameRateLock { PUFRL_None, PUFRL_20, PUFRL_30, PUFRL_60, PUFRL_MAX}
    enum EIOSVersion { IOS_61, IOS_7, IOS_8, IOS_9, IOS_10, IOS_11, IOS_12, IOS_MAX}
    class IOSRuntimeSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableGameCenterSupport: boolean;
        bEnableCloudKitSupport: boolean;
        IOSCloudKitSyncStrategy: EIOSCloudKitSyncStrategy;
        bEnableRemoteNotificationsSupport: boolean;
        bEnableBackgroundFetch: boolean;
        bSupportsMetal: boolean;
        bSupportsMetalMRT: boolean;
        bCookPVRTCTextures: boolean;
        bCookASTCTextures: boolean;
        bBuildAsFramework: boolean;
        EnableRemoteShaderCompile: boolean;
        bGeneratedSYMFile: boolean;
        bGeneratedSYMBundle: boolean;
        bGenerateCrashReportSymbols: boolean;
        bGenerateXCArchive: boolean;
        bDevForArmV7: boolean;
        bDevForArm64: boolean;
        bDevForArmV7S: boolean;
        bShipForArmV7: boolean;
        bShipForArm64: boolean;
        bShipForArmV7S: boolean;
        bShipForBitcode: boolean;
        bEnableAdvertisingIdentifier: boolean;
        AdditionalLinkerFlags: string;
        AdditionalShippingLinkerFlags: string;
        RemoteServerName: string;
        bUseRSync: boolean;
        RSyncUsername: string;
        DeltaCopyInstallPath: IOSBuildResourceDirectory;
        SSHPrivateKeyLocation: string;
        SSHPrivateKeyOverridePath: IOSBuildResourceFilePath;
        bTreatRemoteAsSeparateController: boolean;
        bAllowRemoteRotation: boolean;
        bUseRemoteAsVirtualJoystick: boolean;
        bUseRemoteAbsoluteDpadValues: boolean;
        bAllowControllers: boolean;
        bDisableMotionData: boolean;
        bSupportsPortraitOrientation: boolean;
        bSupportsUpsideDownOrientation: boolean;
        bSupportsLandscapeLeftOrientation: boolean;
        bSupportsLandscapeRightOrientation: boolean;
        bSupportsITunesFileSharing: boolean;
        PreferredLandscapeOrientation: EIOSLandscapeOrientation;
        BundleDisplayName: string;
        BundleName: string;
        BundleIdentifier: string;
        VersionInfo: string;
        FrameRateLock: EPowerUsageFrameRateLock;
        MinimumiOSVersion: EIOSVersion;
        bSupportsIPad: boolean;
        bSupportsIPhone: boolean;
        AdditionalPlistData: string;
        bEnableFacebookSupport: boolean;
        FacebookAppID: string;
        MobileProvision: string;
        SigningCertificate: string;
        bAutomaticSigning: boolean;
        IOSTeamID: string;
        bDisableHTTPS: boolean;
        MaxShaderLanguageVersion: number;
        UseFastIntrinsics: boolean;
        ForceFloats: boolean;
        EnableMathOptimisations: boolean;
        IndirectArgumentTier: number;
        bUseIntegratedKeyboard: boolean;
        AudioSampleRate: number;
        AudioCallbackBufferFrameSize: number;
        AudioNumBuffersToEnqueue: number;
        AudioMaxChannels: number;
        AudioNumSourceWorkers: number;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        CompressionOverrides: PlatformRuntimeAudioCompressionOverrides;
        ChunkSizeKB: number;
        bUseAudioStreamCaching: boolean;
        CacheSizeKB: number;
        bResampleForDevice: boolean;
        SoundCueCookQualityIndex: number;
        MaxSampleRate: number;
        HighSampleRate: number;
        MedSampleRate: number;
        LowSampleRate: number;
        MinSampleRate: number;
        CompressionQualityModifier: number;
        AutoStreamingThreshold: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): IOSRuntimeSettings;
        static Load(InName: string): IOSRuntimeSettings;
    }
    
    enum ELuminFrameTimingHint { Unspecified, Maximum, FPS_60, FPS_120, ELuminFrameTimingHint_MAX}
    enum ELuminPrivilege { Invalid, BatteryInfo, CameraCapture, WorldReconstruction, InAppPurchase, AudioCaptureMic, DrmCertificates, Occlusion, LowLatencyLightwear, Internet, IdentityRead, BackgroundDownload, BackgroundUpload, MediaDrm, Media, MediaMetadata, PowerInfo, LocalAreaNetwork, VoiceInput, Documents, ConnectBackgroundMusicService, RegisterBackgroundMusicService, PwFoundObjRead, NormalNotificationsUsage, MusicService, ControllerPose, ScreensProvider, GesturesSubscribe, GesturesConfig, AddressBookRead, AddressBookWrite, CoarseLocation, HandMesh, WifiStatusRead, ELuminPrivilege_MAX}
    enum ELuminComponentSubElementType { FileExtension, MimeType, Mode, MusicAttribute, Schema, ELuminComponentSubElementType_MAX}
    class LuminComponentSubElement {
        constructor(ElementType: ELuminComponentSubElementType, Value: string);
        ElementType: ELuminComponentSubElementType;
        Value: string;
    }
    
    enum ELuminComponentType { Universe, Fullscreen, SearchProvider, MusicService, Screens, ScreensImmersive, Console, SystemUI, ELuminComponentType_MAX}
    class LuminComponentElement {
        constructor(Name: string, VisibleName: string, ExecutableName: string, ComponentType: ELuminComponentType, ExtraComponentSubElements: TArray<LuminComponentSubElement>);
        Name: string;
        VisibleName: string;
        ExecutableName: string;
        ComponentType: ELuminComponentType;
        ExtraComponentSubElements: TArray<LuminComponentSubElement>;
    }
    
    class LuminRuntimeSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PackageName: string;
        ApplicationDisplayName: string;
        bIsScreensApp: boolean;
        FrameTimingHint: ELuminFrameTimingHint;
        bProtectedContent: boolean;
        bUseMobileRendering: boolean;
        bUseVulkan: boolean;
        Certificate: FilePath;
        IconModelPath: DirectoryPath;
        IconPortalPath: DirectoryPath;
        VersionCode: number;
        MinimumAPILevel: number;
        AppPrivileges: TArray<ELuminPrivilege>;
        ExtraComponentSubElements: TArray<LuminComponentSubElement>;
        ExtraComponentElements: TArray<LuminComponentElement>;
        SpatializationPlugin: string;
        ReverbPlugin: string;
        OcclusionPlugin: string;
        SoundCueCookQualityIndex: number;
        bRemoveDebugInfo: boolean;
        VulkanValidationLayerLibs: DirectoryPath;
        bFrameVignette: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LuminRuntimeSettings;
        static Load(InName: string): LuminRuntimeSettings;
    }
    
    class AndroidSDKSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SDKPath: DirectoryPath;
        NDKPath: DirectoryPath;
        JavaPath: DirectoryPath;
        SDKAPILevel: string;
        NDKAPILevel: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidSDKSettings;
        static Load(InName: string): AndroidSDKSettings;
    }
    
    class MagicLeapSDKSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MLSDKPath: DirectoryPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapSDKSettings;
        static Load(InName: string): MagicLeapSDKSettings;
    }
    
    class TutorialContent {
        constructor(Type: number, Content: string, ExcerptName: string, Text: string);
        Type: number;
        Content: string;
        ExcerptName: string;
        Text: string;
    }
    
    class TutorialContentAnchor {
        constructor(Type: number, WrapperIdentifier: string, Asset: SoftObjectPath, bDrawHighlight: boolean, TabToFocusOrOpen: string, FriendlyName: string, GUIDString: string, OuterName: string);
        Type: number;
        WrapperIdentifier: string;
        Asset: SoftObjectPath;
        bDrawHighlight: boolean;
        TabToFocusOrOpen: string;
        FriendlyName: string;
        GUIDString: string;
        OuterName: string;
    }
    
    class TutorialWidgetContent {
        constructor(Content: TutorialContent, WidgetAnchor: TutorialContentAnchor, HorizontalAlignment: number, VerticalAlignment: number, Offset: Vector2D, ContentWidth: number, bAutoFocus: boolean);
        Content: TutorialContent;
        WidgetAnchor: TutorialContentAnchor;
        HorizontalAlignment: number;
        VerticalAlignment: number;
        Offset: Vector2D;
        ContentWidth: number;
        bAutoFocus: boolean;
    }
    
    class TutorialStage {
        constructor(Name: string, Content: TutorialContent, WidgetContent: TArray<TutorialWidgetContent>, NextButtonText: string, BackButtonText: string, PlatformsToTest: TArray<string>, bInvertPlatformTest: boolean);
        Name: string;
        Content: TutorialContent;
        WidgetContent: TArray<TutorialWidgetContent>;
        NextButtonText: string;
        BackButtonText: string;
        PlatformsToTest: TArray<string>;
        bInvertPlatformTest: boolean;
    }
    
    class EditorTutorial extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Title: string;
        SortOrder: number;
        Icon: string;
        Texture: Texture2D;
        Category: string;
        SummaryContent: TutorialContent;
        Stages: TArray<TutorialStage>;
        PreviousTutorial: SoftClassPath;
        NextTutorial: SoftClassPath;
        bIsStandalone: boolean;
        AssetToUse: SoftObjectPath;
        ImportPath: string;
        bHideInBrowser: boolean;
        SearchTags: string;
        static SetEngineFolderVisibilty(bNewVisibility: boolean): void;
        static OpenAsset(Asset: Object): void;
        OnTutorialStageStarted(StageName: string): void;
        OnTutorialStageEnded(StageName: string): void;
        OnTutorialLaunched(): void;
        OnTutorialClosed(): void;
        static GoToPreviousTutorialStage(): void;
        static GoToNextTutorialStage(): void;
        static GetEngineFolderVisibilty(): boolean;
        GetActorReference(PathToActor: string): Actor;
        static BeginTutorial(TutorialToStart: EditorTutorial, bRestart: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorial;
        static Load(InName: string): EditorTutorial;
    }
    
    class EditorTutorialFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorialFactory;
        static Load(InName: string): EditorTutorialFactory;
    }
    
    class EditorTutorialImportFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorialImportFactory;
        static Load(InName: string): EditorTutorialImportFactory;
    }
    
    class TutorialCategory {
        constructor(Identifier: string, Title: string, SortOrder: number, Description: string, Icon: string, Texture: SoftObjectPath);
        Identifier: string;
        Title: string;
        SortOrder: number;
        Description: string;
        Icon: string;
        Texture: SoftObjectPath;
    }
    
    class TutorialContext {
        constructor(Context: string, BrowserFilter: string, AttractTutorial: SoftClassPath, LaunchTutorial: SoftClassPath);
        Context: string;
        BrowserFilter: string;
        AttractTutorial: SoftClassPath;
        LaunchTutorial: SoftClassPath;
    }
    
    class EditorTutorialSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bDisableAllTutorialAlerts: boolean;
        Categories: TArray<TutorialCategory>;
        StartupTutorial: SoftClassPath;
        TutorialContexts: TArray<TutorialContext>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): EditorTutorialSettings;
        static Load(InName: string): EditorTutorialSettings;
    }
    
    class TutorialSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Categories: TArray<TutorialCategory>;
        StartupTutorial: SoftClassPath;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TutorialSettings;
        static Load(InName: string): TutorialSettings;
    }
    
    class TutorialProgress {
        constructor(Tutorial: SoftClassPath, CurrentStage: number, bUserDismissed: boolean);
        Tutorial: SoftClassPath;
        CurrentStage: number;
        bUserDismissed: boolean;
    }
    
    class TutorialStateSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TutorialsProgress: TArray<TutorialProgress>;
        bDismissedAllTutorials: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TutorialStateSettings;
        static Load(InName: string): TutorialStateSettings;
    }
    
    class LogVisualizerSessionSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bEnableGraphsVisualization: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LogVisualizerSessionSettings;
        static Load(InName: string): LogVisualizerSessionSettings;
    }
    
    class CategoryFilter {
        constructor(CategoryName: string, LogVerbosity: number, Enabled: boolean);
        CategoryName: string;
        LogVerbosity: number;
        Enabled: boolean;
    }
    
    class VisualLoggerFiltersData {
        constructor(SearchBoxFilter: string, ObjectNameFilter: string, Categories: TArray<CategoryFilter>, SelectedClasses: TArray<string>);
        SearchBoxFilter: string;
        ObjectNameFilter: string;
        Categories: TArray<CategoryFilter>;
        SelectedClasses: TArray<string>;
    }
    
    class LogVisualizerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bIgnoreTrivialLogs: boolean;
        TrivialLogsThreshold: number;
        bStickToRecentData: boolean;
        bResetDataWithNewSession: boolean;
        bShowHistogramLabelsOutside: boolean;
        DefaultCameraDistance: number;
        bSearchInsideLogs: boolean;
        GraphsBackgroundColor: Color;
        bPresistentFilters: boolean;
        bDrawExtremesOnGraphs: boolean;
        bConstrainGraphToLocalMinMax: boolean;
        bUsePlayersOnlyForPause: boolean;
        bLogNavOctreeOnStop: boolean;
        PresistentFilters: VisualLoggerFiltersData;
        DebugMeshMaterialFakeLight: Material;
        DebugMeshMaterialFakeLightName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LogVisualizerSettings;
        static Load(InName: string): LogVisualizerSettings;
    }
    
    class VisualLoggerCameraController extends DebugCameraController {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PickedActor: Actor;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerCameraController;
        static Load(InName: string): VisualLoggerCameraController;
    }
    
    class VisualLoggerHUD extends DebugCameraHUD {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerHUD;
        static Load(InName: string): VisualLoggerHUD;
    }
    
    class VisualLoggerRenderingActor extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerRenderingActor;
        static Load(InName: string): VisualLoggerRenderingActor;
    }
    
    class VisualLoggerRenderingComponent extends PrimitiveComponent {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): VisualLoggerRenderingComponent;
        static Load(InName: string): VisualLoggerRenderingComponent;
    }
    
    class ClothPainterSettings extends MeshPaintSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ViewMin: number;
        ViewMax: number;
        bAutoViewRange: boolean;
        AutoCalculatedViewMin: number;
        AutoCalculatedViewMax: number;
        ClothingAssets: TArray<ClothingAssetCommon>;
        bFlipNormal: boolean;
        bCullBackface: boolean;
        Opacity: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPainterSettings;
        static Load(InName: string): ClothPainterSettings;
    }
    
    class ClothPaintTool_BrushSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PaintValue: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_BrushSettings;
        static Load(InName: string): ClothPaintTool_BrushSettings;
    }
    
    class ClothPaintTool_GradientSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GradientStartValue: number;
        GradientEndValue: number;
        bUseRegularBrush: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_GradientSettings;
        static Load(InName: string): ClothPaintTool_GradientSettings;
    }
    
    class ClothPaintTool_SmoothSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Strength: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_SmoothSettings;
        static Load(InName: string): ClothPaintTool_SmoothSettings;
    }
    
    class ClothPaintTool_FillSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Threshold: number;
        FillValue: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ClothPaintTool_FillSettings;
        static Load(InName: string): ClothPaintTool_FillSettings;
    }
    
    class MagicLeapFileMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MagicLeapFileMediaSourceFactory;
        static Load(InName: string): MagicLeapFileMediaSourceFactory;
    }
    
    class AndroidFileMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidFileMediaSourceFactory;
        static Load(InName: string): AndroidFileMediaSourceFactory;
    }
    
    class AndroidMediaSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        CacheableVideoSampleBuffers: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AndroidMediaSettings;
        static Load(InName: string): AndroidMediaSettings;
    }
    
    class AvfFileMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AvfFileMediaSourceFactory;
        static Load(InName: string): AvfFileMediaSourceFactory;
    }
    
    class AvfMediaSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        NativeAudioOut: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AvfMediaSettings;
        static Load(InName: string): AvfMediaSettings;
    }
    
    class ImgMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSourceFactory;
        static Load(InName: string): ImgMediaSourceFactory;
    }
    
    class ImgMediaSourceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ImgMediaSourceFactoryNew;
        static Load(InName: string): ImgMediaSourceFactoryNew;
    }
    
    class SequenceRecordingBase extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecordingBase;
        static Load(InName: string): SequenceRecordingBase;
    }
    
    class ActorRecordingSettings {
        constructor(Settings: TArray<Object>);
        Settings: TArray<Object>;
    }
    
    class AnimationRecordingSettings {
        constructor(bRecordInWorldSpace: boolean, bRemoveRootAnimation: boolean, bAutoSaveAsset: boolean, SampleRate: number, Length: number, InterpMode: number, TangentMode: number);
        bRecordInWorldSpace: boolean;
        bRemoveRootAnimation: boolean;
        bAutoSaveAsset: boolean;
        SampleRate: number;
        Length: number;
        InterpMode: number;
        TangentMode: number;
    }
    
    class ActorRecording extends SequenceRecordingBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorSettings: ActorRecordingSettings;
        bActive: boolean;
        bCreateLevelSequence: boolean;
        TargetLevelSequence: LevelSequence;
        TargetName: string;
        TakeNumber: number;
        bSpecifyTargetAnimation: boolean;
        TargetAnimation: AnimSequence;
        AnimationSettings: AnimationRecordingSettings;
        bRecordToPossessable: boolean;
        ActorToRecord: TSoftObjectPtr<Actor>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorRecording;
        static Load(InName: string): ActorRecording;
    }
    
    class MovieScene3DTransformSectionRecorderSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRecordTransforms: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieScene3DTransformSectionRecorderSettings;
        static Load(InName: string): MovieScene3DTransformSectionRecorderSettings;
    }
    
    class SequenceRecorderActorGroup extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        GroupName: string;
        SequenceName: string;
        SequenceRecordingBasePath: DirectoryPath;
        bSpecifyTargetLevelSequence: boolean;
        TargetLevelSequence: LevelSequence;
        bDuplicateTargetLevelSequence: boolean;
        bRecordTargetLevelSequenceLength: boolean;
        RecordedActors: TArray<ActorRecording>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderActorGroup;
        static Load(InName: string): SequenceRecorderActorGroup;
    }
    
    class SequenceRecorderGroup extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ActorGroups: TArray<SequenceRecorderActorGroup>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderGroup;
        static Load(InName: string): SequenceRecorderGroup;
    }
    
    class SequenceRecorderBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StopRecordingSequence(): void;
        static StartRecordingSequence(ActorsToRecord: TArray<Actor>): void;
        static IsRecordingSequence(): boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderBlueprintLibrary;
        static Load(InName: string): SequenceRecorderBlueprintLibrary;
    }
    
    enum EAudioRecordingMode { None, AudioTrack, EAudioRecordingMode_MAX}
    class SequenceRecorderActorFilter {
        constructor(ActorClassesToRecord: TArray<Class>);
        ActorClassesToRecord: TArray<Class>;
    }
    
    class PropertiesToRecordForClass {
        constructor(Class: Class, Properties: TArray<string>);
        Class: Class;
        Properties: TArray<string>;
    }
    
    class PropertiesToRecordForActorClass {
        constructor(Class: Class, Properties: TArray<string>);
        Class: Class;
        Properties: TArray<string>;
    }
    
    class SettingsForActorClass {
        constructor(Class: Class, bRecordToPossessable: boolean);
        Class: Class;
        bRecordToPossessable: boolean;
    }
    
    class SequenceRecorderSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bCreateLevelSequence: boolean;
        bImmersiveMode: boolean;
        SequenceLength: number;
        RecordingDelay: number;
        bAllowLooping: boolean;
        GlobalTimeDilation: number;
        bIgnoreTimeDilation: boolean;
        AnimationSubDirectory: string;
        RecordAudio: EAudioRecordingMode;
        AudioGain: number;
        bSplitAudioChannelsIntoSeparateTracks: boolean;
        bReplaceRecordedAudio: boolean;
        AudioTrackName: string;
        AudioSubDirectory: string;
        bRecordNearbySpawnedActors: boolean;
        NearbyActorRecordingProximity: number;
        bRecordWorldSettingsActor: boolean;
        bReduceKeys: boolean;
        bAutoSaveAsset: boolean;
        ActorFilter: SequenceRecorderActorFilter;
        LevelSequenceActorsToTrigger: TArray<TLazyObjectPtr<LevelSequenceActor>>;
        DefaultAnimationSettings: AnimationRecordingSettings;
        bRecordSequencerSpawnedActors: boolean;
        ClassesAndPropertiesToRecord: TArray<PropertiesToRecordForClass>;
        ActorsAndPropertiesToRecord: TArray<PropertiesToRecordForActorClass>;
        PerActorSettings: TArray<SettingsForActorClass>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SequenceRecorderSettings;
        static Load(InName: string): SequenceRecorderSettings;
    }
    
    enum EMediaPlayerRecordingNumerationStyle { AppendFrameNumber, AppendSampleTime, EMediaPlayerRecordingNumerationStyle_MAX}
    enum EMediaPlayerRecordingImageFormat { PNG, JPEG, BMP, EXR, EMediaPlayerRecordingImageFormat_MAX}
    class MediaPlayerRecordingSettings {
        constructor(bActive: boolean, bRecordMediaFrame: boolean, BaseFilename: string, NumerationStyle: EMediaPlayerRecordingNumerationStyle, ImageFormat: EMediaPlayerRecordingImageFormat, CompressionQuality: number, bResetAlpha: boolean);
        bActive: boolean;
        bRecordMediaFrame: boolean;
        BaseFilename: string;
        NumerationStyle: EMediaPlayerRecordingNumerationStyle;
        ImageFormat: EMediaPlayerRecordingImageFormat;
        CompressionQuality: number;
        bResetAlpha: boolean;
    }
    
    class MediaPlayerRecording extends SequenceRecordingBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        RecordingSettings: MediaPlayerRecordingSettings;
        MediaPlayerToRecord: TWeakObjectPtr<MediaPlayer>;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerRecording;
        static Load(InName: string): MediaPlayerRecording;
    }
    
    class MediaSequenceRecorderSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRecordMediaPlayerEnabled: boolean;
        MediaPlayerSubDirectory: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaSequenceRecorderSettings;
        static Load(InName: string): MediaSequenceRecorderSettings;
    }
    
    class FileMediaSourceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FileMediaSourceFactoryNew;
        static Load(InName: string): FileMediaSourceFactoryNew;
    }
    
    class MediaPlayerEditorMediaContext extends ToolMenuContextBase {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SelectedAsset: Object;
        StyleSetName: string;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerEditorMediaContext;
        static Load(InName: string): MediaPlayerEditorMediaContext;
    }
    
    enum EMediaPlayerEditorScale { Fill, Fit, Original, EMediaPlayerEditorScale_MAX}
    class MediaPlayerEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        DesiredPlayerName: string;
        ShowTextOverlays: boolean;
        ViewportScale: EMediaPlayerEditorScale;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerEditorSettings;
        static Load(InName: string): MediaPlayerEditorSettings;
    }
    
    class MediaPlayerFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlayerFactoryNew;
        static Load(InName: string): MediaPlayerFactoryNew;
    }
    
    class MediaPlaylistFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaPlaylistFactoryNew;
        static Load(InName: string): MediaPlaylistFactoryNew;
    }
    
    class MediaTextureFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MediaTextureFactoryNew;
        static Load(InName: string): MediaTextureFactoryNew;
    }
    
    class PlatformMediaSourceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PlatformMediaSourceFactoryNew;
        static Load(InName: string): PlatformMediaSourceFactoryNew;
    }
    
    class StreamMediaSourceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StreamMediaSourceFactoryNew;
        static Load(InName: string): StreamMediaSourceFactoryNew;
    }
    
    class WebMPlatFileMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WebMPlatFileMediaSourceFactory;
        static Load(InName: string): WebMPlatFileMediaSourceFactory;
    }
    
    class WmfFileMediaSourceFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): WmfFileMediaSourceFactory;
        static Load(InName: string): WmfFileMediaSourceFactory;
    }
    
    class LevelSequenceEditorBlueprintLibrary extends BlueprintFunctionLibrary {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static SetLockLevelSequence(bLock: boolean): void;
        static SetCurrentTime(NewFrame: number): void;
        static Play(): void;
        static Pause(): void;
        static OpenLevelSequence(LevelSequence: LevelSequence): boolean;
        static IsPlaying(): boolean;
        static IsLevelSequenceLocked(): boolean;
        static GetCurrentTime(): number;
        static GetCurrentLevelSequence(): LevelSequence;
        static CloseLevelSequence(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceEditorBlueprintLibrary;
        static Load(InName: string): LevelSequenceEditorBlueprintLibrary;
    }
    
    class LevelSequencePropertyTrackSettings {
        constructor(ComponentPath: string, PropertyPath: string);
        ComponentPath: string;
        PropertyPath: string;
    }
    
    class LevelSequenceTrackSettings {
        constructor(MatchingActorClass: SoftClassPath, DefaultTracks: TArray<SoftClassPath>, ExcludeDefaultTracks: TArray<SoftClassPath>, DefaultPropertyTracks: TArray<LevelSequencePropertyTrackSettings>, ExcludeDefaultPropertyTracks: TArray<LevelSequencePropertyTrackSettings>);
        MatchingActorClass: SoftClassPath;
        DefaultTracks: TArray<SoftClassPath>;
        ExcludeDefaultTracks: TArray<SoftClassPath>;
        DefaultPropertyTracks: TArray<LevelSequencePropertyTrackSettings>;
        ExcludeDefaultPropertyTracks: TArray<LevelSequencePropertyTrackSettings>;
    }
    
    class LevelSequenceEditorSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TrackSettings: TArray<LevelSequenceTrackSettings>;
        bAutoBindToPIE: boolean;
        bAutoBindToSimulate: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceEditorSettings;
        static Load(InName: string): LevelSequenceEditorSettings;
    }
    
    class LevelSequenceMasterSequenceSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        MasterSequenceName: string;
        MasterSequenceSuffix: string;
        MasterSequenceBasePath: DirectoryPath;
        MasterSequenceNumShots: number;
        MasterSequenceLevelSequenceToDuplicate: TLazyObjectPtr<LevelSequence>;
        SubSequenceNames: TArray<string>;
        bInstanceSubSequences: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceMasterSequenceSettings;
        static Load(InName: string): LevelSequenceMasterSequenceSettings;
    }
    
    class LevelSequenceFactoryNew extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelSequenceFactoryNew;
        static Load(InName: string): LevelSequenceFactoryNew;
    }
    
    enum EMotionRange { VR_WithoutController, VR_WithController, VR_MAX}
    enum EHandSkeleton { VR_SteamVRHandSkeleton, VR_UE4HandSkeleton, VR_MAX}
    class UE4RetargettingRefs {
        constructor(bIsInitialized: boolean, bIsRightHanded: boolean, KnuckleAverageMS_UE4: Vector, WristSideDirectionLS_UE4: Vector, WristForwardLS_UE4: Vector);
        bIsInitialized: boolean;
        bIsRightHanded: boolean;
        KnuckleAverageMS_UE4: Vector;
        WristSideDirectionLS_UE4: Vector;
        WristForwardLS_UE4: Vector;
    }
    
    class AnimNode_SteamVRInputAnimPose extends AnimNode_Base {
        constructor(MotionRange: EMotionRange, Hand: EHand, HandSkeleton: EHandSkeleton, Mirror: boolean, SteamVRSkeletalTransform: SteamVRSkeletonTransform, UE4RetargettingRefs: UE4RetargettingRefs);
        MotionRange: EMotionRange;
        Hand: EHand;
        HandSkeleton: EHandSkeleton;
        Mirror: boolean;
        SteamVRSkeletalTransform: SteamVRSkeletonTransform;
        UE4RetargettingRefs: UE4RetargettingRefs;
    }
    
    class AnimGraphNode_SteamVRInputAnimPose extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SteamVRInputAnimPose;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SteamVRInputAnimPose;
        static Load(InName: string): AnimGraphNode_SteamVRInputAnimPose;
    }
    
    class AnimNode_SteamVRSetWristTransform extends AnimNode_Base {
        constructor(ReferencePose: PoseLink, HandSkeleton: EHandSkeleton, TargetPose: PoseLink);
        ReferencePose: PoseLink;
        HandSkeleton: EHandSkeleton;
        TargetPose: PoseLink;
    }
    
    class AnimGraphNode_SteamVRSetWristTransform extends AnimGraphNode_Base {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Node: AnimNode_SteamVRSetWristTransform;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): AnimGraphNode_SteamVRSetWristTransform;
        static Load(InName: string): AnimGraphNode_SteamVRSetWristTransform;
    }
    
    class MovieSceneParticleTrackSectionRecorder extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        OnTriggered(Component: ParticleSystemComponent, bActivating: boolean): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneParticleTrackSectionRecorder;
        static Load(InName: string): MovieSceneParticleTrackSectionRecorder;
    }
    
    class MovieSceneVisibilitySectionRecorderSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bRecordVisibility: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MovieSceneVisibilitySectionRecorderSettings;
        static Load(InName: string): MovieSceneVisibilitySectionRecorderSettings;
    }
    
    class GeomModifier extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Description: string;
        Tooltip: string;
        bPushButton: boolean;
        bInitialized: boolean;
        bPendingPivotOffsetUpdate: boolean;
        CachedPolys: Polys;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier;
        static Load(InName: string): GeomModifier;
    }
    
    class GeomModifier_Edit extends GeomModifier {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Edit;
        static Load(InName: string): GeomModifier_Edit;
    }
    
    class GeomModifier_Clip extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bFlipNormal: boolean;
        bSplit: boolean;
        ClipMarkers: TArray<Vector>;
        SnappedMouseWorldSpacePos: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Clip;
        static Load(InName: string): GeomModifier_Clip;
    }
    
    class GeomModifier_Create extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Create;
        static Load(InName: string): GeomModifier_Create;
    }
    
    class GeomModifier_Delete extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Delete;
        static Load(InName: string): GeomModifier_Delete;
    }
    
    class GeomModifier_Extrude extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Length: number;
        Segments: number;
        SaveCoordSystem: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Extrude;
        static Load(InName: string): GeomModifier_Extrude;
    }
    
    class GeomModifier_Flip extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Flip;
        static Load(InName: string): GeomModifier_Flip;
    }
    
    class GeomModifier_Lathe extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        TotalSegments: number;
        Segments: number;
        AlignToSide: boolean;
        Axis: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Lathe;
        static Load(InName: string): GeomModifier_Lathe;
    }
    
    class GeomModifier_Triangulate extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Triangulate;
        static Load(InName: string): GeomModifier_Triangulate;
    }
    
    class GeomModifier_Optimize extends GeomModifier_Triangulate {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Optimize;
        static Load(InName: string): GeomModifier_Optimize;
    }
    
    class GeomModifier_Pen extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bAutoExtrude: boolean;
        bCreateConvexPolygons: boolean;
        bCreateBrushShape: boolean;
        ExtrudeDepth: number;
        ShapeVertices: TArray<Vector>;
        MouseWorldSpacePos: Vector;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Pen;
        static Load(InName: string): GeomModifier_Pen;
    }
    
    class GeomModifier_Split extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Split;
        static Load(InName: string): GeomModifier_Split;
    }
    
    class GeomModifier_Turn extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Turn;
        static Load(InName: string): GeomModifier_Turn;
    }
    
    class GeomModifier_Weld extends GeomModifier_Edit {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): GeomModifier_Weld;
        static Load(InName: string): GeomModifier_Weld;
    }
    
    enum EPaintMode { Vertices, Textures, EPaintMode_MAX}
    enum EMeshPaintMode { PaintColors, PaintWeights, EMeshPaintMode_MAX}
    enum ETextureWeightTypes { AlphaLerp, RGB, ARGB, OneMinusARGB, ETextureWeightTypes_MAX}
    enum ETexturePaintIndex { TextureOne, TextureTwo, TextureThree, TextureFour, TextureFive, ETexturePaintIndex_MAX}
    class VertexPaintSettings {
        constructor(MeshPaintMode: EMeshPaintMode, PaintColor: LinearColor, EraseColor: LinearColor, bWriteRed: boolean, bWriteGreen: boolean, bWriteBlue: boolean, bWriteAlpha: boolean, TextureWeightType: ETextureWeightTypes, PaintTextureWeightIndex: ETexturePaintIndex, EraseTextureWeightIndex: ETexturePaintIndex, bPaintOnSpecificLOD: boolean, LODIndex: number);
        MeshPaintMode: EMeshPaintMode;
        PaintColor: LinearColor;
        EraseColor: LinearColor;
        bWriteRed: boolean;
        bWriteGreen: boolean;
        bWriteBlue: boolean;
        bWriteAlpha: boolean;
        TextureWeightType: ETextureWeightTypes;
        PaintTextureWeightIndex: ETexturePaintIndex;
        EraseTextureWeightIndex: ETexturePaintIndex;
        bPaintOnSpecificLOD: boolean;
        LODIndex: number;
    }
    
    class TexturePaintSettings {
        constructor(PaintColor: LinearColor, EraseColor: LinearColor, bWriteRed: boolean, bWriteGreen: boolean, bWriteBlue: boolean, bWriteAlpha: boolean, UVChannel: number, bEnableSeamPainting: boolean, PaintTexture: Texture2D);
        PaintColor: LinearColor;
        EraseColor: LinearColor;
        bWriteRed: boolean;
        bWriteGreen: boolean;
        bWriteBlue: boolean;
        bWriteAlpha: boolean;
        UVChannel: number;
        bEnableSeamPainting: boolean;
        PaintTexture: Texture2D;
    }
    
    class PaintModeSettings extends MeshPaintSettings {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        PaintMode: EPaintMode;
        VertexPaintSettings: VertexPaintSettings;
        TexturePaintSettings: TexturePaintSettings;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): PaintModeSettings;
        static Load(InName: string): PaintModeSettings;
    }
    
    class ActorFactoryLandscape extends ActorFactory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryLandscape;
        static Load(InName: string): ActorFactoryLandscape;
    }
    
    enum ELandscapeToolFlattenMode { Invalid, Both, Raise, Lower, Interval, Terrace, ELandscapeToolFlattenMode_MAX}
    enum ELandscapeToolErosionMode { Invalid, Both, Raise, Lower, ELandscapeToolErosionMode_MAX}
    enum ELandscapeToolHydroErosionMode { Invalid, Both, Positive, ELandscapeToolHydroErosionMode_MAX}
    enum ELandscapeToolNoiseMode { Invalid, Both, Add, Sub, ELandscapeToolNoiseMode_MAX}
    enum ELandscapeToolPasteMode { Invalid, Both, Raise, Lower, ELandscapeToolPasteMode_MAX}
    class GizmoImportLayer {
        constructor(LayerFilename: string, LayerName: string, bNoImport: boolean);
        LayerFilename: string;
        LayerName: string;
        bNoImport: boolean;
    }
    
    enum ELandscapeMirrorOperation { MinusXToPlusX, PlusXToMinusX, MinusYToPlusY, PlusYToMinusY, RotateMinusXToPlusX, RotatePlusXToMinusX, RotateMinusYToPlusY, RotatePlusYToMinusY, ELandscapeMirrorOperation_MAX}
    enum ELandscapeConvertMode { Invalid, Expand, Clip, Resample, ELandscapeConvertMode_MAX}
    enum ELandscapeImportResult { Success, Warning, Error, ELandscapeImportResult_MAX}
    enum ELandscapeImportAlphamapType { Additive, Layered, ELandscapeImportAlphamapType_MAX}
    class LandscapeImportLayerInfo {
        constructor(LayerName: string, LayerInfo: LandscapeLayerInfoObject, SourceFilePath: string);
        LayerName: string;
        LayerInfo: LandscapeLayerInfoObject;
        SourceFilePath: string;
    }
    
    class LandscapeImportLayer extends LandscapeImportLayerInfo {
        constructor(ThumbnailMIC: LandscapeMaterialInstanceConstant, ImportResult: ELandscapeImportResult, ErrorMessage: string);
        ThumbnailMIC: LandscapeMaterialInstanceConstant;
        ImportResult: ELandscapeImportResult;
        ErrorMessage: string;
    }
    
    class LandscapePatternBrushWorldSpaceSettings {
        constructor(Origin: Vector2D, Rotation: number, bCenterTextureOnOrigin: boolean, RepeatSize: number);
        Origin: Vector2D;
        Rotation: number;
        bCenterTextureOnOrigin: boolean;
        RepeatSize: number;
    }
    
    enum ELandscapeLayerPaintingRestriction { None, UseMaxLayers, ExistingOnly, UseComponentWhitelist, ELandscapeLayerPaintingRestriction_MAX}
    class LandscapeEditorObject extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ToolStrength: number;
        bUseWeightTargetValue: boolean;
        WeightTargetValue: number;
        MaximumValueRadius: number;
        bCombinedLayersOperation: boolean;
        FlattenMode: ELandscapeToolFlattenMode;
        bUseSlopeFlatten: boolean;
        bPickValuePerApply: boolean;
        bUseFlattenTarget: boolean;
        FlattenTarget: number;
        bShowFlattenTargetPreview: boolean;
        TerraceInterval: number;
        TerraceSmooth: number;
        bFlattenEyeDropperModeActivated: boolean;
        FlattenEyeDropperModeDesiredTarget: number;
        RampWidth: number;
        RampSideFalloff: number;
        SmoothFilterKernelSize: number;
        bDetailSmooth: boolean;
        DetailScale: number;
        ErodeThresh: number;
        ErodeSurfaceThickness: number;
        ErodeIterationNum: number;
        ErosionNoiseMode: ELandscapeToolErosionMode;
        ErosionNoiseScale: number;
        RainAmount: number;
        SedimentCapacity: number;
        HErodeIterationNum: number;
        RainDistMode: ELandscapeToolHydroErosionMode;
        RainDistScale: number;
        bHErosionDetailSmooth: boolean;
        HErosionDetailScale: number;
        NoiseMode: ELandscapeToolNoiseMode;
        NoiseScale: number;
        bUseSelectedRegion: boolean;
        bUseNegativeMask: boolean;
        PasteMode: ELandscapeToolPasteMode;
        bApplyToAllTargets: boolean;
        bSnapGizmo: boolean;
        bSmoothGizmoBrush: boolean;
        GizmoHeightmapFilenameString: string;
        GizmoImportSize: IntPoint;
        GizmoImportLayers: TArray<GizmoImportLayer>;
        MirrorPoint: Vector2D;
        MirrorOp: ELandscapeMirrorOperation;
        MirrorSmoothingWidth: number;
        BlueprintBrush: Class;
        ResizeLandscape_QuadsPerSection: number;
        ResizeLandscape_SectionsPerComponent: number;
        ResizeLandscape_ComponentCount: IntPoint;
        ResizeLandscape_ConvertMode: ELandscapeConvertMode;
        NewLandscape_Material: TWeakObjectPtr<MaterialInterface>;
        NewLandscape_QuadsPerSection: number;
        NewLandscape_SectionsPerComponent: number;
        NewLandscape_ComponentCount: IntPoint;
        NewLandscape_Location: Vector;
        NewLandscape_Rotation: Rotator;
        NewLandscape_Scale: Vector;
        ImportLandscape_HeightmapImportResult: ELandscapeImportResult;
        ImportLandscape_HeightmapErrorMessage: string;
        ImportLandscape_HeightmapFilename: string;
        ImportLandscape_Width: number;
        ImportLandscape_Height: number;
        ImportLandscape_Data: TArray<number>;
        bCanHaveLayersContent: boolean;
        ImportLandscape_AlphamapType: ELandscapeImportAlphamapType;
        ImportLandscape_Layers: TArray<LandscapeImportLayer>;
        BrushRadius: number;
        BrushFalloff: number;
        bUseClayBrush: boolean;
        AlphaBrushScale: number;
        bAlphaBrushAutoRotate: boolean;
        AlphaBrushRotation: number;
        AlphaBrushPanU: number;
        AlphaBrushPanV: number;
        bUseWorldSpacePatternBrush: boolean;
        WorldSpacePatternBrushSettings: LandscapePatternBrushWorldSpaceSettings;
        AlphaTexture: Texture2D;
        AlphaTextureChannel: number;
        AlphaTextureSizeX: number;
        AlphaTextureSizeY: number;
        AlphaTextureData: TArray<number>;
        BrushComponentSize: number;
        PaintingRestriction: ELandscapeLayerPaintingRestriction;
        TargetDisplayOrder: ELandscapeLayerDisplayMode;
        ShowUnusedLayers: boolean;
        CurrentLayerIndex: number;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeEditorObject;
        static Load(InName: string): LandscapeEditorObject;
    }
    
    class LandscapePlaceholder extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapePlaceholder;
        static Load(InName: string): LandscapePlaceholder;
    }
    
    class ActorFactoryProceduralFoliage extends ActorFactoryBoxVolume {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ActorFactoryProceduralFoliage;
        static Load(InName: string): ActorFactoryProceduralFoliage;
    }
    
    class FoliageType_ActorThumbnailRenderer extends BlueprintThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_ActorThumbnailRenderer;
        static Load(InName: string): FoliageType_ActorThumbnailRenderer;
    }
    
    class FoliageType_ISMThumbnailRenderer extends DefaultSizedThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_ISMThumbnailRenderer;
        static Load(InName: string): FoliageType_ISMThumbnailRenderer;
    }
    
    class FoliageType_InstancedStaticMeshFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_InstancedStaticMeshFactory;
        static Load(InName: string): FoliageType_InstancedStaticMeshFactory;
    }
    
    class FoliageType_ActorFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): FoliageType_ActorFactory;
        static Load(InName: string): FoliageType_ActorFactory;
    }
    
    class LandscapeGrassTypeFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LandscapeGrassTypeFactory;
        static Load(InName: string): LandscapeGrassTypeFactory;
    }
    
    class ProceduralFoliageSpawnerFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): ProceduralFoliageSpawnerFactory;
        static Load(InName: string): ProceduralFoliageSpawnerFactory;
    }
    
    class RuntimeVirtualTextureFactory extends Factory {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureFactory;
        static Load(InName: string): RuntimeVirtualTextureFactory;
    }
    
    class RuntimeVirtualTextureThumbnailRenderer extends ThumbnailRenderer {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): RuntimeVirtualTextureThumbnailRenderer;
        static Load(InName: string): RuntimeVirtualTextureThumbnailRenderer;
    }
    
    class SceneOutlinerMenuContext extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneOutlinerMenuContext;
        static Load(InName: string): SceneOutlinerMenuContext;
    }
    
    class SceneOutlinerSettings extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        bHideTemporaryActors: boolean;
        bShowOnlyActorsInCurrentLevel: boolean;
        bHideFoldersContainingHiddenActors: boolean;
        bShowOnlySelectedActors: boolean;
        bShowActorComponents: boolean;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SceneOutlinerSettings;
        static Load(InName: string): SceneOutlinerSettings;
    }
    
    class DmgTypeBP_Environmental_C extends DamageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): DmgTypeBP_Environmental_C;
        static Load(InName: string): DmgTypeBP_Environmental_C;
    }
    
    class PointerToUberGraphFrame {
        constructor();
    }
    
    class SKEL_LevelEditorAttract_C extends EditorTutorial {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SKEL_LevelEditorAttract_C;
        static Load(InName: string): SKEL_LevelEditorAttract_C;
    }
    
    class SKEL_DmgTypeBP_Environmental_C extends DamageType {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SKEL_DmgTypeBP_Environmental_C;
        static Load(InName: string): SKEL_DmgTypeBP_Environmental_C;
    }
    
    class LevelEditorAttract_C extends EditorTutorial {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorAttract_C;
        static Load(InName: string): LevelEditorAttract_C;
    }
    
    class StandardMacros_C extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): StandardMacros_C;
        static Load(InName: string): StandardMacros_C;
    }
    
    class SKEL_StandardMacros_C extends Object {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SKEL_StandardMacros_C;
        static Load(InName: string): SKEL_StandardMacros_C;
    }
    
    class BP_Sky_Sphere_C extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        SkySphereMesh: StaticMeshComponent;
        Base: SceneComponent;
        Skymaterial: MaterialInstanceDynamic;
        Refreshmaterial: boolean;
        Directionallightactor: DirectionalLight;
        Colorsdeterminedbysunposition: boolean;
        Sunheight: number;
        Sunbrightness: number;
        HorizonFalloff: number;
        ZenithColor: LinearColor;
        Horizoncolor: LinearColor;
        Cloudcolor: LinearColor;
        OverallColor: LinearColor;
        Cloudspeed: number;
        Cloudopacity: number;
        Starsbrightness: number;
        Horizoncolorcurve: CurveLinearColor;
        Zenithcolorcurve: CurveLinearColor;
        Cloudcolorcurve: CurveLinearColor;
        RefreshMaterial(): void;
        UpdateSunDirection(): void;
        UserConstructionScript(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): BP_Sky_Sphere_C;
        static Load(InName: string): BP_Sky_Sphere_C;
    }
    
    class SKEL_BP_Sky_Sphere_C extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        SkySphereMesh: StaticMeshComponent;
        Base: SceneComponent;
        Skymaterial: MaterialInstanceDynamic;
        Refreshmaterial: boolean;
        Directionallightactor: DirectionalLight;
        Colorsdeterminedbysunposition: boolean;
        Sunheight: number;
        Sunbrightness: number;
        HorizonFalloff: number;
        ZenithColor: LinearColor;
        Horizoncolor: LinearColor;
        Cloudcolor: LinearColor;
        OverallColor: LinearColor;
        Cloudspeed: number;
        Cloudopacity: number;
        Starsbrightness: number;
        Horizoncolorcurve: CurveLinearColor;
        Zenithcolorcurve: CurveLinearColor;
        Cloudcolorcurve: CurveLinearColor;
        UserConstructionScript(): void;
        UpdateSunDirection(): void;
        RefreshMaterial(): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SKEL_BP_Sky_Sphere_C;
        static Load(InName: string): SKEL_BP_Sky_Sphere_C;
    }
    
    class LevelEditorOverview_C extends EditorTutorial {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): LevelEditorOverview_C;
        static Load(InName: string): LevelEditorOverview_C;
    }
    
    class SKEL_LevelEditorOverview_C extends EditorTutorial {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SKEL_LevelEditorOverview_C;
        static Load(InName: string): SKEL_LevelEditorOverview_C;
    }
    
    class TestBlueprint_C extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        DefaultSceneRoot: SceneComponent;
        B1: boolean;
        I1: number;
        I2: number;
        Foo(P1: boolean, P2: number, P3: number): void;
        ReceiveBeginPlay(): void;
        ExecuteUbergraph_TestBlueprint(EntryPoint: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TestBlueprint_C;
        static Load(InName: string): TestBlueprint_C;
    }
    
    class SKEL_TestBlueprint_C extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        DefaultSceneRoot: SceneComponent;
        B1: boolean;
        I1: number;
        I2: number;
        ReceiveBeginPlay(): void;
        ReceiveActorBeginOverlap(OtherActor: Actor): void;
        ReceiveTick(DeltaSeconds: number): void;
        UserConstructionScript(): void;
        Foo(P1: boolean, P2: number, P3: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): SKEL_TestBlueprint_C;
        static Load(InName: string): SKEL_TestBlueprint_C;
    }
    
    class REINST_TestBlueprint_C_5 extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        UberGraphFrame: PointerToUberGraphFrame;
        DefaultSceneRoot: SceneComponent;
        B1: boolean;
        I1: number;
        I2: number;
        Foo(P1: boolean, P2: number, P3: number): void;
        UserConstructionScript(): void;
        ReceiveBeginPlay(): void;
        ExecuteUbergraph_TestBlueprint(EntryPoint: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): REINST_TestBlueprint_C_5;
        static Load(InName: string): REINST_TestBlueprint_C_5;
    }
    
    class TRASHCLASS_TestBlueprint_6 {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): TRASHCLASS_TestBlueprint_6;
        static Load(InName: string): TRASHCLASS_TestBlueprint_6;
    }
    
    class MyActor_C extends Actor {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        ReceiveBeginPlay(): void;
        ReceiveTick(DeltaSeconds: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MyActor_C;
        static Load(InName: string): MyActor_C;
    }
    
    class MyBPActor_C extends TestBlueprint_C {
        constructor(Outer?: Object, Name?: string, ObjectFlags?: number);
        Foo(P1: boolean, P2: number, P3: number): void;
        static StaticClass(): Class;
        static Find(OrigInName: string, Outer?: Object): MyBPActor_C;
        static Load(InName: string): MyBPActor_C;
    }
    
}
